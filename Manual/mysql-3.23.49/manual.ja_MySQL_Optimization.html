<html><head>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 17 Febuary 2002 -->

  <title>MySQL Reference Manual for version 3.23.49. - 5  MySQL Optimization</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  </head>
  <body bgcolor="silver" text="#000000" link="#101090" vlink="#7030B0">
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_MySQL_Database_Administration.html">previous</a>, <a href="manual.ja_Reference.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
<p></p><hr><p>


</p><h1><a name="MySQL_Optimization" href="manual.ja_toc.html#MySQL_Optimization">5  MySQL Optimization</a></h1>

<p>
Optimization is a complicated task because it ultimately requires
understanding of the whole system. While it may be possible to do some
local optimizations with small knowledge of your system or application,
the more optimal you want your system to become the more you will have
to know about it.

</p>
<p>
This chapter will try to explain and give some examples of different
ways to optimize MySQL.  Remember, however, that there are 
always some (increasingly harder) additional ways to make the system
even faster.

</p>



<h2><a name="Optimize_Overview" href="manual.ja_toc.html#Optimize_Overview">5.1  最適化 概要</a></h2>

<p>
システムを速くするための最も重要な部分は、もちろん基礎的な設計です。
You also need to know what kinds of things your system will be
doing, and what your bottlenecks are.

</p>
<p>
主なボトルネックは：

</p><ul>
<li>Disk シーク ：

一片のデータを見つけるためには、ディスクに時間がかかります。
1999年の最新型のディスクでは、このための平均時間は、10msよりも通常より小さいです。
したがって、我々は、理論上は 1秒で約1000 シークすることができます。
この時間は、一つのテーブルであるならば、データの増加と共にディスクアクセスの時間
が少しずつ増加することになり、とても最適化するのは難しくなっていきます。
これを最適化する方法は、データを 1個以上のディスクに分散する事です。

</li><li>Disk reading/writing.

When the disk is at the correct position we need to read the data. With
modern disks in 1999, one disk delivers something like 10-20Mb/s. This
is easier to optimize than seeks because you can read in parallel from
multiple disks.

</li><li>CPU cycles.

データをメイン・メモリーの中に入れた(または既にメモリに存在している)場合に、
結果を得るためには、それを処理する必要があります。
メモリー容量よりも小さなテーブルを持っている場合、これは、制限の要因となります。
小さいテーブルでは、スピードは、通常問題にはなりません。

</li><li>Memory bandwidth.

CPU がキャッシュに収まらないようなデータを要求した場合、メイン・メモリー
のバンド幅はボトルネックになります。
これはほとんどのシステムで分かりにくいボトルネックとなりますが、
誰かはそれを知っているべきです。
</li></ul>



<h3><a name="Design_Limitations" href="manual.ja_toc.html#Design_Limitations">5.1.1  MySQL Design Limitations/Tradeoffs</a></h3>

<p>
<a name="IDX815"></a>
<a name="IDX816"></a>

</p>
<p>
MySQLは極端に早いテーブルブロックのしくみ(複数のリードと一つのライトによる方式)を
使用するために、一つのテーブルに対して続けざまにインサートを行いながら、同時に
遅いセレクトを行った場合に生じる問題が、最大の難点です。

</p>
<p>
私たちはこの選択により数多くのシステムにおいて非常に高速なパフォーマンスを実現する
ことができると信じています。またこの問題は、若干の手数とハードウェアリソースを必要
とはするものの、通常、テーブルのコピーを複数行うことにより回避できます。

</p>
<p>
また、我々は、幾つかの共通アプリケーションのために、
この問題を解決しうるための複数の拡張を行っています。

</p>


<h3><a name="Portability" href="manual.ja_toc.html#Portability">5.1.2  Portability</a></h3>

<p>
<a name="IDX817"></a>
<a name="IDX818"></a>
<a name="IDX819"></a>

</p>
<p>
全てのSQLサーバはそれぞれ異なるSQL処理ルーチンにより構成されています。
したがって色々なSQLサーバ上で同じように動作するような(ポータブルな)
SQLアプリケーションを書くのは手間がかかります。
確かに単純なインサートやセレクトを行うようなものは簡単ですが、
必要な機能が増えれば増えるほど難しくなっていきます。
高速動作を要求されるSQLプラットフォームの数が増えれば増えるほど
そのようなアプリケーションの開発は大変になっていきます。

</p>
<p>
ポータブルな多機能アプリケーションを開発するためには
沢山のSQLサーバでの動作を検証する必要があります。

</p>
<p>
You can use the MySQL crash-me program/web-page
<a href="http://www.mysql.com/information/crash-me.php">http://www.mysql.com/information/crash-me.php</a> to find functions,
types, and limits you can use with a selection of database
servers. Crash-me now tests far from everything possible, but it
is still comprehensive with about 450 things tested.

</p>
<p>
For example, you shouldn't have column names longer than 18 characters
if you want to be able to use Informix or DB2.

</p>
<p>
Both the MySQL benchmarks and crash-me programs are very
database-independent.  By taking a look at how we have handled this, you
can get a feeling for what you have to do to write your application
database-independent.  The benchmarks themselves can be found in the
<tt>`sql-bench'</tt> directory in the MySQL source
distribution. They are written in Perl with DBI database interface
(which solves the access part of the problem).

</p>
<p>
See <a href="http://www.mysql.com/information/benchmarks.html">http://www.mysql.com/information/benchmarks.html</a> for the results
from this benchmark.

</p>
<p>
As you can see in these results, all databases have some weak points. That
is, they have different design compromises that lead to different
behavior.

</p>
<p>
If you strive for database independence, you need to get a good feeling
for each SQL server's bottlenecks. MySQL is VERY fast in
retrieving and updating things, but will have a problem in mixing slow
readers/writers on the same table. Oracle, on the other hand, has a big
problem when you try to access rows that you have recently updated
(until they are flushed to disk). Transaction databases in general are
not very good at generating summary tables from log tables, as in this
case row locking is almost useless.

</p>
<p>
To get your application <em>really</em> database-independent, you need to define
an easy extendable interface through which you manipulate your data. As
C++ is available on most systems, it makes sense to use a C++ classes
interface to the databases.

</p>
<p>
If you use some specific feature for some database (like the
<code>REPLACE</code> command in MySQL), you should code a method for
the other SQL servers to implement the same feature (but slower).  With
MySQL you can use the <code>/*!  */</code> syntax to add
MySQL-specific keywords to a query.  The code inside
<code>/**/</code> will be treated as a comment (ignored) by most other SQL
servers.

</p>
<p>
If REAL high performance is more important than exactness, as in some
Web applications, a possibility is to create an application layer that
caches all results to give you even higher performance. By letting
old results 'expire' after a while, you can keep the cache reasonably
fresh.  This is quite nice in case of extremely high load, in which case
you can dynamically increase the cache and set the expire timeout higher
until things get back to normal.

</p>
<p>
In this case the table creation information should contain information
of the initial size of the cache and how often the table should normally
be refreshed.

</p>



<h3><a name="Internal_use" href="manual.ja_toc.html#Internal_use">5.1.3  What Have We Used MySQL For?</a></h3>

<p>
<a name="IDX820"></a>
<a name="IDX821"></a>

</p>
<p>
MySQL の初期の開発期には、MySQL は我々のもっとも大口の顧客に合うように
機能が作成されました。 彼らは、いくつかのスウェーデン最大手の小売り業者
のために、倉庫に入れている（商品）データを取り扱います。

</p>
<p>
我々は、すべての店から、全ボーナス・カード取扱高の、その週間まとめを得ます。
そして、その店のオーナにとって有益な情報、その店の広告キャンペーンが
お客にどの程度影響を及ぼすか、を提供することが、我々に求められています。

</p>
<p>
そのデータは、とても大きくて (約700万/月 回の取り扱い)、
我々はその顧客に提供する必要のあるデータを 4～10年分、持っています。
我々は、カスタマーから、彼らがこのデータからできる新しいレポートに
”即時に”アクセスしたいという、要求を受けました。

</p>
<p>
我々はこれを、全ての月ごとの情報を圧縮した 'transaction' テーブルに
保存することで解決しました。
We have a set of simple macros (script) that
generates summary tables grouped by different criteria (product group,
customer id, store ...) from the transaction tables.
そのレポートは Web ページで、これは小さな perl スクリプトで動的に
作成されます。 この perl script は Web Page を分析し、SQL 文を
実行し、結果を挿入します。
We would have used PHP or mod_perl instead but they were
not available at that time.

</p>
<p>
画像データのために、我々は簡単なツールを <code>C</code> でかきました。
これは SQL のクエリの結果を元に(結果にいくつか処理をして) GIF を提供します。
これも動的に perl スクリプト(<code>HTML</code> ファイルを分析する)から実行されます。

</p>
<p>
In most cases a new report can simply be done by copying an existing
script and modifying the SQL query in it.  In some cases, we will need to
add more fields to an existing summary table or generate a new one, but
this is also quite simple, as we keep all transactions tables on disk.
(Currently we have at least 50G of transactions tables and 200G of other
customer data.)

</p>
<p>
We also let our customers access the summary tables directly with ODBC
so that the advanced users can themselves experiment with the data.

</p>
<p>
我々はこれらを  Sun Ultra SPARCstation (2x200 Mz) で扱っていますが、
なんの問題もありません。
We recently upgraded one of our servers to a 2
CPU 400 Mhz UltraSPARC, and we are now planning to start handling
transactions on the product level, which would mean a ten-fold increase
of data. We think we can keep up with this by just adding more disk to
our systems.

</p>
<p>
We are also experimenting with Intel-Linux to be able to get more CPU
power cheaper. 現在、我々はバイナリ互換のデータベースフォーマットを持っており
(new in Version 3.23) 、我々はこれをアプリケーションのいくつかの部分に使用しはじ
める事でしょう。

</p>
<p>
Our initial feelings are that Linux will perform much better on
low-to-medium load and Solaris will perform better when you start to get a
high load because of extreme disk IO, but we don't yet have anything
conclusive about this. After some discussion with a Linux Kernel
developer, this might be a side effect of Linux giving so much resources
to the batch job that the interactive performance gets very low. This
makes the machine feel very slow and unresponsive while big batches are
going. Hopefully this will be better handled in future Linux Kernels.

</p>



<h3><a name="MySQL_Benchmarks" href="manual.ja_toc.html#MySQL_Benchmarks">5.1.4  The MySQL Benchmark Suite</a></h3>

<p>
<a name="IDX822"></a>
<a name="IDX823"></a>

</p>
<p>
This should contain a technical description of the MySQL
benchmark suite (and <code>crash-me</code>), but that description is not
written yet. Currently, you can get a good idea of the benchmark by
looking at the code and results in the <tt>`sql-bench'</tt> directory in any
MySQL source distributions.

</p>
<p>
This benchmark suite is meant to be a benchmark that will tell any user
what things a given SQL implementation performs well or poorly at.

</p>
<p>
Note that this benchmark is single threaded, so it measures the minimum
time for the operations. We plan to in the future add a lot of
multi-threaded tests to the benchmark suite.

</p>
<p>
For example, (run on the same NT 4.0 machine):

</p>
<strong>Reading 2000000 rows by index</strong><table border="" width="100%" nosave="">
 <tbody><tr><td> <strong>Seconds</strong> </td><td> <strong>Seconds</strong>
</td></tr><tr><td>mysql </td><td> 367 </td><td> 249
</td></tr>
<tr><td>mysql_odbc </td><td> 464
</td></tr>
<tr><td>db2_odbc </td><td> 1206
</td></tr>
<tr><td>informix_odbc </td><td> 121126
</td></tr>
<tr><td>ms-sql_odbc </td><td> 1634
</td></tr>
<tr><td>oracle_odbc </td><td> 20800
</td></tr>
<tr><td>solid_odbc </td><td> 877
</td></tr>
<tr><td>sybase_odbc </td><td> 17614
</td></tr>
</tbody></table>

<strong>Inserting (350768) rows</strong><table border="" width="100%" nosave="">
 <tbody><tr><td> <strong>Seconds</strong> </td><td> <strong>Seconds</strong>
</td></tr><tr><td>mysql </td><td> 381 </td><td> 206
</td></tr>
<tr><td>mysql_odbc </td><td> 619
</td></tr>
<tr><td>db2_odbc </td><td> 3460
</td></tr>
<tr><td>informix_odbc </td><td> 2692
</td></tr>
<tr><td>ms-sql_odbc </td><td> 4012
</td></tr>
<tr><td>oracle_odbc </td><td> 11291
</td></tr>
<tr><td>solid_odbc </td><td> 1801
</td></tr>
<tr><td>sybase_odbc </td><td> 4802
</td></tr>
</tbody></table>

<p>
In the above test MySQL was run with a 8M index cache.

</p>
<p>
We have gather some more benchmark results at
<a href="http://www.mysql.com/information/benchmarks.html">http://www.mysql.com/information/benchmarks.html</a>.

</p>
<p>
Note that Oracle is not included because they asked to be removed. All
Oracle benchmarks have to be passed by Oracle! We believe that makes
Oracle benchmarks <strong>VERY</strong> biased because the above benchmarks are
supposed to show what a standard installation can do for a single
client.

</p>
<p>
To run the benchmark suite, you have to download a MySQL source
distribution, install the perl DBI driver, the perl DBD driver for the
database you want to test and then do:

</p>

<pre>cd sql-bench
perl run-all-tests --server=#
</pre>

<p>
where # is one of supported servers. You can get a list of all options
and supported servers by doing <code>run-all-tests --help</code>.

</p>
<p>
<a name="IDX824"></a>
<code>crash-me</code> tries to determine what features a database supports and
what its capabilities and limitations are by actually running
queries. For example, it determines:

</p>

<ul>
<li>

What column types are supported
</li><li>

How many indexes are supported
</li><li>

What functions are supported
</li><li>

How big a query can be
</li><li>

How big a <code>VARCHAR</code> column can be
</li></ul>

<p>
We can find the result from crash-me on a lot of different databases at
<a href="http://www.mysql.com/information/crash-me.php">http://www.mysql.com/information/crash-me.php</a>.

</p>



<h3><a name="Custom_Benchmarks" href="manual.ja_toc.html#Custom_Benchmarks">5.1.5  Using Your Own Benchmarks</a></h3>

<p>
<a name="IDX825"></a>
<a name="IDX826"></a>

</p>
<p>
You should definitely benchmark your application and database to find
out where the bottlenecks are.  By fixing it (or by replacing the
bottleneck with a 'dummy module') you can then easily identify the next
bottleneck (and so on).  Even if the overall performance for your
application is sufficient, you should at least make a plan for each
bottleneck, and decide how to solve it if someday you really need the
extra performance.

</p>
<p>
For an example of portable benchmark programs, look at the MySQL
benchmark suite.  「<a href="manual.ja_MySQL_Optimization.html#MySQL_Benchmarks">5.1.4  The MySQL Benchmark Suite</a>」節参照. You
can take any program from this suite and modify it for your needs. By doing
this, you can try different solutions to your problem and test which is really
the fastest solution for you.

</p>
<p>
It is very common that some problems only occur when the system is very
heavily loaded. We have had many customers who contact us when they
have a (tested) system in production and have encountered load problems. In
every one of these cases so far, it has been problems with basic design
(table scans are NOT good at high load) or OS/Library issues. Most of
this would be a <strong>LOT</strong> easier to fix if the systems were not
already in production.

</p>
<p>
To avoid problems like this, you should put some effort into benchmarking
your whole application under the worst possible load!  You can use
Super Smack for this, and it is available at:
<a href="http://www.mysql.com/Downloads/super-smack/super-smack-1.0.tar.gz">http://www.mysql.com/Downloads/super-smack/super-smack-1.0.tar.gz</a>.
As the name suggests, it can bring your system down to its knees if you ask it,
so make sure to use it only on your development systems.

</p>



<h2><a name="Query_Speed" href="manual.ja_toc.html#Query_Speed">5.2  Optimizing <code>SELECT</code>s and Other Queries</a></h2>

<p>
<a name="IDX827"></a>
<a name="IDX828"></a>
<a name="IDX829"></a>

</p>
<p>
最初に、全てのクエリに影響する一つの事柄をのべます：
より複雑な権限の設定を行うと、オーバーヘッドが多くなります。

</p>
<p>
もしあなたがいかなる <code>GRANT</code> 文も行っていなければ、
<strong>MySQL</strong> はパーミッションの検査を少ししか最適化しないでしょう。
So if you have a very high
volume it may be worth the time to avoid grants. Otherwise more
permission check results in a larger overhead.

</p>
<p>
もし <strong>MySQL</strong> 関数のあるものが確実に問題を引き起こしているのならば、
常に <strong>MySQL</strong> クライアント側は以下のようになります：

</p>

<pre>mysql&gt; select benchmark(1000000,1+1);
+------------------------+
| benchmark(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</pre>

<p>
上の例では <strong>MySQL</strong> は 1,000,000 <code>+</code> 式を 0.32 秒で実行できています
(たんなる <code>PentiumII 400MHz</code> マシンで)。

</p>
<p>
全ての <strong>MySQL</strong> 関数は最適化されていますが、
いくつかは例外があるかもしれません。
<code>benchmark(loop_count,expression)</code>はあなたのクエリの
問題を見つけるためのとてもよいツールです。

</p>



<h3><a name="EXPLAIN" href="manual.ja_toc.html#EXPLAIN">5.2.1  <code>EXPLAIN</code> 構文 (<code>SELECT</code>についての情報を得る)</a></h3>

<p>
<a name="IDX830"></a>
<a name="IDX831"></a>

</p>

<pre>    EXPLAIN tbl_name
or  EXPLAIN SELECT select_options
</pre>

<p>
<code>EXPLAIN tbl_name</code> は、 <code>DESCRIBE tbl_name</code> や
<code>SHOW COLUMNS FROM tbl_name</code> と同義です。

</p>
<p>
もし <code>EXPLAIN</code> をともなって <code>SELECT</code> 構文を実行した場合、
<strong>MySQL</strong> はこの <code>SELECT</code> がいかに動作するかを説明し、
いかにテーブルが結合されるかの情報を与えます。

</p>
<p>
<code>EXPLAIN</code> の情報を元に、インデックスを使用した速い <code>SELECT</code> を
得るためにテーブルにインデックスを加えなくてはならないという事がわかります。
テーブル結合の最適化もオプションによって見ることができます。
<code>SELECT</code> 構文での結合を強制的に最適化するには <code>STRAIGHT_JOIN</code> 節を加え
ます。

</p>
<p>
単純ではない join のために、<code>EXPLAIN</code> は <code>SELECT</code> 文で使用されている
それぞれのテーブルの情報を返します。
テーブルは読まれる順に表示されます。<strong>MySQL</strong> は one-sweep multi-join method
を用いた全ての join を解決します。これは <strong>MySQL</strong> は最初のテーブルから
一レコード読み込み、二つ目のテーブルからマッチしたレコードを探し、そして三番目を
探すということです。
全てのテーブルが処理される時、選択されたフィールドを出力し、テーブルの一覧は
よりマッチするレコードをもつテーブルを見つけるまで back-track されます。
次のレコードはこのテーブルから読まれ、次のテーブルから処理を続けます。

</p>
<p>
<code>EXPLAIN</code> の出力は以下のフィールドを含みます：

</p>
<dl compact="">

<dt><code>table</code>
</dt><dd>
出力レコードが参照されるテーブル

</dd><dt><code>type</code>
</dt><dd>
join タイプ.  様々なタイプの説明は後述します

</dd><dt><code>possible_keys</code>
</dt><dd>
<code>possible_keys</code> 項目は、<strong>MySQL</strong> がテーブルからレコードを見つけるために
どのインデックスを使用する事ができたかを示します。
注意: このフィールドはテーブルの順にまったく依存しません。これは、
possible_keys 内のいくつかのキーは、生成されたテーブル順での実行に使用でき
ないことを意味します。

この項目が空なら、関連した
インデックスは無いということです。この場合、あなたは <code>WHERE</code> 節を
調べることによって、クエリの性能を向上させることができるかもしれません。
もしそれがインデックスに適合したフィールドを参照しているならば。
仮にそうだとすると、適切なインデックスを作成し、 <code>EXPLAIN</code> でクエリを
もう一度チェックしてみてください。

テーブルがどんなインデックスを持っているかみるには、<code>SHOW INDEX FROM tbl_name</code> とします。

</dd><dt><code>key</code>
</dt><dd>
<code>key</code> 項目は、 <strong>MySQL</strong> が使用すると実際に決めたキーを示します。
どのインデックスも選ばれなかったならば、キーは <code>NULL</code> です。
<strong>MySQL</strong> が間違ったインデックスを選択する場合、たいていは 
<strong>MySQL</strong> に他のインデックスを使用するように強制することができます。
<code>myisamchk --analyze</code> の使用、 「<a href="manual.ja_MySQL_Database_Administration.html#myisamchk_syntax">4.4.6.1  <code>myisamchk</code> 起動構文</a>」節参照、または 
<code>USE INDEX/IGNORE INDEX</code> の使用によって。
 「<a href="manual.ja_Reference.html#JOIN">6.4.1.1  <code>JOIN</code> 構文</a>」節参照.

</dd><dt><code>key_len</code>
</dt><dd>
<code>key_len</code> 項目は、<strong>MySQL</strong> が使用すると決めたキーの長さを示します。
もし <code>key</code> が <code>NULL</code> なら、長さは <code>NULL</code> です。
注意: これは<strong>MySQL</strong> がマルチパートキーのいくつのパートを実際に使用
するかを示します。

</dd><dt><code>ref</code>
</dt><dd>
<code>ref</code> 項目は、テーブルからレコードを select するために、どのフィールドや
定数が <code>key</code> と共に使用されたかを示します。

</dd><dt><code>rows</code>
</dt><dd>
<code>rows</code> フィールドは、<strong>MySQL</strong> がクエリを実行するために検査する
必要があると考えているレコードの数を示します。

</dd><dt><code>Extra</code>
</dt><dd>
このフィールドは、<strong>MySQL</strong> がどのようにクエリを解決するかの追加情報
を含んでいます。ここで、このフィールドに現れ得る様々なテキスト文字列の説明
をします:

<dl compact="">

<dt><code>Distinct</code>
</dt><dd>
MySQL will not continue searching for more rows for the current row
combination after it has found the first matching row.

</dd><dt><code>Not exists</code>
</dt><dd>
<strong>MySQL</strong> はクエリの <code>LEFT JOIN</code> 最適化を行なうことができて、
<code>LEFT JOIN</code> 判定基準に適合する１つのレコードを見つけた後、前のレコード組
み合わせについてこのテーブルにそれ以上のレコードを検査しません。

Here is an example for this:


<pre>SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</pre>

Assume that <code>t2.id</code> is defined with <code>NOT NULL</code>.  In this case
MySQL will scan <code>t1</code> and look up the rows in <code>t2</code>
through <code>t1.id</code>. If MySQL finds a matching row in
<code>t2</code>, it knows that <code>t2.id</code> can never be <code>NULL</code>, and will
not scan through the rest of the rows in <code>t2</code> that has the same
<code>id</code>.  In other words, for each row in <code>t1</code>, MySQL
only needs to do a single lookup in <code>t2</code>, independent of how many
matching rows there are in <code>t2</code>.

</dd><dt><code><code>range checked for each record (index map: #)</code></code>
</dt><dd>
<strong>MySQL</strong> は使用すべき本当に良いインデックスを見つけられませんでし
た。先行するテーブル内に各レコードの結合の代わりに、テーブルからレコード
を取り出すためにどのインデックスを使用するかチェックを行ないます。これは
とても速いというわけではありませんが、もちろんインデックス無しでの結合を
行なわなければならないよりは速いです。

</dd><dt><code>Using filesort</code>
</dt><dd>
<strong>MySQL</strong> は、ソート順でレコードを取り出す方法を見つけ出すため、余
計なパスの実行が必要です。ソートは、<code>join type</code> に一致する全てのレ
コードを通して行なわれ、<code>WHERE</code> に適合する全てのレコードについて、
ソートキーとレコードへのポインタを格納します。それから、キーがソートされま
す。最後にレコードはソートされた順に取り出されます。

</dd><dt><code>Using index</code>
</dt><dd>
フィールド情報は、実際のレコードから読み込む追加シークを行なうことはせず
に、インデックスツリー内の情報だけを使用するテーブルから取り出されます。
テーブルについての使用される全てのフィールドが同じインデックスの一部であ
る時にこれが行なわれます。

</dd><dt><code>Using temporary</code>
</dt><dd>
クエリを解決できるように、<strong>MySQL</strong> は、結果を保持するための一時テー
ブルを作成する必要があります。これは通常 <code>GROUP BY</code> が行なわれたも
のとは別のフィールド上で <code>ORDER BY</code> を行なう場合に発生します。

</dd><dt><code>Where used</code>
</dt><dd>
どのレコードが次のテーブルに対して適合するか、またはクライアントに送られ
るかを制限するために、<code>WHERE</code> 節が使用されます。この情報がなくて、
テーブルが型 <code>ALL</code> か <code>index</code> であれば、クエリ内に何か間違った
ものがあります(テーブルから全てのレコードを fetch/examine しようとしてい
るのでなければ)。
</dd></dl>

クエリを可能な限り速く得たい場合、<code>Using filesort</code> と <code>Using
temporary</code> に注意すべきです。
</dd></dl>

<p>
join type は以下のものがあります。良い物から順に書いています：

</p>
<p>
<a name="IDX832"></a>
<a name="IDX833"></a>
</p><dl compact="">

<dt><code>system</code>
</dt><dd>
テーブルが一レコードだけ持っている (= system table). これは <code>const</code> join type
の特別な場合です。

<a name="IDX834"></a>
<a name="IDX835"></a>
</dd><dt><code>const</code>
</dt><dd>
テーブルは、最もマッチするレコードを１つもっており、これはクエリの
最初に読まれます。
1 つのレコードであるため、このレコード中のフィールドの値は
オプティマイザーによって常数としてみなされます。
1回だけ読まれるので、<code>const</code> テーブルはとても速いです! 

</dd><dt><code>eq_ref</code>
</dt><dd>
前のテーブルのそれぞれのレコードと結合する際、このテーブルから1レコード読まれま
す。これは join では <code>const</code> よりも良い形です。
インデックスの全てのパートが join で使用され、かつ、インデックスが
<code>UNIQUE</code> か <code>PRIMARY KEY</code> であるときに、これは使用されます。

</dd><dt><code>ref</code>
</dt><dd>
インデックスの値に合ったすべてのレコードは、前のテーブルからレコードと結合するた
めに、このテーブルから読まれるでしょう。
もしその join がキーの一番左の接頭部分だけを使用するならば、
あるいは、もしそのキーが <code>UNIQUE</code> や <code>PRIMARY KEY</code> でなければ
(言い換えるなら、もし join がキーの値を元に一つだけの、レコードを選択できなけれ
ば)、<code>ref</code> は使用されます。
もしそのキーがいくつかのマッチするレコードに使用されるだけなら、
join は良い形です。

</dd><dt><code>range</code>
</dt><dd>
示された範囲内にあるレコードのみが検索されます。
<code>key</code> 項目はどのインデックスが使用されているか示します。
The <code>key_len</code> contains the longest key part that was used.
The <code>ref</code> column will be NULL for this type.

</dd><dt><code>index</code>
</dt><dd>
<code>ALL</code> と同じですが、インデックスツリーが走査される場合のみを除きます。
これは、インデックスファイルはデータファイルよりも小さいため、通常 <code>ALL</code> よ
り速いです。

</dd><dt><code>ALL</code>
</dt><dd>
前のテーブルのレコードとのそれぞれの結合において、全テーブルが走査されます。
もしそのテーブルが最初のテーブルで <code>const</code> 状態ではないなら、通常
これは良くありません。他の状態では<strong>とても</strong>悪くなります。
これは普通、レコードががより早いテーブルからから定数値に基づいて検索することがで
きるように、
インデックスを追加することにより <code>ALL</code> を避けることが可能です。 
</dd></dl>

<p>
<code>EXPLAIN</code> 出力の <code>rows</code> フィールド内のすべての値を増やすことによ
り、join がどのように良くなるかの良い表示を得ることができます。これは、
<strong>MySQL</strong> がクエリ実行の検査をする必要があるレコードのおおよその数を
知らせます。この数は <code>max_join_size</code> 変数でのクエリを制限する時にも使
用します。
 「<a href="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a>」節参照.

</p>
<p>
以下の例は、<code>EXPLAIN</code> が提供する情報を元に、いかに <code>JOIN</code> が最適化
できるかの例です。

</p>
<p>
以下のような <code>EXPLAIN</code> で検査する <code>SELECT</code> 構文があるとします：

</p>

<pre>EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
            tt.ProjectReference, tt.EstimatedShipDate,
            tt.ActualShipDate, tt.ClientID,
            tt.ServiceCodes, tt.RepetitiveID,
            tt.CurrentProcess, tt.CurrentDPPerson,
            tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
            et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
            AND tt.ActualPC = et.EMPLOYID
            AND tt.AssignedPC = et_1.EMPLOYID
            AND tt.ClientID = do.CUSTNMBR;
</pre>

<p>
この例では、以下のように仮定します：

</p>

<ul>
<li>

フィールドは以下のように定義されています：

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Table</strong> </td><td> <strong>Column</strong> </td><td> <strong>Column type</strong>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ActualPC</code> </td><td> <code>CHAR(10)</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>AssignedPC</code> </td><td> <code>CHAR(10)</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ClientID</code> </td><td> <code>CHAR(10)</code>
</td></tr>
<tr><td><code>et</code> </td><td> <code>EMPLOYID</code> </td><td> <code>CHAR(15)</code>
</td></tr>
<tr><td><code>do</code> </td><td> <code>CUSTNMBR</code> </td><td> <code>CHAR(15)</code>
</td></tr>
</tbody></table>

</li><li>

テーブルは以下のインデックスを持ちます：

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Table</strong> </td><td> <strong>Index</strong>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ActualPC</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>AssignedPC</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ClientID</code>
</td></tr>
<tr><td><code>et</code> </td><td> <code>EMPLOYID</code> (primary key)
</td></tr>
<tr><td><code>do</code> </td><td> <code>CUSTNMBR</code> (primary key)
</td></tr>
</tbody></table>

</li><li>

<code>tt.ActualPC</code> の値は、いちように分布して(配置されて)いません。
</li></ul>

<p>
最初、いかなる最適化も行われていない状態では、<code>EXPLAIN</code> 構文は
以下の情報を提示します：

</p>

<pre>table type possible_keys                key  key_len ref  rows  Extra
et    ALL  PRIMARY                      NULL NULL    NULL 74
do    ALL  PRIMARY                      NULL NULL    NULL 2135
et_1  ALL  PRIMARY                      NULL NULL    NULL 74
tt    ALL  AssignedPC,ClientID,ActualPC NULL NULL    NULL 3872
      range checked for each record (key map: 35)
</pre>

<p>
それぞれのテーブルで、<code>type</code> が <code>ALL</code> になっています。
これは <strong>MySQL</strong> が全てのテーブルを全結合することを示します！
それぞれのテーブル内の行数分から作った物が調べられるので、とても長い時間がかかり
ます！
この場合、<code>74 * 2135 * 74 * 3872 = 45,268,558,720</code> 行調べることになります。
テーブルが肥大化したときにかかる時間を考えてください....

</p>
<p>
一つ問題があります。(まだ) <strong>MySQL</strong> がフィールドのインデックスを効果的に
使用できていません。
この例の場合では、<code>VARCHAR</code> と <code>CHAR</code> は、それらが同じ長さで定義されて
いれば、変わりがありません。
<code>tt.ActualPC</code> は <code>CHAR(10)</code> と定義されており、
<code>et.EMPLOYID</code> は <code>CHAR(15)</code> です。これらの長さは違います。

</p>
<p>
この不釣り合いを修正するにあたり、<code>ALTER TABLE</code> を使って
<code>ActualPC</code> の長さを 10 文字から 15 文字にします：

</p>

<pre>mysql&gt; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
</pre>

<p>
これで <code>tt.ActualPC</code> and <code>et.EMPLOYID</code> は両方とも <code>VARCHAR(15)</code> 
になりました。
 <code>EXPLAIN</code> 構文を実行し直すと、以下を提示します：

</p>

<pre>table type   possible_keys   key     key_len ref         rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL 3872    where used
do    ALL    PRIMARY         NULL    NULL    NULL        2135
      range checked for each record (key map: 1)
et_1  ALL    PRIMARY         NULL    NULL    NULL        74
      range checked for each record (key map: 1)
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC 1
</pre>

<p>
まだ完全ではありませんが、よりよくなっています(<code>rows</code> 値の
生成量は 74 より小さくなります)。この場合、実行は数秒でしょう。

</p>
<p>
A second alteration can be made to eliminate the column length mismatches
for the <code>tt.AssignedPC = et_1.EMPLOYID</code> and <code>tt.ClientID =
do.CUSTNMBR</code> comparisons:

</p>

<pre>mysql&gt; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
                      MODIFY ClientID   VARCHAR(15);
</pre>

<p>
これで <code>EXPLAIN</code> は以下を出力します：

</p>

<pre>table type   possible_keys   key     key_len ref            rows     Extra
et    ALL    PRIMARY         NULL    NULL    NULL           74
tt    ref    AssignedPC,ClientID,ActualPC ActualPC 15 et.EMPLOYID 52 where used
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</pre>

<p>
これは ``ほとんど'' 最良に近いです。

</p>
<p>
残る問題は、デフォルトでは、<strong>MySQL</strong> は <code>tt.ActualPC</code> フィールド内の
値がまんべんなく分布していると想定しており、この <code>tt</code> テーブルの場合には
適合しません。
幸運にも、これを <strong>MySQL</strong> に教えるのはとても簡単です：

</p>

<pre>shell&gt; myisamchk --analyze PATH_TO_MYSQL_DATABASE/tt
shell&gt; mysqladmin refresh
</pre>

<p>
これで join は ``完璧'' です。
<code>EXPLAIN</code> は以下の結果を示します：

</p>

<pre>table type   possible_keys   key     key_len ref            rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL    3872    where used
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC    1
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</pre>

<p>
 <code>EXPLAIN</code> の出力中の <code>rows</code> 項目は、 <strong>MySQL</strong> JOIN オプティマイ
ザーによる、``推測'' です；  
クエリの最適化のために、この数値が実際に近いかどうかをチェックすべきです。
そうでなければ、<code>SELECT</code> ステートメントで <code>STRAIGHT_JOIN</code> を使用
し、<code>FROM</code> 節に異なる順でテーブルを並べることで、良いパフォーマンスを
得られます。

</p>



<h3><a name="Estimating_performance" href="manual.ja_toc.html#Estimating_performance">5.2.2  Estimating Query Performance</a></h3>

<p>
<a name="IDX836"></a>
<a name="IDX837"></a>
<a name="IDX838"></a>

</p>
<p>
ほとんどの場合、ディスク・シークを数えることでだいたいのパフォーマンスを予測でき
ます。
小さなテーブルでは、通常、1回のディスク・シークでレコードを見つけれるでしょう
(インデックスがたぶんキャッシュされるので)。 大きなテーブルでは、
おおよその予測として、(B++ ツリーインデックスを使用している場合)、
<code>log(row_count) /
log(index_block_length / 3 * 2 / (index_length + data_pointer_length)) +
1</code> シーク、1レコードを見つけるのに必要となるでしょう。

</p>
<p>
<strong>MySQL</strong> では、インデックス・ブロックは通常 1024 バイトで、
データ・ポインターは通常 4 バイトです。 これは、
インデックス長が 3 (medium integer) 、データが 500,000 レコードあるテーブルでは、 
<code>log(500,000)/log(1024/3*2/(3+4)) + 1</code> = 4 シークとなります。

</p>
<p>
As the above index would require about 500,000 * 7 * 3/2 = 5.2M,
(assuming that the index buffers are filled to 2/3, which is typical)
you will probably have much of the index in memory and you will probably
only need 1-2 calls to read data from the OS to find the row.

</p>
<p>
書き込み時には、上の場合、新しいインデックスを書き込める場所を
探し出すのに、4 シークかかり、さらに、通常、インデックスを更新し、
レコードを書くのに 2 シーク必要です。

</p>
<p>
Note that the above doesn't mean that your application will slowly
degenerate by N log N!  As long as everything is cached by the OS or SQL
server things will only go marginally slower while the table gets
bigger. After the data gets too big to be cached, things will start to
go much slower until your applications is only bound by disk-seeks
(which increase by N log N). To avoid this, increase the index cache as
the data grows.  「<a href="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a>」節参照.

</p>



<h3><a name="SELECT_speed" href="manual.ja_toc.html#SELECT_speed">5.2.3  <code>SELECT</code> クエリの速度</a></h3>

<p>
<a name="IDX839"></a>

</p>
<p>
<a name="IDX840"></a>

</p>
<p>
通常、遅い <code>SELECT ... WHERE</code> を速くするには、
まず最初にインデックスがあるかどうかをチェックします。
 「<a href="manual.ja_MySQL_Optimization.html#MySQL_indexes">5.4.3  MySQL はどのようにインデックスを使用するか？</a>」節参照.
違うテーブルを参照する場合には、普通はインデックスをともなうべきです。
<code>EXPLAIN</code> コマンドを使用すれば、<code>SELECT</code> でどのインデックスが
使用されているか確認できます。
 「<a href="manual.ja_MySQL_Optimization.html#EXPLAIN">5.2.1  <code>EXPLAIN</code> 構文 (<code>SELECT</code>についての情報を得る)</a>」節参照.

</p>
<p>
Some general tips:

</p>

<ul>
<li>

To help MySQL optimize queries better, run <code>myisamchk
--analyze</code> on a table after it has been loaded with relevant data. This
updates a value for each index part that indicates the average number of
rows that have the same value.  (For unique indexes, this is always 1,
of course.).  MySQL will use this to decide which index to
choose when you connect two tables with 'a non-constant expression'.
You can check the result from the <code>analyze</code> run by doing <code>SHOW
INDEX FROM table_name</code> and examining the <code>Cardinality</code> column.

</li><li>

インデックスとデータをインデックス順に従ってソートするには、
<code>myisamchk --sort-index --sort-records=1</code> を使用します
(もし １番目のインデックス順にソートするなら)。 
If you
have a unique index from which you want to read all records in order
according to that index, this is a good way to make that faster. 
しかし、このソート方法は最適状態では書かれず、また大きなテーブルでは
多くの時間がかかることに注意してください！
</li></ul>



<h3><a name="Where_optimizations" href="manual.ja_toc.html#Where_optimizations">5.2.4  MySQL はどのように <code>WHERE</code> 節を最適化するか？</a></h3>

<p>
<a name="IDX841"></a>

</p>
<p>
<a name="IDX842"></a>

</p>
<p>
<code>WHERE</code> の最適化は、<code>WHERE</code> がほとんど <code>SELECT</code> で使用されるため、
<code>SELECT</code> に置かれています。 しかし、同じ最適化は
<code>DELETE</code> や <code>UPDATE</code> 文でも使用されます。

</p>
<p>
このセクションの最適化の説明はまだ不十分です。
なぜなら、 <strong>MySQL</strong> はとても多くの最適化を行っており、
それら全てについての説明を書ける時間が、我々はとれません。

</p>
<p>
<strong>MySQL</strong>による最適化のいくつかを以下に示します:

</p>

<ul>
<li>

括弧の除去 (全ての不必要な括弧は削除されます):

<pre>   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&gt; (a AND b AND c) OR (a AND b AND c AND d)
</pre>

</li><li>

定数の保持:

<pre>   (a&lt;b AND b=c) AND a=5
-&gt; b&gt;5 AND b=c AND a=5
</pre>

</li><li>

定数条件の除去 (定数保持のために必要とされます):

<pre>   (B&gt;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&gt; B=5 OR B=6
</pre>

</li><li>

インデックスに使用される全ての表現は一度だけ評価されます。
</li><li>

一つのテーブル上の <code>WHERE</code> がない <code>CONST(*)</code> は、テーブルから
直接取り出されます。これはまた同じ条件下での任意の <code>NOT NULL</code> 表現
のためにも行われます。
</li><li>

不当な定数表現は早く検出されます。
<strong>MySQL</strong> は不可能な  <code>SELECT</code> 構文を素早く見つけ、0 行を結果として返
します。
</li><li>

<code>GROUP BY</code> または group 関数 (<code>COUNT()</code>, <code>MIN()</code>...) を使用しない
場合は、
<code>HAVING</code> は <code>WHERE</code> とマージされます。
</li><li>

各サブ結合についての速い <code>WHERE</code> 評価を得るために、また、可能な限り
早くレコードをスキップするために、各サブ結合についてより簡単な 
<code>WHERE</code> が構築されます。
<a name="IDX843"></a>
<a name="IDX844"></a>
</li><li>

全ての定数テーブルをクエリー中の他のテーブルより先に読みます。
定数テーブルは次です:

<ul>
<li>

0 または 1 レコードのテーブル。
</li><li>

<code>WHERE</code> 節で <code>UNIQUE</code> インデックスや <code>PRIMARY KEY</code> が使用されたテ
ーブルで、かつ、全てのインデックスが定数式で使用されていて、
かつ、インデックスのパートが <code>NOT NULL</code> で定義されているテーブル。
</li></ul>

以下のテーブルのように定数だけを使用するテーブル:

<pre>mysql&gt; SELECT * FROM t WHERE primary_key=1;
mysql&gt; SELECT * FROM t1,t2
           WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
</pre>

</li><li>

テーブルを結合するために最良の結合の組合せを見つけます。全ての可能性を試して 。
<code>ORDER BY</code> または <code>GROUP</code> 内の全てのフィールドが同じテーブルの場合は、
このテーブルは結合時に最初に優先されます。
</li><li>

<code>ORDER BY</code> 節と <code>GROUP BY</code> 節がある場合、または <code>ORDER BY</code> か
 <code>GROUP BY</code> が結合キュー内の最初のテーブルではない他のテーブルからの項目を
含む場合、一時テーブルが生成されます。
</li><li>

もし <code>SQL_SMALL_RESULT</code> を使用するなら, <strong>MySQL</strong> はメモリー内の一時
テーブルを使用します
</li><li>

各テーブルのインデックスはクエリされ、得られる行の 30% 未満の幅しかない最良のイ
ンデックスが使用されます。
そのようなインデックスが見つけられない場合、素早いテーブルの走査
(quick table scan)が使用されます。
</li><li>

同じように、<strong>MySQL</strong> はデータファイルを等しく調べはしないインデックスから
レコードを読むことが可能です。もし全てのフィールドが数値型のインデックスなら、
インデックスツリーだけがクエリの解決に使用されます。
</li><li>

各レコードが出力される前に、<code>HAVING</code> 節に適合するものをスキップします。
</li></ul>

<p>
以下はとても速いクエリの例です:

</p>

<pre>mysql&gt; SELECT COUNT(*) FROM tbl_name;
mysql&gt; SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;
mysql&gt; SELECT MAX(key_part2) FROM tbl_name
           WHERE key_part_1=constant;
mysql&gt; SELECT ... FROM tbl_name
           ORDER BY key_part1,key_part2,... LIMIT 10;
mysql&gt; SELECT ... FROM tbl_name
           ORDER BY key_part1 DESC,key_part2 DESC,... LIMIT 10;
</pre>

<p>
以下のクエリはインデックスツリーのみを使用します(インデックス化されているフィー
ルドは数値型と仮定します)：

</p>

<pre>mysql&gt; SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
mysql&gt; SELECT COUNT(*) FROM tbl_name
           WHERE key_part1=val1 AND key_part2=val2;
mysql&gt; SELECT key_part2 FROM tbl_name GROUP BY key_part1;
</pre>

<p>
以下のクエリは、ソートされた行の検索にインデックスを使用します：

</p>

<pre>mysql&gt; SELECT ... FROM tbl_name ORDER BY key_part1,key_part2,... ;
mysql&gt; SELECT ... FROM tbl_name ORDER BY key_part1 DESC,key_part2 DESC,... ;
</pre>



<h3><a name="DISTINCT_optimization" href="manual.ja_toc.html#DISTINCT_optimization">5.2.5  How MySQL Optimizes <code>DISTINCT</code></a></h3>

<p>
<a name="IDX845"></a>

</p>
<p>
<a name="IDX846"></a>

</p>
<p>
<code>DISTINCT</code> is converted to a <code>GROUP BY</code> on all columns,
<code>DISTINCT</code> combined with <code>ORDER BY</code> will in many cases also
need a temporary table.

</p>
<p>
When combining <code>LIMIT #</code> with <code>DISTINCT</code>, MySQL will stop
as soon as it finds <code>#</code> unique rows.

</p>
<p>
If you don't use columns from all used tables, MySQL will stop
the scanning of the not used tables as soon as it has found the first match.

</p>

<pre>SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
</pre>

<p>
In the case, assuming t1 is used before t2 (check with <code>EXPLAIN</code>), then
MySQL will stop reading from t2 (for that particular row in t1)
when the first row in t2 is found.

</p>



<h3><a name="LEFT_JOIN_optimization" href="manual.ja_toc.html#LEFT_JOIN_optimization">5.2.6  MySQL はどのように <code>LEFT JOIN</code> と <code>RIGHT JOIN</code> を最適化するか？</a></h3>

<p>
<a name="IDX847"></a>

</p>
<p>
<a name="IDX848"></a>

</p>
<p>
<strong>MySQL</strong> の <code>A LEFT JOIN B</code> は以下のように組みこまれています：

</p>

<ul>
<li>

The table <code>B</code> is set to be dependent on table <code>A</code> and all tables
that <code>A</code> is dependent on.

</li><li>

テーブル <code>A</code> が <code>LEFT JOIN</code> 条件中に使用される全てのテーブル
（ただし <code>B</code> は除く）に依存すると、セットされます。

</li><li>

全ての <code>LEFT JOIN</code> 条件が <code>WHERE</code> 節に移動されます。

</li><li>

All standard join optimizations are done, with the exception that a table is
always read after all tables it is dependent on.  If there is a circular
dependence then MySQL will issue an error.

</li><li>

全ての <code>WHERE</code> 節の最適化が行われます。

</li><li>

<code>WHERE</code> 節にマッチするレコードが <code>A</code> にあり、
<code>LEFT JOIN</code> 条件にマッチするレコードが <code>B</code> にない場合、
全てのフィールドが <code>NULL</code> にセットされた <code>B</code> のレコードが
作成されます。 

</li><li>

If you use <code>LEFT JOIN</code> to find rows that don't exist in some
table and you have the following test: <code>column_name IS NULL</code> in the
<code>WHERE</code> part, where column_name is a column that is declared as
<code>NOT NULL</code>, then MySQL will stop searching after more rows
(for a particular key combination) after it has found one row that
matches the <code>LEFT JOIN</code> condition.
</li></ul>

<p>
<code>RIGHT JOIN</code> is implemented analogously as <code>LEFT JOIN</code>.

</p>
<p>
The table read order forced by <code>LEFT JOIN</code> and <code>STRAIGHT JOIN</code>
will help the join optimizer (which calculates in which order tables
should be joined) to do its work much more quickly, as there are fewer
table permutations to check.

</p>
<p>
Note that the above means that if you do a query of type:

</p>

<pre>SELECT * FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key) WHERE b.key=d.key
</pre>

<p>
MySQL will do a full scan on <code>b</code> as the <code>LEFT JOIN</code> will force 
it to be read before <code>d</code>.

</p>
<p>
The fix in this case is to change the query to:

</p>

<pre>SELECT * FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key) WHERE b.key=d.key
</pre>



<h3><a name="LIMIT_optimization" href="manual.ja_toc.html#LIMIT_optimization">5.2.7  MySQL はどのように <code>LIMIT</code> を最適化するか？</a></h3>

<p>
<a name="IDX849"></a>

</p>
<p>
<a name="IDX850"></a>

</p>
<p>
In some cases MySQL will handle the query differently when you are
using <code>LIMIT #</code> and not using <code>HAVING</code>:

</p>

<ul>
<li>

もし <code>LIMIT</code> を使用して限定した数だけ select を行うなら、 <strong>MySQL</strong> は、
ある場合、テーブルを全て走査するよりも、インデックスを使用しようとします。

</li><li>

もし <code>LIMIT #</code> を <code>ORDER BY</code> と共に使用するなら, <strong>MySQL</strong> は
最初の <code>#</code> 行を見つけたらすぐに、全テーブルのソートは行わずに、
ソートを終わらせます。 

</li><li>

<code>LIMIT #</code> を <code>DISTINCT</code> と共に使用するなら, <strong>MySQL</strong> は
<code>#</code> 個の一意なレコードを見つけた時点で終わります。

</li><li>

In some cases a <code>GROUP BY</code> can be resolved by reading the key in order
(or do a sort on the key) and then calculate summaries until the
key value changes.  In this case <code>LIMIT #</code> will not calculate any
unnecessary <code>GROUP BY</code>'s.
</li><li>

<strong>MySQL</strong> は、最初の <code>#</code> 行をクライアントに送ったあと直に、
クエリを中断します。

</li><li>

<code>LIMIT 0</code> は常に素早く空の結果を返します。
これはクエリのチェックや結果として得られるフィールドの型を得るために利用できます。

</li><li>

一時テーブルの大きさは、クエリを解決するためにどれぐらいのスペースがいるかを
計算するのに、<code>LIMIT #</code> を使用します。

</li></ul>



<h3><a name="Insert_speed" href="manual.ja_toc.html#Insert_speed">5.2.8  <code>INSERT</code> クエリの速度</a></h3>

<p>
<a name="IDX851"></a>

</p>
<p>
<a name="IDX852"></a>
<a name="IDX853"></a>

</p>
<p>
レコードを挿入する時間はおおよそ次からなります:

</p>

<ul>
<li>

Connect:                 (3)
</li><li>

Sending query to server: (2)
</li><li>

Parsing query:           (2)
</li><li>

Inserting record:        (1 x size of record)
</li><li>

Inserting indexes:       (1 x number of indexes)
</li><li>

Close:                   (1)
</li></ul>

<p>
ここで (数字) は比例時間です。これは、テーブルのオープンにかかる初期オーバーヘッ
ド(これは同時に動作する各クエリ毎に1回行なわれます)は考慮されていません。

</p>
<p>
テーブルのサイズはインデックスの挿入を N log N で遅くします (B-tree)。

</p>
<p>
INSERT を速くするいくつかの方法：

</p>

<ul>
<li>

もし同じクライアントから多くのレコードを同時にインサートするなら、
複数の値が書ける <code>INSERT</code> 文を使用します。 これは個々に <code>INSERT</code> 文
を発行する場合に比べて、とても速くなります。

</li><li>

もし違うクライアントから多くのレコードを同時にインサートするなら、
 <code>INSERT DELAYED</code> 文の使用で、より速くなるでしょう。  「<a href="manual.ja_Reference.html#INSERT">6.4.2  <code>INSERT</code> 構文</a>」節参照.

</li><li>

<code>MyISAM</code> では、複数の <code>SELECT</code> が走っているテーブルに対して、
同時に、レコードを挿入できます。 ただしそのテーブルに対して
レコードの削除がない場合に。

</li><li>

テキストファイルからテーブルにデータをいれる場合は、 <code>LOAD DATA INFILE</code> を
使用します。 これはたくさんの <code>INSERT</code> 文の発行に比べて通常 20倍 程度
速くなります
 「<a href="manual.ja_Reference.html#LOAD_DATA">6.4.8  <code>LOAD DATA INFILE</code> 構文</a>」節参照.

</li><li>

テーブルが多くのインデックスを持っている場合、ある方法で、
<code>LOAD DATA INFILE</code> の実行を速くすることが可能です。
以下の手順で行います：


<ol>
<li>

Optionally create the table with <code>CREATE TABLE</code>. For example, using
<code>mysql</code> or Perl-DBI.

</li><li>

<code>FLUSH TABLES</code> の実行。 あるいは <code>mysqladmin flush-tables</code> 
コマンドの実行。

</li><li>

<code>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</code> の使用。
これは指定されたテーブルから全てのインデックスを削除します。

</li><li>

そのテーブルに <code>LOAD DATA INFILE</code> を使用してデータを入れます. 
これはいかなるインデックスも更新しないでしょうし、そのため、速くもなるでしょう。

</li><li>

If you are going to only read the table in the future, run <code>myisampack</code>
on it to make it smaller.  「<a href="manual.ja_Table_types.html#Compressed_format">7.1.2.3  Compressed Table Characteristics</a>」節参照.

</li><li>

<code>myisamchk -r -q /path/to/db/tbl_name</code> でインデックスを再構築. 
これは disk に書き込む前にインデックスをメモリに作成します。
これは多くのディスクシークを避けることが出来るのでとても速くなります。
でき上がったインデックスツリーは、バランスのよいものになります。

</li><li>

<code>FLUSH TABLES</code> の実行。 あるいは <code>mysqladmin flush-tables</code> 
コマンドの実行。
</li></ol>

この手順は、将来の MySQL の <code>LOAD DATA INFILE</code> に組み込むかもしれません。

</li><li>

テーブルをロックすることで、挿入を速くすることも可能です：


<pre>mysql&gt; LOCK TABLES a WRITE;
mysql&gt; INSERT INTO a VALUES (1,23),(2,34),(4,33);
mysql&gt; INSERT INTO a VALUES (8,26),(6,29);
mysql&gt; UNLOCK TABLES;
</pre>

主な速度差は、全ての <code>INSERT</code> 構文でインデックスバッファが一度だけディスク
にフラッシュされることです。通常は  <code>INSERT</code> 構文があるのと同じくらい多くの
インデックスバッファフラッシュがあります。単一構文の全てのレコードは、ロック
なしで挿入できます。

ロックも複数接続テストの合計時間を低くしますが、いくつかのスレッドの最大
待ち時間は上がります(ロックを待っているから)。
例えば:


<pre>thread 1 does 1000 inserts
thread 2, 3, and 4 does 1 insert
thread 5 does 1000 inserts
</pre>

ロックを使用しない場合、2, 3 そして 4 は 1 と 5 の前に終ります。ロックを
使用する場合、2,3,4 は 1 や 5 の前に終わることはおそらくありませんが、合
計時間は約 40 % 速くなります。

<code>INSERT</code>, <code>UPDATE</code> , <code>DELETE</code> は、 <strong>MySQL</strong> ではとても速い
ので、
1 行で約 5 つ以上、値を 挿入・更新 をする操作に対して、
ロックを追加すれば、全般的により良い性能が得られます。
とても多い insert を行なう場合、
他のスレッドにそのロックしたテーブルへのアクセスを与えるために 、
だいたい 1000 レコードごとに一度、<code>UNLOCK TABLES</code> した後に
 <code>LOCK TABLES</code> を行います。 これでもまだ良い性能が得られます。

もちろん <code>LOAD DATA INFILE</code> はとても速いです。
</li></ul>

<p>
<code>LOAD DATA INFILE</code> と <code>INSERT</code> を共に速くするためには、
キーバッファを増やします。  「<a href="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a>」節参照.

</p>



<h3><a name="Update_speed" href="manual.ja_toc.html#Update_speed">5.2.9  <code>UPDATE</code> クエリの速度</a></h3>

<p>
<code>UPDATE</code> クエリは <code>SELECT</code> クエリのように最適化されますが、
書き込みのオーバーヘッドが加わります。
書き込み速度は、更新されるデータの大きさ、更新されるインデックス数に
依ります。 変更されないインデックスは更新されません。

</p>
<p>
Also, another way to get fast updates is to delay updates and then do
many updates in a row later. Doing many updates in a row is much quicker
than doing one at a time if you lock the table.

</p>
<p>
Note that, with dynamic record format, updating a record to
a longer total length may split the record.  So if you do this often,
it is very important to <code>OPTIMIZE TABLE</code> sometimes.
 「<a href="manual.ja_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  <code>OPTIMIZE TABLE</code> 構文</a>」節参照.

</p>



<h3><a name="Delete_speed" href="manual.ja_toc.html#Delete_speed">5.2.10  <code>DELETE</code> クエリの速度</a></h3>

<p>
If you want to delete all rows in the table, you should use
<code>TRUNCATE TABLE table_name</code>.  「<a href="manual.ja_Reference.html#TRUNCATE">6.4.6  <code>TRUNCATE</code> 構文</a>」節参照.

</p>
<p>
1レコードを削除する時間は、ちょうどインデックスの数に比例します。
より速くレコードを削除したいなら、インデックス・キャッシュを
増やします。  「<a href="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a>」節参照.

</p>



<h3><a name="Tips" href="manual.ja_toc.html#Tips">5.2.11  最適化に関するその他の助言</a></h3>

<p>
<a name="IDX854"></a>
<a name="IDX855"></a>

</p>
<p>
Unsorted tips for faster systems:

</p>

<ul>
<li>

コネクションオーバーヘッドを避けるために、データベースに対して、
逐次コネクションを落とさないように、常に接続を保ちます。
If you can't use persistent connections and you are doing a
lot of new connections to the database, you may want to change the value
of the <code>thread_cache_size</code> variable.  「<a href="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a>」節参照.
</li><li>

あなたのクエリがテーブルのインデックスを使用しているか、いつもチェックします。
<strong>MySQL</strong> では <code>EXPLAIN</code> コマンドでこれが行えれます。
 「<a href="manual.ja_MySQL_Optimization.html#EXPLAIN">5.2.1  <code>EXPLAIN</code> 構文 (<code>SELECT</code>についての情報を得る)</a>」節参照.
</li><li>

たくさん変更されるようなテーブルに対して、複雑な <code>SELECT</code> クエリを
避けるように試みます。 これはテーブル・ロックの問題を避けるためです。
</li><li>

新しい <code>MyISAM</code> テーブルでは、あるテーブルにレコードが挿入(削除は無しで)
されている最中に、同時に、同じテーブルからデータを読むことが可能です。
これがあなたにとって重要項目であるなら、
レコードの削除の必要のない方法や、多くのレコードを削除した後に
 <code>OPTIMIZE TABLE</code> を実行することを、考慮すべきです。
</li><li>

Use <code>ALTER TABLE ... ORDER BY expr1,expr2...</code> if you mostly
retrieve rows in expr1,expr2.. order.  By using this option after big
changes to the table, you may be able to get higher performance.
</li><li>

In some cases it may make sense to introduce a column that is 'hashed'
based on information from other columns. If this column is short and
reasonably unique it may be much faster than a big index on many
columns. In MySQL it's very easy to use this extra column:
<code>SELECT * FROM table_name WHERE hash=MD5(concat(col1,col2))
AND col_1='constant' AND col_2='constant'</code>
</li><li>

多くの変更がなされるテーブルに対しては、全ての <code>VARCHAR</code> や <code>BLOB</code> 
フィールドを避けるように試みるべきです。
You will get dynamic row length as soon as you
are using a single <code>VARCHAR</code> or <code>BLOB</code> column.  「<a href="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</a>」節参照.
</li><li>

通常、あるテーブルを違うテーブルに分けることは、レコードが大きくなる
ために役立ちません。
レコードにアクセスする際、そのレコードの最初のバイトを見つけるための
ディスク・シークが、一番かかります。
After finding
the data most new disks can read the whole row fast enough for most
applications. The only cases where it really matters to split up a table is if
it's a dynamic row size table (see above) that you can change to a fixed
row size, or if you very often need to scan the table and don't need
most of the columns.  「<a href="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</a>」節参照.
</li><li>

もし、多くのレコードからの情報を元にした計算(あるもののカウントとか)を
しょっちゅう行う必要があるなら、新しいテーブルを用意し、逐次カウンターを
更新した方が多分良いでしょう。
<code>UPDATE table set count=count+1 where index_column=constant</code> の更新は
とても速いです！

これは、<strong>MySQL</strong> のようなテーブル・ロッキング
(multiple readers / single writers)をもつデータベースを
使う上で、本当に重要なことです。
This will
also give better performance with most databases, as the row locking
manager in this case will have less to do.
</li><li>

もしたくさんの大きなテーブルから統計を収集する必要があるなら、
全テーブルを走査する代わりに、サマリーテーブルを使用します。
Maintaining the summaries should be
much faster than trying to do statistics 'live'. It's much faster to
regenerate new summary tables from the logs when things change
(depending on business decisions) than to have to change the running
application!
</li><li>

If possible, one should classify reports as 'live' or 'statistical',
where data needed for statistical reports are only generated based on
summary tables that are generated from the actual data.
</li><li>

フィールドにはデフォルト値があるという事を利用して下さい。
値がデフォルトとは違う場合に限り、値を挿入します。
これは <strong>MySQL</strong> が必要とする分析を少なくし、インサートの速度が向上します。
</li><li>

ある場合では、BLOB にデータをパックして保存するのが便利です。
この場合、BLOB に入れた値を パック・アンパック するためのコードを
あなたのアプリケーションに組み込まなくてはなりません。
しかしこれは、多くのアクセスを抑制するでしょう。
これは、静的(固定長)テーブル構造に適しないデータを持っている場合に
実用になります。
</li><li>

通常、あなたは全てのデータを冗長の無いように(データベース理論で
第３正規形 , 3rd Normal Form , 3NF と呼ばれる)
しようとするかもしれませんが、しかし、よりスピードを求める場合は、
重複やサマリーテーブルの作成をおそれてはいけません。
</li><li>

ストアド・プロシージャ や UDF (ユーザー定義関数) はよりパフォーマンスを得る
ためにはよい方法かもしれません。
In this case you should, however, always have a way
to do this some other (slower) way if you use some database that doesn't
support this.
</li><li>

You can always gain something by caching queries/answers in your
application and trying to do many inserts/updates at the same time.  If
your database supports lock tables (like MySQL and Oracle),
this should help to ensure that the index cache is only flushed once
after all updates.
</li><li>

データをすぐには書く必要がないとき、<code>INSERT /*! DELAYED */</code> を使用します。
これは、一回のディスクへの書き込みで、多くのレコードがかかれるので、
速くなります。
</li><li>

SELECT がより重要な場合、<code>INSERT /*! LOW_PRIORITY */</code> を使用します。
</li><li>

キューを無視して SELECT を優先的に行いたいときは
<code>SELECT /*! HIGH_PRIORITY */</code> を使用します。
これは、たとえ誰かが書き込みを待っていたとしても、その SELECT は
実行されます。
</li><li>

複数行 <code>INSERT</code> 文の使用。 これは多くのレコードを一つの SQL コマンドで
挿入することが出来ます。
(多くの SQL サーバーがこれをサポートしています)
</li><li>

大きなデータの読み込みには <code>LOAD DATA INFILE</code> を使用します。
This is
faster than normal inserts and will be even faster when <code>myisamchk</code>
is integrated in <code>mysqld</code>.
</li><li>

一意の値を作るために、 <code>AUTO_INCREMENT</code> を使用します。
</li><li>

動的テーブルフォーマットの使用時には、フラグメンテーションを避けるために、
<code>OPTIMIZE TABLE</code> を時々使用します。
 「<a href="manual.ja_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  <code>OPTIMIZE TABLE</code> 構文</a>」節参照.

</li><li>

可能ならば <code>HEAP</code> テーブルをスピードアップのために使用します.
  「<a href="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</a>」節参照.
</li><li>

通常の Web サーバーの設定ならば、イメージはファイルに保存すべきです。
データベースには、それらファイルの参照(パスとか)のみを入れます。
この主な理由は、通常の Web サーバーはデータベースよりもコンテンツを
よりよくキャッシュしてくれるからです。 それでファイルを使用するなら、
速いシステムをより簡単に得ることができます。
</li><li>

重要でないデータで、よくアクセスされる物は、メモリテーブルにいれます。
(like
information about the last shown banner for users that don't have
cookies).
</li><li>

Columns with identical information in different tables should be
declared identical and have identical names. Before Version 3.23 you
got slow joins otherwise.

名前は単純にしてください（customer テーブルでは <code>customer_name</code> の
かわりに <code>name</code> を使うとか）。 他の SQL サーバーへの移植を考慮するなら、
名前は 18 文字より短くすべきです。
</li><li>

もし本当にハイ・スピードが必要なら、SQL サーバーがサポートしている物とは
違う、ローレベルのデータ保存のインターフェースに注目すべきです。
例えば、 <strong>MySQL</strong> <code>MyISAM</code> を直接アクセスすることは、
SQL インターフェースを介してアクセスするよりも、2～5倍速くなるでしょう。
これを可能にするには、そのデータは、アプリケーションと同じマシン上になくてはなら
ず、通常、一つのプロセスだけでアクセスされるべきです。
(なぜなら、外部ファイルロックは、とても遅いから)。
上の問題は、<strong>MySQL</strong> サーバー内の <code>MyISAM</code> のローレベルのコマンドの
導入で解決できるでしょう。 (これはよりよいパフォーマンスを得ることの出来る、
簡単な方法の一つです)。
By carefully designing the database interface,
it should be quite easy to support this types of optimization.
</li><li>

多くの場合、データベースからデータをアクセスする方が(接続を維持していれば)、
テキストファイルからデータをアクセスするよりも速いです。 なぜなら、
データベースはテキストファイルよりもコンパクトになり（数値データの場合）、
このため、ディスクアクセスが少なくなるからです。
また、行や項目を見つけるために、テキストファイルを解析する必要も省けます。
</li><li>

レプリケーションもスピードアップに使用できるでしょう。  「<a href="manual.ja_MySQL_Database_Administration.html#Replication">4.10  MySQL のレプリケーション</a>」節参照.
</li><li>

<code>DELAY_KEY_WRITE=1</code> が定義されたテーブルは、インデックスの更新が速くなります。
これはそのインデックス・ファイルが閉じられるまでディスクに記録されないからです。
したがって、なにかが途中で <code>mysqld</code> をキルしてもテーブルが大丈夫なようにす
るため、<code>mysqld</code> を起動する前には、<code>myisamchk</code> をそれらのテーブルに
対して実行すべきです。
As the key information can always be generated
from the data, you should not lose anything by using <code>DELAY_KEY_WRITE</code>.
</li></ul>



<h2><a name="Locking_Issues" href="manual.ja_toc.html#Locking_Issues">5.3  Locking Issues</a></h2>



<h3><a name="Internal_locking" href="manual.ja_toc.html#Internal_locking">5.3.1  MySQL はどのようにテーブルをロックするか</a></h3>

<p>
<a name="IDX856"></a>
<a name="IDX857"></a>
<a name="IDX858"></a>

</p>
<p>
付録に、異なるロックする方法に関する議論があります。
 「<a href="manual.ja_Porting.html#Locking_methods">G.4  Locking methods</a>」節参照.

</p>
<p>
<strong>MySQL</strong> の全てのロックはデッドロックフリーです。これは、常にクエ
リ開始時に一度ロックを必要とする全てを要求し、常に同じ順でテーブルをロッ
クすることで管理されます。

</p>
<p>
<strong>MySQL</strong> が使用する <code>WRITE</code> ロックは次のように働きます:

</p>

<ul>
<li>

テーブル上にロックがない場合 write ロックを置きます。
</li><li>

そうでなければ write ロックキューにロックを置きます。
</li></ul>

<p>
<strong>MySQL</strong> の <code>READ</code> ロックは次のように動きます:

</p>

<ul>
<li>

テーブル上に write ロックがない場合 read ロックを置きます。
</li><li>

そうでなければ read ロックキューにロックを置きます。
</li></ul>

<p>
ロックが解放されたとき、最初に write ロックキュー内のスレッドに、その後 
read ロックキュー内のスレッドにロックを与えます。

</p>
<p>
これは、同じテーブルで多くの更新をする場合、<code>SELECT</code> 構文は 
update がなくなるまで待たされることを意味します。

</p>
<p>
同じテーブルで多くの <code>INSERT</code> と多くの <code>SELECT</code> を行う場合、これを解決
するには、他のテーブルに行を挿入して、たまに、その一時テーブルから全ての
レコードをもう一方のテーブルに update します。

</p>
<p>
これは次のコードで行えます:

</p><pre>mysql&gt; LOCK TABLES real_table WRITE, insert_table WRITE;
mysql&gt; insert into real_table select * from insert_table;
mysql&gt; TRUNCATE TABLE insert_table;
mysql&gt; UNLOCK TABLES;
</pre>

<p>
特定の場合での検索を優先的に行いたい場合、
 <code>LOW_PRIORITY</code> オプションと共に <code>INSERT</code> 、 <code>UPDATE</code> 、
 <code>DELETE</code> 構文、または <code>HIGH_PRIORITY</code> オプションと共に
 <code>SELECT</code> 構文を使用できます。
また、同様の動作を得るために、 <code>--low-priority-updates</code> オプション
と共に <code>mysqld</code> を開始することができます。

</p>
<p>
<code>SQL_BUFFER_RESULT</code> の使用はさらにテーブル・ロックをより短くするために有効かもしれません。
 「<a href="manual.ja_Reference.html#SELECT">6.4.1  <code>SELECT</code> 構文</a>」節参照.

</p>
<p>
一つのキューだけを使用するように <tt>`mysys/thr_lock.c'</tt> 内のロックコードを変更
することもできます。この場合、いくつかのアプリケーションのために、
write ロックは read ロックと同じ優先順位にします。

</p>



<h3><a name="Table_locking" href="manual.ja_toc.html#Table_locking">5.3.2  テーブル・ロッキングの問題</a></h3>

<p>
<a name="IDX859"></a>

</p>
<p>
<strong>MySQL</strong> のテーブル・ロッキングのコードはデッドロック・フリーです。

</p>
<p>
<strong>MySQL</strong> はとても速いロックスピードを得るために、
(レコードのロックやフィールドのロックの代わりに) テーブルのロックを使用します。
大きなテーブルには、 テーブルのロックはレコードのロックよりはるかに良いですが、
いくつかの落とし穴があります。

</p>
<p>
<code>BDB</code> と <code>InnoDB</code> のテーブルでは、 <code>LOCK TABLES</code> を使用して
明示的にテーブルをロックするか、 <code>ALTER TABLE</code> のようなテーブル中のすべて
のレコードを修正するコマンドを実行した場合にのみ、MySQLはテーブル・ロッキングを使用
します。これらのテーブル・タイプについては、 <code>LOCK TABLES</code> を全く使用
しないことを推奨します。

</p>
<p>
<strong>MySQL</strong> バージョン 3.23.7 以上では、
あるスレッドが <code>MyISAM</code> テーブルを読んでいる最中に、
同じテーブルにレコードを挿入する事ができます。
現在、これは挿入が行われる時に、テーブルのレコードを削除した後にホールがない場合にのみ
動作することに注意してください。すべてのホールが新しいデータで満たされた時に、
自動的に同時挿入が再び可能になります。

</p>
<p>
テーブルのロックはたくさんのスレッドが同時にあるテーブルから読み出すのを可能にし
ますが、もしあるスレッドがあるテーブルに対し書込み要求を出す場合、
それはまず最初に排他的なアクセスを得なければなりません.
その更新の間、更新が完了するまで、この特定のテーブルにアクセスしようとする
他の全てのスレッドが待たされることになります。

</p>
<p>
通常データベースの更新は <code>SELECT</code> よりも重要とされるため、
テーブルを更新する全てのスレッドが、テーブルから情報を検索するスレッドよりも
高い優先順位を持ちます。 これは ある特定のテーブルに対して、多くの重いクエリが発
行された場合に、 更新が不完全に終わらないことを確実にするためです。
(これは、 LOW_PRIORITY と共に更新を行うステートメントを用いるか、
 <code>HIGH_PRIORITY</code> と共に <code>SELECT</code> ステートメントを用いることにより
変更が可能です。)

</p>
<p>
<strong>MySQL バージョン 3.23.7</strong> から、<code>max_write_lock_count</code> 変数が使用で
きます。
これは、一つのテーブルに対して、指定された回数だけ INSERT が行われた後に、
<code>SELECT</code> を発行するようにします。

</p>
<p>
テーブルロッキングは以下の場合にはあまり良くありません：

</p>

<ul>
<li>

あるクライアントが実行に長い時間のかかる <code>SELECT</code> を発行。
</li><li>

その後に、他のクライアントが、使用されているテーブルに対し <code>UPDATE</code> を発行；
このクライアントは先の <code>SELECT</code> が完了するまで待ちます
</li><li>

さらに他のクライアントが同じテーブルに対して <code>SELECT</code> 構文を発行；
<code>UPDATE</code> は <code>SELECT</code> よりも高い優先度を持つので、
この <code>SELECT</code> は先の <code>UPDATE</code> が完了するまで待ちます。
これは一番最初の <code>SELECT</code> が 終了するまで待たされます！
</li><li>

スレッドが <code>full disk</code> のような待機状態になっている場合、
問題のテーブルにアクセスを行おうとした全てのスレッドもまた、
より多くのディスク・スペースが利用可能になるまで待機状態に入ります。
</li></ul>

<p>
この問題のいくつかの可能な解決は以下の通りです：

</p>

<ul>
<li>

<code>SELECT</code> 構文を速く実行できるように試みます； これを行うにあたり、
いくつかのサマリーテーブルを作成しなければならないかもしれません.

</li><li>

<code>mysqld</code> を <code>--low-priority-updates</code> オプションで起動。
これは全てのあるテーブルを更新する構文に対して、 <code>SELECT</code> 構文よりも
低い優先度を与えます。 この場合、前述のシナリオ中の最後の <code>SELECT</code> 構文は
<code>INSERT</code> 構文が完了する前に実行されます。

</li><li>

<code>LOW_PRIORITY</code> 属性指定を用いて、 <code>INSERT</code>,<code>UPDATE</code>,<code>DELETE</code>
 構文に低い優先度を与えることも出来ます。

</li><li>

ある程度の数の <code>WRITE</code> ロックの後に <code>READ</code> ロックを与えるために、
 <strong>max_write_lock_count</strong> を低い値にして <code>mysqld</code> を開始します。

</li><li>

SQL コマンドの <code>SET SQL_LOW_PRIORITY_UPDATES=1</code> を使用して、
ある特定のスレッドからの全ての更新を、低い優先度に指定する事ができます。
 「<a href="manual.ja_MySQL_Optimization.html#SET_OPTION">5.5.6  <code>SET</code> 構文</a>」節参照.

</li><li>

<code>HIGH_PRIORITY</code> 属性を用いて、特定の <code>SELECT</code> がとても重要であると
指定することが可能です。.  「<a href="manual.ja_Reference.html#SELECT">6.4.1  <code>SELECT</code> 構文</a>」節参照.

</li><li>

もし <code>INSERT</code> と <code>SELECT</code> をあわせて使用した場合に問題が起きた場合、
新しい <code>MyISAM</code> テーブルに切り替えます。 これは <code>SELECT</code>
と <code>INSERT</code> を同時に行えます。

</li><li>

もし <code>INSERT</code> と <code>SELECT</code> 構文を主に混在させるのなら、
<code>INSERT</code> の <code>DELAYED</code> 属性指定はこの問題を解決させるでしょう。
 「<a href="manual.ja_Reference.html#INSERT">6.4.2  <code>INSERT</code> 構文</a>」節参照.

</li><li>

もし <code>SELECT</code> と <code>DELETE</code> で問題があるなら、
<code>DELETE</code> の <code>LIMIT</code> オプションが助けになるでしょう。
  「<a href="manual.ja_Reference.html#DELETE">6.4.5  <code>DELETE</code> 構文</a>」節参照.
</li></ul>



<h2><a name="Optimizing_Database_Structure" href="manual.ja_toc.html#Optimizing_Database_Structure">5.4  Optimizing Database Structure</a></h2>



<h3><a name="Design" href="manual.ja_toc.html#Design">5.4.1  Design Choices</a></h3>

<p>
<a name="IDX860"></a>
<a name="IDX861"></a>
<a name="IDX862"></a>

</p>
<p>
<code>MySQL</code> は、レコードのデータとインデックスを別のファイルに保存します。
他の多くの(ほとんど全て)データベースでは、同じファイルにデータとインデックスを
混在させて保存します。 我々は、最近のシステムには、<strong>MySQL</strong> の選択の方が
良いと信じています。

</p>
<p>
Another way to store the row data is to keep the information for each
column in a separate area (examples are SDBM and Focus). This will cause a
performance hit for every query that accesses more than one column. Because
this degenerates so quickly when more than one column is accessed,
we believe that this model is not good for general purpose databases.

</p>
<p>
The more common case is that the index and data are stored together
(like in Oracle/Sybase et al). In this case you will find the row
information at the leaf page of the index. The good thing with this
layout is that it, in many cases, depending on how well the index is
cached, saves a disk read.  The bad things with this layout are:

</p>

<ul>
<li>

Table scanning is much slower because you have to read through the indexes
to get at the data.
</li><li>

You can't use only the index table to retrieve data for a query.
</li><li>

You lose a lot of space, as you must duplicate indexes from the nodes
(as you can't store the row in the nodes).
</li><li>

Deletes will degenerate the table over time (as indexes in nodes are
usually not updated on delete).
</li><li>

It's harder to cache ONLY the index data.
</li></ul>



<h3><a name="Data_size" href="manual.ja_toc.html#Data_size">5.4.2  可能な限りデータを小さくする</a></h3>

<p>
<a name="IDX863"></a>
<a name="IDX864"></a>
<a name="IDX865"></a>
<a name="IDX866"></a>
<a name="IDX867"></a>

</p>
<p>
One of the most basic optimization is to get your data (and indexes) to
take as little space on the disk (and in memory) as possible. This can
give huge improvements because disk reads are faster and normally less
main memory will be used. Indexing also takes less resources if
done on smaller columns.

</p>
<p>
MySQL supports a lot of different table types and row formats.
Choosing the right table format may give you a big performance gain.
 「<a href="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</a>」節参照.

</p>
<p>
以下に挙げるテクニックを使用すれば、テーブルでのパフォーマンスの向上、
保存領域の縮小化が可能でしょう：

</p>

<ul>
<li>

可能ならば、一番小さな型を使用します。 <strong>MySQL</strong> は
ディスクとメモリーを節約する多くの型を持っています。

</li><li>

より小さな整数型を可能ならば使用します。 例えば、
<code>MEDIUMINT</code> は <code>INT</code> より良いでしょう。

</li><li>

可能ならフィールドを <code>NOT NULL</code> に定義してください。これは全てをより速くし、
各フィールド毎に1ビットを節約します。
Note that if you really need
<code>NULL</code> in your application you should definitely use it. Just avoid
having it on all columns by default.

</li><li>

可変長のフィールド (<code>VARCHAR</code>, <code>TEXT</code>, <code>BLOB</code>) を持たない場合は、
固定サイズレコード形式が使用されます。
これはかなり速いです。しかしあいにくいくらかの領域を浪費します。
 「<a href="manual.ja_Table_types.html#MyISAM_table_formats">7.1.2  MyISAM Table Formats</a>」節参照.

</li><li>

それぞれのテーブルは可能な限り短いプライマリ・インデックスを持つべきです。
これは１レコードを一意にし、効率的にします。

</li><li>

それぞれのテーブルについて、どのテーブルの形式を使用するかを
決めます。  「<a href="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</a>」節参照.

</li><li>

本当に必要な物にだけインデックスを作成します。
インデックスは検索には良いですが、より速く保存したい場合には良くありません。
もしテーブルをフィールドの組み合わせでサーチすることがほとんどであれば、
それらにインデックスを作成します。 最初のインデックスの部分は、もっとも
使用されるフィールドにすべきです。
If you are
ALWAYS using many columns, you should use the column with more duplicates
first to get better compression of the index.

</li><li>

もしインデックスが頭からの何文字かで一意性を持っているなら、この部分にだけ
インデックスを張る方が良いでしょう。 <strong>MySQL</strong> は文字列フィールドの
一部分に対してのインデックスをサポートします。
短いインデックスは、ディスクスペースを節約するだけでなく、
インデックスのキャッシュに収まりやすくなることにより、ディスク・シークも少
なくなるので、速くなります。  「<a href="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a>」節参照.

</li><li>

いくつかの状況下で、とてもよく走査されるテーブルを２つに分割することは、
利益になることがあります。
This is especially true if it is a dynamic
format table and it is possible to use a smaller static format table that
can be used to find the relevant rows when scanning the table.
</li></ul>



<h3><a name="MySQL_indexes" href="manual.ja_toc.html#MySQL_indexes">5.4.3  MySQL はどのようにインデックスを使用するか？</a></h3>

<p>
<a name="IDX868"></a>

</p>
<p>
Indexes are used to find rows with a specific value of one column
fast. インデックスがない場合、<strong>MySQL</strong> は、そのレコードが見つかるまで、
最初のレコードからテーブルをなめていきます。 大きなテーブルでは多くの
手間がかかります。 もし問い合わせの中にインデックスを持ったフィールドが
ある場合、<strong>MySQL</strong> は全てのデータをみることなく、データの途中の位置を速く
得ることができます。 もしあるテーブルが1000レコード持っていたとすると、
順番に頭からなめていくことに比べて、これは少なくとも100倍速いことに
なります。 Note that if you need to access almost all 1000
rows it is faster to read sequentially because we then avoid disk seeks.

</p>
<p>
全ての <strong>MySQL</strong> インデックス, <code>PRIMARY</code>, <code>UNIQUE</code> そして
 <code>INDEX()</code> は B tree に格納されます。
文字列は自動的に始めと終りの空白が圧縮されます。
 「<a href="manual.ja_Reference.html#CREATE_INDEX">6.5.7  <code>CREATE INDEX</code> 構文</a>」節参照.

</p>
<p>
Indexes are used to:

</p><ul>
<li>

<code>WHERE</code>節にマッチした行の素早い検索

</li><li>

join を実行したときの他のテーブルからの行の検索

</li><li>

Find the <code>MAX()</code> or <code>MIN()</code> value for a specific indexed
column. This is optimized by a preprocessor that checks if you are
using <code>WHERE</code> key_part_# = constant on all key parts &lt; N.  In this case
MySQL will do a single key lookup and replace the <code>MIN()</code>
expression with a constant.  If all expressions are replaced with
constants, the query will return at once:


<pre>SELECT MIN(key_part2),MAX(key_part2) FROM table_name where key_part1=10
</pre>

</li><li>

テーブルをソートかグループ化する場合で、ソート(グループ化)が一番左(接頭部)の
キーを使用して行われる場合(例えば <code>ORDER BY key_part_1,key_part_2 </code>)。
もし <code>DESC</code> 指定があれば、全てのキーは逆順に読まれます。

The index can also be used even if the <code>ORDER BY</code> doesn't match the index
exactly, as long as all the unused index parts and all the extra
are <code>ORDER BY</code> columns are constants in the <code>WHERE</code> clause. The
following queries will use the index to resolve the <code>ORDER BY</code> part:


<pre>SELECT * FROM foo ORDER BY key_part1,key_part2,key_part3;
SELECT * FROM foo WHERE column=constant ORDER BY column, key_part1;
SELECT * FROM foo WHERE key_part1=const GROUP BY key_part2;
</pre>

</li><li>

データファイルを参照することなく値を検索する場合。
もし使用する全てのフィールドが数値でかつ、一番左から(接頭部から)キーを形成する場
合、
値はインデックスツリーから検索され、これはとても速くなります。


<pre>SELECT key_part3 FROM table_name WHERE key_part1=1
</pre>

</li></ul>

<p>
以下のような <code>SELECT</code> 文を発行したとします：

</p>

<pre>mysql&gt; SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
</pre>

<p>
もし <code>col1</code> と <code>col2</code> に複数フィールドインデックスが定義されている場合、
すぐに思ったとおりの結果が得られます。
If separate single-column
indexes exist on <code>col1</code> and <code>col2</code>, the optimizer tries to
find the most restrictive index by deciding which index will find fewer
rows and using that index to fetch the rows.

</p>
<p>
<a name="IDX869"></a>
<a name="IDX870"></a>
<a name="IDX871"></a>
もしテーブルが複数フィールドインデックスを持つなら、インデックスの接頭部一番左の
部分がレコードを見つけるための最適化に使用されます。例えば、3つのフィールド
 <code>(col1,col2,col3)</code> に対して一つのインデックスを持っていたとします。
すると、これは <code>(col1)</code>, <code>(col1,col2)</code> ,
<code>(col1,col2,col3)</code> でインデックスがサーチされます。

</p>
<p>
もし一番左に指定しているフィールドがインデックスを作成していないなら、
<strong>MySQL</strong> は部分的なインデックスを使用しません。

</p>
<p>
以下のような <code>SELECT</code> 文を発行したとします：

</p>

<pre>mysql&gt; SELECT * FROM tbl_name WHERE col1=val1;
mysql&gt; SELECT * FROM tbl_name WHERE col2=val2;
mysql&gt; SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
</pre>

<p>
もしインデックスが <code>(col1,col2,col3)</code> にあるならば、
上に示した最初のクエリだけがインデックスを使用します。二番目三番目のクエリは
インデックスを持つフィールドを発動しますが、
<code>(col2)</code> と <code>(col2,col3)</code> は、<code>(col1,col2,col3)</code> の
接頭部一番左に指定されていません。

</p>
<p>
<a name="IDX872"></a>
<a name="IDX873"></a>
<a name="IDX874"></a>
<a name="IDX875"></a>
<strong>MySQL</strong> は、もし  <code>LIKE</code> がワイルドカードから始まっていなくて、
ある種固定された文字で始まっているなら、
<code>LIKE</code> の評価にインデックスを使用します。
例えば、以下の <code>SELECT</code> 文はインデックスを使用します:

</p>

<pre>mysql&gt; select * from tbl_name where key_col LIKE "Patrick%";
mysql&gt; select * from tbl_name where key_col LIKE "Pat%_ck%";
</pre>

<p>
一つ目の文は、<code>"Patrick" &lt;= key_col &lt; "Patricl"</code> となるレコードだけ、考慮さ
れます。
二つ目の文は、<code>"Pat" &lt;= key_col &lt; "Pau"</code> となるレコードだけ、考慮されます。

</p>
<p>
以下の <code>SELECT</code> 文はインデックスを使用しません:

</p><pre>mysql&gt; select * from tbl_name where key_col LIKE "%Patrick%";
mysql&gt; select * from tbl_name where key_col LIKE other_col;
</pre>

<p>
最初の文は、<code>LIKE</code> がワイルドカード文字で始まっています。
二つ目の文は、<code>LIKE</code> が定数ではありません。

</p>
<p>
<a name="IDX876"></a>
<a name="IDX877"></a>
Searching using <code>column_name IS NULL</code> will use indexes if column_name
is an index.

</p>
<p>
<strong>MySQL</strong> は通常、一番少ないレコード数を見つけるインデックスを使用します。
インデックスは次に示す演算子を用いて比較できるフィールドに対して使用されます：
<code>=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>BETWEEN</code> そして
<code>'something%'</code> の様に頭にワイルドカードがない <code>LIKE</code>。

</p>
<p>
<code>WHERE</code> 節内の全ての <code>AND</code> にかからないインデックスは、
全くクエリの最適化に使用されません。
In other words:  To be able to use an
index, a prefix of the index must be used in every <code>AND</code> group.

</p>
<p>
以下の <code>WHERE</code> 節はインデックスを使用します：

</p><pre>... WHERE index_part1=1 AND index_part2=2 AND other_column=3
... WHERE index=1 OR A=10 AND index=2      /* index = 1 OR index = 2 */
... WHERE index_part1='hello' AND index_part_3=5
          /* optimized like "index_part1='hello'" */
... WHERE index1=1 and index2=2 or index1=3 and index3=3;
          /* Can use index on index1 but not on index2 or index 3 */
</pre>

<p>
以下の <code>WHERE</code> 節はインデックスを<strong>使用しません</strong>：

</p><pre>... WHERE index_part2=1 AND index_part3=2  /* index_part_1 is not used */
... WHERE index=1 OR A=10                  /* Index is not used in both AND parts */
... WHERE index_part1=1 OR index_part2=10  /* No index spans all rows */
</pre>

<p>
Note that in some cases MySQL will not use an index, even if one
would be available.  Some of the cases where this happens are:

</p>

<ul>
<li>

If the use of the index would require MySQL to access more
than 30 % of the rows in the table.  (In this case a table scan is
probably much faster, as this will require us to do much fewer seeks).
Note that if such a query uses <code>LIMIT</code> to only retrieve
part of the rows, MySQL will use an index anyway, as it can
much more quickly find the few rows to return in the result.
</li></ul>



<h3><a name="Indexes" href="manual.ja_toc.html#Indexes">5.4.4  Column Indexes</a></h3>

<p>
<a name="IDX878"></a>
<a name="IDX879"></a>
<a name="IDX880"></a>

</p>
<p>
<strong>MySQL</strong> の全てのフィールドはインデックスを持つことができます。
適切なフィールドでのインデックスの使用は、<code>SELECT</code> の
性能を向上する最良の方法です。

</p>
<p>
キーの最大数と最大インデックス長はテーブルハンドラ毎に定義されます。
 「<a href="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</a>」節参照。すべてのテーブルハンドラで少なくとも 16 個のキーと少な
くとも合計 256 バイトのインデックス長を持つことができます。

</p>
<p>
<code>CHAR</code> と <code>VARCHAR</code> フィールドには接頭部にインデックスを持つことが
できます。フィールド全体をインデックス化するより、
これははるかに早く、少ないディスク容量でできます。

</p>
<p>
<code>CREATE TABLE</code> 構文でフィールドにインデックスを作るには、
以下のようにします：

</p>

<pre>KEY index_name (col_name(length))
</pre>

<p>
以下の例は <code>name</code> フィールドの最初の10文字にインデックスを創り出します:

</p>

<pre>mysql&gt; CREATE TABLE test (
           name CHAR(200) NOT NULL,
           KEY index_name (name(10)));
</pre>

<p>
 <code>BLOB</code> と <code>TEXT</code> フィールドでは、そのフィールドの頭の部分に
インデックスを張らなくてはなりません。
フィールドの全体にインデックスは張れません。

</p>
<p>
<strong>MySQL</strong> バージョン 3.23.23 以降では、特殊な <strong>FULLTEXT</strong> イン
デックスを生成することもできます。これは全文検索に使用されます。
<code>MyISAM</code> テーブル型だけが <code>FULLTEXT</code> インデックスをサポートしま
す。これは <code>VARCHAR</code> と <code>TEXT</code> フィールドだけに生成できます。イ
ンデックスは常にフィールド全体に対して行なわれ、部分インデックスはサポート
されません。詳細は   「<a href="manual.ja_Reference.html#Fulltext_Search">6.8  MySQL Full-text Search</a>」節.

</p>



<h3><a name="Multiple-column_indexes" href="manual.ja_toc.html#Multiple-column_indexes">5.4.5  Multiple-Column Indexes</a></h3>

<p>
<a name="IDX881"></a>
<a name="IDX882"></a>
<a name="IDX883"></a>

</p>
<p>
MySQL は異なるフィールドのセットに一つのインデックスを持つことができます。
インデックスは最大15個のコラムまで許されます。
(<code>CHAR</code> と <code>VARCHAR</code> フィールドの接頭部をインデックスとして使用できます)

</p>
<p>
複数フィールドインデックスは、
ソートされた配列(インデックス化されたフィールドの値が結合されている配列)
を扱うことができます。

</p>
<p>
インデックス化されたコラムに対して、既知の値を <code>WHERE</code> 節で指定した時、
たとえ他のフィールドの値を指定しなくとも、
<strong>MySQL</strong> は複数フィールドインデックスを使用します。

</p>
<p>
以下のテーブルがあると仮定してください：

</p>

<pre>mysql&gt; CREATE TABLE test (
           id INT NOT NULL,
           last_name CHAR(30) NOT NULL,
           first_name CHAR(30) NOT NULL,
           PRIMARY KEY (id),
           INDEX name (last_name,first_name));
</pre>

<p>
<code>name</code> インデックスは、<code>last_name</code> と <code>first_name</code> にまたがるイン
デックスです。
このインデックスは、<code>last_name</code> に対するクエリや、
<code>name</code> インデックスは以下のクエリで使われます：

</p>

<pre>mysql&gt; SELECT * FROM test WHERE last_name="Widenius";

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
                          AND first_name="Michael";

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
                          AND (first_name="Michael" OR first_name="Monty");

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
                          AND first_name &gt;="M" AND first_name &lt; "N";
</pre>

<p>
しかし <code>name</code> インデックスは以下のクエリでは使用されません:

</p>

<pre>mysql&gt; SELECT * FROM test WHERE first_name="Michael";

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
                          OR first_name="Michael";
</pre>

<p>
<strong>MySQL</strong> がクエリの性能を上げるためにどうインデックスを使用しているか、
より詳しい情報はこちら：  「<a href="manual.ja_MySQL_Optimization.html#MySQL_indexes">5.4.3  MySQL はどのようにインデックスを使用するか？</a>」節.

</p>



<h3><a name="Table_cache" href="manual.ja_toc.html#Table_cache">5.4.6  MySQL はどのようにテーブルのオープン &amp; クローズを行なうか？</a></h3>

<p>
<a name="IDX884"></a>

</p>
<p>
<a name="IDX885"></a>
<a name="IDX886"></a>
<a name="IDX887"></a>
<a name="IDX888"></a>
<a name="IDX889"></a>

</p>
<p>
<code>table_cache</code> , <code>max_connections</code> , <code>max_tmp_tables</code> は
サーバーが開いた状態にしておく事が出来るファイルの最大数に影響します。
もしこれらの変数のうちの一つ、あるいは複数を増加させるなら、
あなたのオペレーティング・システムの、1 プロセスあたりに開かれる
 ファイル・デスクリプタ の最大値を増やすことになるかもしれません。
多くのシステムではこの制限を増やすことが可能です。
これをどうやって行うかは、あなたの使用している OS のドキュメントを見てください。
制限値の変更方法は、システムによってまちまちだからです。

</p>
<p>
<code>table_cache</code> は <code>max_connections</code> に関連します。
例えば 200 のコネクションを同時に開けるなら、少なくとも <code>200 * n</code> の
テーブル・キャッシュが必要です。 ここで <code>n</code> は join におけるテーブルの
最大数です。
You also need to reserve some extra file descriptors for
temporary tables and files.

</p>
<p>
オープンテーブルのキャッシュは最大で <code>table_cache</code> まで大きくなります(デ
フォルトは 64, <code>mysqld</code> のオプション <code>-O table_cache=#</code> で変更可能)。
キャッシュが一杯になって、他のスレッドがテーブルのオープンを試みた時、
または <code>mysqladmin refresh</code> <code>mysqladmin flush-tables</code>
を使用した場合を除いて、テーブルはクローズされません。

</p>
<p>
キャッシュがいっぱいになった場合、サーバーは以下の処置を取って
キャッシュを使用できるように配置します：

</p>

<ul>
<li>

現在使われていないテーブルが解放されます。もっとも使用されていないテーブルからか
ら順に。

</li><li>

もしキャッシュが一杯でテーブルを解放することが出来ず、さらに新しいテーブルの
オープン要求がある場合、キャッシュは一時的な拡張を必要とします。

</li><li>

もしそのキャッシュが一時拡張に配置されていて、かつ、テーブルが使用状態から
未使用状態に移行した場合、そのテーブルは閉じられ、キャッシュから解放されます。
</li></ul>

<p>
テーブルは各同時アクセスに (再び) オープンされます。これは、同じテーブルで2つの
スレッドが実行されている場合、または同じクエリで(<code>AS</code> で)テーブルを2回
アクセスする場合、テーブルは2回オープンする必要があることを意味します。
最初のテーブルのオープンは2つのファイル記述子を使用し、続くテーブルの各使用は
1つだけのファイル記述子を使用します。

</p>
<p>
You can check if your table cache is too small by checking the mysqld
variable <code>opened_tables</code>.  If this is quite big, even if you
haven't done a lot of <code>FLUSH TABLES</code>, you should increase your table
cache.  「<a href="manual.ja_MySQL_Database_Administration.html#SHOW_STATUS">4.5.5.3  <code>SHOW STATUS</code></a>」節参照.

</p>



<h3><a name="Creating_many_tables" href="manual.ja_toc.html#Creating_many_tables">5.4.7  Drawbacks to Creating Large Numbers of Tables in the Same Database</a></h3>

<p>
<a name="IDX890"></a>

</p>
<p>
もしたくさんのファイルが一つのディレクトリにある場合、オープン、クローズ、
create 操作は遅くなるでしょう。 もし <code>SELECT</code> 文を多くのテーブルに対し
実行した場合、テーブルキャッシュが一杯ならば、このオーバーヘッドは多くなるでしょ
う。
なぜなら、それぞれのテーブルにつきオープンし、クローズしなくてはならないからです。
このオーバーヘッドを緩和するには、テーブルキャッシュを大きくします。

</p>



<h3><a name="Open_tables" href="manual.ja_toc.html#Open_tables">5.4.8  何故そんなに多くのテーブルをオープンするのか？</a></h3>

<p>
<a name="IDX891"></a>
<a name="IDX892"></a>

</p>
<p>
<code>mysqladmin status</code> を実行すると、次のようなものが得られます:

</p>

<pre>Uptime: 426 Running threads: 1 Questions: 11082 Reloads: 1 Open tables: 12
</pre>

<p>
確かにたった6個しかテーブルがないのに、このような結果が出るので少々戸惑われるか
もしれません。

</p>
<p>
<strong>MySQL</strong> はマルチスレッドなので、同じテーブルで一度に多くのクエリを持て
ます。同じファイル上で異なる状態を持つ2つのスレッドで、問題を最小化する
ため、同時に動作する各スレッドのためテーブルを再びオープンします。これはいくつ
かのメモリとデータファイルについての一つの拡張ファイル記述子を使用します。
インデックスファイル記述子は全てのスレッド間で共有されます。

</p>



<h2><a name="Optimizing_the_Server" href="manual.ja_toc.html#Optimizing_the_Server">5.5  Optimizing the MySQL Server</a></h2>



<h3><a name="System" href="manual.ja_toc.html#System">5.5.1  システム、コンパイル時、スタートパラメターのチューニング</a></h3>

<p>
<a name="IDX893"></a>
<a name="IDX894"></a>
<a name="IDX895"></a>

</p>
<p>
We start with the system level things since some of these decisions have
to be made very early. In other cases a fast look at this part may
suffice because it not that important for the big gains. However, it is always
nice to have a feeling about how much one could gain by changing things
at this level.

</p>
<p>
使うべき OS はとても重要です！ 複数の CPU を持つマシンでは、
Solaris (なぜなら、Solaris のスレッドはとても素晴らしく動作するから)、
あるいは、Linux ( kernel 2.2 は良い SMP をサポートしているから) を
使用すべきです。 32bit マシンの Linux では、2G bytes のファイルサイズの
制限があります。 これは新しいファイルシステム (XFS/ReiserFS) のリリース時に
なくなって欲しいものです。
If you have a desperate need for files bigger
than 2G on Linux-intel 32 bit, you should get the LFS patch for the ext2
file system.

</p>
<p>
Because we have not run MySQL in production on that many platforms, we
advice you to test your intended platform before choosing it, if possible.

</p>
<p>
<a name="IDX896"></a>
Other tips:

</p><ul>
<li>

充分 RAM があるならば、全ての swap を外してもよいでしょう。
いくつかのシステムでは、たとえメモリーが空いていても、
swap を使用する場合があります。

</li><li>

外部のロックを避けるため、<code>--skip-locking</code> <strong>MySQL</strong> オプション
を使用します。 
Note that this will not impact MySQL's functionality as
long as you only run one server. Just remember to take down the server (or
lock relevant parts) before you run <code>myisamchk</code>. On some system
this switch is mandatory because the external locking does not work in any
case.

MIT-pthread でコンパイルする時は <code>--skip-locking</code> がデフォルトです。
これは全てのプラットフォームで MIT-pthread が <code>flock()</code> を完全にサポートし
ていないためです。
It's also on default for Linux
as Linux file locking are not yet safe.

<code>--skip-locking</code> が使用できないただ一つの状態は、
もしあなたが複数の <strong>MySQL</strong> <em>サーバー</em> (クライアントではない) を
同じデータに対して走らせている場合です。

You can still use <code>LOCK TABLES</code>/<code>UNLOCK TABLES</code> even if you
are using <code>--skip-locking</code>
</li></ul>



<h3><a name="Server_parameters" href="manual.ja_toc.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a></h3>

<p>
<a name="IDX897"></a>
<a name="IDX898"></a>
<a name="IDX899"></a>
<a name="IDX900"></a>

</p>
<p>
<code>mysqld</code> サーバーが使用している現在のバッファサイズを次で得ることができます:

</p>

<pre>shell&gt; mysqld --help
</pre>

<p>
<a name="IDX901"></a>
<a name="IDX902"></a>
この結果、全ての <code>mysqld</code> オプションと次のようなコンフィグ可能変数のリスト
を得られます。出力結果にはデフォルト値が含まれ、以下のように表示されます:

</p>

<pre>Possible variables for option --set-variable (-O) are:
back_log              current value: 5
bdb_cache_size        current value: 1048540
binlog_cache_size     current_value: 32768
connect_timeout       current value: 5
delayed_insert_timeout  current value: 300
delayed_insert_limit  current value: 100
delayed_queue_size    current value: 1000
flush_time            current value: 0
interactive_timeout   current value: 28800
join_buffer_size      current value: 131072
key_buffer_size       current value: 1048540
lower_case_table_names  current value: 0
long_query_time       current value: 10
max_allowed_packet    current value: 1048576
max_binlog_cache_size current_value: 4294967295
max_connections       current value: 100
max_connect_errors    current value: 10
max_delayed_threads   current value: 20
max_heap_table_size   current value: 16777216
max_join_size         current value: 4294967295
max_sort_length       current value: 1024
max_tmp_tables        current value: 32
max_write_lock_count  current value: 4294967295
myisam_sort_buffer_size  current value: 8388608
net_buffer_length     current value: 16384
net_retry_count       current value: 10
net_read_timeout      current value: 30
net_write_timeout     current value: 60
query_buffer_size     current value: 0
record_buffer         current value: 131072
record_rnd_buffer     current value: 131072
slow_launch_time      current value: 2
sort_buffer           current value: 2097116
table_cache           current value: 64
thread_concurrency    current value: 10
tmp_table_size        current value: 1048576
thread_stack          current value: 131072
wait_timeout          current value: 28800
</pre>

<p>
もし <code>mysqld</code> サーバーを走らせているなら、以下のコマンドでも変数の値を見る
ことができます:

</p>

<pre>shell&gt; mysqladmin variables
</pre>

<p>
You can find a full description for all variables in the <code>SHOW VARIABLES</code>
section in this manual.  「<a href="manual.ja_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.5.4  <code>SHOW VARIABLES</code></a>」節参照.

</p>
<p>
You can also see some statistics from a running server by issuing the command
<code>SHOW STATUS</code>.  「<a href="manual.ja_MySQL_Database_Administration.html#SHOW_STATUS">4.5.5.3  <code>SHOW STATUS</code></a>」節参照.

</p>
<p>
<strong>MySQL</strong> はとてもスケーラブルなアルゴリズムを使用します。そのため
通常はとても少ないメモリで動作します。しかし <strong>MySQL</strong> に多くのメモリを
与えれば、より良い性能を得ることができます。

</p>
<p>
When tuning a MySQL server, the two most important variables to use
are <code>key_buffer_size</code> and <code>table_cache</code>.  You should first feel
confident that you have these right before trying to change any of the
other variables.

</p>
<p>
多くのメモリ(&gt;=256M)と多くのテーブルを持っていて、適度のクライアント数で最大性能
を得たい場合、次のようなものを使用します:

</p>

<pre>shell&gt; safe_mysqld -O key_buffer=64M -O table_cache=256 \
           -O sort_buffer=4M -O record_buffer=1M &amp;
</pre>

<p>
If you have only 128M and only a few tables, but you still do a lot of
sorting, you can use something like:

</p>

<pre>shell&gt; safe_mysqld -O key_buffer=16M -O sort_buffer=1M
</pre>

<p>
多くの接続で少ないメモリしかない場合、次のようなものを使用します

</p>

<pre>shell&gt; safe_mysqld -O key_buffer=512k -O sort_buffer=100k \
           -O record_buffer=100k &amp;
</pre>

<p>
or even:

</p>

<pre>shell&gt; safe_mysqld -O key_buffer=512k -O sort_buffer=16k \
           -O table_cache=32 -O record_buffer=8k -O net_buffer=1K &amp;
</pre>

<p>
If you are doing a <code>GROUP BY</code> or <code>ORDER BY</code> on files that are
much bigger than your available memory you should increase the value of
<code>record_rnd_buffer</code> to speed up the reading of rows after the sorting
is done.

</p>
<p>
When you have installed MySQL, the <tt>`support-files'</tt> directory will
contain some different <code>my.cnf</code> example files, <tt>`my-huge.cnf'</tt>,
<tt>`my-large.cnf'</tt>, <tt>`my-medium.cnf'</tt>, and <tt>`my-small.cnf'</tt>, you can
use as a base to optimize your system.

</p>
<p>
もしとても多くの接続があり、<code>mysqld</code> が各接続に対して少ないメモリーで
動作するように設定されていれば、スワップの読み書きによるパフォーマンスの低下がお
きます。
もちろん十分なメモリーがあれば、全ての接続にたいして <code>mysqld</code> のパフォーマ
ンス良くなります。

</p>
<p>
<code>mysqld</code> へのオプションを変更する場合、そのサーバのインスタンスにだけに
有効であることに注意して下さい。

</p>
<p>
パラメータ変更の効果を見るには、このようにします:

</p>

<pre>shell&gt; mysqld -O key_buffer=32m --help
</pre>

<p>
<code>--help</code> オプションは最後につけてください。
その他のオプションを --help の後につけると、そのオプションは反映されません。

</p>



<h3><a name="Compile_and_link_options" href="manual.ja_toc.html#Compile_and_link_options">5.5.3  MySQL の速度に影響するコンパイルとリンク方法</a></h3>

<p>
<a name="IDX903"></a>
<a name="IDX904"></a>
<a name="IDX905"></a>
<a name="IDX906"></a>

</p>
<p>
次のテストの多くは Linux 上で <strong>MySQL</strong> ベンチマークで行われました。
しかし、これらは他の OS についてもいくつかの指標を与えます。 

</p>
<p>
<code>-static</code> でのリンク時に最速の実行形式を得ます。

</p>
<p>
Linux では、<code>pgcc</code> と <code>-O3</code> でコンパイルした時に最速のコードを得られます。
このオプションで <tt>`sql_yacc.cc'</tt> をコンパイルすると、<code>gcc/pgcc</code> は
全ての関数をインラインにするために多くのメモリを必要とするので、200M のメモリが
必要です。
<code>libstdc++</code> ライブラリの増加を避けるためには、
<strong>MySQL</strong> の configure 時に <code>CXX=gcc</code> も設定すべきです。 
Note that with some versions of <code>pgcc</code>,
the resulting code will only run on true Pentium processors, even if you
use the compiler option that you want the resulting code to be working on
all x586 type processors (like AMD).

</p>
<p>
より良いコンパイラー、そしてコンパイラーのオプションは、10-30% の
速度の向上をもたらします。 これはあなた自身が MySQL をコンパイルする
時に重要なことです！

</p>
<p>
我々は Cygnus CodeFusion と Fujitsu コンパイラーでもテストしましたが、
<strong>MySQL</strong> を最適化オプションでコンパイルするには、
どちらもまだ完全なバグ・フリーではありませんでした。

</p>
<p>
When you compile MySQL you should only include support for the
character sets that you are going to use. (Option <code>--with-charset=xxx</code>).
The standard MySQL binary distributions are compiled with support
for all character sets.

</p>
<p>
Here is a list of some measurements that we have done:

</p><ul>
<li>

<code>pgcc</code> を使用して <code>-O6</code> で全てをコンパイルすると、
<code>gcc</code> 2.95.2 より、<code>mysqld</code> サーバーは 1% 速くなります。 

</li><li>

Linux 上では、動的リンク(<code>-static</code>) 無し)の場合、結果は 13% 遅くなります。
Note that you still can use a dynamic linked
MySQL library. It is only the server that is critical for
performance.

</li><li>

If you strip your <code>mysqld</code> binary with <code>strip libexec/mysqld</code>,
the resulting binary can be up to 4 % faster.

</li><li>

(localhost への接続に) Unix ソケットの代わりに TCP/IP を使用すると、結果は 7.5% 
遅くなります。 
(<code>localhost</code> へ接続する場合、<strong>MySQL</strong> はデフォルトではソケット
を使用します)。

</li><li>

If you connect using TCP/IP from another computer over a 100M Ethernet,
things will be 8-11 % slower.

</li><li>

<code>--with-debug=full</code> でコンパイルすると、ほとんどのクエリで 20% 遅くな
りますが、いくつかのクエリは実質的にはもっと長くなります(<strong>MySQL</strong> ベ
ンチマークでは 35% 遅くなりました)。
<code>--with-debug</code> を使用すると、15% だけ遅くなります。
By starting a <code>mysqld</code> version compiled with <code>--with-debug=full</code>
with <code>--skip-safemalloc</code> the end result should be close to when
configuring with <code>--with-debug</code>.

</li><li>

SPARCstation 20 では、<code>gcc</code> 2.95.2 は Sun Pro C++ 4.2 より 5% 速くなります

</li><li>

UltraSPARC で <code>gcc</code> 2.95.2 でオプション <code>-mcpu=v8
-Wa,-xarch=v8plusa</code> をつけてコンパイルすると 4% 良い性能が得られます。

</li><li>

シングルプロセッサの Solaris 2.5.1 では、MIT-pthreads は Solaris ネイティブスレ
ッドより 8-12% 遅くなります。
With more load/CPUs the difference should
get bigger.

</li><li>

<code>--log-bin</code> での実行は <strong>MySQL</strong> を 1% 遅くします。

</li><li>

Compiling on Linux-x86 using gcc without frame pointers
<code>-fomit-frame-pointer</code> or <code>-fomit-frame-pointer -ffixed-ebp</code>
<code>mysqld</code> 1-4% faster.
</li></ul>

<p>
The MySQL-Linux distribution provided by MySQL AB used
to be compiled with <code>pgcc</code>, but we had to go back to regular gcc
because of a bug in <code>pgcc</code> that would generate the code that does
not run on AMD. We will continue using gcc until that bug is resolved.
In the meantime, if you have a non-AMD machine, you can get a faster
binary by compiling with <code>pgcc</code>.  The standard MySQL
Linux binary is linked statically to get it faster and more portable.

</p>



<h3><a name="Memory_use" href="manual.ja_toc.html#Memory_use">5.5.4  MySQL はどのようにメモリを使用するのか？</a></h3>

<p>
<a name="IDX907"></a>

</p>
<p>
以下に <code>mysqld</code> サーバーがどのようにメモリーを使用するか、いくつか示します。
サーバーに与える変数名は、サーバーのメモリーの使用方に関連した名前となっています:

</p>

<ul>
<li>

キーバッファ (変数 <code>key_buffer</code>) は全てのスレッドで共有され、
残りは必要時に割り当てられます。  「<a href="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</a>」節参照.

</li><li>

各接続はいくつかのスレッド空間を使用します；
スタック (64K, 変数 <code>thread_stack</code>), 接続バッファ(variable
<code>net_buffer_length</code>), 結果バッファ(variable
<code>net_buffer_length</code>)。接続バッファと結果バッファは必要となった時、
動的に最大 <code>max_allowed_packet</code> まで増えます。
クエリが走っている時、そのクエリの文字のコピーが割り当てられます。

</li><li>

全てのスレッドは同じベースメモリを共有します。

</li><li>

圧縮された ISAM / MyISAM だけが、memory mapped されます。
これは 4GB の 32bit メモリ空間は多くの大きなテーブルを扱うには小さいためです。
64bit アドレス空間を持つシステムがより普及すれば、我々は mmemory mapping を通常
にサポートします。

</li><li>

テーブルを越えて順次スキャンを行なう各要求は、読み込みバッファを割り当てます
(変数 record_buffer)

</li><li>

When reading rows in 'random' order (for example after a sort) a
random-read buffer is allocated to avoid disk seeks.
(variable <code>record_rnd_buffer</code>).

</li><li>

全ての結合は1パスで行なわれ、多くの結合は一時テーブルを使用せずに行なわ
れます。多くの一時テーブルはメモリベース(HEAP)のテーブルです。大きなレコー
ドサイズ (= 全フィールド長の合計) を持つ一時テーブルまたは、<code>BLOB</code> を含む
テーブルはディスク上に置かれます。

<strong>MySQL</strong> バージョン 3.23.2 以前での問題は、HEAP テーブルが 
<code>tmp_table_size</code> のサイズを越えると、エラー <code>The table tbl_name is full</code>
が出ることです。将来我々は、必要時にメモリ (HEAP) テーブルをディスクベー
ス (NISAM) テーブルに自動的に変更することにより、これを修正します。この
問題を回避するため、<code>mysqld</code> への <code>tmp_table_size</code> オプションま
たはクライアント側で SQL オプション <code>SQL_BIG_TABLES</code> で増加できます。
 「<a href="manual.ja_MySQL_Optimization.html#SET_OPTION">5.5.6  <code>SET</code> 構文</a>」節参照.
<strong>MySQL</strong> バージョン 3.20 では、一時テーブルの最大サイズは 
<code>recordbuffer*16</code> でした。そのため、このバージョンを使用していると、
<code>recordbuffer</code> を追加する必要があります。 <code>mysqld</code> を <code>--big-tables</code> で
開始することで、常に一時テーブルをディスク上に格納できます。しかしこれは
多くの複雑なクエリの速度に影響します。

</li><li>

ほとんどのリクエストは、0-2個の一時ファイルとわずかなソートバッファへの割り当て
を行います。  「<a href="manual.ja_Problems.html#Temporary_files">A.4.4  MySQL が一時ファイルを格納する場所</a>」節参照.

</li><li>

パースと演算時に使用されるほとんど全てのメモリはローカルメモリストア内で行
なわれます。小さな項目に必要とされるメモリオーバーヘッドはなく、通常の遅
いメモリ割り当て/解放が回避されます。メモリは予期しない大きな文字列にだ
け割り当てられます(これは <code>malloc()</code> と <code>free()</code> で行なわれます)。

</li><li>

各インデックスファイルは一度オープンされ、データファイルは各同時実行
スレッド毎に一度オープンされます。各同時スレッドには、テーブル構造、
各フィールドの構造そして <code>3 * n</code> のサイズのバッファが割り当てられます。
( <code>n</code> は <code>BLOB</code> 型のフィールドの長さを含めない、一レコードの最大長です )
<code>BLOB</code> は 5 から 8 バイト + <code>BLOB</code> データの長さを使用します。
The <code>ISAM</code>/<code>MyISAM</code> table handlers will use one extra row
buffer for internal usage.

</li><li>

<code>BLOB</code> を持つ各テーブルでは、より大きな <code>BLOB</code> の読み込みでバッファ
は動的に拡大されます。テーブルのスキャンをする場合、割り当てられたバッファは最
も大きい <code>BLOB</code> と同じ大きさになります。

</li><li>

全ての使用されているテーブルのテーブルハンドラーはキャッシュ内に保存され、
FIFO として管理されます。
通常、キャッシュは 64 個のテーブルです。テーブルが 2 つの実行しているス
レッドで同時に使用される場合、キャッシュ内にテーブルの 2 つのエントリが
あります。  「<a href="manual.ja_MySQL_Optimization.html#Table_cache">5.4.6  MySQL はどのようにテーブルのオープン &amp; クローズを行なうか？</a>」節参照.

</li><li>

<code>mysqladmin flush-tables</code> は使用されていない全てのテーブルをクローズし、
使用されている全てのテーブルを、実行中スレッドが終った時にクローズするよ
うにマークします。これは多くの使用メモリを解放するのに有効です。全てのロ
グファイルもクローズと再オープンされます。
</li></ul>

<p>
<strong>mysqld</strong> 実行時、<code>ps</code> や他のプログラムは、それが多くのメモリ
を使用していると報告するでしょう。これは異なったメモリアドレス上のスレッ
ドスタックによって発生します。例えば、Solaris ps はスタック間の未使用メ
モリを使用メモリとして計算します。'swap -s' で有効なスワップをチェックす
ることでこれを確かめられます。我々は市販のメモリリーク検出プログラムで 
<code>mysqld</code> をテストしました。そのため、メモリリークは全くありません。

</p>



<h3><a name="DNS" href="manual.ja_toc.html#DNS">5.5.5  How MySQL uses DNS</a></h3>

<p>
<a name="IDX908"></a>
<a name="IDX909"></a>

</p>
<p>
When a new thread connects to <code>mysqld</code>, <code>mysqld</code> will span a
new thread to handle the request.  This thread will first check if the
hostname is in the hostname cache. If not the thread will call
<code>gethostbyaddr_r()</code> and <code>gethostbyname_r()</code> to resolve the
hostname.

</p>
<p>
If the operating system doesn't support the above thread-safe calls, the
thread will lock a mutex and call <code>gethostbyaddr()</code> and
<code>gethostbyname()</code> instead. Note that in this case no other thread
can resolve other hostnames that is not in the hostname cache until the
first thread is ready.

</p>
<p>
You can disable DNS host lookup by starting <code>mysqld</code> with
<code>--skip-name-resolve</code>.  In this case you can however only use IP
names in the MySQL privilege tables.

</p>
<p>
If you have a very slow DNS and many hosts, you can get more performance by
either disabling DNS lookop with <code>--skip-name-resolve</code> or by
increasing the <code>HOST_CACHE_SIZE</code> define (default: 128) and recompile
<code>mysqld</code>.

</p>
<p>
You can disable the hostname cache with <code>--skip-host-cache</code>. You
can clear the hostname cache with <code>FLUSH HOSTS</code> or <code>mysqladmin
flush-hosts</code>.

</p>
<p>
If you don't want to allow connections over <code>TCP/IP</code>, you can do this
by starting <code>mysqld</code> with <code>--skip-networking</code>.

</p>



<h3><a name="SET_OPTION" href="manual.ja_toc.html#SET_OPTION">5.5.6  <code>SET</code> 構文</a></h3>

<p>
<a name="IDX910"></a>

</p>

<pre>SET [OPTION] SQL_VALUE_OPTION= value, ...
</pre>

<p>
<code>SET OPTION</code> はサーバやクライアントの操作に影響する様々なオプションを設定します. 
現在のセッションが終わるか,またはあなたが異なった値にオプションを設定するまで,
設定されたオプション値は残っています.

</p>
<dl compact="">

<dt><code>CHARACTER SET character_set_name | DEFAULT</code>
</dt><dd>
これは指定されたマッピングに従って、すべての文字列をクライアントからクライアント
にマップします.
現在、<code>character_set_name</code> に指定できるオプションは <code>cp1251_koi8</code> だけですが,
<strong>MySQL</strong> のソース中にある <tt>`sql/convert.cc'</tt> ファイルを編集することによって,
容易に新しいマッピングを加えることができます. 標準のマッピングに戻すには、
<code>character_set_name</code> に <code>DEFAULT</code> を指定します。

<code>CHARACTER SET</code> オプションを設定するための構文は、
他のオプションを設定する構文と異なっていることに注意してください.

</dd><dt><code>PASSWORD = PASSWORD('some password')</code>
</dt><dd>
<a name="IDX911"></a>
現在のユーザのパスワードを設定します。いかなる非匿名のユーザも、
自分自身パスワードを変えることができます!

</dd><dt><code>PASSWORD FOR user = PASSWORD('some password')</code>
</dt><dd>
現在ログインしているホストの特定ユーザのパスワードを設定します。
<code>mysql</code> データベースにアクセスができるユーザーだけが実行できます。
ユーザは <code>user@hostname</code> 形式で与えなくてはなりません。
ここで <code>user</code> と <code>hostname</code> は、<code>mysql.user</code> テーブルの
<code>User</code>, <code>Host</code> フィールドに登録されていなくてはなりません。
例えば、<code>User</code> と <code>Host</code> フィールドが <code>'bob'</code> と
<code>'%.loc.gov'</code> ならば、以下のようにします：


<pre>mysql&gt; SET PASSWORD FOR bob@"%.loc.gov" = PASSWORD("newpass");

or

mysql&gt; UPDATE mysql.user SET password=PASSWORD("newpass") where user="bob' and host="%.loc.gov";
</pre>

</dd><dt><code>SQL_AUTO_IS_NULL = 0 | 1</code>
</dt><dd>
<code>1</code> (デフォルト) を設定すると、次のようにして、auto_increment レコー
ドを持つテーブルで、最後に挿入されたレコードを見つけることができます:
<code>WHERE auto_increment_column IS NULL</code>。これは、Access のようないくつ
かの ODBC プログラムによって使用されます。

</dd><dt><code>AUTOCOMMIT= 0 | 1</code>
</dt><dd>
<code>1</code> を設定すると、テーブルへのすべての変更はすぐに行なわれます。
複数コマンドトランザクションを開始するためには、<code>BEGIN</code> ステートメ
ントを使用する必要があります。 「<a href="manual.ja_Reference.html#COMMIT">6.7.1  <code>BEGIN/COMMIT/ROLLBACK</code> 構文</a>」節参照。
<code>0</code> を設定すると、そのトランザクションを許可/破棄するために、
<code>COMMIT</code> / <code>ROLLBACK</code> を使用する必要があります。 「<a href="manual.ja_Reference.html#COMMIT">6.7.1  <code>BEGIN/COMMIT/ROLLBACK</code> 構文</a>」節参照。
注意: 非 <code>AUTOCOMMIT</code> モードから <code>AUTOCOMMIT</code> モードに変更する時、
<strong>MySQL</strong> はすべてのオープントランザクションを自動的に 
<code>COMMIT</code> します。

</dd><dt><code>SQL_BIG_TABLES = 0 | 1</code>
</dt><dd>
<a name="IDX912"></a>
<code>0</code> の場合、全ての一時テーブルはメモリーではなくディスクに書き出されます。
これは少し遅くなりますが、多くの一時テーブルを必要とする大きな <code>SELECT</code> を
実行しても、<code>The table tbl_name is full</code> エラーが出なくなります。
新しい接続におけるこの値のデフォルト値は <code>1</code> (メモリーに一時テーブルを作る)
です。

</dd><dt><code>SQL_BIG_SELECTS = 0 | 1</code>
</dt><dd>
<code>1</code> の場合、とても時間のかかる <code>SELECT</code> が実行された場合、
<strong>MySQL</strong> はそれを中止します。
これはあまり芳しくない(間違った) <code>WHERE</code> 構文が発行されたときに役立ちます。
<code>max_join_size</code> 行以上を検討するような <code>SELECT</code> が
大きなクエリと定義されます。
新しい接続におけるこの値のデフォルト値は <code>0</code> です。
(全ての <code>SELECT</code> 構文を許します)

</dd><dt><code>SQL_BUFFER_RESULT = 0 | 1</code>
</dt><dd>
<code>SQL_BUFFER_RESULT</code> は一時ファイルに置かれる <code>SELECT</code> からの結果
を強制的に置きます。これは <strong>MySQL</strong> がテーブルロックを早く解放する手
助けをし、クライアントへ結果セットを送信するために長い時間が掛かる場合に役
立ちます。

</dd><dt><code>SQL_LOW_PRIORITY_UPDATES = 0 | 1</code>
</dt><dd>
<code>1</code> の場合、全ての <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>,
 <code>LOCK TABLE WRITE</code>構文は、
対象となるテーブルを処理中の <code>SELECT</code> や <code>LOCK TABLE READ</code>
がなくなるまで待ちます。

</dd><dt><code>SQL_MAX_JOIN_SIZE = value | DEFAULT</code>
</dt><dd>
おそらく <code>value</code> よりも多いレコードの組合せを試験する必要があるような
<code>SELECT</code> を許可しません。この値を設定することで、キーが使用されないで
あろう <code>SELECT</code> と長い時間が掛かるであろう <code>SELECT</code> を捕捉できま
す。これを <code>DEFAULT</code> 以外の値に設定すると、<code>SQL_BIG_SELECTS</code> フ
ラグをリセットします。<code>SQL_BIG_SELECTS</code> フラグを再び設定すると、
<code>SQL_MAX_JOIN_SIZE</code> 変数は無視されます。<code>-O max_join_size=#</code> で 
<code>mysqld</code> を起動することで、この変数のデフォルト値を設定できます。

</dd><dt><code>SQL_SAFE_UPDATES = 0 | 1</code>
</dt><dd>
<code>1</code> に設定すると、<code>WHERE</code> 節内でキーや <code>LIMIT</code> を使用しない
で <code>UPDATE</code> または <code>DELETE</code> を行なおうとした場合に 
<strong>MySQL</strong> がアボートします。これは、手で SQL コマンドを生成する時の間
違った更新の捕捉を可能にします。

</dd><dt><code>SQL_SELECT_LIMIT = value | DEFAULT</code>
</dt><dd>
<code>SELECT</code> 構文から返されるレコードの最大値。
もし <code>SELECT</code> に <code>LIMIT</code> 節を使用している場合、<code>LIMIT</code> は
 <code>SQL_SELECT_LIMIT</code> の値より優先されます。
新しい接続におけるこの値の標準値は ``unlimited''.
もしリミットを変えているならば、<code>SQL_SELECT_LIMIT</code> に
 <code>DEFAULT</code> を指定することにより、標準値に戻すことができます。

</dd><dt><code>SQL_LOG_OFF = 0 | 1</code>
</dt><dd>
この値が <code>1</code> の場合、もしクライアントが <strong>process</strong> 権限を持っているならば、
このクライアントのログが行われません。
これは更新ログに影響しません！

</dd><dt><code>SQL_LOG_UPDATE = 0 | 1</code>
</dt><dd>
<code>0</code> の場合、もしクライアントが <strong>process</strong> 権限を持っているならば、
このクライアントの更新ログの記録は行われません。
これは通常のログには影響しません！

</dd><dt><code>SQL_QUOTE_SHOW_CREATE = 0 | 1</code>
</dt><dd>
If set to <code>1</code>, <code>SHOW CREATE TABLE</code> will quote
table and column names. This is <strong>on</strong> by default,
for replication of tables with fancy column names to work.
 「<a href="manual.ja_MySQL_Database_Administration.html#SHOW_CREATE_TABLE">4.5.5.8  <code>SHOW CREATE TABLE</code></a>」節.

</dd><dt><code>TIMESTAMP = timestamp_value | DEFAULT</code>
</dt><dd>
クライアントに時間を設定します。
もしレコードのリストアに更新ログを使用する場合、オリジナルのタイムスタンプを得る
ために使用します。
<code>timestamp_value</code> should be a
UNIX Epoch timestamp, not a MySQL timestamp.

</dd><dt><code>LAST_INSERT_ID = #</code>
</dt><dd>
<code>LAST_INSERT_ID()</code> からの返り値を設定します。
テーブルを更新するコマンド中に <code>LAST_INSERT_ID()</code> を使用した場合、
これは更新ログに保存されます。

</dd><dt><code>INSERT_ID = #</code>
</dt><dd>
 <code>AUTO_INCREMENT</code> 値を挿入する時、
<code>INSERT</code> , <code>ALTER TABLE</code> コマンドに従って使用される値をセットします。
これは更新ログによって使用されます。

</dd></dl>



<h2><a name="Disk_issues" href="manual.ja_toc.html#Disk_issues">5.6  Disk の問題</a></h2>

<p>
<a name="IDX913"></a>
<a name="IDX914"></a>

</p>

<ul>
<li>

前に述べたディスクシークが大きなボトルネックです。 この問題は、データが効果的に
キャッシングが不可能になるほど、大きくなり始めるときに、だんだん明白になってきま
す。
For large databases,
where you access data more or less randomly, you can be sure that you
will need at least one disk seek to read and a couple of disk seeks to
write things. この問題を少なくするには、diskシーク時間の少ないディスクを
使用します。

</li><li>

利用できるディスクスピンドルの数を増やします(それによってディスクシーク
のオーバーヘッドは縮小します)。
これは違うディスクにシンボリックリンクをはったり、ストライピングを行うことで
可能です。

<dl compact="">

<dt><strong>Using symbolic links</strong>
</dt><dd>
これは通常のデータディレクトリから、違うディスクへ、
インデックスやデータファイルをシンボリック・リンクすることです。
これは シーク と リード を速くします。 (もしそのディスクが
他に使用されていなければ).  「<a href="manual.ja_MySQL_Optimization.html#Symbolic_links">5.6.1  シンボリックリンクの使用</a>」節参照.

<a name="IDX915"></a>
</dd><dt><strong>Striping</strong>
</dt><dd>
ストライピングは、複数のディスクに対して、まずデータの最初のブロックを
1番目の disk に書き、2番目のブロックを2つ目のdiskに書き、順次 N 番目
(N は disk の数) まで順に書いていきます。 これは、もしデータがストライプの
サイズよりも小さければ、よりよいパフォーマンスを得ることが出来ます。
ストライピングは、OS や ストライプのサイズにとても依存していることに注意してくだ
さい。そのため、あなたのアプリケーションのベンチマークがストライプサイズによって
変わるでしょう。  「<a href="manual.ja_MySQL_Optimization.html#Custom_Benchmarks">5.1.5  Using Your Own Benchmarks</a>」節参照.

ストライピングのスピードの違いは、<strong>とても</strong> パラメターに依存しています。
Depending on how you set the striping parameters and
number of disks you may get a difference in orders of magnitude. Note that
you have to choose to optimize for random or sequential access.
</dd></dl>

</li><li>

信頼性のため、あなたは RAID 0+1 (striping + mirroring) を使用したいと
思うかもしれません。 しかしこれは N 個のドライブのデータを収めるのに
2*N 個のドライブが必要となります。
これはもし資金があるならば一番よい方法でしょう！ しかし、能率的にそれを
取り扱うために、ボリューム・マネージメント・ソフトウェアに投資する必要が
あってもよいです。

</li><li>

A good option is to have semi-important data (that can be regenerated)
on RAID 0 disk while storing really important data (like host information
and logs) on a RAID 0+1 or RAID N disk. RAID N can be a problem if you
have many writes because of the time to update the parity bits.

</li><li>

データベースに使用しているファイルシステムの mount パラメターを変更しても
良いでしょう。 一つの簡単な方法としては、noatime オプションでファイルシステムを
マウントします。 これは inode にある最後にアクセスした時間の更新を
スキップします。 これでいくらか ディスクシークを避けることができるでしょう。

</li><li>

On Linux, you can get much more performance (up to 100 % under load is
not uncommon) by using hdpram to configure your disk's interface!  The
following should be quite good hdparm options for MySQL (and
probably many other applications):


<pre>hdparm -m 16 -d 1
</pre>

Note that the performance/reliability when using the above depends on
your hardware, so we strongly suggest that you test your system
thoroughly after using <code>hdparm</code>!  Please consult the <code>hdparm</code>
man page for more information!  If <code>hdparm</code> is not used wisely,
filesystem corruption may result.  Backup everything before experimenting!

</li><li>

On many operating systems you can mount the disks with the 'async' flag to
set the file system to be updated asynchronously.  If your computer is
reasonable stable, this should give you more performance without sacrificing
too much reliability.  (This flag is on by default on Linux.)

</li><li>

If you don't need to know when a file was last accessed (which is not
really useful on a database server), you can mount your file systems
with the noatime flag.
</li></ul>



<h3><a name="Symbolic_links" href="manual.ja_toc.html#Symbolic_links">5.6.1  シンボリックリンクの使用</a></h3>

<p>
<a name="IDX916"></a>
<a name="IDX917"></a>

</p>
<p>
テーブルとデータベースのファイルを MySQL のデータベースディレクトリーから
違う場所に移動し、 それに対してシンボリックリンクを張ることができます。例
えば、もっと空き容量のあるファイルシステムへデータベースを移すため、あるい
はテーブルを異なるディスクに広げることでシステムのスピードを増加するために
これを行ないたくなるでしょう。

</p>
<p>
The recommended may to do this, is to just symlink databases to different
disk and only symlink tables as a last resort.

</p>
<p>
<a name="IDX918"></a>

</p>



<h4><a name="Symbolic_links_to_databases" href="manual.ja_toc.html#Symbolic_links_to_databases">5.6.1.1  Using Symbolic Links for Databases</a></h4>

<p>
The way to symlink a database is to first create a directory on some
disk where you have free space and then create a symlink to it from
the MySQL database directory.

</p>

<pre>shell&gt; mkdir /dr1/databases/test
shell&gt; ln -s /dr1/databases/test mysqld-datadir
</pre>

<p>
<strong>MySQL</strong> は一つのディレクトリを複数のデータベースにリンクすることは
サポートしていません。シンボリックリンクを持つデータベースディレクトリの複
製は、データベース間のシンボリックリンクを作成しなければ、正常に動作します。
<strong>MySQL</strong> データディレクトリに <code>db1</code> データベースがあるとして、
<code>db1</code> を指すシンボリックリンク <code>db2</code> を作成します。

</p>

<pre>shell&gt; cd /path/to/datadir
shell&gt; ln -s db1 db2
</pre>

<p>
すると、<code>db1</code> 中の <code>tbl_a</code> テーブルは <code>db2</code> の  <code>tbl_a</code> テー
ブルとして見えます。
もしあるスレッドが <code>db1.tbl_a</code> を更新し、他のスレッドが <code>db2.tbl_a</code> を
更新した場合、 問題が発生します。 

</p>
<p>
こういった使用をどうしてもしたい場合、<tt>`mysys/mf_format.c'</tt> を以下のように変
更します: 

</p>

<pre>if (flag &amp; 32 || (!lstat(to,&amp;stat_buff) &amp;&amp; S_ISLNK(stat_buff.st_mode)))
</pre>

<p>
to

</p>

<pre>if (1)
</pre>

<p>
On Windows you can use internal symbolic links to directories by compiling
MySQL with <code>-DUSE_SYMDIR</code>. This allows you to put different
databases on different disks.  「<a href="manual.ja_Installing.html#Windows_symbolic_links">2.6.2.5  Windows 上で、異なるディスクにデータを分割する</a>」節参照.

</p>



<h4><a name="Symbolic_links_to_tables" href="manual.ja_toc.html#Symbolic_links_to_tables">5.6.1.2  Using Symbolic Links for Tables</a></h4>

<p>
<a name="IDX919"></a>

</p>
<p>
Before MySQL 4.0 you should not symlink tables, if you are not
very carefully with them. The problem is that if you run <code>ALTER
TABLE</code>, <code>REPAIR TABLE</code> or <code>OPTIMIZE TABLE</code> on a symlinked
table, the symlinks will be removed and replaced by the original
files. This happens because the above command works by creating a
temporary file in the database directory and when the command is
complete, replace the original file with the temporary file.

</p>
<p>
You should not symlink tables on system that doesn't have a fully
working <code>realpath()</code> call. (At least Linux and Solaris support
<code>realpath()</code>)

</p>
<p>
In MySQL 4.0 symlinks is only fully supported for <code>MyISAM</code>
tables.  For other table types you will probably get strange problems
when doing any of the above mentioned commands.

</p>
<p>
The handling of symbolic links in MySQL 4.0 works the following
way (this is mostly relevant only for <code>MyISAM</code> tables).

</p>

<ul>
<li>

In the data directory you will always have the table definition file
and the data/index files.

</li><li>

You can symlink the index file and the data file to different directories
independent of the other.

</li><li>

The symlinking can be done from the operating system (if <code>mysqld</code> is
not running) or with the <code>INDEX/DATA DIRECTORY="path-to-dir"</code> command
in <code>CREATE TABLE</code>.  「<a href="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <code>CREATE TABLE</code> 構文</a>」節参照.

</li><li>

<code>myisamchk</code> will not replace a symlink with the index/file but
work directly on the files the symlinks points to. Any temporary files
will be created in the same directory where the data/index file is.

</li><li>

When you drop a table that is using symlinks, both the symlink and the
file the symlink points to is dropped.  This is a good reason to why you
should NOT run <code>mysqld</code> as root and not allow persons to have write
access to the MySQL database directories.

</li><li>

If you rename a table with <code>ALTER TABLE RENAME</code> and you don't change
database, the symlink in the database directory will be renamed to the new
name and the data/index file will be renamed accordingly.

</li><li>

If you use <code>ALTER TABLE RENAME</code> to move a table to another database,
then the table will be moved to the other database directory and the old
symlinks and the files they pointed to will be deleted.

</li><li>

If you are not using symlinks you should use the <code>--skip-symlink</code>
option to <code>mysqld</code> to ensure that no one can drop or rename a file
outside of the <code>mysqld</code> data directory.
</li></ul>

<p>
Things that are not yet supported:

</p>
<p>
<a name="IDX920"></a>

</p><ul>
<li>

<code>ALTER TABLE</code> ignores all <code>INDEX/DATA DIRECTORY="path"</code> options.
</li><li>

<code>CREATE TABLE</code> doesn't report if the table has symbolic links.
</li><li>

<code>mysqldump</code> doesn't include the symbolic links information in the output.
</li><li>

<code>BACKUP TABLE</code> and <code>RESTORE TABLE</code> don't respect symbolic links.
</li></ul>

<p></p><hr><p>
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_MySQL_Database_Administration.html">previous</a>, <a href="manual.ja_Reference.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
 
 
</p></body></html>