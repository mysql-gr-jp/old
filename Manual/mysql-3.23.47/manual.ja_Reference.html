  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 30 December 2001 -->

  <TITLE>MySQL Reference Manual for version 3.23.47. - 6  MySQL Language Reference</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=silver TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_MySQL_Optimization.html">previous</A>, <A HREF="manual.ja_Table_types.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Reference" HREF="manual.ja_toc.html#Reference">6  MySQL Language Reference</A></H1>

<P>
<STRONG>MySQL</STRONG> はとても複雑ですが、直感的で、SQL インタフェースを学ぶのに
簡単です。この章は、<STRONG>MySQL</STRONG> を効率よく効果的に使用するために知って
おく必要がある様々なコマンド、型、関数について説明します。この章は、
<STRONG>MySQL</STRONG> に含まれているすべての機能へのリファレンスも提供します。こ
の章を効果的に使用するため、様々なインデックスを参照して便利に見つけられま
す。

</P>



<H2><A NAME="Language_Structure" HREF="manual.ja_toc.html#Language_Structure">6.1  Language Structure</A></H2>



<H3><A NAME="Literals" HREF="manual.ja_toc.html#Literals">6.1.1  文字列と数値をどのように書くか？</A></H3>

<P>
<A NAME="IDX921"></A>
<A NAME="IDX922"></A>
<A NAME="IDX923"></A>
<A NAME="IDX924"></A>
<A NAME="IDX925"></A>

</P>

<P>
この節は <STRONG>MySQL</STRONG> で文字列と数値を記述するさまざまな方法を説明します。
<STRONG>MySQL</STRONG> でのこれらの基本型の取り扱い時に、出会うであろうさまざまな
ニュアンスと ``了解'' もカバーします。

</P>



<H4><A NAME="String_syntax" HREF="manual.ja_toc.html#String_syntax">6.1.1.1  文字列</A></H4>

<P>
文字列は文字の並びです。引用符(<SAMP>`''</SAMP>)または二重引用符(<SAMP>`"'</SAMP>)で括ら
れます(後者は ANSI モードで実行していない場合のみ)。 例：

</P>

<PRE>
'a string'
"another string"
</PRE>

<P>
文字列中では、いくつかのシーケンスは特別な意味を持ちます。これらのシーケ
ンスのそれぞれは<EM>エスケープ文字</EM>として知られるバックスラッシュ
(<SAMP>`\'</SAMP>)で始まります。<STRONG>MySQL</STRONG> は次のエスケープシーケンスを認識
します。

</P>
<DL COMPACT>

<DT><CODE>\0</CODE>
<DD>
<A NAME="IDX926"></A>
 <A NAME="IDX927"></A>
 
ASCII 0 (<CODE>NUL</CODE>) 文字。

<A NAME="IDX928"></A>
<A NAME="IDX929"></A>
<DT><CODE>\'</CODE>
<DD>
引用符(<SAMP>`''</SAMP>)。

<A NAME="IDX930"></A>
<A NAME="IDX931"></A>
<DT><CODE>\"</CODE>
<DD>
二重引用符(<SAMP>`"'</SAMP>)。

<A NAME="IDX932"></A>
<A NAME="IDX933"></A>
<DT><CODE>\b</CODE>
<DD>
バックスペース文字。

<A NAME="IDX934"></A>
<A NAME="IDX935"></A>
<DT><CODE>\n</CODE>
<DD>
改行文字。

<A NAME="IDX936"></A>
<A NAME="IDX937"></A>
<A NAME="IDX938"></A>
<DT><CODE>\r</CODE>
<DD>
リターン文字。

<A NAME="IDX939"></A>
<A NAME="IDX940"></A>
<DT><CODE>\t</CODE>
<DD>
タブ文字。

<A NAME="IDX941"></A>
<A NAME="IDX942"></A>
<DT><CODE>\z</CODE>
<DD>
ASCII(26) (Control-Z)。この文字は、ASCII(26) が Windows では END-OF-FILE 
であるという問題を回避するために、コード化できます。(ASCII(26) は 
<CODE>mysql database &#60; filename</CODE> を使用しようとする場合に問題になります)。

<A NAME="IDX943"></A>
<A NAME="IDX944"></A>
<DT><CODE>\\</CODE>
<DD>
バックスラッシュ(<SAMP>`\'</SAMP>)文字。

<A NAME="IDX945"></A>
<A NAME="IDX946"></A>
<DT><CODE>\%</CODE>
<DD>
<SAMP>`%'</SAMP> 文字。これは <SAMP>`%'</SAMP> がワイルドカード文字として解釈される文脈
で、<SAMP>`%'</SAMP> そのものを検索するために使用されます。
 「<A HREF="manual.ja_Reference.html#String_comparison_functions">6.3.2.1  文字列比較関数</A>」節参照.

<A NAME="IDX947"></A>
<A NAME="IDX948"></A>
<DT><CODE>\_</CODE>
<DD>
<CODE>_</CODE> 文字。これは <SAMP>`_'</SAMP> がワイルドカード文字として解釈される文脈
で、<CODE>_</CODE> そのものを検索するために使用されます。
 「<A HREF="manual.ja_Reference.html#String_comparison_functions">6.3.2.1  文字列比較関数</A>」節参照.
</DL>

<P>
いくつかの文字列文脈で <SAMP>`\%'</SAMP> または <SAMP>`\_'</SAMP> を使用すると、これらは文
字列 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> ではなく、<SAMP>`\%'</SAMP> と <SAMP>`\_'</SAMP> を返します。

</P>
<P>
<A NAME="IDX949"></A>
文字列中に引用符を含める方法はいくつかあります:

</P>

<UL>
<LI>

<SAMP>`''</SAMP> で括られる文字列中の <SAMP>`''</SAMP> は <SAMP>`'''</SAMP> として書くことができ
ます。

<LI>

<SAMP>`"'</SAMP> で括られる文字列中の <SAMP>`"'</SAMP> は <SAMP>`""'</SAMP> として書くことができ
ます。

<LI>

引用符の前にエスケープ文字 (<SAMP>`\'</SAMP>) を置くことができます。

<LI>

<SAMP>`"'</SAMP> で括られた文字列中の <SAMP>`''</SAMP> は特別扱いの必要はなく、二重にし
たり、エスケープする必要はありません。同じように、<SAMP>`''</SAMP> で括られた文
字列中の <SAMP>`"'</SAMP> は特別扱いの必要はありません。
</UL>

<P>
次の <CODE>SELECT</CODE> ステートメントは、クォートとエスケープがどのように働
くかを示します:

</P>

<PRE>
mysql&#62; SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+

mysql&#62; SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+

mysql&#62; SELECT "This\nIs\nFour\nlines";
+--------------------+
| This
Is
Four
lines |
+--------------------+
</PRE>

<P>
<A NAME="IDX950"></A>

</P>
<P>
バイナリデータを <CODE>BLOB</CODE> フィールドに挿入したい場合、次の文字をエスケープ
シーケンスで表す必要があります:
<DL COMPACT>

<DT><CODE>NUL</CODE>
<DD>
ASCII 0。<SAMP>`\0'</SAMP> (バックスラッシュと ASCII <SAMP>`0'</SAMP> 文字) に置き換える
べきです。
<DT><CODE>\</CODE>
<DD>
ASCII 92, バックスラッシュ。<SAMP>`\\'</SAMP> と表記してください。
<DT><CODE>'</CODE>
<DD>
ASCII 39, 引用符。<SAMP>`\''</SAMP> と表記してください。
<DT><CODE>"</CODE>
<DD>
ASCII 34, 二重引用符。<SAMP>`\"'</SAMP> と表記してください。
</DL>

<P>
<A NAME="IDX951"></A>
<A NAME="IDX952"></A>
<A NAME="IDX953"></A>
<A NAME="IDX954"></A>
C コードを書く場合、<CODE>INSERT</CODE> 節で文字をエスケープするために、C API 
関数 <CODE>mysql_escape_string()</CODE> を使用できます。 「<A HREF="manual.ja_Clients.html#C_API_function_overview">8.4.2  C API 関数概要</A>」節参照.  Perl では、<CODE>DBI</CODE> パッケージの <CODE>quote</CODE> メソッドを使
用して、特殊文字を適当なエスケープシーケンスに変換できます。 「<A HREF="manual.ja_Clients.html#Perl_DBI_Class">8.2.2  The <CODE>DBI</CODE> Interface</A>」節参照.

</P>
<P>
上記の特殊文字のどれかを含む可能性のある全ての文字列について、エスケープ
関数を使用すべきです！

</P>



<H4><A NAME="Number_syntax" HREF="manual.ja_toc.html#Number_syntax">6.1.1.2  数値</A></H4>

<P>
<A NAME="IDX955"></A>
<A NAME="IDX956"></A>
<A NAME="IDX957"></A>
<A NAME="IDX958"></A>
<A NAME="IDX959"></A>

</P>
<P>
整数は数字の並びで表現されます。
浮動小数点は <SAMP>`.'</SAMP> で小数を分割します。
どちらの型も負数を表すために <SAMP>`-'</SAMP> を前につけます。

</P>
<P>
正当な数値の例:

</P>

<PRE>
1221
0
-32
</PRE>

<P>
有効な浮動小数点の例：

</P>

<PRE>
294.42
-32032.6809e+10
148.00
</PRE>

<P>
整数が浮動小数点の文脈で使用されるかもしれません； この場合、浮動小数点に
変換されます。

</P>



<H4><A NAME="Hexadecimal_values" HREF="manual.ja_toc.html#Hexadecimal_values">6.1.1.3  16進法の値</A></H4>

<P>
<A NAME="IDX960"></A>

</P>
<P>
<STRONG>MySQL</STRONG> は16進法の値をサポートします。
数値の文脈では、これらは整数(64ビット精度)のように振る舞います。
文字列の文脈では、hexの桁のそれぞれのペアが文字に変換された
バイナリー文字のように振る舞います。

</P>

<PRE>
mysql&#62; SELECT 0xa+0;
       -&#62; 10
mysql&#62; select 0x5061756c;
       -&#62; Paul
</PRE>

<P>
16進数表記は、ODBC において BLOB の値を与えるためにしばしば使用されます。

</P>



<H4><A NAME="NULL_values" HREF="manual.ja_toc.html#NULL_values">6.1.1.4  <CODE>NULL</CODE> 値</A></H4>

<P>
<A NAME="IDX961"></A>

</P>
<P>
<CODE>NULL</CODE> は ``no data'' を意味し、数値型の <CODE>0</CODE> や文字列型の空文
字列とは異なることに注意してください。
 「<A HREF="manual.ja_Problems.html#Problems_with_NULL">A.5.3  <CODE>NULL</CODE> 値での問題</A>」節参照.

</P>
<P>
テキストファイルの読み込みや書き出し時に、<CODE>NULL</CODE> は <CODE>\N</CODE> で
表現されます。 (<CODE>LOAD DATA INFILE</CODE>, <CODE>SELECT ... INTO OUTFILE</CODE>).
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.8  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.

</P>



<H3><A NAME="Legal_names" HREF="manual.ja_toc.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A></H3>

<P>
<A NAME="IDX962"></A>
<A NAME="IDX963"></A>
<A NAME="IDX964"></A>
<A NAME="IDX965"></A>
<A NAME="IDX966"></A>
<A NAME="IDX967"></A>
<A NAME="IDX968"></A>

</P>

<P>
データベース名、テーブル名、インデックス名、フィールド名、エイリアス名は
<STRONG>MySQL</STRONG> では全て同じ規則に基づきます:

</P>
<P>
<A NAME="IDX969"></A>
<A NAME="IDX970"></A>
<A NAME="IDX971"></A>
<A NAME="IDX972"></A>
注意: 規則は <STRONG>MySQL</STRONG> 3.23.6 で変更されました。それは識別子(データベー
ス名、テーブル名、フィールド名)の <SAMP>``'</SAMP> でのクォートを導入した時です
(ANSI モードで実行する場合は、<CODE>"</CODE> も識別子をクォートするために働きま
す)。

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>識別子</STRONG> </TD><TD> <STRONG>最大長</STRONG> </TD><TD> <STRONG>許される文字</STRONG>
</TR NOSAVE>
<TR><TD>データベース </TD><TD> 64 </TD><TD> ディレクトリ名として許されるすべての文字。<CODE>/</CODE> を除く。
</TR NOSAVE>
<TR><TD>テーブル </TD><TD> 64 </TD><TD> ファイル名として許されるすべての文字。<CODE>/</CODE> と <CODE>.</CODE> を除く。
</TR NOSAVE>
<TR><TD>フィールド </TD><TD> 64 </TD><TD> すべての文字
</TR NOSAVE>
<TR><TD>エイリアス </TD><TD> 255 </TD><TD> すべての文字
</TR>
</TABLE>

<P>
注意: 上記に加え、識別子内には ASCII(0) と ASCII(255) を持てません。

</P>
<P>
注意: 識別子が制限された単語であったり特殊文字を含む場合は、それを使用する
時には常に <CODE>`</CODE> でクォートする必要があります:

</P>

<PRE>
SELECT * from `select` where `select`.id &#62; 100;
</PRE>

<P>
<STRONG>MySQL</STRONG> の前のバージョンでは、名前の規則は次に従います:

</P>

<UL>
<LI>

名前は、現在の文字セットのアルファベットと数字文字から成り、<SAMP>`_'</SAMP> と 
<SAMP>`$'</SAMP> も含みます。デフォルト文字セットは ISO-8859-1 Latin1 ですが、
これは <CODE>mysqld</CODE> に <CODE>--default-character-set</CODE> オプションを
与えることで変更できます. (3.23.14 以上の場合のみ。
それ以前のバージョンでは <STRONG>MySQL</STRONG> 再コンパイルが必要)
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_sets">4.6.1  データとソートに使用されるキャラクターセット</A>」節参照.

<LI>

名前は、名前として正しい任意の文字で始めることができます。特に、名前は数
字で始めることができます(これは他の多くのシステムと異なります！)。しかし、
数字<EM>だけ</EM>の名前にする事はできません。

<LI>

名前の中に <SAMP>`.'</SAMP> 文字を使用することはできません。フィールドを参照できるよう
に形式を拡張するために使用されるためです(後述)。
</UL>

<P>
<CODE>1e</CODE> のような名前は使用しないことを勧めます。<CODE>1e+1</CODE> のような式が
あいまいだからです。これは、式 <CODE>1e + 1</CODE> として、または数値 
<CODE>1e+1</CODE> として解釈されます。

</P>
<P>
<STRONG>MySQL</STRONG> では次の形式のいずれかを使用してフィールドを参照できます:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドの参照方法</STRONG> </TD><TD> <STRONG>意味</STRONG>
</TR NOSAVE>
<TR><TD><CODE>col_name</CODE> </TD><TD> クエリ中で使用されるテーブル内に存在している <CODE>col_name</CODE> という名前のフィールド
</TR NOSAVE>
<TR><TD><CODE>tbl_name.col_name</CODE> </TD><TD> 現在のデータベースのテーブル <CODE>tbl_name</CODE> 内のフィールド <CODE>col_name</CODE>
</TR NOSAVE>
<TR><TD><CODE>db_name.tbl_name.col_name</CODE> </TD><TD> データベース <CODE>db_name</CODE>
のテーブル <CODE>tbl_name</CODE> 内のフィールド <CODE>col_name</CODE>。この形式は
バージョン 3.22 以降で有効です。
</TR NOSAVE>
<TR><TD>
<CODE>`column_name`</CODE> </TD><TD> キーワードであったり特殊文字を含むフィールド。
</TR>
</TABLE>

<P>
参照が曖昧でないならば、ステートメント中のフィールド参照の前に <CODE>tbl_name</CODE> 
または <CODE>db_name.tbl_name</CODE> を記述する必要はありません。例えば、テー
ブル <CODE>t1</CODE> と <CODE>t2</CODE> がそれぞれフィールド <CODE>c</CODE> を含み、<CODE>t1</CODE> と 
<CODE>t2</CODE> の両方を使用する <CODE>SELECT</CODE> ステートメントで <CODE>c</CODE> を取
り出すとします。この場合、<CODE>c</CODE> はステートメントで使用されるテーブル
間で唯一でないので曖昧です。そのため、<CODE>t1.c</CODE> または <CODE>t2.c</CODE> と
記述するこよによりどちらのテーブルを意味するかを示す必要があります。同様
に、データベース <CODE>db1</CODE> のテーブル <CODE>t</CODE> とデータベース 
<CODE>db2</CODE> のテーブル <CODE>t</CODE> から取り出す場合、これらのテーブル中の項
目は、<CODE>db1.t.col_name</CODE> と <CODE>db2.t.col_name</CODE> として参照する必要
があります。

</P>
<P>
<A NAME="IDX973"></A>
<A NAME="IDX974"></A>
構文 <CODE>.tbl_name</CODE> は現在のデータベース内のテーブル <CODE>tbl_name</CODE> 
を意味します。この構文はいくつかの ODBC が <SAMP>`.'</SAMP> 文字をテーブル名の前
に置くために許されています。

</P>



<H3><A NAME="Name_case_sensitivity" HREF="manual.ja_toc.html#Name_case_sensitivity">6.1.3  名前のケース依存性</A></H3>

<P>
<A NAME="IDX975"></A>
<A NAME="IDX976"></A>
<A NAME="IDX977"></A>
<A NAME="IDX978"></A>
<A NAME="IDX979"></A>
<A NAME="IDX980"></A>

</P>
<P>
<STRONG>MySQL</STRONG> では、データベースとテーブルは、ディレクトリと
そのディレクトリ中のファイルに対応します。そのため、下で動作するオペレー
ティングシステムのケース依存性は、データベースとテーブル名のケース依存性を決定します。
データベース名とテーブル名は UNIX ではケース依存で、Windows ではケース非依
存です。 「<A HREF="manual.ja_Introduction.html#Extensions_to_ANSI">1.4.1  MySQL の ANSI SQL92 に対する拡張</A>」節参照.

</P>
<P>
<STRONG>注意:</STRONG> Windows ではデータベース名とファイル名はケース非依存ですが、
同じクエリ内で、データベースやテーブルを異なるケースを使用して参照すべき
ではありません。
以下のクエリは動きません。なぜなら <CODE>my_table</CODE> と <CODE>MY_TABLE</CODE> の両方を
参照しているからです：

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE MY_TABLE.col=1;
</PRE>

<P>
フィールド名は全ての場合でケース非依存です。

</P>
<P>
テーブルの別名はケース依存です。
以下のクエリは動きません。なぜなら <CODE>a</CODE> と <CODE>A</CODE> のエイリアスを両方
参照しているからです：

</P>

<PRE>
mysql&#62; SELECT col_name FROM tbl_name AS a
           WHERE a.col_name = 1 OR A.col_name = 2;
</PRE>

<P>
フィールドのエイリアス名はケース非依存です。

</P>
<P>
テーブル名に使用されたケースを覚えておくことに問題があるなら、常にデータベー
スとテーブルに小文字の名前をつけるというような、一貫した慣習を採用してくだ
さい。

</P>
<P>
この問題を回避する一つの方法は、<CODE>mysqld</CODE> を <CODE>-O
lower_case_table_names=1</CODE> をつけて起動することです。デフォルトではこのオプ
ションは Windows では 1 で UNIX では 0 です。

</P>
<P>
<CODE>lower_case_table_names</CODE> が 1 の場合、<STRONG>MySQL</STRONG> はディスク上のす
べてのテーブル名を小文字に変換して検索します。注意: このオプションを変更し
た場合、<CODE>mysqld</CODE> を起動する前に、最初に古いテーブル名を小文字に変換す
ることが必要です。

</P>



<H3><A NAME="Variables" HREF="manual.ja_toc.html#Variables">6.1.4  ユーザー変数</A></H3>

<P>
<A NAME="IDX981"></A>
<A NAME="IDX982"></A>
<A NAME="IDX983"></A>

</P>
<P>
<STRONG>MySQL</STRONG> は、<CODE>@variablename</CODE> 構文でスレッド固有の変数をサポー
トします。変数名は現在の文字セットのアルファベットと数字、それに 
<SAMP>`_'</SAMP>、<SAMP>`$'</SAMP>、<SAMP>`.'</SAMP> 文字からなります。デフォルト文字セットは 
ISO-8859-1 Latin1 です。
これは <CODE>mysqld</CODE> に <CODE>--default-character-set</CODE> オプションを
与えることで変更できます. (3.23.14 以上の場合のみ。
それ以前のバージョンでは <STRONG>MySQL</STRONG> 再コンパイルが必要)
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_sets">4.6.1  データとソートに使用されるキャラクターセット</A>」節参照.

</P>
<P>
変数は初期化する必要はありません。デフォルトでは <CODE>NULL</CODE> であり、整数
値、実数値、文字列値を格納できます。すべてのスレッド変数は、スレッドが終了
すると自動的に解放されます。

</P>
<P>
<CODE>SET</CODE> 構文で変数を設定できます:

</P>

<PRE>
SET @variable= { integer expression | real expression | string expression }
[,@variable= ...].
</PRE>

<P>
<CODE>@variable:=expr</CODE> 構文で、式中で変数を設定することも可能です:

</P>

<PRE>
select @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;
+----------------------+------+------+------+
| @t1:=(@t2:=1)+@t3:=4 | @t1  | @t2  | @t3  |
+----------------------+------+------+------+
|                    5 |    5 |    1 |    4 |
+----------------------+------+------+------+
</PRE>

<P>
(我々は <CODE>:=</CODE> 構文を使用する必要がありました。<CODE>=</CODE> は比較のために
予約されていたからです。)

</P>
<P>
ユーザー変数は式が許される場所で使用できます。注意: これは現在、
<CODE>SELECT</CODE> ステートメントの <CODE>LIMIT</CODE> 節、<CODE>LOAD DATA</CODE> ステート
メントの <CODE>IGNORE number LINES</CODE> 節のように、数値が明示的に要求される文
脈での使用を含みません。

</P>
<P>
<STRONG>注意:</STRONG> <CODE>SELECT</CODE> ステートメントでは、それぞれの式はクライアン
トに送られた時にだけ評価されます。これは、<CODE>SELECT</CODE> 部で設定された変数
を必要とする式を参照する <CODE>HAVING</CODE>, <CODE>GROUP BY</CODE>, <CODE>ORDER BY</CODE> 
節ができないことを意味します。例えば、次のステートメントは期待通りには動作
しません:

</P>

<PRE>
SELECT (@aa:=id) AS a, (@aa+3) AS b FROM table_name HAVING b=5;
</PRE>

<P>
この理由は、<CODE>@aa</CODE> が現在のレコードの値ではなく、前に受け取ったレコー
ドの <CODE>id</CODE> の値になるからです。

</P>



<H3><A NAME="Comments" HREF="manual.ja_toc.html#Comments">6.1.5  コメント 構文</A></H3>

<P>
<A NAME="IDX984"></A>

</P>
<P>
<A NAME="IDX985"></A>

</P>
<P>
<STRONG>MySQL</STRONG> は <CODE># 行末まで</CODE> , <CODE>-- 行末まで</CODE> そして <CODE>/* 
行中または複数行 */</CODE> コメント書式をサポートします:

</P>

<PRE>
mysql&#62; select 1+1;     # このコメントは行末まで続く
mysql&#62; select 1+1;     -- このコメントは行末まで続く
mysql&#62; select 1 /* これは行中コメント */ + 1;
mysql&#62; select 1+
/*
これは
複数行コメント
*/
1;
</PRE>

<P>
<CODE>--</CODE> コメントスタイルは <CODE>--</CODE> の後ろに最低一つのスペースが
必要であることに注意！

</P>
<P>
サーバーはコメント構文を理解しますが、 <CODE>mysql</CODE> クライアントが
 <CODE>/* ... */</CODE> コメントを分析するにはいくつか制限があります：

</P>

<UL>
<LI>

シングルクウォートとダブルクオート文字は引用文字列のトークンの開始を
示します。たとえコメントの中であっても。
もしコメントの中でクオートが二つ目のクオートにマッチしなかった場合、
パーサーはコメントが終了していないと認識します。
<CODE>mysql</CODE> を対話モードで実行している場合、
プロンプトが <CODE>mysql&#62;</CODE> から <CODE>'&#62;</CODE> か <CODE>"&#62;</CODE> に変わります。

<LI>

セミコロンは SQL 構文の終了を示し、これに続く文字は次の構文の開始と
なります。
</UL>

<P>
これらの制限は <CODE>mysql</CODE> を対話モードで実行している場合と、
<CODE>mysql</CODE> にファイルを読み込ませている場合 ( <CODE>mysql &#60; some-file</CODE> ) の
両方で現れます。

</P>
<P>
<STRONG>MySQL</STRONG> は ANSI SQL コメントの <SAMP>`--'</SAMP> をサポートしません。
 「<A HREF="manual.ja_Introduction.html#Missing_comments">1.4.4.8  コメント開始としての <SAMP>`--'</SAMP></A>」節参照.

</P>



<H3><A NAME="Reserved_words" HREF="manual.ja_toc.html#Reserved_words">6.1.6  Is MySQL Picky About Reserved Words?</A></H3>

<P>
<A NAME="IDX986"></A>
<A NAME="IDX987"></A>

</P>
<P>
共通の問題は、フィールドの名前を、 <CODE>TIMESTAMP</CODE> とか <CODE>GROUP</CODE> とかの
 <STRONG>MySQL</STRONG> に埋め込まれているデータ型や関数名と同名にして、
テーブルを作った場合に起こります。
このようなことは行えます(例えば <CODE>ABS</CODE> はフィールド名にできます)。
しかし、関数として使用する場合、
この名前がフィールド名として使用されているなら、
関数名と <SAMP>`('</SAMP> の間の空白は許されません。

</P>
<P>
以下の語は <STRONG>MySQL</STRONG> に予約されています。
これらのほとんどは、 ANSI SQL92 によって、
テーブル、フィールド名としての使用は禁止されています。(例えば <CODE>group</CODE>)。
またいくつかの語は <STRONG>MySQL</STRONG> が必要とし、 <CODE>yacc</CODE> パーサーで
使用しているので予約されています。

</P>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>action</CODE> </TD><TD> <CODE>add</CODE> </TD><TD> <CODE>aggregate</CODE> </TD><TD> <CODE>all</CODE>
</TR NOSAVE>
<TR><TD><CODE>alter</CODE> </TD><TD> <CODE>after</CODE> </TD><TD> <CODE>and</CODE> </TD><TD> <CODE>as</CODE>
</TR NOSAVE>
<TR><TD><CODE>asc</CODE> </TD><TD> <CODE>avg</CODE> </TD><TD> <CODE>avg_row_length</CODE> </TD><TD> <CODE>auto_increment</CODE>
</TR NOSAVE>
<TR><TD><CODE>between</CODE> </TD><TD> <CODE>bigint</CODE> </TD><TD> <CODE>bit</CODE> </TD><TD> <CODE>binary</CODE>
</TR NOSAVE>
<TR><TD><CODE>blob</CODE> </TD><TD> <CODE>bool</CODE> </TD><TD> <CODE>both</CODE> </TD><TD> <CODE>by</CODE>
</TR NOSAVE>
<TR><TD><CODE>cascade</CODE> </TD><TD> <CODE>case</CODE> </TD><TD> <CODE>char</CODE> </TD><TD> <CODE>character</CODE>
</TR NOSAVE>
<TR><TD><CODE>change</CODE> </TD><TD> <CODE>check</CODE> </TD><TD> <CODE>checksum</CODE> </TD><TD> <CODE>column</CODE>
</TR NOSAVE>
<TR><TD><CODE>columns</CODE> </TD><TD> <CODE>comment</CODE> </TD><TD> <CODE>constraint</CODE> </TD><TD> <CODE>create</CODE>
</TR NOSAVE>
<TR><TD><CODE>cross</CODE> </TD><TD> <CODE>current_date</CODE> </TD><TD> <CODE>current_time</CODE> </TD><TD> <CODE>current_timestamp</CODE>
</TR NOSAVE>
<TR><TD><CODE>data</CODE> </TD><TD> <CODE>database</CODE> </TD><TD> <CODE>databases</CODE> </TD><TD> <CODE>date</CODE>
</TR NOSAVE>
<TR><TD><CODE>datetime</CODE> </TD><TD> <CODE>day</CODE> </TD><TD> <CODE>day_hour</CODE> </TD><TD> <CODE>day_minute</CODE>
</TR NOSAVE>
<TR><TD><CODE>day_second</CODE> </TD><TD> <CODE>dayofmonth</CODE> </TD><TD> <CODE>dayofweek</CODE> </TD><TD> <CODE>dayofyear</CODE>
</TR NOSAVE>
<TR><TD><CODE>dec</CODE> </TD><TD> <CODE>decimal</CODE> </TD><TD> <CODE>default</CODE> </TD><TD> <CODE>delayed</CODE>
</TR NOSAVE>
<TR><TD><CODE>delay_key_write</CODE> </TD><TD> <CODE>delete</CODE> </TD><TD> <CODE>desc</CODE> </TD><TD> <CODE>describe</CODE>
</TR NOSAVE>
<TR><TD><CODE>distinct</CODE> </TD><TD> <CODE>distinctrow</CODE> </TD><TD> <CODE>double</CODE> </TD><TD> <CODE>drop</CODE>
</TR NOSAVE>
<TR><TD><CODE>end</CODE> </TD><TD> <CODE>else</CODE> </TD><TD> <CODE>escape</CODE> </TD><TD> <CODE>escaped</CODE>
</TR NOSAVE>
<TR><TD><CODE>enclosed</CODE> </TD><TD> <CODE>enum</CODE> </TD><TD> <CODE>explain</CODE> </TD><TD> <CODE>exists</CODE>
</TR NOSAVE>
<TR><TD><CODE>fields</CODE> </TD><TD> <CODE>file</CODE> </TD><TD> <CODE>first</CODE> </TD><TD> <CODE>float</CODE>
</TR NOSAVE>
<TR><TD><CODE>float4</CODE> </TD><TD> <CODE>float8</CODE> </TD><TD> <CODE>flush</CODE> </TD><TD> <CODE>foreign</CODE>
</TR NOSAVE>
<TR><TD><CODE>from</CODE> </TD><TD> <CODE>for</CODE> </TD><TD> <CODE>full</CODE> </TD><TD> <CODE>function</CODE>
</TR NOSAVE>
<TR><TD><CODE>global</CODE> </TD><TD> <CODE>grant</CODE> </TD><TD> <CODE>grants</CODE> </TD><TD> <CODE>group</CODE>
</TR NOSAVE>
<TR><TD><CODE>having</CODE> </TD><TD> <CODE>heap</CODE> </TD><TD> <CODE>high_priority</CODE> </TD><TD> <CODE>hour</CODE>
</TR NOSAVE>
<TR><TD><CODE>hour_minute</CODE> </TD><TD> <CODE>hour_second</CODE> </TD><TD> <CODE>hosts</CODE> </TD><TD> <CODE>identified</CODE>
</TR NOSAVE>
<TR><TD><CODE>ignore</CODE> </TD><TD> <CODE>in</CODE> </TD><TD> <CODE>index</CODE> </TD><TD> <CODE>infile</CODE>
</TR NOSAVE>
<TR><TD><CODE>inner</CODE> </TD><TD> <CODE>insert</CODE> </TD><TD> <CODE>insert_id</CODE> </TD><TD> <CODE>int</CODE>
</TR NOSAVE>
<TR><TD><CODE>integer</CODE> </TD><TD> <CODE>interval</CODE> </TD><TD> <CODE>int1</CODE> </TD><TD> <CODE>int2</CODE>
</TR NOSAVE>
<TR><TD><CODE>int3</CODE> </TD><TD> <CODE>int4</CODE> </TD><TD> <CODE>int8</CODE> </TD><TD> <CODE>into</CODE>
</TR NOSAVE>
<TR><TD><CODE>if</CODE> </TD><TD> <CODE>is</CODE> </TD><TD> <CODE>isam</CODE> </TD><TD> <CODE>join</CODE>
</TR NOSAVE>
<TR><TD><CODE>key</CODE> </TD><TD> <CODE>keys</CODE> </TD><TD> <CODE>kill</CODE> </TD><TD> <CODE>last_insert_id</CODE>
</TR NOSAVE>
<TR><TD><CODE>leading</CODE> </TD><TD> <CODE>left</CODE> </TD><TD> <CODE>length</CODE> </TD><TD> <CODE>like</CODE>
</TR NOSAVE>
<TR><TD><CODE>lines</CODE> </TD><TD> <CODE>limit</CODE> </TD><TD> <CODE>load</CODE> </TD><TD> <CODE>local</CODE>
</TR NOSAVE>
<TR><TD><CODE>lock</CODE> </TD><TD> <CODE>logs</CODE> </TD><TD> <CODE>long</CODE> </TD><TD> <CODE>longblob</CODE>
</TR NOSAVE>
<TR><TD><CODE>longtext</CODE> </TD><TD> <CODE>low_priority</CODE> </TD><TD> <CODE>max</CODE> </TD><TD> <CODE>max_rows</CODE>
</TR NOSAVE>
<TR><TD><CODE>match</CODE> </TD><TD> <CODE>mediumblob</CODE> </TD><TD> <CODE>mediumtext</CODE> </TD><TD> <CODE>mediumint</CODE>
</TR NOSAVE>
<TR><TD><CODE>middleint</CODE> </TD><TD> <CODE>min_rows</CODE> </TD><TD> <CODE>minute</CODE> </TD><TD> <CODE>minute_second</CODE>
</TR NOSAVE>
<TR><TD><CODE>modify</CODE> </TD><TD> <CODE>month</CODE> </TD><TD> <CODE>monthname</CODE> </TD><TD> <CODE>myisam</CODE>
</TR NOSAVE>
<TR><TD><CODE>natural</CODE> </TD><TD> <CODE>numeric</CODE> </TD><TD> <CODE>no</CODE> </TD><TD> <CODE>not</CODE>
</TR NOSAVE>
<TR><TD><CODE>null</CODE> </TD><TD> <CODE>on</CODE> </TD><TD> <CODE>optimize</CODE> </TD><TD> <CODE>option</CODE>
</TR NOSAVE>
<TR><TD><CODE>optionally</CODE> </TD><TD> <CODE>or</CODE> </TD><TD> <CODE>order</CODE> </TD><TD> <CODE>outer</CODE>
</TR NOSAVE>
<TR><TD><CODE>outfile</CODE> </TD><TD> <CODE>pack_keys</CODE> </TD><TD> <CODE>partial</CODE> </TD><TD> <CODE>password</CODE>
</TR NOSAVE>
<TR><TD><CODE>precision</CODE> </TD><TD> <CODE>primary</CODE> </TD><TD> <CODE>procedure</CODE> </TD><TD> <CODE>process</CODE>
</TR NOSAVE>
<TR><TD><CODE>processlist</CODE> </TD><TD> <CODE>privileges</CODE> </TD><TD> <CODE>read</CODE> </TD><TD> <CODE>real</CODE>
</TR NOSAVE>
<TR><TD><CODE>references</CODE> </TD><TD> <CODE>reload</CODE> </TD><TD> <CODE>regexp</CODE> </TD><TD> <CODE>rename</CODE>
</TR NOSAVE>
<TR><TD><CODE>replace</CODE> </TD><TD> <CODE>restrict</CODE> </TD><TD> <CODE>returns</CODE> </TD><TD> <CODE>revoke</CODE>
</TR NOSAVE>
<TR><TD><CODE>rlike</CODE> </TD><TD> <CODE>row</CODE> </TD><TD> <CODE>rows</CODE> </TD><TD> <CODE>second</CODE>
</TR NOSAVE>
<TR><TD><CODE>select</CODE> </TD><TD> <CODE>set</CODE> </TD><TD> <CODE>show</CODE> </TD><TD> <CODE>shutdown</CODE>
</TR NOSAVE>
<TR><TD><CODE>smallint</CODE> </TD><TD> <CODE>soname</CODE> </TD><TD> <CODE>sql_big_tables</CODE> </TD><TD> <CODE>sql_big_selects</CODE>
</TR NOSAVE>
<TR><TD><CODE>sql_low_priority_updates</CODE> </TD><TD> <CODE>sql_log_off</CODE> </TD><TD> <CODE>sql_log_update</CODE> </TD><TD> <CODE>sql_select_limit</CODE>
</TR NOSAVE>
<TR><TD><CODE>sql_small_result</CODE> </TD><TD> <CODE>sql_big_result</CODE> </TD><TD> <CODE>sql_warnings</CODE> </TD><TD> <CODE>straight_join</CODE>
</TR NOSAVE>
<TR><TD><CODE>starting</CODE> </TD><TD> <CODE>status</CODE> </TD><TD> <CODE>string</CODE> </TD><TD> <CODE>table</CODE>
</TR NOSAVE>
<TR><TD><CODE>tables</CODE> </TD><TD> <CODE>temporary</CODE> </TD><TD> <CODE>terminated</CODE> </TD><TD> <CODE>text</CODE>
</TR NOSAVE>
<TR><TD><CODE>then</CODE> </TD><TD> <CODE>time</CODE> </TD><TD> <CODE>timestamp</CODE> </TD><TD> <CODE>tinyblob</CODE>
</TR NOSAVE>
<TR><TD><CODE>tinytext</CODE> </TD><TD> <CODE>tinyint</CODE> </TD><TD> <CODE>trailing</CODE> </TD><TD> <CODE>to</CODE>
</TR NOSAVE>
<TR><TD><CODE>type</CODE> </TD><TD> <CODE>use</CODE> </TD><TD> <CODE>using</CODE> </TD><TD> <CODE>unique</CODE>
</TR NOSAVE>
<TR><TD><CODE>unlock</CODE> </TD><TD> <CODE>unsigned</CODE> </TD><TD> <CODE>update</CODE> </TD><TD> <CODE>usage</CODE>
</TR NOSAVE>
<TR><TD><CODE>values</CODE> </TD><TD> <CODE>varchar</CODE> </TD><TD> <CODE>variables</CODE> </TD><TD> <CODE>varying</CODE>
</TR NOSAVE>
<TR><TD><CODE>varbinary</CODE> </TD><TD> <CODE>with</CODE> </TD><TD> <CODE>write</CODE> </TD><TD> <CODE>when</CODE>
</TR NOSAVE>
<TR><TD><CODE>where</CODE> </TD><TD> <CODE>year</CODE> </TD><TD> <CODE>year_month</CODE> </TD><TD> <CODE>zerofill</CODE>
</TR>
</TABLE>

<P>
The following symbols (from the table above) are disallowed by ANSI SQL
but allowed by MySQL as column/table names. This is because some
of these names are very natural names and a lot of people have already
used them.

</P>

<UL>
<LI><CODE>ACTION</CODE>

<LI><CODE>BIT</CODE>

<LI><CODE>DATE</CODE>

<LI><CODE>ENUM</CODE>

<LI><CODE>NO</CODE>

<LI><CODE>TEXT</CODE>

<LI><CODE>TIME</CODE>

<LI><CODE>TIMESTAMP</CODE>

</UL>



<H2><A NAME="Column_types" HREF="manual.ja_toc.html#Column_types">6.2  フィールド型</A></H2>

<P>
<A NAME="IDX988"></A>
<A NAME="IDX989"></A>

</P>
<P>
<STRONG>MySQL</STRONG>は多くのフィールド型をサポートしており、それらは３つのカテゴリに
グループ化されます: 数値型、日付及び時間型、そして文字列(文字)型。
この章ではまず、利用できる型の概要から始まり、それから各カテゴリの各フィールド
型の所要記憶容量の要約と、型の属性についてのより詳細な情報を提供します。
概要は意図的に簡潔にまとめています。値として指定できる書式のようなフィールド
型固有の付加情報は、詳細の説明部にて調べて下さい。

</P>
<P>
<STRONG>MySQL</STRONG>でサポートされるフィールド型は以下に示す通りです。
後に続く文字の意味は説明のために使われます:

</P>
<P>
<A NAME="IDX990"></A>
<A NAME="IDX991"></A>
<A NAME="IDX992"></A>
<A NAME="IDX993"></A>
<A NAME="IDX994"></A>
<A NAME="IDX995"></A>
<DL COMPACT>

<DT><CODE>M</CODE>
<DD>
最大表示サイズを意味します。最大の表示桁数は 255.

<DT><CODE>D</CODE>
<DD>
浮動小数点数型に適用され、小数点以下の桁数を表します。
最大の値は 30 ですが、これは <CODE>M</CODE>-2 より大きくなってはいけません。
</DL>

<P>
中カッコ(<SAMP>`['</SAMP>及び<SAMP>`]'</SAMP>)は型定義の一部であり、それがオプションであることを
表します。

</P>
<P>
<A NAME="IDX996"></A>

</P>

<P>
もしあるフィールドに <CODE>ZEROFILL</CODE> を指定した場合、
 <STRONG>MySQL</STRONG> は自動で <CODE>UNSIGNED</CODE> 属性をそのフィールドに
追加します。

</P>
<DL COMPACT>

<DT><CODE>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
<A NAME="IDX997"></A>
 

とても小さい整数。符号つきの範囲は <CODE>-128</CODE>〜<CODE>127</CODE>。符号なしの範囲は
<CODE>0</CODE>〜<CODE>255</CODE>。

<A NAME="IDX998"></A>
<DT><CODE>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
小さい整数。符号つきの範囲は <CODE>-32768</CODE>〜<CODE>32767</CODE>。
符号なしの範囲は <CODE>0</CODE>〜<CODE>65535</CODE>。

<A NAME="IDX999"></A>
<DT><CODE>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
中間の整数。符号ありの範囲は <CODE>-8388608</CODE>〜<CODE>8388607</CODE>。
符号なしの範囲は <CODE>0</CODE>〜<CODE>16777215</CODE>

<A NAME="IDX1000"></A>
<DT><CODE>INT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
通常の整数。符号ありの範囲は <CODE>-2147483648</CODE>〜<CODE>2147483647</CODE>。符号なしの範
囲は <CODE>0</CODE>〜<CODE>4294967295</CODE>

<A NAME="IDX1001"></A>
<DT><CODE>INTEGER[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
これは、<CODE>INT</CODE>の同義語です。

<A NAME="IDX1002"></A>
<DT><CODE>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
大きい整数。
符号ありの範囲は <CODE>-9223372036854775808</CODE>〜<CODE>9223372036854775807</CODE>。
符号なしの範囲は <CODE>0</CODE>〜<CODE>18446744073709551615</CODE>。

<CODE>BIGINT</CODE> フィールドについて意識すべきことのいくつか:


<UL>
<LI>

<A NAME="IDX1003"></A>
全ての演算は符合付き <CODE>BIGINT</CODE> または <CODE>DOUBLE</CODE> で行われるため、
符合無しの <CODE>9223372036854775807</CODE> (63 bits) よりも大きな整数を
ビット関数以外で使用すべきではありません！
それを行なうと、結果の最後の桁のいくつかは不正になるでしょう
<CODE>BIGINT</CODE> を <CODE>DOUBLE</CODE> に変換する時の丸めエラーのためです。
<LI>

文字列として格納することで <CODE>BIGINT</CODE> フィールドの正確な整数値を常に格
納することができます。この場合、double 表現を介在しません。
<LI>

<CODE>-</CODE>、<CODE>+</CODE>及び<CODE>*</CODE>は、両方の引数が<CODE>INTEGER</CODE>値の時、
<CODE>BIGINT</CODE>演算を使うことに注意して下さい！ これは、２つの大きな整数の
かけ算を行なう(又は整数を返す関数の結果が大きな整数である)時、
結果が<CODE>9223372036854775807</CODE>よりも大きい場合に予期しない結果を
受け取ることがあるということを意味しています。
</UL>

<A NAME="IDX1004"></A>
<A NAME="IDX1005"></A>
<A NAME="IDX1006"></A>
<DT><CODE>FLOAT(precision) [ZEROFILL]</CODE>
<DD>
浮動小数点数。符号なしにはできません。単精度浮動小数点数では 
<CODE>precision</CODE> が <CODE>&#60;=24</CODE> で、倍精度浮動小数点数では 25〜53 の間です。
これらの型は次で述べる<CODE>FLOAT</CODE>や<CODE>DOUBLE</CODE>型に似ています。
<CODE>FLOAT(X)</CODE>は、<CODE>FLOAT</CODE>及び<CODE>DOUBLE</CODE>型に一致する同じ範囲を持っていま
すが、
表示サイズや小数点以下桁数が定義されません。

<STRONG>MySQL</STRONG> バージョン 3.23 では、これは正しい浮動小数点です。前の 
<STRONG>MySQL</STRONG> バージョンでは, <CODE>FLOAT(precision)</CODE> は常に小数部は2桁で
した。

注意: <CODE>FLOAT</CODE> の使用は、<STRONG>MySQL</STRONG> での全ての演算が double 精度で行
なわれるため、いくつかの予期しない問題が起こり得ます。
 「<A HREF="manual.ja_Problems.html#No_matching_rows">A.5.6  Solving Problems with No Matching Rows</A>」節参照.

<A NAME="IDX1007"></A>
<A NAME="IDX1008"></A>
この構文は ODBC 互換です。

<A NAME="IDX1009"></A>
<A NAME="IDX1010"></A>
<DT><CODE>FLOAT[(M,D)] [ZEROFILL]</CODE>
<DD>
小さい浮動小数点数。符号なしにはできません。
範囲は <CODE>-3.402823466E+38</CODE>〜<CODE>-1.175494351E-38</CODE>、 <CODE>0</CODE>、
<CODE>1.175494351E-38</CODE>〜<CODE>3.402823466E+38</CODE>です。
M は表示幅で D は小数部桁数です。引数が無いか引数が24以下の <CODE>FLOAT</CODE> 
は単精度浮動小数点数を意味します。

<A NAME="IDX1011"></A>
<A NAME="IDX1012"></A>
<DT><CODE>DOUBLE[(M,D)] [ZEROFILL]</CODE>
<DD>
通常の浮動小数点数。符号なしにはできません。
範囲は <CODE>-1.7976931348623157E+308</CODE>〜<CODE>-2.2250738585072014E-308</CODE>
、 <CODE>0</CODE>、<CODE>2.2250738585072014E-308</CODE>〜<CODE>1.7976931348623157E+308</CODE>です。
M は表示幅で D は小数部桁数です。引数が無いか <CODE>DOUBLE</CODE> か、25 &#60;= X
&#60;= 53 である <CODE>FLOAT(X)</CODE> は倍精度浮動小数点数を意味します。

<A NAME="IDX1013"></A>
<A NAME="IDX1014"></A>
<DT><CODE>DOUBLE PRECISION[(M,D)] [ZEROFILL]</CODE>
<DD>
<DT><CODE>REAL[(M,D)] [ZEROFILL]</CODE>
<DD>
これらは<CODE>DOUBLE</CODE>の同義語です。

<A NAME="IDX1015"></A>
<DT><CODE>DECIMAL[(M[,D])] [ZEROFILL]</CODE>
<DD>
パック無し浮動小数点数。符号なしにはできません。<CODE>CHAR</CODE>フィールドのように振
舞います。`パック無し'は、数値が文字列として格納されることを意味し、数値のそれぞ
れの桁、小数点、及び負数での<SAMP>`-'</SAMP>符号に１文字使用します。
<CODE>D</CODE>が0の時、値は小数点や小数部を持ちません。<CODE>DECIMAL</CODE>値の最大範囲は
<CODE>DOUBLE</CODE>と同じですが、実際の範囲は<CODE>DECIMAL</CODE>フィールドに与えられた<CODE>M</CODE>
及び<CODE>D</CODE>の選択に強制されます。

<CODE>D</CODE> を省略した場合は 0 に設定されいます。<CODE>M</CODE> を省略した場合は 
10 に設定されます。

<STRONG>MySQL</STRONG> 3.22 では、 <CODE>M</CODE> 引数は符号や小数点を含みます。 

<A NAME="IDX1016"></A>
<DT><CODE>NUMERIC(M,D) [ZEROFILL]</CODE>
<DD>
<CODE>DECIMAL</CODE>と同じ。

<A NAME="IDX1017"></A>
<DT><CODE>DATE</CODE>
<DD>
日付。サポートされる範囲は<CODE>'1000-01-01'</CODE>から<CODE>'9999-12-31'</CODE>まで。
MySQL は<CODE>'YYYY-MM-DD'</CODE>の書式で<CODE>DATE</CODE>値を表示しますが、<CODE>DATE</CODE>
フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。
 「<A HREF="manual.ja_Reference.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A>」節参照.

<A NAME="IDX1018"></A>
<DT><CODE>DATETIME</CODE>
<DD>
日付と時刻の組み合わせ。サポートされる範囲は<CODE>'1000-01-01 00:00:00'</CODE>〜
<CODE>'9999-12-31 23:59:59'</CODE>です。<STRONG>MySQL</STRONG>は<CODE>DATETIME</CODE>値を
<CODE>'YYYY-MM-DD HH:MM:SS'</CODE>という書式で表示しますが、<CODE>DATETIME</CODE>フィールド
への値の割当ては、文字列もしくは数値のいずれかの使用が許されます。
 「<A HREF="manual.ja_Reference.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A>」節参照.

<A NAME="IDX1019"></A>
<DT><CODE>TIMESTAMP[(M)]</CODE>
<DD>
タイムスタンプ。範囲は<CODE>'1970-01-01 00:00:00'</CODE>〜<CODE>2037</CODE>年末までです。
MySQL は<CODE>TIMESTAMP</CODE>値を<CODE>YYYYMMDDHHMMSS</CODE>、<CODE>YYMMDDHHMMSS</CODE>、
<CODE>YYYYMMDD</CODE>又は<CODE>YYMMDD</CODE>という書式で表示し、それは<CODE>M</CODE>に<CODE>14</CODE>(もし
くは誤ってそれ以上の値を指定した時)、<CODE>12</CODE>、<CODE>8</CODE>又は<CODE>6</CODE>のいずれが指
定されたかに依存します。しかしながら<CODE>TIMESTAMP</CODE>フィールドへの値の割当ては、
文字列もしくは数値のいずれかの使用が許されます。
<CODE>TIMESTAMP</CODE>フィールドは、最後に操作された時刻を自動的に設定するので、
<CODE>INSERT</CODE>や<CODE>UPDATE</CODE>操作の時刻を記録するのに役立ちます。
<CODE>NULL</CODE>値を与えることによっても、現在時刻を設定できます。
 「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節参照.

<CODE>TIMESTAMP</CODE> は常に 4 バイトで格納されます。<CODE>M</CODE> 引数は
<CODE>TIMESTAMP</CODE> フィールドがどのように表示されるかだけに影響します。

注意: X が 8 または 14 である <CODE>TIMESTAMP(X)</CODE> フィールドは数値として報
告されます。他の <CODE>TIMESTAMP(X)</CODE> フィールドは文字列として報告されます。
これは、これらの型を持ったテーブルを確実にダンプとリストアできるようにする
ためです！
 「<A HREF="manual.ja_Reference.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A>」節参照.

<A NAME="IDX1020"></A>
<DT><CODE>TIME</CODE>
<DD>
時間。範囲は<CODE>'-838:59:59'</CODE>〜<CODE>'838:59:59'</CODE>です。
MySQL は<CODE>TIME</CODE>値を<CODE>'HH:MM:SS'</CODE>という書式で表示しますが、<CODE>TIME</CODE>
フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。
 「<A HREF="manual.ja_Reference.html#TIME">6.2.2.3  <CODE>TIME</CODE> 型</A>」節参照.

<A NAME="IDX1021"></A>
<DT><CODE>YEAR[(2|4)]</CODE>
<DD>
年。2桁または4桁形式(デフォルトは4桁)。許される値は、4桁形式では 
<CODE>1901</CODE>〜<CODE>2155</CODE>, <CODE>0000</CODE> で、2桁形式(70〜69)では 1970〜2069 
です。<STRONG>MySQL</STRONG> は <CODE>YEAR</CODE> 値を <CODE>YYYY</CODE> 形式で表示しますが、
<CODE>YEAR</CODE> フィールドへの値の割り当ては文字列と数字のどちらでも使用できま
す。(<CODE>YEAR</CODE> は <STRONG>MySQL</STRONG> バージョン 3.22 での新しい型です。)
 「<A HREF="manual.ja_Reference.html#YEAR">6.2.2.4  <CODE>YEAR</CODE> 型</A>」節参照.

<A NAME="IDX1022"></A>
<A NAME="IDX1023"></A>
<A NAME="IDX1024"></A>
<A NAME="IDX1025"></A>
<DT><CODE>[NATIONAL] CHAR(M) [BINARY]</CODE>
<DD>
固定長文字列で、格納時には必ず指定された長さまで右側に空白を埋めます。
<CODE>M</CODE>の範囲は 1 から 255 文字です。後続の空白は値の取り出し時に削除され
ます。<CODE>BINARY</CODE> キーワードが与えられない場合、<CODE>CHAR</CODE> 値のソートと
比較は、デフォルト文字セットに従ってケース非依存の方法で行なわれます。

<CODE>NATIONAL CHAR</CODE> (短い形式は <CODE>NCHAR</CODE>) は、ANSI SQL で、CHAR フィー
ルドがデフォルト文字セットを使用することを定義する方法です。これは 
<STRONG>MySQL</STRONG> ではデフォルトです。

<CODE>CHAR</CODE> は <CODE>CHARACTER</CODE> の略記です。

<STRONG>MySQL</STRONG> は <CODE>CHAR(0)</CODE> 型のフィールドの生成を許します。これは主
に、実際にはもう値が使われていないフィールドが存在することに依存しているよ
うないくつかの古いアプリケーションに対応する必要がある時に便利です。２つの
値だけを取ることができるフィールドを必要とする時にもとても良いことです:
<CODE>NOT NULL</CODE> として定義されていない <CODE>CHAR(0)</CODE> は1ビットだけを占有
し、２つの値だけを取ることができます: <CODE>NULL</CODE> または <CODE>""</CODE>。
 「<A HREF="manual.ja_Reference.html#CHAR">6.2.3.1  <CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型</A>」節参照.

<A NAME="IDX1026"></A>
<A NAME="IDX1027"></A>
<DT><CODE>BIT</CODE>
<DD>
<DT><CODE>BOOL</CODE>
<DD>
<DT><CODE>CHAR</CODE>
<DD>
These three are synonyms for <CODE>CHAR(1)</CODE>.

<A NAME="IDX1028"></A>
<A NAME="IDX1029"></A>
<A NAME="IDX1030"></A>
<DT><CODE>[NATIONAL] VARCHAR(M) [BINARY]</CODE>
<DD>
可変長文字列。  注意:
後続の空白は格納時に削除されます(これは ANSI SQL 仕様と異なります)。
<CODE>M</CODE>の範囲は 1 から 255 文字です。
<CODE>BINARY</CODE> キーワードが与えられない場合、ソートと比較はケースに依存しません。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

<CODE>VARCHAR</CODE> は <CODE>CHARACTER VARYING</CODE> の略記です。
 「<A HREF="manual.ja_Reference.html#CHAR">6.2.3.1  <CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型</A>」節参照.

<A NAME="IDX1031"></A>
<A NAME="IDX1032"></A>
<DT><CODE>TINYBLOB</CODE>
<DD>
<DT><CODE>TINYTEXT</CODE>
<DD>
最大長 255 (2^8 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.  「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<A NAME="IDX1033"></A>
<A NAME="IDX1034"></A>
<DT><CODE>BLOB</CODE>
<DD>
<DT><CODE>TEXT</CODE>
<DD>
最大長 65535 (2^16 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.  「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<A NAME="IDX1035"></A>
<A NAME="IDX1036"></A>
<DT><CODE>MEDIUMBLOB</CODE>
<DD>
<DT><CODE>MEDIUMTEXT</CODE>
<DD>
最大長 16777215 (2^24 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.  「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<A NAME="IDX1037"></A>
<A NAME="IDX1038"></A>
<DT><CODE>LONGBLOB</CODE>
<DD>
<DT><CODE>LONGTEXT</CODE>
<DD>
最大長 4294967295 (2^32 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照。注意: サーバ／クライアントプロトコルと 
MyISAM テーブルは、通信パケット単位 / テーブルレコードで、現在 16M の制限
があるため、この型の範囲全体はまだ使用できません。 「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照。

<A NAME="IDX1039"></A>
<DT><CODE>ENUM('value1','value2',...)</CODE>
<DD>
列挙。
対象となる文字列は、値を一つだけ持ち、値リスト<CODE>'value1', 'value2',...</CODE>(又は
<CODE>NULL</CODE>)から選ばれます。<CODE>ENUM</CODE>は最大65535個の固有値を持つことができます
。  「<A HREF="manual.ja_Reference.html#ENUM">6.2.3.3  <CODE>ENUM</CODE> 型</A>」節参照.

<A NAME="IDX1040"></A>
<DT><CODE>SET('value1','value2',...)</CODE>
<DD>
組。
対象となる文字列は0以上の値を持ち、それぞれ値リスト<CODE>'value1', 'value2',...</CODE>
から選ばれなければなりません。
<CODE>SET</CODE>は、最大 64個の要素を持つことができます。 「<A HREF="manual.ja_Reference.html#SET">6.2.3.4  <CODE>SET</CODE> 型</A>」節参照.
</DL>



<H3><A NAME="Numeric_types" HREF="manual.ja_toc.html#Numeric_types">6.2.1  数値型</A></H3>

<P>
<STRONG>MySQL</STRONG> は ANSI/ISO SQL92 数値型をすべてサポートします。これらの型
は正確な数値データ型(<CODE>NUMERIC</CODE>, <CODE>DECIMAL</CODE>, <CODE>INTEGER</CODE>,
<CODE>SMALLINT</CODE>)、近似数値型(<CODE>FLOAT</CODE>, <CODE>REAL</CODE>, <CODE>DOUBLE
PRECISION</CODE>)を含みます。キーワード <CODE>INT</CODE> は <CODE>INTEGER</CODE> の同義語で、
<CODE>DEC</CODE>は <CODE>DECIMAL</CODE> の同義語です。

</P>
<P>
<STRONG>MySQL</STRONG> では <CODE>NUMERIC</CODE> と <CODE>DECIMAL</CODE> 型は、SQL92 標準で許
されているように同じ型として実装されています。これらは正確な精度を維持する
ことが重要な値(例えば金銭データ)に使用されます。これらの型の一つのフィール
ドを宣言する時、精度と大きさが指定できます(通常はそうします); 例えば:

</P>

<PRE>
    salary DECIMAL(9,2)
</PRE>

<P>
この例では、<CODE>9</CODE> (<CODE>precisoin</CODE>) は値を格納する重要な数値の桁数を表
します。そして <CODE>2</CODE> (<CODE>scale</CODE>) は小数点に続いて格納される桁数を表
します。従って、この場合 <CODE>salary</CODE> フィールドに格納することができる値
の範囲は、<CODE>-9999999.99</CODE> から <CODE>9999999.99</CODE> です。ANSI/ISO SQL92 
では、構文 <CODE>DECIMAL(p)</CODE> は <CODE>DECIMAL(p,0)</CODE> と等しいです。同様に、
構文 <CODE>DECIMAL</CODE> は <CODE>DECIMAL(p,0)</CODE> と等しいです。ここで <CODE>p</CODE> 
の値の決定は実装に許されてます。<CODE>DECIMAL</CODE>/<CODE>NUMERIC</CODE> データ型のこ
れらの異なる形式は、<STRONG>MySQL</STRONG> は現在サポートしていません。この型の主
な利益は精度と大きさの両方を明示的に制御する機能から引き出されるので、これ
は通常深刻な問題ではありません。

</P>
<P>
<CODE>DECIMAL</CODE> と <CODE>NUMERIC</CODE> 値は、値の小数の精度を維持するため、バイ
ナリ浮動小数点数としてではなく、文字列として格納されます。1文字は値のそれ
ぞれの桁(<CODE>scale</CODE> &#62; 0 の場合)と <SAMP>`-'</SAMP> 記号(負数の場合)に使用されま
す。<CODE>scale</CODE> が 0 の場合、<CODE>DECIMAL</CODE> と <CODE>NUMERIC</CODE> 値は小数点
と小数部を含みません。

</P>
<P>
<CODE>DECIMAL</CODE> と <CODE>NUMERIC</CODE> 値の最大範囲は <CODE>DOUBLE</CODE> と同じです。
しかし <CODE>DECIMAL</CODE> や <CODE>NUMERIC</CODE> フィールドに与えられる実際の範囲は
フィールドに与えられた <CODE>precision</CODE> と <CODE>scale</CODE> によって強制されま
す。このフィールドに、指定された <CODE>scale</CODE> で許されるよりも多い桁の小数
部を持つ数値が割り当てられた場合、値はその <CODE>scale</CODE> に丸められます。
<CODE>DECIMAL</CODE> や <CODE>NUMERIC</CODE> フィールドに、指定された(またはデフォルト
の) <CODE>precision</CODE> と <CODE>scale</CODE> で示された範囲を超えた大きさの値を割
り当てた時、<STRONG>MySQL</STRONG> はその範囲の対応する最大値を表す値を格納します。

</P>
<P>
ANSI/ISO SQL92 標準に対する拡張として、上の表にリストしたように、
<STRONG>MySQL</STRONG> は整数型 <CODE>TINYINT</CODE>, <CODE>MEDIUMINT</CODE>, <CODE>BIGINT</CODE> も
サポートします。<STRONG>MySQL</STRONG> によってサポートされる他の拡張として、オプ
ションで、型の基本キーワードに続けて括弧内に指定する整数値の表示幅(例えば 
<CODE>INT(4)</CODE>)があります。このオプションの幅指定は、フィールドに指定された
幅よりも少ない幅の値の表示の左側を埋めるために使用されます。しかしフィール
ドに格納することができる値の範囲や、フィールドに指定された幅を超える幅の値
について表示される桁数は制約されません。オプションの拡張属性 
<CODE>ZEROFILL</CODE> を指定して使用された場合、デフォルトの埋められる空白は 0 
で置き換えられます。例えば、<CODE>INT(5) ZEROFILL</CODE> として宣言されたフィー
ルドでは、値 <CODE>4</CODE> は <CODE>0004</CODE> として取り出されます。注意: 整数フィー
ルド内に表示幅よりも大きい値を格納する場合、<STRONG>MySQL</STRONG> が複雑な join 
のために一時テーブルを生成する時に、問題を体験するでしょう。この場合 
<STRONG>MySQL</STRONG> はデータがオリジナルのフィールド幅に合っていることを信用す
るためです。

</P>
<P>
すべての整数型はオプションの(非標準)属性 <CODE>UNSIGNED</CODE> を持つことができ
ます。符合無しの値はフィールド内に正の数だけを許可したくて、フィールドに対
して少し大きい数値の範囲が必要な時に使用できます。

</P>
<P>
<CODE>FLOAT</CODE> 型は近似数データ型を表すために使用されます。ANSI/ISO SQL92 標
準は、<CODE>FLOAT</CODE> キーワードに続く括弧中にオプションの精度(指数の範囲では
ない)の指定を許しています。<STRONG>MySQL</STRONG> 実装はこのオプションの精度指定も
サポートしています。キーワード <CODE>FLOAT</CODE> が精度の指定無しでフィールド型
として使用された時は、<STRONG>MySQL</STRONG> は値を格納するために4バイトを使用しま
す。<CODE>FLOAT</CODE> キーワードに続く括弧中に2つの数値を与える構文もサポートさ
れます。このオプションでの、最初の数値は値に必要な容量をバイトで表します。
2番目の数値は、格納、表示される小数部の桁数を指定します(<CODE>DECIMAL</CODE> と 
<CODE>NUMERIC</CODE> と同様)。<STRONG>MySQL</STRONG> がフィールドに指定されたよりも大き
い小数部の桁数を持つ数値をこのフィールドに格納する時、値の格納時に余計な桁
を取り除くように値が丸められます。

</P>
<P>
<CODE>REAL</CODE> と <CODE>DOUBLE PRECISION</CODE> 型は精度指定を許しません。
ANSI/ISO SQL92 標準に対する拡張として、<STRONG>MySQL</STRONG> は <CODE>DOUBLE</CODE> を 
<CODE>DOUBLE PRECISION</CODE> 型の同義語として認識します。<CODE>REAL</CODE> の精度は 
<CODE>DOUBLE PRECISION</CODE> の指定よりも小さいことを要求する標準と異なり、
<STRONG>MySQL</STRONG> はどちらも8バイトの倍精度小数点の値として実装しています
(非"ANSI モード"で実行した場合)。移植性を最大にするためには、近似数値
データ値の格納を要求するコードは、精度や小数部桁数の指定無しの 
<CODE>FLOAT</CODE> か <CODE>DOUBLE PRECISION</CODE> を使用すべきです。

</P>
<P>
フィールドの型の値の許容範囲を超えた数値を代入しようとすると、<STRONG>MySQL</STRONG> は
その値を許容範囲いっぱいに切り詰め、その結果を代わりに代入します。

</P>
<P>
例えば、 <CODE>INT</CODE> フィールドの範囲は <CODE>-2147483648</CODE> から <CODE>2147483647</CODE>
 です。
もし <CODE>-9999999999</CODE> を <CODE>INT</CODE> フィールドに挿入しようとすると、値は範囲の
最低値に修正され、 <CODE>-2147483648</CODE> が代わりに代入されます。同様に、
<CODE>9999999999</CODE> の場合、 <CODE>2147483647</CODE> が代わりに代入されます。

</P>
<P>
そして、<CODE>INT</CODE> フィールドが符号無しの場合、フィールドの範囲の大きさは
同じですが、限界値は <CODE>0</CODE> と<CODE>4294967296</CODE> になります。
もし <CODE>-9999999999</CODE> と <CODE>9999999999</CODE> を代入しようとすると、
値は <CODE>0</CODE> と <CODE>4294967296</CODE> として代入されます。

</P>
<P>
<CODE>ALTER TABLE</CODE>, <CODE>LOAD DATA INFILE</CODE>, <CODE>UPDATE</CODE> または
 multi-row <CODE>INSERT</CODE> 時、これらの変換は `警告' として得られます。

</P>



<H3><A NAME="Date_and_time_types" HREF="manual.ja_toc.html#Date_and_time_types">6.2.2  日付と時間の型</A></H3>

<P>
<A NAME="IDX1041"></A>
<A NAME="IDX1042"></A>

</P>

<P>
日付と時間の型は <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE>,
<CODE>TIME</CODE>, <CODE>YEAR</CODE> です.  これらはそれぞれ値に適正な範囲があり、
``zero'' はあなたが間違った値を指定した場合に用いられます。注意: MySQL は
確実に '厳密でない' 正しい日付の値、例えば <CODE>1999-11-31</CODE> を格納するこ
とができます。この理由は、日付をチェックする処理の責任はアプリケーションに
あり、SQL サーバにはないと考えているからです。日付を'速く'チェックするため
に、<STRONG>MySQL</STRONG> は月が 0〜12 の範囲であるかと日が 0〜31 の範囲であるか
だけをチェックします。上述の範囲は、<STRONG>MySQL</STRONG> が <CODE>DATE</CODE> または 
<CODE>DATETIME</CODE> フィールドに、日または月日が 0 である日付を格納できるため
に定義されています。これは、正確な日付を知らない誕生日を登録する必要がある
アプリケーションに非常に有用です。この場合、<CODE>1999-00-00</CODE> や 
<CODE>1999-01-00</CODE> のような日付を単純に登録できます(もちろん、このような日
付を <CODE>DATE_SUB()</CODE> や <CODE>DATE_ADD</CODE> のような関数で使用して、正しい値
が返ることは期待できません)。

</P>
<P>
これは、日付と時間型で作業する場合に、一般的に考慮しなければならないことです:

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG>は、標準形式で与えられた日付や時間から値を抽出しますが、与えられた
多様な形式の値(例えば、指定された値を日付や時間型に割り当てたり、比較したり)を解
釈しようと試みます。
それでも、次節で述べる形式だけがサポートされます。
それは、正当な値が与えられることを期待し、他の形式の値を使用されるような事態が起
こると、どのような結果となるか予想できません。

<LI>

<STRONG>MySQL</STRONG> はいくつかの形式に値を変えてくれますが、
常に年の部分と日にちの部分は左から与えられていると期待しています。
日付は 年-月-日 の順(例えば、<CODE>'98-09-04'</CODE>)でなくてはなりません。
月-日-年 や 日-月-年 の様などこでも使われているような形であってはなりません。
(例えば、<CODE>'09-04-98'</CODE>や<CODE>'04-09-98'</CODE>).

<LI>

<STRONG>MySQL</STRONG> は、もし数値の文脈で日付と時間の型が使用されると、
自動的に日付と時間を数値に直します。逆も行います。

<LI>

<STRONG>MySQL</STRONG> が範囲外の誤った値を日付と時間型として受け取った場合
(このセクションの最初をみてください)、その値は ``ゼロ'' に変換されます。
(例外は、範囲外の<CODE>TIME</CODE>値が適切な<CODE>TIME</CODE>の範囲の限界値に切り詰められる
ことです。)
以下に、それぞれの型の `ゼロ' の形式を示します：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>`ゼロ'値</STRONG>
</TR NOSAVE>
<TR><TD><CODE>DATETIME</CODE> </TD><TD> <CODE>'0000-00-00 00:00:00'</CODE>
</TR NOSAVE>
<TR><TD><CODE>DATE</CODE> </TD><TD> <CODE>'0000-00-00'</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP</CODE> </TD><TD> <CODE>00000000000000</CODE> (長さは表示サイズに依存し
ます)
</TR NOSAVE>
<TR><TD><CODE>TIME</CODE> </TD><TD> <CODE>'00:00:00'</CODE>
</TR NOSAVE>
<TR><TD><CODE>YEAR</CODE> </TD><TD> <CODE>0000</CODE>
</TR>
</TABLE>

<LI>

`ゼロ'値は特別ですが、表に示された値を明示的に使用して、格納したり参照したりでき
ます。
この値は、 <CODE>'0'</CODE> 又は <CODE>0</CODE> を使用することにより、より簡潔に書くこともで
きます。

<LI>

<STRONG>MyODBC</STRONG> 内で使用されている `ゼロ' の日付と時間は、
<STRONG>MyODBC</STRONG> 2.50.12 以上では自動的に <CODE>NULL</CODE> に変換されます。
これは ODBC がこれらの値を扱えないからです。
</UL>



<H4><A NAME="Y2K_issues" HREF="manual.ja_toc.html#Y2K_issues">6.2.2.1  西暦２０００年問題とデータ型</A></H4>

<P>
<A NAME="IDX1043"></A>
<A NAME="IDX1044"></A>

</P>
<P>
<STRONG>MySQL</STRONG> 自体は2000年問題に対して安全です( 「<A HREF="manual.ja_Introduction.html#Year_2000_compliance">1.1.9  2000 年対応</A>」節参照)が、
 <STRONG>MySQL</STRONG> に提示される入力値に関してはそうではありません。2桁の
年の入力は何世紀なのかわからないので全て曖昧です。このような値は <STRONG>MySQL</STRONG>
が内部で年に4桁を使っていることから4桁の形式に変換されてしまいます。

</P>
<P>
 <STRONG>MySQL</STRONG> は曖昧な日付を <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 
および <CODE>YEAR</CODE> 型に関して、以下の
ルールに従って解釈します。

</P>

<UL>
<LI>

<CODE>00-69</CODE> の範囲の年は <CODE>2000-2069</CODE> に変換。

<LI>

<CODE>70-99</CODE> の範囲の年は <CODE>1970-1999</CODE> に変換。
</UL>

<P>
これらのルールはデータが何を意味しているかに対して妥当な推定を与えるに
過ぎないことに注意してください。この <STRONG>MySQL</STRONG> 発見的手法が正しい値を生成し
ない場合は曖昧でない4桁の年を含む入力を与えるべきです。

</P>
<P>
<CODE>ORDER BY</CODE> は2桁の <CODE>YEAR/DATE/DATETIME</CODE> 型を正しくソートされます。

</P>
<P>
注意: <CODE>MIN()</CODE> と <CODE>MAX()</CODE> のようないくつかの関数は <CODE>TIMESTAMP/DATE</CODE>
を数値に変換します。これは年が2桁のタイムスタンプはこれらの関数で正しく動作しな
いことを意味します。この場合の修復は、<CODE>TIMESTAMP/DATE</CODE> を4桁の年の形
式に変換するか、<CODE>MIN(DATE_ADD(timestamp,INTERVAL 0 DAYS))</CODE> のような何
かを使用することです。

</P>



<H4><A NAME="DATETIME" HREF="manual.ja_toc.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A></H4>

<P>
<A NAME="IDX1045"></A>
<A NAME="IDX1046"></A>
<A NAME="IDX1047"></A>

</P>
<P>
<CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE>型はお互いに関連しています。このセ
クションではそれらの特徴と、それぞれがどう同じでどう違うかを示します。

</P>
<P>
<CODE>DATETIME</CODE> 型は日付と時刻の情報を含む値が必要な場合に使います。MySQL は
<CODE>DATETIME</CODE> 値を <CODE>'YYYY-MM-DD HH:MM:SS'</CODE> のフォーマットで取り出し、
表示します。
サポートされる範囲は <CODE>'1000-01-01 00:00:00'</CODE> から <CODE>'9999-12-31 23:59:59'</CODE> です。
(「サポートされる」とはさらに過去の値でも動くかも知れませんが保証の限りではない
という意味です)

</P>
<P>
<CODE>DATE</CODE> 型は時刻の部分なしで日付の値のみが必要な場合に使います。MySQL は
 <CODE>DATE</CODE> 値を<CODE>'YYYY-MM-DD'</CODE> のフォーマットで取り出し、表示します。サポ
ートされる範囲は <CODE>'1000-01-01'</CODE> から <CODE>'9999-12-31'</CODE> です。

</P>
<P>
<CODE>TIMESTAMP</CODE> タイプは <CODE>INSERT</CODE> や <CODE>UPDATE</CODE> 操作に自動的に
現在の日付と時刻をマークする場合に提供される型です。
もし複数の <CODE>TIMESTAMP</CODE> フィールドがある場合には最初
の一つだけが自動的に更新されます。

</P>
<P>
最初の <CODE>TIMESTAMP</CODE> フィールドの自動更新は以下のいずれかの条件で起こります：

</P>

<UL>
<LI>

そのフィールドが明示的に <CODE>INSERT</CODE> または <CODE>LOAD DATA INFILE</CODE> 文で指定さ
れていないとき。
<LI>

そのフィールドが明示的に <CODE>UPDATE</CODE> 文で指定されず、かつ、他のフィールドの値
が変わった場合。
(もともとフィールドに入っていた値と同じ値に更新しようとする <CODE>UPDATE</CODE> 文は
<CODE>TIMESTAMP</CODE> フィールドを更新しないことに注意。なぜならあるフィールドを現在
と同じ値に変えようとしても <STRONG>MySQL</STRONG> は効率のためにそれを無視するからです。)
<LI>

明示的に <CODE>TIMESTAMP</CODE> フィールドを <CODE>NULL</CODE> にした場合。
</UL>

<P>
最初以外の <CODE>TIMESTAMP</CODE> フィールドも現在の日付と時刻にすることができます。そ
れらのフィールドを<CODE>NULL</CODE> または <CODE>NOW()</CODE> にすることです。

</P>
<P>
どの <CODE>TIMESTAMP</CODE> フィールドも明示的に望む値をセットすることで現在の日時でな
い値にすることができます。それは最初の <CODE>TIMESTAMP</CODE> フィールドについても同じ
です。この特性は例えば <CODE>TIMESTAMP</CODE> フィールドをあるレコードが生成された時の
日時にし、その後その行が更新されても変化しないようにしたいというようなときに使え
ます。

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> にレコードが生成されたときにそのフィールドをセットさせる。これで
現在日時に初期化される。

<LI>

以降の他のフィールドに対する更新時に <CODE>TIMESTAMP</CODE> フィールドをそれ自体が今持
っている値に明示的に更新する。
</UL>

<P>
一方、この手法は <CODE>DATATIME</CODE> フィールドを行生成時に <CODE>NOW()</CODE> で初期化し
、以降の更新時に
それをほうっておくのと同じように簡単であるとわかるでしょう。

</P>
<P>
<CODE>TIMESTAMP</CODE> の値は <CODE>1970</CODE> 年の最初から <CODE>2037</CODE> 年のどこかの時点ま
での範囲で有効で、
1秒の時間分解能を持ちます。値は数値として表示されます。

</P>
<P>
<STRONG>MySQL</STRONG> が <CODE>TIMESTAMP</CODE> 値を取り出したり表示するのに使うフォーマット
は以下の表
に示すようにその表示サイズに依存します。「目一杯の」 <CODE>TIMESTAMP</CODE> フォーマッ
トは14桁ですが、 <CODE>TIMESTAMP</CODE> フィールドはより短い表示サイズで生成することも
できます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールド型</STRONG> </TD><TD> <STRONG>表示フォーマット</STRONG>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(14)</CODE> </TD><TD> <CODE>YYYYMMDDHHMMSS</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(12)</CODE> </TD><TD> <CODE>YYMMDDHHMMSS</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(10)</CODE> </TD><TD> <CODE>YYMMDDHHMM</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(8)</CODE> </TD><TD> <CODE>YYYYMMDD</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(6)</CODE> </TD><TD> <CODE>YYMMDD</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(4)</CODE> </TD><TD> <CODE>YYMM</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(2)</CODE> </TD><TD> <CODE>YY</CODE>
</TR>
</TABLE>

<P>
全ての <CODE>TIMESTAMP</CODE> フィールドは表示サイズに関係なく同じ格納サイズを持ちます。
もっとも一般的な表示サイズは 6 , 8 , 12 および 14 です。表示サイズはテーブル生成
時に任意の値に指定できますが、 0 および 14 以上の値は強制的に 14 になります。1
から 13 までの奇数のサイズは強制的に一つ大きい偶数になります。

</P>
<P>
<CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 値は以下の共通フォーマットセット
のいずれかを使って指定できます：

</P>

<UL>
<LI>

文字列で <CODE>'YYYY-MM-DD HH:MM:SS'</CODE> か <CODE>'YY-MM-DD HH:MM:SS'</CODE> の形式。
"柔軟な"書き方を許しています -- 日付や時刻の区切り文字として、いかなる句読記号
も使用できます。例えば、<CODE>'98-12-31 11:30:45'</CODE>, <CODE>'98.12.31 11+30+45'</CODE>,
<CODE>'98/12/31 11*30*45'</CODE>, <CODE>'98@12@31 11^30^45'</CODE> は等価です。

<LI>

文字列で <CODE>'YYYY-MM-DD'</CODE> か <CODE>'YY-MM-DD'</CODE> の形式。
これも"柔軟な"書き方ができます。
例えば, <CODE>'98-12-31'</CODE>,<CODE>'98.12.31'</CODE>, <CODE>'98/12/31'</CODE>,
 <CODE>'98@12@31'</CODE> は
等価です。

<LI>

文字列 <CODE>'YYYYMMDDHHMMSS'</CODE> または <CODE>'YYMMDDHHMMSS'</CODE> フォーマット。
「緩やかな」文法が認められていて、句読記号は日付、時刻部分の区切り
として使えます。例えば <CODE>'98-12-31 11:30:45'</CODE>,  <CODE>'98.12.31 11+30+45'</CODE>,
 <CODE>'98/12/31 11*:30*:45'</CODE>,  <CODE>'98@12@31 11^30^45'</CODE> は全て等価です。

<LI>

文字列 <CODE>'YYYY-MM-DD'</CODE> または <CODE>'YY-MM-DD'</CODE> フォーマット。
これも「緩やかな」文法が認められています。例えば <CODE>'98-12-31'</CODE>,
<CODE>'98.12.31'</CODE>,  <CODE>'98/12/31'</CODE>, <CODE>'98@12@31'</CODE>は全て等価です。

<LI>

区切り文字なしの文字列 <CODE>'YYYYMMDDHHMMSS'</CODE> または <CODE>'YYMMDDHHMMSS'</CODE> フォ
ーマットで日時として意味のあるもの。
例えば <CODE>'19970523091528'</CODE> および <CODE>'970523091528'</CODE> は
<CODE>'1997-05-23 09:15:28'</CODE> と解釈されます。しかし <CODE>'971122129015'</CODE> は無効で
(時と分の部分がおかしい)、 <CODE>'0000-00-00 00:00:00'</CODE> になります。

<LI>

区切り文字なしの文字列 <CODE>'YYYYMMDD'</CODE> または <CODE>'YYMMDD'</CODE> フォーマットで、
日付として意味のあるもの。
例えば <CODE>'19970523'</CODE> および <CODE>'970523'</CODE> は <CODE>'1997-05-23'</CODE> と解釈
されます。
しかし <CODE>'971332'</CODE> は無効で(月と日の部分がおかしい)、 <CODE>'0000-00-00'</CODE> 
になります。

<LI>

 <CODE>YYYYMMDDHHMMSS</CODE> または <CODE>YYMMDDHHMMSS</CODE> のフォーマットの数値で、日時と
して意味のあるもの。例えば <CODE>19830905132800</CODE> および <CODE>830905132800</CODE> は
 <CODE>'1983-09-05 13:28:00'</CODE> と解釈されます。

<LI>

 <CODE>YYYYMMDD</CODE> または <CODE>YYMDD</CODE> のフォーマットの数値で日付として意味のある
もの。
例えば <CODE>19830905</CODE> および <CODE>830905</CODE> は <CODE>'1983-09-05'</CODE> として解釈さ
れます。

<LI>

 <CODE>NOW()</CODE> や <CODE>CURRENT_DATE</CODE> のように
 <CODE>DATETIME</CODE> , <CODE>DATE</CODE> , <CODE>TIMESTAMP</CODE> のコンテキストで
アクセス可能な値を返す関数の結果。
</UL>

<P>
無効な <CODE>DATETIME</CODE> , <CODE>DATE</CODE> , <CODE>TIMESTAMP</CODE> の値は適切な「ゼロ」値に
変換されます(<CODE>'0000-00-00 00:00:00'</CODE> , <CODE>'0000-00-00'</CODE> または <CODE>00000000000000</CODE> )。

</P>
<P>
日時の部分に区切りを持つ文字列で指定される値で、月、日の値が10未満の場
合は2桁で指定しなくてもかまいません。 <CODE>'1979-6-9'</CODE> は <CODE>'1979-06-09'</CODE> 
と等価です。同様に時刻の部分に区切りを持つ文字列で指定される値で、時、分、秒が
 <CODE>10</CODE> 未満の場合は2桁で指定しなくてもかまいません。
 <CODE>'1979-10-30 1:2:3'</CODE> は <CODE>'1979-10-30 01:02:03'</CODE> と等価です。

</P>
<P>
数値でしていされる値は 6, 8, 12 または 14 桁である必要があります。もしその数
値が 8 または 14 桁の長さの時はそれぞれ <CODE>YYYYMMDD</CODE> および
<CODE>YYYYMMDDHHMMSS</CODE> フォーマットで、最初の 4 桁で年が与えられるものと仮定
されます。もしその数値が 6または12桁の長さの時は <CODE>YYMMDD</CODE> および
<CODE>YYMMDDHHMMSS</CODE> フォーマットで最初の2桁で年が与えられるものと仮定されます。
これら以外の長さの数値はあとに <CODE>0</CODE> が追加されてこれらのうちのもっとも近い
長さのものと解釈されます。

</P>
<P>
<A NAME="IDX1048"></A>
<A NAME="IDX1049"></A>
区切りなしの文字列で与えられる値はそれ自身の長さを使って解釈されます。
もし文字列が8または14文字ならば年は最初の4文字で与えられると仮定されま
す。そうでなければ最初の2文字で与えられると仮定されます。文字列は左か
ら右に年、月、日、時、分、秒と文字列中に表現されている分だけ順に解釈さ
れます。つまり6文字以下の文字列は使ってはいけないということです。例え
ば1999年3月を指定するつもりで <CODE>'9903'</CODE> を指定した場合、MySQL は「ゼロ」日付
をテーブルに挿入します。これは年と月の部分は <CODE>99</CODE> と <CODE>03</CODE> ですが日の部
分が欠けている(ゼロ)ために値が有効な日付でないために起こります。

</P>
<P>
<CODE>TIMESTAMP</CODE> フィールドは有効な値を、表示サイズに関係なく指定された値を最高
精度の時間分解能で格納します。このことはいくつかの意味合いを持ちます。

</P>
<P>
年の値が二桁で指定された場合、世紀の部分がないので曖昧な値となります。
<STRONG>MySQL</STRONG> は二桁の年の値を以下に示す規則にそって変換します：

</P>

<UL>
<LI>

列の型がTIMESTAMP(4)であってもTIMESTAMP(2)であっても常に年月日を指定
すること。そうでなければ値は無効で0が格納されます。

<LI>

もし短い形式の <CODE>TIMESTAMP</CODE> を <CODE>ALTER TABLE</CODE> を使って拡張しようとした場
合、拡張前には「隠れていた」情報が現れます。

<LI>

同様に <CODE>TIMESTAMP</CODE> フィールドを縮めた場合も、値が表示された時により少ない情
報しか現れないという点を除いて、情報は失われません。

<LI>

 <CODE>TIMESTAMP</CODE> 値は最高精度の時間分解能で格納されますが、内部的に格納され
た値を直接操作できる関数は <CODE>UNIX_TIMESTAMP()</CODE> のみです。他の関数はフォーマ
ットされて取り出された値について操作します。つまり、 <CODE>HOUR()</CODE> や
<CODE>SECOND()</CODE> などの関数は <CODE>TIMESTAMP</CODE> 値の対応する部分がフォーマットされた
値で含まれないと使うことができません。例えば <CODE>TIMESTAMP</CODE> 列の <CODE>HH</CODE> の部分は
表示サイズが少なくとも10以上ないと表示されないので、それより短い <CODE>TIMESTAMP</CODE> 値
に <CODE>HOUR()</CODE> の操作を行っても無意味な値しか得られません。
</UL>

<P>
ある日付型を他の日付型のオブジェクトに拡張して指定することができます。
しかしそれは値の変化や情報の欠落を起こす可能性があります。

</P>

<UL>
<LI>

<CODE>DATE</CODE> の値を <CODE>DATETIME</CODE> か <CODE>TIMESTAMP</CODE> の物に与えた場合、
時刻の部分は <CODE>'00:00:00'</CODE> になります。これは <CODE>DATE</CODE> 値が
時刻の情報を持っていないからです。

<LI>

<CODE>DATETIME</CODE> か <CODE>TIMESTAMP</CODE> の値を <CODE>DATE</CODE> の物に与えた場合、
時刻の部分は削られます。これは <CODE>DATE</CODE> 値が
時刻の情報を持っていないからです。

<LI>

 <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 値は同じフォーマットのセットを使
って表現できますが、どの型も同じ値の範囲を持っているわけではないことを覚えておい
てください。例えば <CODE>TIMESTAMP</CODE> 値は <CODE>1970</CODE> 年より前や <CODE>2037</CODE> 年よ
り後の値にはできません。つまり <CODE>'1968-01-01'</CODE> という値は <CODE>DATETIME</CODE> や
<CODE>DATE</CODE> の値としては有効ですが <CODE>TIMESTAMP</CODE> の値としては無効で、
そのようなオブジェクトを指定した場合は <CODE>0</CODE> に変換されます。
</UL>

<P>
<A NAME="IDX1050"></A>
<A NAME="IDX1051"></A>
日付の値を指定するときの落とし穴に注意してください

</P>

<UL>
<LI>

文字列として指定される値の柔軟なフォーマットに騙されないよう。例え
ば <CODE>'10:11:12'</CODE> は <SAMP>`':''</SAMP> を区切り文字とする時刻のように見えますが、日
付のコンテキストで使われるとこれは <CODE>'2010-11-12'</CODE> と解釈されます。
<CODE>'10:45:15'</CODE> は <CODE>'45'</CODE> が有効な月ではないので <CODE>'0000-00-00'</CODE> に
変換されます。

<LI>

2桁で表される年は世紀の部分が不明なので曖昧です。 <STRONG>MySQL</STRONG> は以下のルール
で2桁の年を解釈します。


<UL>
<LI>

<CODE>00-69</CODE> の範囲にある年の値は <CODE>2000-2069</CODE> 年とする。

<LI>

<CODE>70-99</CODE> の範囲にある年の値は <CODE>1970-1999</CODE> 年とする。
</UL>

</UL>



<H4><A NAME="TIME" HREF="manual.ja_toc.html#TIME">6.2.2.3  <CODE>TIME</CODE> 型</A></H4>

<P>
<A NAME="IDX1052"></A>

</P>
<P>
<STRONG>MySQL</STRONG> は <CODE>TIME</CODE> の値を <CODE>'HH:MM:SS'</CODE>
 (時の部分が大きい場合は <CODE>'HHH:MM:SS'</CODE>)
というフォーマットで扱い、また表示します。
(時の部分が大きい場合は <CODE>'HHH:MM:SS'</CODE>)。
<CODE>TIME</CODE> 値の範囲は <CODE>'-838:59:59'</CODE> から <CODE>'838:59:59'</CODE> の範囲です。
時の部分がこんなに大きいのは、<CODE>TIME</CODE> 型は一日すなわち24時間以内
の時刻を表現するのに用いられるだけではなく経過時間や二つの事象の間隔
(どちらも２４時間を越えたり、負の数になる場合もあります)を表現すること
もあるからです。

</P>
<P>
<CODE>TIME</CODE> 値は様々なフォーマットで指定可能です：

</P>

<UL>
<LI>

文字列で <CODE>'D HH:MM:SS.fraction'</CODE> というフォーマット。
(<STRONG>MySQL</STRONG>はまだこの fraction を time フィールドに保存できません)。
以下の ``柔軟な'' 文法が使用できます：

<CODE>HH:MM:SS.fraction</CODE>, <CODE>HH:MM:SS</CODE>, <CODE>HH:MM</CODE>, <CODE>D HH:MM:SS</CODE>,
<CODE>D HH:MM</CODE>, <CODE>D HH</CODE> または <CODE>SS</CODE>。
ここで、<CODE>D</CODE> は 0〜33 の間の日です。

<LI>

文字列で <CODE>'HHMMSS'</CODE> というように区切りのないフォーマットで時刻として有効
なもの。例えば <CODE>'101112'</CODE> は <CODE>'10:11:12'</CODE> と解釈されますが <CODE>'1097
12'</CODE> は無効で(分の部分が無意味) <CODE>'00:00:00'</CODE> になります。

<LI>

数値で <CODE>HHMMSS</CODE> のフォーマットで時刻として有効なもの。
例えば <CODE>101112</CODE> は <CODE>'10:11:12'</CODE> と解釈されます。
次の別の形式も解釈できます: <CODE>SS</CODE>, <CODE>MMSS</CODE>,<CODE>HHMMSS</CODE>,
<CODE>HHMMSS.fraction</CODE>。注意: <STRONG>MySQL</STRONG> はまだ fraction 部を保存でき
ません。

<LI>

例えば <CODE>CURRENT_TIME</CODE> のように <CODE>TIME</CODE> のコンテキストで受け付けられる値
を返す関数の結果。
</UL>

<P>
文字列で時刻の各部の区切りを含む <CODE>TIME</CODE> の値については、時、分、秒が
<CODE>10</CODE> 以下の場合、２桁の数字を指定する必要はありません。<CODE>'8:3:2'</CODE> は
<CODE>'08:03:02'</CODE> と同じです。

</P>
<P>
「短い」 <CODE>TIME</CODE> 値を <CODE>TIME</CODE> フィールドとして指定する場合は要注意です。
コロンなしでは、<STRONG>MySQL</STRONG> はその値のもっとも右端の桁は秒を表すと仮定して解
釈します。
(<STRONG>MySQL</STRONG> は <CODE>TIME</CODE> の値を一日のうちの時刻としてより経過時間として
解釈します)。例えば <CODE>'11:12'</CODE>,<CODE>'1112'</CODE>, <CODE>1112</CODE> が
<CODE>'11:12:00'</CODE> (11時12分)を表しているつもりでいても、
<STRONG>MySQL</STRONG> はこれらを <CODE>'00:11:12'</CODE> (11分12秒)として解釈します。
同様に <CODE>'12'</CODE> および <CODE>12</CODE> は <CODE>'00:00:12'</CODE> と解釈します。

</P>
<P>
<CODE>TIME</CODE> の範囲外にある値で値以外は正しいものは範囲の端の値の適当な方にクリッ
プされます。例えば <CODE>'-850:00:00'</CODE> および <CODE>'850:00:00'</CODE> は
それぞれ <CODE>'-838:59:59'</CODE> および <CODE>'838:59:59'</CODE> になります。

</P>
<P>
無効な <CODE>TIME</CODE> 値は <CODE>'00:00:00'</CODE> に変換されます。
ここで <CODE>'00:00:00'</CODE> 自体は有効な <CODE>TIME</CODE> 値なので、
テーブル内に保存された'00:00:00'という値からそれがもとも
と <CODE>'00:00:00'</CODE> と指定された値なのか無効なために変換された結果なのかを区
別する方法はないことに注意してください。

</P>



<H4><A NAME="YEAR" HREF="manual.ja_toc.html#YEAR">6.2.2.4  <CODE>YEAR</CODE> 型</A></H4>

<P>
<A NAME="IDX1053"></A>

</P>
<P>
<CODE>YEAR</CODE> 型は年を表現するのに使われる1バイトの値です。

</P>
<P>
<STRONG>MySQL</STRONG> は <CODE>YEAR</CODE> の値を <CODE>YYYY</CODE> というフォーマットで扱い、
また表示します。範囲は <CODE>1901</CODE> から <CODE>2155</CODE> です。

</P>
<P>
<CODE>YEAR</CODE> 型は様々なフォーマットで指定可能です：

</P>

<UL>
<LI>

<CODE>'1901'</CODE> から <CODE>'2155'</CODE> の範囲にある4桁の文字列

<LI>

<CODE>1901</CODE> から <CODE>2155</CODE> の範囲にある4桁の数値。

<LI>

<CODE>'00'</CODE> から <CODE>'99'</CODE> の範囲にある2桁の文字列。
<CODE>'00'</CODE> から <CODE>'69'</CODE> までおよび <CODE>'70'</CODE> から
<CODE>'99'</CODE> までの範囲はそれぞれ <CODE>2000</CODE> から <CODE>2069</CODE> まで
および <CODE>1970</CODE> から <CODE>1999</CODE> までの範囲の
YEAR型に変換されます。

<LI>

<CODE>1</CODE> から <CODE>99</CODE> の範囲にある2桁の数値。<CODE>1</CODE> から <CODE>69</CODE> まで
および <CODE>70</CODE> から <CODE>99</CODE> までの範囲は
それぞれ <CODE>2001</CODE> から <CODE>2069</CODE> までおよび <CODE>1970</CODE> から <CODE>1999</CODE> まで
の範囲の <CODE>YEAR</CODE> 型に変換されます。
2桁の数値の場合は2桁の文字列の場合と若干異なっている点に注意してください。
なぜなら0を数値として指定し、それを2000年として解釈させることができないからです。
その場合は文字列で <CODE>'0'</CODE> または <CODE>'00'</CODE> を<EM>指定しなければ
なりません</EM>。そうでなければ数値0は無効なYEAR値を示す <CODE>0000</CODE> に変換されます。

<LI>

例えば <CODE>NOW()</CODE> のように <CODE>YEAR</CODE> コンテキストで受け入れられる値を返す関
数の結果。
</UL>

<P>
無効な <CODE>YEAR</CODE> 値は <CODE>0000</CODE> に変換されます。

</P>



<H3><A NAME="String_types" HREF="manual.ja_toc.html#String_types">6.2.3  文字列型</A></H3>

<P>
<A NAME="IDX1054"></A>
<A NAME="IDX1055"></A>

</P>
<P>
<A NAME="IDX1056"></A>
<A NAME="IDX1057"></A>

</P>

<P>
文字列型は<CODE>CHAR</CODE>, <CODE>VARCHAR</CODE>, <CODE>BLOB</CODE>, <CODE>TEXT</CODE>,
<CODE>ENUM</CODE>, <CODE>SET</CODE> です。このセクションは、それらの型がどのように動作
するかと、要求されるサイズと、クエリ内での使用方法を説明します。

</P>



<H4><A NAME="CHAR" HREF="manual.ja_toc.html#CHAR">6.2.3.1  <CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型</A></H4>

<P>
<CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型はよく似ていますが格納、取り出しの手順に違いが
あります。

</P>
<P>
<CODE>CHAR</CODE> フィールドの長さはテーブルを生成するときに宣言した長さに固定されます。
長さは 1 から 255 までの値を取ります。<CODE>CHAR</CODE> が格納されるときには指定された
長さになるように右側に空白が詰められます。<CODE>CHAR</CODE> の値が取り出された場合には
右側(後続)の空白は取り除かれます。

</P>
<P>
<CODE>VARCHAR</CODE> フィールドの値は可変長文字列です。
<CODE>VARCHAR</CODE> フィールドは <CODE>CHAR</CODE> フィールド
と同じく 1 から 255 までの長さに宣言できます。
(<STRONG>MySQL</STRONG> バージョン 3.23 では, <CODE>CHAR</CODE> の長さは 0 から 255 まで許され
ています.)
しかし <CODE>CHAR</CODE> 型と異なり <CODE>VARCHAR</CODE> 型の値は必要な文字数の分に
長さを記録する1 バイトを足した領域に格納されます。値には桁合わせのための空白はつ
けられません。後続の空白は値の格納時に取り除かれます。(この空白の除去は ANSI
SQL仕様とは違っています。)

</P>
<P>
もし <CODE>CHAR</CODE> または <CODE>VARCHAR</CODE> フィールドに、フィールドの最大長を
越える長さの値を与えた場合は、適合するように切り詰められます。

</P>
<P>
以下の表はこれらの二つのフィールド型の違いを、<CODE>CHAR(4)</CODE> および <CODE>VARCHA
R(4)</CODE> に様々な文字列値を格納した結果を示すことで表しています。

</P>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>値</STRONG> </TD><TD> <CODE>CHAR(4)</CODE> </TD><TD> <STRONG>必要な格納域</STRONG> </TD><TD> @code
{VARCHAR(4)} </TD><TD> <STRONG>必要な格納域</STRONG>
</TR NOSAVE>
<TR><TD><CODE>''</CODE> </TD><TD> <CODE>'    '</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>''</CODE> </TD><TD> 1 バイト
</TR NOSAVE>
<TR><TD><CODE>'ab'</CODE> </TD><TD> <CODE>'ab  '</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>'ab'</CODE> </TD><TD> 3 バイト
</TR NOSAVE>
<TR><TD><CODE>'abcd'</CODE> </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 5 バイト
</TR NOSAVE>
<TR><TD><CODE>'abcdefgh'</CODE> </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 5 バイト
</TR>
</TABLE>

<P>
<CODE>CHAR(4)</CODE> フィールドの後続の空白は取り出し時にとりのぞかれるので、CHAR(4)お
よび
<CODE>VARCHAR(4)</CODE> から取り出される値はどの場合でも同じです。

</P>
<P>
<CODE>CHAR</CODE> および <CODE>VARCHAR</CODE> フィールドの値はテーブルの生成時に <CODE>BINARY</CODE> 属性が
つけられない限り、大文字と小文字を区別しないでソート・比較されます。<CODE>BINARY</CODE> 属性は
その列の値が大文字、小文字を区別して、MySQLサーバを実行しているマシンのASCII順に
ソート・比較されることを意味します。
<CODE>BINARY</CODE> はフィールドがどのように格納されるか、どのように取り出される
かには影響しません。

</P>
<P>
<CODE>BINARY</CODE> 属性は「固定的」です。つまり、もし <CODE>BINARY</CODE> であると指定された
フィールドが式の中にあると式全体が <CODE>BINARY</CODE> の値として比較されるのです。

</P>
<P>
<STRONG>MySQL</STRONG> はテーブル生成時に何も断らずに<CODE>CHAR</CODE> または <CODE>VARCHAR</CODE> 
型のフィールドを変更する事があります。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

</P>



<H4><A NAME="BLOB" HREF="manual.ja_toc.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A></H4>

<P>
<A NAME="IDX1058"></A>
<A NAME="IDX1059"></A>

</P>
<P>
<CODE>BLOB</CODE> は大きなバイナリ型のオブジェクトで、可変長のデータを保持できます。
4 つの <CODE>BLOB</CODE> 型、すなわち <CODE>TINYBLOB</CODE>, <CODE>BLOB</CODE>,
<CODE>MEDIUMBLOB</CODE> と <CODE>LONGBLOB</CODE> は保持できるデータの最大長が違うだけです。
 「<A HREF="manual.ja_Reference.html#Storage_requirements">6.2.6  各フィールド型の所要容量</A>」節参照.

</P>
<P>
4 つの <CODE>TEXT</CODE> 型、すなわち <CODE>TINYTEXT</CODE>, <CODE>TEXT</CODE>, <CODE>MEDIUMTEXT</CODE>
と <CODE>LONGTEXT</CODE> は 4 つの <CODE>BLOB</CODE> 型に対応し、同じ最大長と
格納条件を持っています。 <CODE>TEXT</CODE> と <CODE>BLOB</CODE> の違いは、
<CODE>TEXT</CODE> はケースに依存しないでソートと比較され、
<CODE>BLOB</CODE> はケースに依存して(文字コードで)比較されることだけです。
いうならば、<CODE>TEXT</CODE> は、ケースに依存しない <CODE>BLOB</CODE> です。

</P>
<P>
もし <CODE>BLOB</CODE> や <CODE>TEXT</CODE> フィールドにそれらの最大長以上の値が与えられた
場合、その値はきっちり収まるように切り落とされます。

</P>
<P>
ほとんどの点で、<CODE>TEXT</CODE> フィールドを <CODE>VARCHAR</CODE> の大きい物と見なすことが
出来ます。
同様に、<CODE>BLOB</CODE> フィールドは <CODE>VARCHAR BINARY</CODE> フィールドの大きくなった
物です。
違いは、

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> バージョン 3.23.2 以上では、<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 項に
インデックスを持つことが出来ます。それ以前のバージョンでは
インデックスをもつことが出来ません。

<LI>

<CODE>VARCHAR</CODE> フィールドで行っているようには、<CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィー
ルドの値の後ろについている連続した空白文字は切り落とされません。

<LI>

<A NAME="IDX1060"></A>
<A NAME="IDX1061"></A>
<A NAME="IDX1062"></A>
<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 項は <CODE>DEFAULT</CODE> 値を持つことが出来ません。
</UL>

<P>
<CODE>MyODBC</CODE> は <CODE>BLOB</CODE> を <CODE>LONGVARBINARY</CODE> として、 
<CODE>TEXT</CODE> を <CODE>LONGVARCHAR</CODE> として定義します。

</P>
<P>
<CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィールドは極端に長いので、それらを使用する際には、
いくつかの困った事にでくわすかもしれません：

</P>

<UL>
<LI>

もし <CODE>GROUP BY</CODE> か <CODE>ORDER BY</CODE> を <CODE>BLOB</CODE> フィールドや <CODE>TEXT</CODE> 
フィールドで使用したいなら、フィールドの値を固定長のものに変換しなくてはなりま
せん。標準的な方法は、 <CODE>SUBSTRING</CODE> 関数を使用することです。
たとえば：


<PRE>
mysql&#62; select comment from tbl_name,substring(comment,20) as substr
       ORDER BY substr;
</PRE>

もしこれをしない場合、フィールドの最初の <CODE>max_sort_length</CODE> バイトが
ソート時に使用されます。 <CODE>max_sort_length</CODE> のデフォルト値は 1024; 
この値は <CODE>mysqld</CODE> サーバー起動時に <CODE>-O</CODE> オプションを使用することで
変更できます。
フィールドの位置を指定することによってか、エイリアスを使用することによって、
 <CODE>BLOB</CODE> や <CODE>TEXT</CODE> の値で group 化できます。


<PRE>
mysql&#62; select id,substring(blob_col,1,100) from tbl_name
           GROUP BY 2;
mysql&#62; select id,substring(blob_col,1,100) as b from tbl_name
           GROUP BY b;
</PRE>

<LI>

<CODE>BLOB</CODE> または <CODE>TEXT</CODE> オブジェクトの最大長はその型により決定されますが、
あなたがクライアントとサーバの間で実際に送ることができるは最大長は、
利用可能なメモリ量とコミュニケーションバッファのサイズによって決定されます。
メッセージバッファサイズを変えることができますが、その場合、サーバーとクライアン
ト、両方共に変更しなければなりません。 「<A HREF="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.
</UL>

<P>
それぞれの <CODE>BLOB</CODE>, <CODE>TEXT</CODE> フィールドは、一意のアロケートされたオブジェ
クトによって、内部では表されることに注意してください.。
これはテーブルが開かれるときに一度だけアロケートされる他のフィールドとは対照的で
す。

</P>



<H4><A NAME="ENUM" HREF="manual.ja_toc.html#ENUM">6.2.3.3  <CODE>ENUM</CODE> 型</A></H4>

<P>
<A NAME="IDX1063"></A>

</P>
<P>
<CODE>ENUM</CODE> はストリングオブジェクトで、
その値は、通常、テーブル作成時のフィールド定義で列挙された値の中から選ばれます。

</P>
<P>
値はある状況下では 空文字 (<CODE>""</CODE>) か <CODE>NULL</CODE> を取ることがあります：

</P>

<UL>
<LI>

もし <CODE>ENUM</CODE> に無効な値 (列挙されている値の中に含まれない文字) を
代入した場合、 そのエラーになる文字の代わりに空文字が挿入されます。

<LI>

もし <CODE>ENUM</CODE> が <CODE>NULL</CODE> と定義された場合, <CODE>NULL</CODE> はそのフィールドで
許可される値となり、デフォルト値が <CODE>NULL</CODE> になります。
 もし <CODE>ENUM</CODE> が <CODE>NOT NULL</CODE> と定義されたならば、 デフォルト値は、
列挙リストの最初の値になります。
</UL>

<P>
列挙されたそれぞれの値はインデックスを持ちます：

</P>

<UL>
<LI>

列挙リストの要素は 1 から付番されます。

<LI>

空文字エラーのインデックス値は 0 。
 これは不正な <CODE>ENUM</CODE> 値が与えられているレコードを見つけるために
以下のような <CODE>SELECT</CODE> 構文が使用できることを意味します：


<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE enum_col=0;
</PRE>

<LI>

<CODE>NULL</CODE> のインデックス値は <CODE>NULL</CODE>.
</UL>

<P>
たとえば、フィールドが <CODE>ENUM("one", "two", "three")</CODE> と定義されたなら、
以下に示す値をとります。 それぞれのインデックス値も示します。

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>値</STRONG> </TD><TD> <STRONG>インデックス</STRONG>
</TR NOSAVE>
<TR><TD><CODE>NULL</CODE> </TD><TD> <CODE>NULL</CODE>
</TR NOSAVE>
<TR><TD><CODE>""</CODE> </TD><TD> 0
</TR NOSAVE>
<TR><TD><CODE>"one"</CODE> </TD><TD> 1
</TR NOSAVE>
<TR><TD><CODE>"two"</CODE> </TD><TD> 2
</TR NOSAVE>
<TR><TD><CODE>"three"</CODE> </TD><TD> 3
</TR>
</TABLE>

<P>
列挙は最大 65535 個の要素まで可能です。

</P>
<P>
<CODE>ENUM</CODE> フィールドに値を与える場合は大文字小文字は無関係です。
しかし、後でフィールドから検索される値は、大文字小文字をもちます。
これはテーブル作成時に与えられたリストの値です。

</P>
<P>
もし <CODE>ENUM</CODE> を数値の文脈で検索した場合、そのメンバーを前から数えた
時の順番が数値で返ってきます。
たとえば、<CODE>ENUM</CODE> フィールドから次のようにして数値を取り出すことができ
ます:

</P>

<PRE>
mysql&#62; SELECT enum_col+0 FROM tbl_name;
</PRE>

<P>
もし <CODE>ENUM</CODE> に数値を代入しようとした場合、その数値の位置にある
メンバーが代入されます。
(しかし、これは <CODE>LOAD DATA</CODE> では働きません。これはすべての入力を文字
列として扱います。)

</P>
<P>
<CODE>ENUM</CODE> 値は列挙メンバがフィールド指定にリストされた順に従ってソートさ
れます。(つまり、<CODE>ENUM</CODE> 値はインデックス値に従ってソートされます。)
例えば、<CODE>ENUM("a", "b")</CODE> ならば <CODE>"a"</CODE> が <CODE>"b"</CODE> の前にソートされ、
<CODE>ENUM("b", "a")</CODE> ならば <CODE>"b"</CODE> が <CODE>"a"</CODE> の前にソートされます。
空文字列は空ではない文字の前にソートされ、
<CODE>NULL</CODE> は他の列挙の前に並びます。

</P>
<P>
<CODE>ENUM</CODE> フィールドで指定可能な値のリストを全て取りたいならば、
次のようにします：
<CODE>SHOW COLUMNS FROM table_name LIKE enum_column_name</CODE>
そして二番目のフィールドの <CODE>ENUM</CODE> 定義を分析します。

</P>



<H4><A NAME="SET" HREF="manual.ja_toc.html#SET">6.2.3.4  <CODE>SET</CODE> 型</A></H4>

<P>
<CODE>SET</CODE> は文字型オブジェクトでゼロかそれ以上を値持ちます。
テーブル作成時には、それぞれの値はリストから選ばれるべきです。
<CODE>SET</CODE> 型のフィールドの値は、コンマ(<SAMP>`,'</SAMP>)
区切りで並べられた複数のメンバーで構成されています。 
これは、 <CODE>SET</CODE> メンバーの値中にコンマを含むことが出来ない、
ということです。

</P>
<P>
例えば、
<CODE>SET("one", "two") NOT NULL</CODE> と指定されたフィールドは以下の値をとります：

</P>

<PRE>
""
"one"
"two"
"one,two"
</PRE>

<P>
<CODE>SET</CODE> は最大 64 個の異なったメンバーがもてます。

</P>
<P>
<STRONG>MySQL</STRONG> は <CODE>SET</CODE> の値を数値として代入します。代入された
値の最下位のビットが最初のメンバーに対応します。もし <CODE>SET</CODE> 値を
数値の文脈で検索した場合、検索される値はフィールドの値に対応します。
たとえば、<CODE>SET</CODE> フィールドから次のようにして数値を取り出すことができ
ます:

</P>

<PRE>
mysql&#62; SELECT set_col+0 FROM tbl_name;
</PRE>

<P>
もし数値が <CODE>SET</CODE> フィールドに代入された場合、
二進数で表される数値のビットによって、メンバーが決定されます。
<CODE>SET("a","b","c","d")</CODE> とフィールドが定義されたとします。
メンバーは以下の２進数の値を持ちます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>SET</CODE> <STRONG>member</STRONG> </TD><TD> <STRONG>10進数</STRONG> </TD><TD> <STRONG>２進数値</STRONG>
</TR NOSAVE>
<TR><TD><CODE>a</CODE> </TD><TD> <CODE>1</CODE> </TD><TD> <CODE>0001</CODE>
</TR NOSAVE>
<TR><TD><CODE>b</CODE> </TD><TD> <CODE>2</CODE> </TD><TD> <CODE>0010</CODE>
</TR NOSAVE>
<TR><TD><CODE>c</CODE> </TD><TD> <CODE>4</CODE> </TD><TD> <CODE>0100</CODE>
</TR NOSAVE>
<TR><TD><CODE>d</CODE> </TD><TD> <CODE>8</CODE> </TD><TD> <CODE>1000</CODE>
</TR>
</TABLE>

<P>
もしこのフィールドに <CODE>9</CODE> を与えた場合、これは２進数で <CODE>1001</CODE> ですから、
1 番目と 4 番目の <CODE>SET</CODE> メンバーである <CODE>"a"</CODE> と <CODE>"d"</CODE> が
選択され、結果、 <CODE>"a,d"</CODE> となります。

</P>
<P>
1つ以上の <CODE>SET</CODE> 要素を含む値においては,あなたが値を挿入するとき,要素がどん
な
順序で記載されているのかは重要ではありません. また,何回要素が与えられたのかは
重要ではありません. 後で値が検索されるとき, 値の中のそれぞれの要素は
ただ一回だけ表れます。そのとき、テーブル作成時に与えられた順に要素は並びます。
例えば、フィールドが <CODE>SET("a","b","c","d")</CODE> と設定されていたなら、
<CODE>"a,d"</CODE>, <CODE>"d,a"</CODE>, <CODE>"d,a,a,d,d"</CODE> は検索されると <CODE>"a,d"</CODE> と
なります。

</P>
<P>
<CODE>SET</CODE> 値は数値として代入されます。
<CODE>NULL</CODE> 値は非 <CODE>NULL</CODE> <CODE>SET</CODE> 値の前にソートされます。

</P>
<P>
通常、<CODE>LIKE</CODE> か <CODE>FIND_IN_SET()</CODE> を使用して <CODE>SET</CODE> フィールド
の <CODE>SELECT</CODE> を行います：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE set_col LIKE '%value%';
mysql&#62; SELECT * FROM tbl_name WHERE FIND_IN_SET('value',set_col)&#62;0;
</PRE>

<P>
しかし、以下も動作します：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE set_col = 'val1,val2';
mysql&#62; SELECT * FROM tbl_name WHERE set_col &#38; 1;
</PRE>

<P>
最初の文は完全一致するものを探します。
二つ目は第一番目のメンバーを含む値を探します。

</P>
<P>
もし <CODE>SET</CODE> フィールドで設定可能なすべてのメンバーを知りたい場合：
 <CODE>SHOW COLUMNS FROM table_name LIKE set_column_name</CODE> とし、
２番目にあらわされる <CODE>SET</CODE> 定義を分析します。

</P>



<H3><A NAME="Choosing_types" HREF="manual.ja_toc.html#Choosing_types">6.2.4  正しいフィールド型の選択</A></H3>

<P>
<A NAME="IDX1064"></A>
<A NAME="IDX1065"></A>

</P>
<P>
もっとも効率よく格納するには、全てにおいて一番正確な型を使用することです。
例えば、<CODE>1</CODE>-<CODE>99999</CODE> の整数
には、<CODE>MEDIUMINT UNSIGNED</CODE> が最良の型です。

</P>
<P>
良くある問題は、貨幣の値の正確な表現です。<STRONG>MySQL</STRONG> では 
<CODE>DECIMAL</CODE> 型を使用すべきです。これは文字列として格納し、正確さのロ
スは発生しません。正確さが重要でない場合は <CODE>DOUBLE</CODE> 型でも十分良い
です。

</P>
<P>
高精度のため、常に <CODE>BITINT</CODE> に格納される固定小数点型に変換できます。
これは、全ての計算を整数で行なうようにし、結果だけを浮動小数点に変換して
戻します。

</P>



<H3><A NAME="Other-vendor_column_types" HREF="manual.ja_toc.html#Other-vendor_column_types">6.2.5  他のデータベースエンジンのフィールド型の使用</A></H3>

<P>
<A NAME="IDX1066"></A>
<A NAME="IDX1067"></A>
<A NAME="IDX1068"></A>

</P>
<P>
ほかのベンダーからSQLを簡単に書けれるように、 <STRONG>MySQL</STRONG> は以下の表に
しめすフィールド型をサポートします。これらは、テーブルの定義を、
他のデータベースエンジンから <STRONG>MySQL</STRONG> に簡単に移行させてくれます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Other vendor type</STRONG> </TD><TD> <STRONG>MySQL type</STRONG>
</TR NOSAVE>
<TR><TD><CODE>BINARY(NUM)</CODE> </TD><TD> <CODE>CHAR(NUM) BINARY</CODE>
</TR NOSAVE>
<TR><TD><CODE>CHAR VARYING(NUM)</CODE> </TD><TD> <CODE>VARCHAR(NUM)</CODE>
</TR NOSAVE>
<TR><TD><CODE>FLOAT4</CODE> </TD><TD> <CODE>FLOAT</CODE>
</TR NOSAVE>
<TR><TD><CODE>FLOAT8</CODE> </TD><TD> <CODE>DOUBLE</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT1</CODE> </TD><TD> <CODE>TINYINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT2</CODE> </TD><TD> <CODE>SMALLINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT3</CODE> </TD><TD> <CODE>MEDIUMINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT4</CODE> </TD><TD> <CODE>INT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT8</CODE> </TD><TD> <CODE>BIGINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>LONG VARBINARY</CODE> </TD><TD> <CODE>MEDIUMBLOB</CODE>
</TR NOSAVE>
<TR><TD><CODE>LONG VARCHAR</CODE> </TD><TD> <CODE>MEDIUMTEXT</CODE>
</TR NOSAVE>
<TR><TD><CODE>MIDDLEINT</CODE> </TD><TD> <CODE>MEDIUMINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>VARBINARY(NUM)</CODE> </TD><TD> <CODE>VARCHAR(NUM) BINARY</CODE>
</TR>
</TABLE>

<P>
もし他のベンダーの型を使用してテーブルを作ろうとすると、
テーブル作成時のフィールドの型のマッピングが発生し、
<CODE>DESCRIBE tbl_name</CODE> 構文を発行します。
そして <STRONG>MySQL</STRONG> は、使用された型と等価な <STRONG>MySQL</STRONG> の型を用いて
テーブルを構成したことを告げます。

</P>



<H3><A NAME="Storage_requirements" HREF="manual.ja_toc.html#Storage_requirements">6.2.6  各フィールド型の所要容量</A></H3>

<P>
<A NAME="IDX1069"></A>
<A NAME="IDX1070"></A>

</P>
<P>
<STRONG>MySQL</STRONG>がサポートする各フィールドタイプ毎の所要容量を、カテゴリ別に以下に
記述します。

</P>
<P>
<A NAME="IDX1071"></A>
<A NAME="IDX1072"></A>

</P>

<H4>6.2.6.1  数値タイプの保存容量</H4>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>所要容量</STRONG>
</TR NOSAVE>
<TR><TD><CODE>TINYINT</CODE> </TD><TD> 1 byte
</TR NOSAVE>
<TR><TD><CODE>SMALLINT</CODE> </TD><TD> 2 bytes
</TR NOSAVE>
<TR><TD><CODE>MEDIUMINT</CODE> </TD><TD> 3 bytes
</TR NOSAVE>
<TR><TD><CODE>INT</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>INTEGER</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>BIGINT</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>FLOAT(X)</CODE> </TD><TD> X &#60;= 24 の場合 4、25 &#60;= X &#60;= 53 の場合 8
</TR NOSAVE>
<TR><TD><CODE>FLOAT</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>DOUBLE</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>DOUBLE PRECISION</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>REAL</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>DECIMAL(M,D)</CODE> </TD><TD> D &#62; 0 の場合 <CODE>M+2</CODE>, D = 0 の場合 <CODE>M+1</CODE> bytes (<CODE>M &#60; D</CODE> の場合 <CODE>D</CODE>+2)
</TR NOSAVE>
<TR><TD><CODE>NUMERIC(M,D)</CODE> </TD><TD> D &#62; 0 の場合 <CODE>M+2</CODE>, D = 0 の場合 <CODE>M+1</CODE> bytes (<CODE>M &#60; D</CODE> の場合 <CODE>D</CODE>+2)
</TR>
</TABLE>

<P>
<A NAME="IDX1073"></A>
<A NAME="IDX1074"></A>
<A NAME="IDX1075"></A>
<A NAME="IDX1076"></A>

</P>

<H4>6.2.6.2  日付と時間タイプの保存容量</H4>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>所要容量</STRONG>
</TR NOSAVE>
<TR><TD><CODE>DATE</CODE> </TD><TD> 3 bytes
</TR NOSAVE>
<TR><TD><CODE>DATETIME</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>TIME</CODE> </TD><TD> 3 bytes
</TR NOSAVE>
<TR><TD><CODE>YEAR</CODE> </TD><TD> 1 byte
</TR>
</TABLE>


<H4>6.2.6.3  文字列タイプの保存容量</H4>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>所要容量</STRONG>
</TR NOSAVE>
<TR><TD><CODE>CHAR(M)</CODE> </TD><TD> <CODE>M</CODE> bytes, <CODE>1 &#60;= M &#60;= 255</CODE>
</TR NOSAVE>
<TR><TD><CODE>VARCHAR(M)</CODE> </TD><TD> <CODE>L</CODE>+1 bytes, where <CODE>L &#60;= M</CODE> and <CODE>1 &#60;= M &#60;= 255</CODE>
</TR NOSAVE>
<TR><TD><CODE>TINYBLOB</CODE>, <CODE>TINYTEXT</CODE> </TD><TD> <CODE>L</CODE>+1 bytes,where <CODE>L</CODE> &#60; 2^8
</TR NOSAVE>
<TR><TD><CODE>BLOB</CODE>, <CODE>TEXT</CODE> </TD><TD> <CODE>L</CODE>+2 bytes,where <CODE>L</CODE> &#60; 2^16
</TR NOSAVE>
<TR><TD><CODE>MEDIUMBLOB</CODE>, <CODE>MEDIUMTEXT</CODE> </TD><TD> <CODE>L</CODE>+3 bytes,where <CODE>L</CODE> &#60; 2^24
</TR NOSAVE>
<TR><TD><CODE>LONGBLOB</CODE>, <CODE>LONGTEXT</CODE> </TD><TD> <CODE>L</CODE>+4 bytes,where <CODE>L</CODE> &#60; 2^32
</TR NOSAVE>
<TR><TD><CODE>ENUM('value1','value2',...)</CODE> </TD><TD> 1 or 2 bytes, 列挙値の数に依存 (最大値は 65535 )
</TR NOSAVE>
<TR><TD><CODE>SET('value1','value2',...)</CODE> </TD><TD> 1, 2, 3, 4 or 8 bytes, 要素の数に依存 (最大要素 64 )
</TR>
</TABLE>

<P>
<A NAME="IDX1077"></A>
<A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>
<CODE>VARCHAR</CODE>、<CODE>BLOB</CODE>、及び<CODE>TEXT</CODE>型は可変長型であり、所要容量は、フィ
ールドのとり得る最大サイズというよりはむしろフィールド値の実際の長さに依存します
(前の表で<CODE>L</CODE>と表しました)。
例えば、<CODE>VARCHAR(10)</CODE>フィールドは、最大10文字分の長さの文字列を保持すること
が出来ます。実際の所要容量は、文字列の長さ(<CODE>L</CODE>)と、その長さを記録するための
１バイトを加えます。文字列<CODE>'abcd'</CODE>においては、<CODE>L</CODE>は４で、所要容量は５
バイトです。

</P>
<P>
<CODE>BLOB</CODE>と<CODE>TEXT</CODE>型は、フィールド値の長さを記録するのに、１、２、３、又は
４バイト必要とし、型のとり得る最大の長さに依存します。 「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

</P>
<P>
テーブルが可変長フィールド型を含む場合、そのレコードフォーマットもまた可変長とな
るでしょう。
テーブルが作成された時、<STRONG>MySQL</STRONG>は確かな条件の下、フィールドを可変長タイプ
から固定長タイプへ変更し、副作用を起こすことに注意して下さい。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

</P>
<P>
<A NAME="IDX1080"></A>
<CODE>ENUM</CODE>オブジェクトのサイズは、異なる列挙値の数によって決められます。
列挙する数が255以内では、１バイトが使用されます。
列挙する数が65535以内では、２バイトが使用されます。 「<A HREF="manual.ja_Reference.html#ENUM">6.2.3.3  <CODE>ENUM</CODE> 型</A>」節参照.

</P>
<P>
<A NAME="IDX1081"></A>
<CODE>SET</CODE>オブジェクトのサイズは、異なる要素の数によって決められます。
組のサイズを<CODE>N</CODE>とすると、オブジェクトは<CODE>(N+7)/8</CODE>バイトを占有し、
１、２、３、４又は８バイトに切上げられます。
１つの<CODE>SET</CODE>は、最大６４要素を持つことができます。 「<A HREF="manual.ja_Reference.html#SET">6.2.3.4  <CODE>SET</CODE> 型</A>」節参照.

</P>



<H2><A NAME="Functions" HREF="manual.ja_toc.html#Functions">6.3  <CODE>SELECT</CODE> と <CODE>WHERE</CODE> 節で使用する関数</A></H2>

<P>
<A NAME="IDX1082"></A>

</P>
<P>
SQL ステートメント中の <CODE>select_expression</CODE> または 
<CODE>where_definition</CODE> は後述の関数を使用した任意の式からなります。

</P>
<P>
演算と関数を式の中で呼ぶ時、本ドキュメントに示しているもの以外の、
<CODE>NULL</CODE> を含む式は常に <CODE>NULL</CODE> 値を生成します

</P>
<P>
<STRONG>注意:</STRONG> 関数名とそれに続く語句の間には、空白はありません。
これは関数の呼び出しと、関数と同名のテーブル(かフィールド)の参照を、
 <STRONG>MySQL</STRONG> パーサが区別するのを助けます。

</P>
<P>
<CODE>mysqld</CODE> に <CODE>--ansi</CODE> をつけて起動するか、
<CODE>CLIENT_IGNORE_SPACE</CODE> を <CODE>mysql_connect()</CODE> に使用すれば、
<STRONG>MySQL</STRONG> が関数名の後の空白を許すようになりますが、その場合、すべて
の関数名が予約語になります。 「<A HREF="manual.ja_Introduction.html#ANSI_mode">1.4.3  ANSI モードでの MySQL の実行</A>」節参照。

</P>
<P>
次の例では、<CODE>mysql</CODE> プログラムの出力は短くなっています。つまり:

</P>

<PRE>
mysql&#62; select MOD(29,9);
1 rows in set (0.00 sec)

+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+
</PRE>

<P>
これは次に変換されています:

</P>

<PRE>
mysql&#62; select MOD(29,9);
        -&#62; 2
</PRE>



<H3><A NAME="Non-typed_Operators" HREF="manual.ja_toc.html#Non-typed_Operators">6.3.1  Non-Type-Specific Operators and Functions</A></H3>



<H4><A NAME="Parenthesis" HREF="manual.ja_toc.html#Parenthesis">6.3.1.1  Parenthesis</A></H4>

<P>
<A NAME="IDX1083"></A>
<A NAME="IDX1084"></A>

</P>
<P>
<A NAME="IDX1085"></A>
<A NAME="IDX1086"></A>

</P>

<PRE>
( ... )
</PRE>

<P>
Use parenthesis to force the order of evaluation in an expression.  For 
example:

</P>

<PRE>
mysql&#62; select 1+2*3;
        -&#62; 7
mysql&#62; select (1+2)*3;
        -&#62; 9
</PRE>



<H4><A NAME="Comparison_Operators" HREF="manual.ja_toc.html#Comparison_Operators">6.3.1.2  比較演算子</A></H4>

<P>
<A NAME="IDX1087"></A>

</P>
<P>
<A NAME="IDX1088"></A>
<A NAME="IDX1089"></A>

</P>
<P>
<CODE>1</CODE> (TRUE), <CODE>0</CODE> (FALSE) または <CODE>NULL</CODE> を返します。
これらの関数は数値と文字列の両方で働きます。
必要ならば、文字は自動的に数字に変換され、数字は文字に変換されます。
(Perlがおこなっているみたいに)

</P>
<P>
<STRONG>MySQL</STRONG> は以下の規則で比較を行います：

</P>

<UL>
<LI>

どちらかまたは両方の引数が <CODE>NULL</CODE> の場合は、比較結果は <CODE>NULL</CODE> 
です。<CODE>&#60;=&#62;</CODE> 演算子を除きます。

<LI>

比較操作の両方の引数が文字列の場合、文字列として比較されます。

<LI>

両方の引数が整数の場合、整数として比較されます。

<LI>

16進数の値は、もし数値と比較されないのであれば、文字列として扱われます。

<LI>

<A NAME="IDX1090"></A>
<A NAME="IDX1091"></A>
引数の一方が <CODE>TIMESTAMP</CODE> または <CODE>DATETIME</CODE> フィールドで、他の引数が
定数の場合は、定数は比較前に timestamp に変換されます。これはより ODBC 
フレンドリにするためです。

<LI>

他の場合は全て浮動小数点(real)として比較されます。
</UL>

<P>
文字列の比較は、ケースに依存せず、標準のキャラクターセットに従って
行われます。(ISO-8859-1 Latin1 がデフォルトです。これは English です)

</P>
<P>
以下は、比較のために文字が数値へ変換されている例です：

</P>

<PRE>
mysql&#62; SELECT 1 &#62; '6x';
         -&#62; 0
mysql&#62; SELECT 7 &#62; '6x';
         -&#62; 1
mysql&#62; SELECT 0 &#62; 'x6';
         -&#62; 0
mysql&#62; SELECT 0 = 'x6';
         -&#62; 1
</PRE>

<DL COMPACT>

<DT><CODE>=</CODE>
<DD>
<A NAME="IDX1092"></A>
 <A NAME="IDX1093"></A>
 
等しい:

<PRE>
mysql&#62; select 1 = 0;
        -&#62; 0
mysql&#62; select '0' = 0;
        -&#62; 1
mysql&#62; select '0.0' = 0;
        -&#62; 1
mysql&#62; select '0.01' = 0;
        -&#62; 0
mysql&#62; select '.01' = 0.01;
        -&#62; 1
</PRE>

<A NAME="IDX1094"></A>
<A NAME="IDX1095"></A>
<A NAME="IDX1096"></A>
<A NAME="IDX1097"></A>
<DT><CODE>&#60;&#62;</CODE>
<DD>
<DT><CODE>!=</CODE>
<DD>
等しくない:

<PRE>
mysql&#62; select '.01' &#60;&#62; '0.01';
        -&#62; 1
mysql&#62; select .01 &#60;&#62; '0.01';
        -&#62; 0
mysql&#62; select 'zapp' &#60;&#62; 'zappp';
        -&#62; 1
</PRE>

<A NAME="IDX1098"></A>
<A NAME="IDX1099"></A>
<DT><CODE>&#60;=</CODE>
<DD>
より小さいか等しい:

<PRE>
mysql&#62; select 0.1 &#60;= 2;
        -&#62; 1
</PRE>

<A NAME="IDX1100"></A>
<A NAME="IDX1101"></A>
<DT><CODE>&#60;</CODE>
<DD>
より小さい:

<PRE>
mysql&#62; select 2 &#60; 2;
        -&#62; 0
</PRE>

<A NAME="IDX1102"></A>
<A NAME="IDX1103"></A>
<DT><CODE>&#62;=</CODE>
<DD>
より大きいか等しい:

<PRE>
mysql&#62; select 2 &#62;= 2;
        -&#62; 1
</PRE>

<A NAME="IDX1104"></A>
<A NAME="IDX1105"></A>
<DT><CODE>&#62;</CODE>
<DD>
より大きい:

<PRE>
mysql&#62; select 2 &#62; 2;
        -&#62; 0
</PRE>

<A NAME="IDX1106"></A>
<A NAME="IDX1107"></A>
<DT><CODE>&#60;=&#62;</CODE>
<DD>
等しい(NULL 安全):

<PRE>
mysql&#62; select 1 &#60;=&#62; 1, NULL &#60;=&#62; NULL, 1 &#60;=&#62; NULL;
        -&#62; 1 1 0
</PRE>

<A NAME="IDX1108"></A>
<A NAME="IDX1109"></A>
<A NAME="IDX1110"></A>
<DT><CODE>IS NULL</CODE>
<DD>
<DT><CODE>IS NOT NULL</CODE>
<DD>
値が <CODE>NULL</CODE> とであるかどうかのテスト:

<PRE>
mysql&#62; select 1 IS NULL, 0 IS NULL, NULL IS NULL;
        -&#62; 0 0 1
mysql&#62; select 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL;
        -&#62; 1 1 0
</PRE>

<A NAME="IDX1111"></A>
<DT><CODE>expr BETWEEN min AND max</CODE>
<DD>
もし <CODE>expr</CODE> が <CODE>min</CODE> 以上、 <CODE>max</CODE> 以下なら <CODE>1</CODE>を返します。
そうでないなら <CODE>0</CODE> を返します。
これは 全ての引数が同じ型ならば、<CODE>(min &#60;= expr AND expr &#60;= max)</CODE> と同じです。
 最初の引数 (<CODE>expr</CODE>) はいかのように比較方法を決定します。


<UL>
<LI>

もし <CODE>exor</CODE> が <CODE>TIMESTAMP</CODE>, <CODE>DATE</CODE>, <CODE>DATETIME</CODE> フィー
ルドなら、最小と最大はそれらが定数の場合と同じフォーマットになります。
<LI>

もし <CODE>expr</CODE> が文字式なら、ケース非依存で比較が行われます。
<LI>

もし <CODE>expr</CODE> がバイナリ文字なら、ケース依存で比較が行われます。
<LI>

もし <CODE>expr</CODE> が整数なら、整数で比較が行われます。
<LI>

その他は浮動小数点(実数)で比較されます。
</UL>


<PRE>
mysql&#62; select 1 BETWEEN 2 AND 3;
        -&#62; 0
mysql&#62; select 'b' BETWEEN 'a' AND 'c';
        -&#62; 1
mysql&#62; select 2 BETWEEN 2 AND '3';
        -&#62; 1
mysql&#62; select 2 BETWEEN 2 AND 'x-3';
        -&#62; 0
</PRE>

<A NAME="IDX1112"></A>
<DT><CODE>expr IN (value,...)</CODE>
<DD>
もし <CODE>expr</CODE> が <CODE>IN</CODE> リストにある値のどれかならば、<CODE>1</CODE> を返します
。
そうでなければ <CODE>0</CODE> を返します。
もし全ての値が定数なら、すべての値が <CODE>expr</CODE> の型に従って評価され、
ソートされます。この検索にはバイナリサーチが使用されます。
これは <CODE>IN</CODE> リストに定数を与えた場合、<CODE>IN</CODE> が速くなることを意味します。
もし <CODE>expr</CODE> がケース依存の文字式なら、ケース依存のやり方で比較されます。


<PRE>
mysql&#62; select 2 IN (0,3,5,'wefwf');
        -&#62; 0
mysql&#62; select 'wefwf' IN (0,3,5,'wefwf');
        -&#62; 1
</PRE>

<A NAME="IDX1113"></A>
<DT><CODE>expr NOT IN (value,...)</CODE>
<DD>
<CODE>NOT (expr IN (value,...))</CODE> と同じ。

<A NAME="IDX1114"></A>
<DT><CODE>ISNULL(expr)</CODE>
<DD>
<CODE>expr</CODE> が <CODE>NULL</CODE> なら <CODE>1</CODE> を、そうでなければ <CODE>0</CODE> を返します

<PRE>
mysql&#62; select ISNULL(1+1);
        -&#62; 0
mysql&#62; select ISNULL(1/0);
        -&#62; 1
</PRE>

<CODE>NULL</CODE> の値を <CODE>=</CODE> を使用して比較した場合は常に偽(false) となることに
注意してください！

<A NAME="IDX1115"></A>
<A NAME="IDX1116"></A>
<DT><CODE>COALESCE(list)</CODE>
<DD>
list 中の、最初に現れた 非-<CODE>NULL</CODE> 要素を返します。


<PRE>
mysql&#62; select COALESCE(NULL,1);
        -&#62; 1
mysql&#62; select COALESCE(NULL,NULL,NULL);
        -&#62; NULL
</PRE>

<A NAME="IDX1117"></A>
<DT><CODE>INTERVAL(N,N1,N2,N3,...)</CODE>
<DD>
もし <CODE>N</CODE> &#60; <CODE>N1</CODE> なら <CODE>0</CODE> を返します。
もし <CODE>N</CODE> &#60; <CODE>N2</CODE> なら <CODE>1</CODE> を返します。
全ての引数は整数として扱われます。
これは <CODE>N1</CODE> &#60; <CODE>N2</CODE> &#60; <CODE>N3</CODE> &#60; <CODE>...</CODE> &#60; <CODE>Nn</CODE>を正しく動作さ
せるために
必要なことです。これはバイナリ検索が使用されます(速いです)


<PRE>
mysql&#62; select INTERVAL(23, 1, 15, 17, 30, 44, 200);
        -&#62; 3
mysql&#62; select INTERVAL(10, 1, 10, 100, 1000);
        -&#62; 2
mysql&#62; select INTERVAL(22, 23, 30, 44, 200);
        -&#62; 0
</PRE>

</DL>

<P>
If you are comparing case sensitive string with any of the standard
operators (<CODE>=</CODE>, <CODE>&#60;&#62;</CODE>..., but not <CODE>LIKE</CODE>) end space will
be ignored.

</P>

<PRE>
mysql&#62; select "a" ="A ";
        -&#62; 1
</PRE>



<H4><A NAME="Logical_Operators" HREF="manual.ja_toc.html#Logical_Operators">6.3.1.3  論理演算</A></H4>

<P>
<A NAME="IDX1118"></A>
<A NAME="IDX1119"></A>

</P>
<P>
全ての論理関数は <CODE>1</CODE> (TRUE) か <CODE>0</CODE> (FALSE) か <CODE>NULL</CODE> を返します。
(unknown は多くの場合 FALSE と同じです)：

</P>
<DL COMPACT>

<DT><CODE>NOT</CODE>
<DD>
<A NAME="IDX1120"></A>
 <A NAME="IDX1121"></A>
 
<DT><CODE>!</CODE>
<DD>
論理否定。引数が <CODE>0</CODE> なら <CODE>1</CODE> を返し、そうでなければ <CODE>0</CODE> を返しま
す。
例外: <CODE>NOT NULL</CODE> は <CODE>NULL</CODE> を返します:

<PRE>
mysql&#62; select NOT 1;
        -&#62; 0
mysql&#62; select NOT NULL;
        -&#62; NULL
mysql&#62; select ! (1+1);
        -&#62; 0
mysql&#62; select ! 1+1;
        -&#62; 1
</PRE>

最後の例は <CODE>1</CODE> を返します。なぜなら、式の評価が
 <CODE>(!1)+1</CODE> と同じだからです。

<A NAME="IDX1122"></A>
<A NAME="IDX1123"></A>
<DT><CODE>OR</CODE>
<DD>
<DT><CODE>||</CODE>
<DD>
論理和。引数のどれかが <CODE>0</CODE> または <CODE>NULL</CODE> でなければ <CODE>1</CODE> を返しま
す:

<PRE>
mysql&#62; select 1 || 0;
        -&#62; 1
mysql&#62; select 0 || 0;
        -&#62; 0
mysql&#62; select 1 || NULL;
        -&#62; 1

</PRE>

<A NAME="IDX1124"></A>
<A NAME="IDX1125"></A>
<DT><CODE>AND</CODE>
<DD>
<DT><CODE>&#38;&</CODE>
<DD>
論理積。全ての引数が <CODE>0</CODE> または <CODE>NULL</CODE> でなければ <CODE>1</CODE> を返します:

<PRE>
mysql&#62; select 1 &#38;& NULL;
        -&#62; 0
mysql&#62; select 1 &#38;& 0;
        -&#62; 0
</PRE>

</DL>



<H4><A NAME="Control_flow_functions" HREF="manual.ja_toc.html#Control_flow_functions">6.3.1.4  フロー制御関数</A></H4>

<P>
<A NAME="IDX1126"></A>
<A NAME="IDX1127"></A>

</P>
<DL COMPACT>

<DT><CODE>IFNULL(expr1,expr2)</CODE>
<DD>
<A NAME="IDX1128"></A>
 <A NAME="IDX1129"></A>
 
<CODE>expr1</CODE> が <CODE>NULL</CODE> でない場合は <CODE>expr1</CODE> を、そうでなければ 
<CODE>expr2</CODE> を返します。
<CODE>IFNULL()</CODE> はどの文脈で使用されたかにより数値か文字を返します:

<PRE>
mysql&#62; select IFNULL(1,0);
        -&#62; 1
mysql&#62; select IFNULL(NULL,10);
        -&#62; 10
mysql&#62; select IFNULL(1/0,10);
        -&#62; 10
mysql&#62; select IFNULL(1/0,'yes');
        -&#62; 'yes'
</PRE>

<A NAME="IDX1130"></A>
<DT><CODE>NULLIF(expr1,expr2)</CODE>
<DD>
<CODE>expr1 = expr2</CODE> が真なら、<CODE>NULL</CODE> を返し、そうでなければ 
<CODE>expr1</CODE> を返します。
これは <CODE>CASE WHEN x = y THEN NULL ELSE x END</CODE> と同じです:

<PRE>
mysql&#62; select NULLIF(1,1);
        -&#62; NULL
mysql&#62; select NULLIF(1,2);
        -&#62; 1
</PRE>

注意: 引数が等しい場合、<CODE>expr1</CODE> は <STRONG>MySQL</STRONG> では2回評価されます。

<A NAME="IDX1131"></A>
<DT><CODE>IF(expr1,expr2,expr3)</CODE>
<DD>
<CODE>expr1</CODE> が真 (<CODE>expr1 &#60;&#62; 0</CODE> and <CODE>expr1 &#60;&#62; NULL</CODE>) の場合
 <CODE>expr2</CODE> を返し、そうでなければ <CODE>expr3</CODE> を返します。
<CODE>IF()</CODE> はどの文脈で使用されたかにより数値か文字を返します:


<PRE>
mysql&#62; select IF(1&#62;2,2,3);
        -&#62; 3
mysql&#62; select IF(1&#60;2,'yes','no');
        -&#62; 'yes'
mysql&#62; select IF(strcmp('test','test1'),'no','yes');
        -&#62; 'no'
</PRE>

<CODE>expr1</CODE> は <CODE>INTEGER</CODE> として評価されます。これは浮動小数点を使用する
場合、比較演算も使用すべきであることを意味します:


<PRE>
mysql&#62; select IF(0.1,1,0);
        -&#62; 0
mysql&#62; select IF(0.1&#60;&#62;0,1,0);
        -&#62; 1
</PRE>

上の最初の例では、 <CODE>IF(0.1)</CODE> は <CODE>0</CODE> を返します。なぜなら <CODE>0.1</CODE> は
整数値として変換され <CODE>IF(0)</CODE> になり、それをもとにしたテスト結果が
返るからです。 これはあなたの期待に添わないかもしれません。
 二番目の場合、 比較は、元の浮動小数点値が非ゼロかどうかテストします。
比較結果は整数として使用されます。

<CODE>IF()</CODE> のデフォルトの戻り値型(一時テーブルに格納される時に問題となり
ます)は <STRONG>MySQL</STRONG> バージョン 3.23 では次のように計算されます:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Expression</STRONG> </TD><TD> <STRONG>Return value</STRONG>
</TR NOSAVE>
<TR><TD>expr2 または expr3 が文字列を返す </TD><TD> 文字列
</TR NOSAVE>
<TR><TD>expr2 または expr3 が浮動小数点値を返す </TD><TD> 浮動小数点
</TR NOSAVE>
<TR><TD>expr2 または expr3 が整数を返す </TD><TD> 整数
</TR>
</TABLE>

<A NAME="IDX1132"></A>
<DT><CODE>CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END</CODE>
<DD>
<DT><CODE>CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END</CODE>
<DD>
最初の式は <CODE>value=compare-value</CODE> ならば <CODE>result</CODE> を返します。
二つ目の式では、最初の条件[condition] が真ならば、 <CODE>result</CODE> を返します。
もしマッチする result の値がなければ、 <CODE>ELSE</CODE> 以下の result が返ります。
もし <CODE>ELSE</CODE> 部分がなければ、 <CODE>NULL</CODE> が返ります:


<PRE>
mysql&#62; SELECT CASE 1 WHEN 1 THEN "one" WHEN 2 THEN "two" ELSE "more" END;
       -&#62; "one"
mysql&#62; SELECT CASE WHEN 1&#62;0 THEN "true" ELSE "false" END;
       -&#62; "true"
mysql&#62; SELECT CASE BINARY "B" when "a" then 1 when "b" then 2 END;
       -&#62; NULL
</PRE>

</DL>

<P>
戻り値の型(<CODE>INTEGER</CODE>, <CODE>DOUBLE</CODE>, <CODE>STRING</CODE>)は最初に返される値
(最初の <CODE>THEN</CODE> の後の式)の型と同じです。

</P>



<H3><A NAME="String_functions" HREF="manual.ja_toc.html#String_functions">6.3.2  文字列関数</A></H3>

<P>
<A NAME="IDX1133"></A>
<A NAME="IDX1134"></A>

</P>
<P>
サーバー側のパラメター <CODE>max_allowed_packet</CODE> よりも結果の長さが大きい場合、
文字列関数は <CODE>NULL</CODE> を返します。  「<A HREF="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.

</P>
<P>
文字の位置を扱う関数においては、一番最初の位置は数字の 1 です。

</P>
<DL COMPACT>

<DT><CODE>ASCII(str)</CODE>
<DD>
<A NAME="IDX1135"></A>
 
<CODE>str</CODE> の左端の文字の ASCII コード値を返します。
<CODE>str</CODE> が空文字の場合は <CODE>0</CODE> を返します。
<CODE>str</CODE> が <CODE>NULL</CODE> の場合は <CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; select ASCII('2');
        -&#62; 50
mysql&#62; select ASCII(2);
        -&#62; 50
mysql&#62; select ASCII('dx');
        -&#62; 100
</PRE>

See also the <CODE>ORD()</CODE> function.

<A NAME="IDX1136"></A>
<DT><CODE>ORD(str)</CODE>
<DD>
文字列 str の左端の文字がマルチバイト文字の場合、文字のASCII コード値を次
の形式で返すことにより、マルチバイト文字のコードを返します:
<CODE>((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...]</CODE>.
左端の文字がマルチバイト文字でない場合は、<CODE>ASCII()</CODE> 関数と同じ値を返
します:


<PRE>
mysql&#62; select ORD('2');
        -&#62; 50
</PRE>

<A NAME="IDX1137"></A>
<DT><CODE>CONV(N,from_base,to_base)</CODE>
<DD>
数字を、進数の違う数字に変換します。
数 <CODE>N</CODE> を <CODE>from_base</CODE> 進数から <CODE>to_base</CODE> 進数に
変換した場合の、文字表現を返します。
もし引数が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します。
引数 <CODE>N</CODE> は整数として解釈されますが、整数か文字列で指定します。
最小の進数は <CODE>2</CODE> で、最大は <CODE>36</CODE> です。
<CODE>to_base</CODE> が負数なら、<CODE>N</CODE> は符号付きの数になります。
<CODE>CONV</CODE> は 64-bit 精度で動作します:


<PRE>
mysql&#62; select CONV("a",16,2);
        -&#62; '1010'
mysql&#62; select CONV("6E",18,8);
        -&#62; '172'
mysql&#62; select CONV(-17,10,-18);
        -&#62; '-H'
mysql&#62; select CONV(10+"10"+'10'+0xa,10,10);
        -&#62; '40'
</PRE>

<A NAME="IDX1138"></A>
<DT><CODE>BIN(N)</CODE>
<DD>
<CODE>N</CODE> を二進数にした値を返します。<CODE>N</CODE> は longlong 数値です。
これは <CODE>CONV(N,10,2)</CODE> と同じです。
<CODE>N</CODE> が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; select BIN(12);
        -&#62; '1100'
</PRE>

<A NAME="IDX1139"></A>
<DT><CODE>OCT(N)</CODE>
<DD>
<CODE>N</CODE> の8進数値を表す文字列を返します。<CODE>N</CODE> は longlong 数値です。
これは <CODE>CONV(N,10,8)</CODE> と同じです。<CODE>N</CODE> が <CODE>NULL</CODE> の場合は 
<CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; select OCT(12);
        -&#62; '14'
</PRE>

<A NAME="IDX1140"></A>
<DT><CODE>HEX(N)</CODE>
<DD>
<CODE>N</CODE> の16進数値を表す文字列を返します。<CODE>N</CODE> は 
longlong(<CODE>BIGINT</CODE>) 数値です。これは <CODE>CONV(N,10,16)</CODE> と同じです。
<CODE>N</CODE> が <CODE>NULL</CODE> の場合は <CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; select HEX(255);
        -&#62; 'FF'
</PRE>

<A NAME="IDX1141"></A>
<DT><CODE>CHAR(N,...)</CODE>
<DD>
引数の ASCII コード値によって与えられた文字からなる文字列を返します。
<CODE>NULL</CODE> は飛ばされます:


<PRE>
mysql&#62; select CHAR(77,121,83,81,'76');
        -&#62; 'MySQL'
mysql&#62; select CHAR(77,77.3,'77.3');
        -&#62; 'MMM'
</PRE>

<A NAME="IDX1142"></A>
<DT><CODE>CONCAT(str1,str2,...)</CODE>
<DD>
引数を結合した結果を返します。引数が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します.
2個以上の引数を必要とします。
数値の引数は等価の文字列形式に変換されます:


<PRE>
mysql&#62; select CONCAT('My', 'S', 'QL');
        -&#62; 'MySQL'
mysql&#62; select CONCAT('My', NULL, 'QL');
        -&#62; NULL
mysql&#62; select CONCAT(14.3);
        -&#62; '14.3'
</PRE>

<A NAME="IDX1143"></A>
<DT><CODE>CONCAT_WS(separator, str1, str2,...)</CODE>
<DD>
<CODE>CONCAT_WS()</CODE> は区切り文字つき CONCAT (CONCAT With Separator) を意味
し、<CODE>CONCAT()</CODE> の特殊な形式です。最初の引数は、残りの引数の区切り文字
です。区切り文字は残りの引数と同じような文字列です。区切り文字が 
<CODE>NULL</CODE> の場合、結果は <CODE>NULL</CODE> になります。関数は区切り文字より後
の <CODE>NULL</CODE> と空文字列を飛ばします。区切り文字は結合される文字列の間に
追加されます:


<PRE>
mysql&#62; select CONCAT_WS(",","First name","Second name","Last Name");
       -&#62; 'First name,Second name,Last Name'
mysql&#62; select CONCAT_WS(",","First name",NULL,"Last Name");
       -&#62; 'First name,Last Name'
</PRE>

<A NAME="IDX1144"></A>
<A NAME="IDX1145"></A>
<A NAME="IDX1146"></A>
<A NAME="IDX1147"></A>
<DT><CODE>LENGTH(str)</CODE>
<DD>
<DT><CODE>OCTET_LENGTH(str)</CODE>
<DD>
<DT><CODE>CHAR_LENGTH(str)</CODE>
<DD>
<DT><CODE>CHARACTER_LENGTH(str)</CODE>
<DD>
文字列 <CODE>str</CODE> の長さ:


<PRE>
mysql&#62; select LENGTH('text');
        -&#62; 4
mysql&#62; select OCTET_LENGTH('text');
        -&#62; 4
</PRE>

注意: <CODE>CHAR_LENGTH()</CODE> については、マルチバイト文字は一度だけしかカウ
ントされません。

<A NAME="IDX1148"></A>
<A NAME="IDX1149"></A>
<DT><CODE>LOCATE(substr,str)</CODE>
<DD>
<DT><CODE>POSITION(substr IN str)</CODE>
<DD>
<CODE>str</CODE> 内にある <CODE>substr</CODE> 文字列の位置を返します。最初の位置は 1 です。
<CODE>str</CODE> 内に <CODE>substr</CODE> がない時は <CODE>0</CODE> を返します:


<PRE>
mysql&#62; select LOCATE('bar', 'foobarbar');
        -&#62; 4
mysql&#62; select LOCATE('xbar', 'foobar');
        -&#62; 0
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1150"></A>
<DT><CODE>LOCATE(substr,str,pos)</CODE>
<DD>
文字列 <CODE>str</CODE> 中に最初に顕れた <CODE>substr</CODE> 文字の位置を返します。
<CODE>pos</CODE> は検索を開始する位置です。
<CODE>str</CODE> に <CODE>substr</CODE> がなければ <CODE>0</CODE> を返します:


<PRE>
mysql&#62; select LOCATE('bar', 'foobarbar',5);
        -&#62; 7
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1151"></A>
<DT><CODE>INSTR(str,substr)</CODE>
<DD>
文字列 <CODE>str</CODE> 内の最初の文字列 <CODE>substr</CODE> の位置を返します。
これは引数が入れ替わっていることをのぞいて、
2つの引数を与えた <CODE>LOCATE</CODE> と同じです:


<PRE>
mysql&#62; select INSTR('foobarbar', 'bar');
        -&#62; 4
mysql&#62; select INSTR('xbar', 'foobar');
        -&#62; 0
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1152"></A>
<DT><CODE>LPAD(str,len,padstr)</CODE>
<DD>
<CODE>str</CODE> の長さが <CODE>len</CODE> になるまで文字列 <CODE>str</CODE> の始めに <CODE>padstr</CODE> を埋めます。
<CODE>str</CODE> が <CODE>len</CODE> よりも長い場合は、<CODE>len</CODE> 文字に短くされます。


<PRE>
mysql&#62; select LPAD('hi',4,'??');
        -&#62; '??hi'
</PRE>

<A NAME="IDX1153"></A>
<DT><CODE>RPAD(str,len,padstr)</CODE>
<DD>
<CODE>str</CODE> の長さが <CODE>len</CODE> になるまで文字列 <CODE>str</CODE> の終わりに <CODE>padstr</CODE> を埋めます。
<CODE>str</CODE> が <CODE>len</CODE> よりも長い場合は、<CODE>len</CODE> 文字に短くされます。


<PRE>
mysql&#62; select RPAD('hi',5,'?');
        -&#62; 'hi???'
</PRE>

<A NAME="IDX1154"></A>
<DT><CODE>LEFT(str,len)</CODE>
<DD>
文字列 <CODE>str</CODE> の最初から <CODE>len</CODE> 個の文字を得ます:


<PRE>
mysql&#62; select LEFT('foobarbar', 5);
        -&#62; 'fooba'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1155"></A>
<DT><CODE>RIGHT(str,len)</CODE>
<DD>
文字列 <CODE>str</CODE> の最後から <CODE>len</CODE> 個の文字を得ます:


<PRE>
mysql&#62; select RIGHT('foobarbar', 4);
        -&#62; 'rbar'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1156"></A>
<A NAME="IDX1157"></A>
<DT><CODE>SUBSTRING(str,pos,len)</CODE>
<DD>
<DT><CODE>SUBSTRING(str FROM pos FOR len)</CODE>
<DD>
<DT><CODE>MID(str,pos,len)</CODE>
<DD>
<CODE>str</CODE> の <CODE>pos</CODE> 位置から <CODE>len</CODE> 文字数分の文字列を返します。
<CODE>FROM</CODE> の違いは ANSI SQL 92 構文です:


<PRE>
mysql&#62; select SUBSTRING('Quadratically',5,6);
        -&#62; 'ratica'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1158"></A>
<DT><CODE>SUBSTRING(str,pos)</CODE>
<DD>
<DT><CODE>SUBSTRING(str FROM pos)</CODE>
<DD>
文字列 <CODE>str</CODE> の 位置 <CODE>pos</CODE> 以降の文字を返します:


<PRE>
mysql&#62; select SUBSTRING('Quadratically',5);
        -&#62; 'ratically'
mysql&#62; select SUBSTRING('foobarbar' FROM 4);
        -&#62; 'barbar'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1159"></A>
<DT><CODE>SUBSTRING_INDEX(str,delim,count)</CODE>
<DD>
<CODE>str</CODE> から、区切り文字 <CODE>delim</CODE> が <CODE>count</CODE> 個現れた位置から前の
文字列を返します。<CODE>count</CODE> が正の場合は文字列は左から検索され、
<CODE>count</CODE> が負の場合は文字列は右から検索されます:


<PRE>
mysql&#62; select SUBSTRING_INDEX('www.mysql.com', '.', 2);
        -&#62; 'www.mysql'
mysql&#62; select SUBSTRING_INDEX('www.mysql.com', '.', -2);
        -&#62; 'mysql.com'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1160"></A>
<DT><CODE>LTRIM(str)</CODE>
<DD>
文字列 <CODE>str</CODE> の最初から空白文字を削除します:


<PRE>
mysql&#62; select LTRIM('  barbar');
        -&#62; 'barbar'
</PRE>

<A NAME="IDX1161"></A>
<DT><CODE>RTRIM(str)</CODE>
<DD>
文字列 <CODE>str</CODE> の最後から空白文字を削除します:


<PRE>
mysql&#62; select RTRIM('barbar   ');
        -&#62; 'barbar'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1162"></A>
<DT><CODE>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</CODE>
<DD>
全ての <CODE>remstr</CODE> プレフィックスまたはサフィックスを  <CODE>str</CODE> から削除した
文字列を返します。<CODE>BOTH</CODE>, <CODE>LEADING</CODE> そして <CODE>TRAILING</CODE> が
使用されない場合、<CODE>BOTH</CODE> が適用されます。<CODE>remstr</CODE> が与えられないと、
空白が削除されます:


<PRE>
mysql&#62; select TRIM('  bar   ');
        -&#62; 'bar'
mysql&#62; select TRIM(LEADING 'x' FROM 'xxxbarxxx');
        -&#62; 'barxxx'
mysql&#62; select TRIM(BOTH 'x' FROM 'xxxbarxxx');
        -&#62; 'bar'
mysql&#62; select TRIM(TRAILING 'xyz' FROM 'barxxyz');
        -&#62; 'barx'
</PRE>

This function is multi-byte safe.

<A NAME="IDX1163"></A>
<DT><CODE>SOUNDEX(str)</CODE>
<DD>
<CODE>str</CODE> からの soundex 文字列を返します。発音が``大体同じ''２つの文字列
は同じ soundex 文字列を持ちます。``標準の'' soundex 文字列は4文字長ですが、
<CODE>SOUNDEX()</CODE> 関数は任意の長さの文字列を返します。<CODE>SUBSTRING()</CODE> を
結果に使用して、``標準の'' soundex 文字列を得ることができます。与えられた
文字列中の非アルファベット文字は無視されます。A-Z の半以外のすべての国際的
なアルファベット文字は母音とみなされます:


<PRE>
mysql&#62; select SOUNDEX('Hello');
        -&#62; 'H400'
mysql&#62; select SOUNDEX('Quadratically');
        -&#62; 'Q36324'
</PRE>

<A NAME="IDX1164"></A>
<DT><CODE>SPACE(N)</CODE>
<DD>
<CODE>N</CODE> 個の空白文字を返します:


<PRE>
mysql&#62; select SPACE(6);
        -&#62; '      '
</PRE>

<A NAME="IDX1165"></A>
<DT><CODE>REPLACE(str,from_str,to_str)</CODE>
<DD>
文字列 <CODE>str</CODE> 内の全ての文字列 <CODE>from_str</CODE> を <CODE>to_str</CODE> に
置き換えます:


<PRE>
mysql&#62; select REPLACE('www.mysql.com', 'w', 'Ww');
        -&#62; 'WwWwWw.mysql.com'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1166"></A>
<DT><CODE>REPEAT(str,count)</CODE>
<DD>
<CODE>str</CODE> を <CODE>count</CODE> 回繰り返します。<CODE>count &#60;= 0</CODE> の場合は
空の文字列を返します。<CODE>str</CODE> または <CODE>count</CODE> が <CODE>NULL</CODE> 
または、<CODE>LENGTH(str)*count &#62; max_allowed_packet</CODE> の場合は 
<CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; select REPEAT('MySQL', 3);
        -&#62; 'MySQLMySQLMySQL'
</PRE>

<A NAME="IDX1167"></A>
<DT><CODE>REVERSE(str)</CODE>
<DD>
文字列 <CODE>str</CODE> を反転します:


<PRE>
mysql&#62; select REVERSE('abc');
        -&#62; 'cba'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1168"></A>
<DT><CODE>INSERT(str,pos,len,newstr)</CODE>
<DD>
<CODE>str</CODE> 中の <CODE>pos</CODE> 位置から <CODE>len</CODE> 長の文字列を 
<CODE>newstr</CODE> で置き換えます。<CODE>str</CODE> 内の最初の位置は1です:


<PRE>
mysql&#62; select INSERT('Quadratic', 3, 4, 'What');
        -&#62; 'QuWhattic'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1169"></A>
<DT><CODE>ELT(N,str1,str2,str3,...)</CODE>
<DD>
<CODE>N</CODE> = <CODE>1</CODE> なら <CODE>str1</CODE> を、<CODE>N</CODE> = <CODE>2</CODE> なら <CODE>str2</CODE> を
返します。
<CODE>N</CODE> が <CODE>1</CODE> より小さい場合、または引数の数より大きい場合は <CODE>NULL</CODE> 
が返されます。
<CODE>ELT()</CODE> は <CODE>FIELD()</CODE> の逆です:


<PRE>
mysql&#62; select ELT(1, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'ej'
mysql&#62; select ELT(4, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'foo'
</PRE>

<A NAME="IDX1170"></A>
<DT><CODE>FIELD(str,str1,str2,str3,...)</CODE>
<DD>
<CODE>str1</CODE>, <CODE>str2</CODE>, <CODE>str3</CODE>, <CODE>...</CODE> リスト内の <CODE>str</CODE> のインデ
ックスを
返します。<CODE>str</CODE> が見つからなければ <CODE>0</CODE> を返します。
<CODE>FIELD()</CODE> は <CODE>ELT()</CODE> の逆です:


<PRE>
mysql&#62; select FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 2
mysql&#62; select FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 0
</PRE>

<A NAME="IDX1171"></A>
<DT><CODE>FIND_IN_SET(str,strlist)</CODE>
<DD>
<CODE>str</CODE> が <CODE>strlist</CODE> 中にあれば、値 <CODE>1</CODE> から <CODE>N</CODE> を返します。
<CODE>strlist</CODE> は、それぞれの異なる値が ',' で分割された文字列です。最初の
引数が定数文字列で２番目が <CODE>SET</CODE> 型のフィールドの場合<CODE>FIND_IN_SET</CODE> は
ビット演算を使用して最適化されます！
<CODE>strlist</CODE> が空文字なら <CODE>0</CODE> を返します。
どちらかの引数が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します.
この関数は最初の引数が  ',' を含んだ場合、うまく動かないでしょう:


<PRE>
mysql&#62; SELECT FIND_IN_SET('b','a,b,c,d');
        -&#62; 2
</PRE>

<A NAME="IDX1172"></A>
<DT><CODE>MAKE_SET(bits,str1,str2,...)</CODE>
<DD>
<CODE>bits</CODE> に指定されたビットに対応する文字列のセットを返します。
(文字列が複数の場合、 <SAMP>`,'</SAMP> で区切られます) 
<CODE>str1</CODE> が ビット 0 に対応し、<CODE>str2</CODE> が ビット 1 に対応し、
<CODE>str3</CODE> が ビット 2 に対応し... となります。
<CODE>str1</CODE>, <CODE>str2</CODE>, <CODE>...</CODE> 中に含まれている <CODE>NULL</CODE> 文字は
結果には追加されません:


<PRE>
mysql&#62; SELECT MAKE_SET(1,'a','b','c');
        -&#62; 'a'
mysql&#62; SELECT MAKE_SET(1 | 4,'hello','nice','world');
        -&#62; 'hello,world'
mysql&#62; SELECT MAKE_SET(0,'a','b','c');
        -&#62; ''
</PRE>

<A NAME="IDX1173"></A>
<DT><CODE>EXPORT_SET(bits,on,off,[separator,[number_of_bits]])</CODE>
<DD>
'bits' に与えられた数値に対し、
全てのセットされているビットを 'on' で指定された文字で表し、
リセットされているビットを 'off' で指定された文字で表した文字列を返します。
それぞれの文字は 'separator' (デフォルト',') で示された文字で区切られ、
'number_of_bits' (default 64) に与えられた桁数だけのビットを表示します:


<PRE>
mysql&#62; select EXPORT_SET(5,'Y','N',',',4)
        -&#62; Y,N,Y,N
</PRE>

<A NAME="IDX1174"></A>
<A NAME="IDX1175"></A>
<DT><CODE>LCASE(str)</CODE>
<DD>
<DT><CODE>LOWER(str)</CODE>
<DD>
<CODE>str</CODE> を現在のキャラクターセットマッピング
 (デフォルト ISO-8859-1 Latin1) にしたがって小文字に変換します:


<PRE>
mysql&#62; select LCASE('QUADRATICALLY');
        -&#62; 'quadratically'
</PRE>

This function is multi-byte safe.

<A NAME="IDX1176"></A>
<A NAME="IDX1177"></A>
<DT><CODE>UCASE(str)</CODE>
<DD>
<DT><CODE>UPPER(str)</CODE>
<DD>
<CODE>str</CODE> を現在のキャラクターセットマッピング
 (デフォルト ISO-8859-1 Latin1) にしたがって大文字に変換します:


<PRE>
mysql&#62; select UCASE('Hej');
        -&#62; 'HEJ'
</PRE>

This function is multi-byte safe.

<A NAME="IDX1178"></A>
<A NAME="IDX1179"></A>
<DT><CODE>LOAD_FILE(file_name)</CODE>
<DD>
ファイルを読み込み、ファイルの中身を文字として返します。 ファイルは
サーバー上になくてはならず、ファイルをフルパスで指定しなければなりません。
そして、 <STRONG>file</STRONG> 権限がなければなりません。 ファイルは全員に
読み込み可能でなければならず、そして、 <CODE>max_allowed_packet</CODE> より
小さいサイズでなければなりません。

このうちどれかの理由で、もしファイルが存在しないか読み込めない場合、
この関数は <CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; UPDATE table_name
           SET blob_column=LOAD_FILE("/tmp/picture")
           WHERE id=1;
</PRE>

</DL>

<P>
<STRONG>MySQL 3.23</STRONG> を使用していない場合、あなたのアプリケーション内部でファ
イルを読み込んで、ファイル情報でデータベースを更新するための 
<CODE>INSERT</CODE> ステートメントを生成する必要があります。これを行なう一つの方
法は、<STRONG>MySQL</STRONG>++ ライブラリを使用する場合、
<a HREF="http://www.mysql.com/documentation/mysql++/mysql++-examples.html">http://www.mysql.com/documentation/mysql++/mysql++-examples.html</a> で
見つけられます。

</P>
<P>
<STRONG>MySQL</STRONG> は必要とあらば数値を文字列に変換します。
逆も同様に行います：

</P>

<PRE>
mysql&#62; SELECT 1+"1";
        -&#62; 2
mysql&#62; SELECT CONCAT(2,' test');
        -&#62; '2 test'
</PRE>

<P>
明示的に数値を文字列に変換したければ、<CODE>CONCAT()</CODE> に引数として渡して下
さい。

</P>
<P>
文字列関数は引数としてバイナリ文字列が与えられると、結果の文字列もバイナリ
文字列になります。文字列に変換された数値はバイナリ文字列とみなされます。こ
れは比較にだけ影響します。

</P>



<H4><A NAME="String_comparison_functions" HREF="manual.ja_toc.html#String_comparison_functions">6.3.2.1  文字列比較関数</A></H4>

<P>
<A NAME="IDX1180"></A>
<A NAME="IDX1181"></A>

</P>
<P>
<A NAME="IDX1182"></A>
<A NAME="IDX1183"></A>

</P>
<P>
通常、比較される表現がケース依存でない場合、比較はケース非依存で行われます。

</P>
<DL COMPACT>

<DT><CODE>expr LIKE pat [ESCAPE 'escape-char']</CODE>
<DD>
<A NAME="IDX1184"></A>
 
SQL の簡単な正規表現比較です。<CODE>1</CODE> (TRUE) または <CODE>0</CODE> (FALSE) を返します
。
<CODE>LIKE</CODE> には2つのワイルドカードがあります:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>%</CODE> </TD><TD> 任意の数の文字(0文字も含む)に適合します。
</TR NOSAVE>
<TR><TD><CODE>_</CODE> </TD><TD> 厳密に1つの文字に適合します。
</TR>
</TABLE>


<PRE>
mysql&#62; select 'David!' LIKE 'David_';
        -&#62; 1
mysql&#62; select 'David!' LIKE '%D%v%';
        -&#62; 1
</PRE>

ワイルドカード文字のテストをするためには、エスケープ文字より先行しておこなって
ください。
<CODE>ESCAPE</CODE> を指定しない場合は、文字 <CODE>'\'</CODE> が使われます:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>\%</CODE> </TD><TD> 1つの <CODE>%</CODE> に適合します。
</TR NOSAVE>
<TR><TD><CODE>\_</CODE> </TD><TD> 1つの <CODE>_</CODE> に適合します。
</TR>
</TABLE>


<PRE>
mysql&#62; select 'David!' LIKE 'David\_';
        -&#62; 0
mysql&#62; select 'David_' LIKE 'David\_';
        -&#62; 1
</PRE>

違うエスケープ文字を指定するには、 <CODE>ESCAPE</CODE> 節を使用します:


<PRE>
mysql&#62; select 'David_' LIKE 'David|_' ESCAPE '|';
        -&#62; 1
</PRE>

次の２つのステートメントは、オペランドの一つがバイナリ文字列でなければ、文
字列比較がケース非依存であることを示しています:


<PRE>
mysql&#62; select 'abc' LIKE 'ABC';
        -&#62; 1
mysql&#62; SELECT 'abc' LIKE BINARY 'ABC';
        -&#62; 0
</PRE>

<CODE>LIKE</CODE> は数値表現でも許されます！
(これは <STRONG>MySQL</STRONG> の、ANSI SQL <CODE>LIKE</CODE> に対する拡張です)

注意： <STRONG>MySQL</STRONG> は文字列中に C のエスケープ文字を使用しているので(e.g.,
<SAMP>`\n'</SAMP>),  <CODE>LIKE</CODE> の指定文字列として使用するには <SAMP>`\'</SAMP> を
二倍しなくてはなりません。 例えば、 <SAMP>`\n'</SAMP> を探すには、<SAMP>`\\n'</SAMP> と
記述します。 <SAMP>`\'</SAMP> を探すには、  <SAMP>`\\\\'</SAMP> (バックスラッシュは、
一つはパーサーに取り除かれ、パターンマッチが行われる際にもうひとつ
取り除かれ、一致を探すために残った一つのバックスラッシュが使用されます)

<A NAME="IDX1185"></A>
<DT><CODE>expr NOT LIKE pat [ESCAPE 'escape-char']</CODE>
<DD>
<CODE>NOT (expr LIKE pat [ESCAPE 'escape-char'])</CODE> と同じ

<A NAME="IDX1186"></A>
<A NAME="IDX1187"></A>
<A NAME="IDX1188"></A>
<A NAME="IDX1189"></A>
<DT><CODE>expr REGEXP pat</CODE>
<DD>
<DT><CODE>expr RLIKE pat</CODE>
<DD>
パターン <CODE>pat</CODE> に対し、文字式 <CODE>expr</CODE> のパターンマッチを行います。
パターン <CODE>pat</CODE> は正規表現の拡張が使用できます。 「<A HREF="manual.ja_Regexp.html#Regexp">I  MySQL の正規表現の文法について</A>」節参照.
もし <CODE>expr</CODE> が <CODE>pat</CODE> にマッチするなら <CODE>1</CODE> を返し、
でなければ <CODE>0</CODE> を返します。
<CODE>RLIKE</CODE> は <CODE>REGEXP</CODE> と同義で、<CODE>mSQL</CODE> 互換を提供します。
注意: <STRONG>MySQL</STRONG> は C エスケープ構文を文字中に使用しており(<CODE>\n</CODE>)、
 <CODE>REGEXP</CODE> 中で使用される <CODE>'\'</CODE> 文字はすべて、二重に書かなければ
なりません。
<STRONG>MySQL</STRONG> 3.23.4 <CODE>REGEXP</CODE> は、普通の文字 (not binary) はケース非依存で
す:


<PRE>
mysql&#62; select 'Monty!' REGEXP 'm%y%%';
        -&#62; 0
mysql&#62; select 'Monty!' REGEXP '.*';
        -&#62; 1
mysql&#62; select 'new*\n*line' REGEXP 'new\\*.\\*line';
        -&#62; 1
mysql&#62; select "a" REGEXP "A", "a" REGEXP BINARY "A";
        -&#62; 1  0
mysql&#62; select "a" REGEXP "^[a-d]";
        -&#62; 1
</PRE>

<DT><CODE></CODE>
<DD>
<CODE>REGEXP</CODE> and <CODE>RLIKE</CODE> は、文字の型を決定する場合、
カレントのキャラクターセットを使用します。
(ISO-8859-1 Latin1 がデフォルト)

<A NAME="IDX1190"></A>
<DT><CODE>expr NOT REGEXP pat</CODE>
<DD>
<DT><CODE>expr NOT RLIKE pat</CODE>
<DD>
<CODE>NOT (expr REGEXP pat)</CODE> と同じ.

<A NAME="IDX1191"></A>
<DT><CODE>STRCMP(expr1,expr2)</CODE>
<DD>
<CODE>STRCMP()</CODE>
文字列が同じなら <CODE>0</CODE> を返します。そうでなければ、最初の引数がソート順で小
さければ <CODE>-1</CODE> を返します。そうでなければ <CODE>1</CODE> を返します:


<PRE>
mysql&#62; select STRCMP('text', 'text2');
        -&#62; -1
mysql&#62; select STRCMP('text2', 'text');
        -&#62; 1
mysql&#62; select STRCMP('text', 'text');
        -&#62; 0
</PRE>

<A NAME="IDX1192"></A>
<DT><CODE>MATCH (col1,col2,...) AGAINST (expr)</CODE>
<DD>
<CODE>MATCH ... AGAINST()</CODE> は全文検索に使用され、妥当性を返します。フィー
ルド <CODE>(col1,col2,...)</CODE> 内のテキストとクエリ <CODE>expr</CODE> との間の類似
点を評価します。妥当性は正の浮動小数点数です。妥当性 0 は類似点なしを意味
します。<CODE>MATCH ... AGAINST()</CODE> が動作するためには、最初に 
<STRONG>FULLTEXT</STRONG> インデックスが作成する必要があります。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照。
<CODE>MATCH ... AGAINST()</CODE> は <STRONG>MySQL</STRONG> 3.23.23 以上のバージョンで有
効です。詳細と使用例は
 「<A HREF="manual.ja_Reference.html#Fulltext_Search">6.8  MySQL Full-text Search</A>」節参照.
</DL>



<H4><A NAME="Case_Sensitivity_Operators" HREF="manual.ja_toc.html#Case_Sensitivity_Operators">6.3.2.2  Case Sensitivity</A></H4>

<P>
<A NAME="IDX1193"></A>

</P>
<P>
<A NAME="IDX1194"></A>
<A NAME="IDX1195"></A>

</P>
<DL COMPACT>

<DT><CODE><CODE>BINARY</CODE></CODE>
<DD>
<A NAME="IDX1196"></A>
 
<CODE>BINARY</CODE> 演算子は、これ以降に続く文字をバイナリにキャストします。
これはたとえフィールドが <CODE>BINARY</CODE> や <CODE>BLOB</CODE> 定義でなくても、
ケース依存でフィールドを比較することが出来る簡単な方法です:

<PRE>
mysql&#62; select "a" = "A";
        -&#62; 1
mysql&#62; select BINARY "a" = "A";
        -&#62; 0
</PRE>

<CODE>BINARY</CODE> は <STRONG>MySQL</STRONG> 3.23.0 で登場しました。

注意: いくつかの文脈では、インデックスされたフィールドを <CODE>BINARY</CODE> に
キャストした時、<STRONG>MySQL</STRONG> はインデックスを効率よく使用できません。
</DL>

<P>
BLOB をケース非依存で比較したい場合、比較を行なう前に BLOB を常に大文字に
変換します:

</P>

<PRE>
SELECT 'A' LIKE UPPER(blob_col) FROM table_name;
</PRE>

<P>
より柔軟に文字列を比較するために、我々は間もなく異なる文字セット間のキャス
トを導入する予定です。

</P>



<H3><A NAME="Numeric_Functions" HREF="manual.ja_toc.html#Numeric_Functions">6.3.3  Numeric Functions</A></H3>



<H4><A NAME="Arithmetic_functions" HREF="manual.ja_toc.html#Arithmetic_functions">6.3.3.1  算術演算</A></H4>

<P>
普通の算術演算が有効です。
<CODE>-</CODE>, <CODE>+</CODE>, <CODE>*</CODE> は、二つの引数が正数ならば
 <CODE>BIGINT</CODE> (64bit精度) で計算されることに注意してください！

</P>
<P>
<A NAME="IDX1197"></A>
<A NAME="IDX1198"></A>
<DL COMPACT>

<DT><CODE>+</CODE>
<DD>
<A NAME="IDX1199"></A>
 <A NAME="IDX1200"></A>
 
足し算:

<PRE>
mysql&#62; select 3+5;
        -&#62; 8
</PRE>

<A NAME="IDX1201"></A>
<A NAME="IDX1202"></A>
<DT><CODE>-</CODE>
<DD>
引き算:

<PRE>
mysql&#62; select 3-5;
        -&#62; -2
</PRE>

<A NAME="IDX1203"></A>
<A NAME="IDX1204"></A>
<DT><CODE>*</CODE>
<DD>
掛け算:

<PRE>
mysql&#62; select 3*5;
        -&#62; 15
mysql&#62; select 18014398509481984*18014398509481984.0;
        -&#62; 324518553658426726783156020576256.0
mysql&#62; select 18014398509481984*18014398509481984;
        -&#62; 0
</PRE>

最後の式の結果は不当です。なぜなら結果は 64 ビットを超えた整数だからです。

<A NAME="IDX1205"></A>
<A NAME="IDX1206"></A>
<DT><CODE>/</CODE>
<DD>
割り算:

<PRE>
mysql&#62; select 3/5;
        -&#62; 0.60
</PRE>

0 で割った場合、<CODE>NULL</CODE> になります。


<PRE>
mysql&#62; select 102/(1-1);
        -&#62; NULL
</PRE>

演算結果が整数になる場合にだけ、 <CODE>BIGINT</CODE> を用いて割り算は計算されます。
</DL>



<H4><A NAME="Mathematical_functions" HREF="manual.ja_toc.html#Mathematical_functions">6.3.3.2  数学関数</A></H4>
<P>
すべての数学関数はエラーの場合 <CODE>NULL</CODE> を返します。

</P>
<P>
<A NAME="IDX1207"></A>
<A NAME="IDX1208"></A>

</P>
<DL COMPACT>

<DT><CODE>-</CODE>
<DD>
<A NAME="IDX1209"></A>
 <A NAME="IDX1210"></A>
 <A NAME="IDX1211"></A>
 
符号。引数の符号を変更します:

<PRE>
mysql&#62; select - 2;
        -&#62; -2
</PRE>

このオペレーターが <CODE>BIGINT</CODE> とともに使用された場合、
返り値は <CODE>BIGINT</CODE> であることに注意してください!  これは <CODE>-2^63</CODE> の値を
持つかもしれない整数を、 <CODE>-</CODE> で使用してはならないことを意味します！

<A NAME="IDX1212"></A>
<DT><CODE>ABS(X)</CODE>
<DD>
Returns the absolute value of <CODE>X</CODE>:

<PRE>
mysql&#62; select ABS(2);
        -&#62; 2
mysql&#62; select ABS(-32);
        -&#62; 32
</PRE>

この関数は <CODE>BIGINT</CODE> 値とともに使用されると安全です。

<A NAME="IDX1213"></A>
<DT><CODE>SIGN(X)</CODE>
<DD>
<CODE>X</CODE> が負数、ゼロ、整数によって、 <CODE>-1</CODE>, <CODE>0</CODE> or <CODE>1</CODE> を
返します:

<PRE>
mysql&#62; select SIGN(-32);
        -&#62; -1
mysql&#62; select SIGN(0);
        -&#62; 0
mysql&#62; select SIGN(234);
        -&#62; 1
</PRE>

<A NAME="IDX1214"></A>
<A NAME="IDX1215"></A>
<A NAME="IDX1216"></A>
<DT><CODE>MOD(N,M)</CODE>
<DD>
<DT><CODE>%</CODE>
<DD>
剰余 ( C の <CODE>%</CODE> 演算子のような ).
<CODE>N</CODE> を <CODE>M</CODE> で割ったときの余りが返ります:

<PRE>
mysql&#62; select MOD(234, 10);
        -&#62; 4
mysql&#62; select 253 % 7;
        -&#62; 1
mysql&#62; select MOD(29,9);
        -&#62; 2
</PRE>

この関数は <CODE>BIGINT</CODE> 値でも安全に使用できます。

<A NAME="IDX1217"></A>
<DT><CODE>FLOOR(X)</CODE>
<DD>
<CODE>X</CODE> より大きくならない整数のうち、最大の整数値を返します:

<PRE>
mysql&#62; select FLOOR(1.23);
        -&#62; 1
mysql&#62; select FLOOR(-1.23);
        -&#62; -2
</PRE>

返り値は <CODE>BIGINT</CODE> に変換されていることに注意!

<A NAME="IDX1218"></A>
<DT><CODE>CEILING(X)</CODE>
<DD>
<CODE>X</CODE> より小さくならない整数のうち、最小の整数値を返します.

<PRE>
mysql&#62; select CEILING(1.23);
        -&#62; 2
mysql&#62; select CEILING(-1.23);
        -&#62; -1
</PRE>

返り値は <CODE>BIGINT</CODE> に変換されていることに注意!

<A NAME="IDX1219"></A>
<DT><CODE>ROUND(X)</CODE>
<DD>
<CODE>X</CODE> を整数に丸めた値(四捨五入)を返します:

<PRE>
mysql&#62; select ROUND(-1.23);
        -&#62; -1
mysql&#62; select ROUND(-1.58);
        -&#62; -2
mysql&#62; select ROUND(1.58);
        -&#62; 2
</PRE>

引数が２つの整数間の半分時の <CODE>ROUND()</CODE> の振る舞いは、C ライブラリの実
装に依存します。いくつかは、近い偶数値、常に上、常に下、または常に０方向に
丸めます。丸めの種類の一つを必要とする場合は、<CODE>TRUNCATE()</CODE> または 
<CODE>FLOOR()</CODE> のようなはっきりと定義された関数を代わりに使用すべきです。

<A NAME="IDX1220"></A>
<DT><CODE>ROUND(X,D)</CODE>
<DD>
<CODE>X</CODE> を <CODE>D</CODE> で指定した少数桁に丸めた値(四捨五入)を返します。
もし <CODE>D</CODE> が <CODE>0</CODE> なら, 結果は小数点無しになるか
少数部分になるでしょう:


<PRE>
mysql&#62; select ROUND(1.298, 1);
        -&#62; 1.3
mysql&#62; select ROUND(1.298, 0);
        -&#62; 1
</PRE>

<A NAME="IDX1221"></A>
<DT><CODE>EXP(X)</CODE>
<DD>
指数関数 : <CODE>e</CODE> (自然対数の底) の <CODE>X</CODE> 乗:

<PRE>
mysql&#62; select EXP(2);
        -&#62; 7.389056
mysql&#62; select EXP(-2);
        -&#62; 0.135335
</PRE>

<A NAME="IDX1222"></A>
<DT><CODE>LOG(X)</CODE>
<DD>
自然対数 <CODE>X</CODE>:

<PRE>
mysql&#62; select LOG(2);
        -&#62; 0.693147
mysql&#62; select LOG(-2);
        -&#62; NULL
</PRE>

任意の底 <CODE>B</CODE> に対する <CODE>X</CODE> の対数を得たければ、公式 
<CODE>LOG(X)/LOG(B)</CODE> を使用してください。

<A NAME="IDX1223"></A>
<DT><CODE>LOG10(X)</CODE>
<DD>
常用対数(10を底とした対数) <CODE>X</CODE>:

<PRE>
mysql&#62; select LOG10(2);
        -&#62; 0.301030
mysql&#62; select LOG10(100);
        -&#62; 2.000000
mysql&#62; select LOG10(-100);
        -&#62; NULL
</PRE>

<A NAME="IDX1224"></A>
<A NAME="IDX1225"></A>
<DT><CODE>POW(X,Y)</CODE>
<DD>
<DT><CODE>POWER(X,Y)</CODE>
<DD>
<CODE>X</CODE> の <CODE>Y</CODE> 乗:

<PRE>
mysql&#62; select POW(2,2);
        -&#62; 4.000000
mysql&#62; select POW(2,-2);
        -&#62; 0.250000
</PRE>

<A NAME="IDX1226"></A>
<DT><CODE>SQRT(X)</CODE>
<DD>
<CODE>X</CODE> の非負の平方根を返します:

<PRE>
mysql&#62; select SQRT(4);
        -&#62; 2.000000
mysql&#62; select SQRT(20);
        -&#62; 4.472136
</PRE>

<A NAME="IDX1227"></A>
<DT><CODE>PI()</CODE>
<DD>
π の値を返します。デフォルトの表示桁数は 5 ですが、<STRONG>MySQL</STRONG> 内部で
は π に完全な倍精度を使用します。

<PRE>
mysql&#62; select PI();
        -&#62; 3.141593
mysql&#62; SELECT PI()+0.000000000000000000;
        -&#62; 3.141592653589793116
</PRE>

<A NAME="IDX1228"></A>
<DT><CODE>COS(X)</CODE>
<DD>
コサイン <CODE>X</CODE>。<CODE>X</CODE> はラジアン:

<PRE>
mysql&#62; select COS(PI());
        -&#62; -1.000000
</PRE>

<A NAME="IDX1229"></A>
<DT><CODE>SIN(X)</CODE>
<DD>
サイン <CODE>X</CODE>。<CODE>X</CODE> はラジアン:

<PRE>
mysql&#62; select SIN(PI());
        -&#62; 0.000000
</PRE>

<A NAME="IDX1230"></A>
<DT><CODE>TAN(X)</CODE>
<DD>
タンジェント <CODE>X</CODE>。<CODE>X</CODE> はラジアン:

<PRE>
mysql&#62; select TAN(PI()+1);
        -&#62; 1.557408
</PRE>

<A NAME="IDX1231"></A>
<DT><CODE>ACOS(X)</CODE>
<DD>
<CODE>X</CODE> のアークコサインを返します。これはコサインが <CODE>X</CODE> である値で
す。<CODE>X</CODE> が <CODE>-1</CODE> から <CODE>1</CODE> の範囲にない場合は <CODE>NULL</CODE> を
返します:

<PRE>
mysql&#62; select ACOS(1);
        -&#62; 0.000000
mysql&#62; select ACOS(1.0001);
        -&#62; NULL
mysql&#62; select ACOS(0);
        -&#62; 1.570796
</PRE>

<A NAME="IDX1232"></A>
<DT><CODE>ASIN(X)</CODE>
<DD>
<CODE>X</CODE> のアークサインを返します。これはサインが <CODE>X</CODE> である値です。
<CODE>X</CODE> が <CODE>-1</CODE> から <CODE>1</CODE> の範囲にない場合は <CODE>NULL</CODE> を返し
ます:

<PRE>
mysql&#62; select ASIN(0.2);
        -&#62; 0.201358
mysql&#62; select ASIN('foo');
        -&#62; 0.000000
</PRE>

<A NAME="IDX1233"></A>
<DT><CODE>ATAN(X)</CODE>
<DD>
<CODE>X</CODE> のアークタンジェントを返します。これはタンジェントが <CODE>X</CODE> で
ある値です:

<PRE>
mysql&#62; select ATAN(2);
        -&#62; 1.107149
mysql&#62; select ATAN(-2);
        -&#62; -1.107149
</PRE>

<A NAME="IDX1234"></A>
<DT><CODE>ATAN(Y,X)</CODE>
<DD>
<DT><CODE>ATAN2(Y,X)</CODE>
<DD>
２つの変数 <CODE>X</CODE> と <CODE>Y</CODE> のアークタンジェントを返します。両方の引数
の符号が結果の象限を決定するために使用されることを除いて、<CODE>Y / X</CODE> の
アークタンジェントの計算と同様です:

<PRE>
mysql&#62; select ATAN(-2,2);
        -&#62; -0.785398
mysql&#62; select ATAN2(PI(),0);
        -&#62; 1.570796
</PRE>

<A NAME="IDX1235"></A>
<DT><CODE>COT(X)</CODE>
<DD>
<CODE>X</CODE> のコタンジェントを返します:

<PRE>
mysql&#62; select COT(12);
        -&#62; -1.57267341
mysql&#62; select COT(0);
        -&#62; NULL
</PRE>

<A NAME="IDX1236"></A>
<DT><CODE>RAND()</CODE>
<DD>
<DT><CODE>RAND(N)</CODE>
<DD>
<CODE>0</CODE> から <CODE>1.0</CODE> 間のランダムな浮動小数点数値を返します。
もし <CODE>N</CODE> に整数を与えた場合、シードとしてこの値が使用されます:

<PRE>
mysql&#62; select RAND();
        -&#62; 0.5925
mysql&#62; select RAND(20);
        -&#62; 0.1811
mysql&#62; select RAND(20);
        -&#62; 0.1811
mysql&#62; select RAND();
        -&#62; 0.2079
mysql&#62; select RAND();
        -&#62; 0.7888
</PRE>

<CODE>RAND()</CODE> 値を持つフィールドは <CODE>ORDER BY</CODE> 節で使用できません。
<CODE>ORDER BY</CODE> はフィールドを複数回評価するためです。

しかし <STRONG>MySQL</STRONG> バージョン 3.23 では, 次が可能です:
<CODE>SELECT * FROM table_name ORDER BY RAND()</CODE>

これは <CODE>SELECT * FROM table1,table2 WHERE a=b AND c&#60;d ORDER BY
RAND() LIMIT 1000</CODE> のセットからランダムなサンプルを得るのに便利です。

注意: <CODE>WHERE</CODE> 節の <CODE>RAND()</CODE> は <CODE>WHERE</CODE> が実行する度に再評価
されます。

<A NAME="IDX1237"></A>
<DT><CODE>LEAST(X,Y,...)</CODE>
<DD>
二つ以上の引数を取り、引数中、最小の値を返します。
引数は以下の規則に従って比較されます：


<UL>
<LI>

値が <CODE>INTEGER</CODE> を使用しているなら、あるいは、全ての引数が
整数値ならば、整数として比較します。

<LI>

値が <CODE>REAL</CODE> として使用されているか、全ての引数が実数ならば、
実数として比較します。

<LI>

いかなる引数もケース依存の文字ならば、引数はケース依存文字として比較されます。

<LI>

そのほかの場合、引数はケース非依存文字として比較されます:
</UL>


<PRE>
mysql&#62; select LEAST(2,0);
        -&#62; 0
mysql&#62; select LEAST(34.0,3.0,5.0,767.0);
        -&#62; 3.0
mysql&#62; select LEAST("B","A","C");
        -&#62; "A"
</PRE>

バージョン 3.22.5 以前の <STRONG>MySQL</STRONG> では、<CODE>MIN()</CODE> を <CODE>LEAST</CODE> の代
わりに使用できます。

<A NAME="IDX1238"></A>
<DT><CODE>GREATEST(X,Y,...)</CODE>
<DD>
二つ以上の引数を取り、引数中、最大の値を返します。
引数は <CODE>LEAST</CODE> の時と同じように比較されます。

<PRE>
mysql&#62; select GREATEST(2,0);
        -&#62; 2
mysql&#62; select GREATEST(34.0,3.0,5.0,767.0);
        -&#62; 767.0
mysql&#62; select GREATEST("B","A","C");
        -&#62; "C"
</PRE>

バージョン 3.22.5 以前の <STRONG>MySQL</STRONG> では、<CODE>MAX()</CODE> を <CODE>GREATEST</CODE> の
代わりに使用できます。

<A NAME="IDX1239"></A>
<DT><CODE>DEGREES(X)</CODE>
<DD>
引数 <CODE>X</CODE> をラジアンから度に変換して返します:

<PRE>
mysql&#62; select DEGREES(PI());
        -&#62; 180.000000
</PRE>

<A NAME="IDX1240"></A>
<DT><CODE>RADIANS(X)</CODE>
<DD>
引数 <CODE>X</CODE> を度からラジアンに変換して返します:

<PRE>
mysql&#62; select RADIANS(90);
        -&#62; 1.570796
</PRE>

<A NAME="IDX1241"></A>
<DT><CODE>TRUNCATE(X,D)</CODE>
<DD>
少数点以下 <CODE>D</CODE> 桁で <CODE>X</CODE> を切り捨てた値を返します。
<CODE>D</CODE> が <CODE>0</CODE> の場合、結果は小数部や微小部を持ちません:

<PRE>
mysql&#62; select TRUNCATE(1.223,1);
        -&#62; 1.2
mysql&#62; select TRUNCATE(1.999,1);
        -&#62; 1.9
mysql&#62; select TRUNCATE(1.999,0);
        -&#62; 1
</PRE>

注意: コンピュータでは小数点数は正確な数値としては格納されず、double 値と
して格納されます。次の結果によってだまされるでしょう:

<A NAME="IDX1242"></A>

<PRE>
mysql&#62; select TRUNCATE(10.28*100,0);
       -&#62; 1027
</PRE>

上記は 10.28 は実際には 10.2799999999999999 のようなものとして格納さえるた
めに発生します。
</DL>



<H3><A NAME="Date_and_time_functions" HREF="manual.ja_toc.html#Date_and_time_functions">6.3.4  日付と時刻関数</A></H3>

<P>
<A NAME="IDX1243"></A>
<A NAME="IDX1244"></A>

</P>
<P>
それぞれの型がもつ値の範囲と日と時間の値が記述される有効な形式については
  「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節. 

</P>
<P>
日付関数を使用する例:
<CODE>date_col</CODE> が最新の30日である全てのレコードを選択します:

</P>

<PRE>
mysql&#62; SELECT something FROM table
           WHERE TO_DAYS(NOW()) - TO_DAYS(date_col) &#60;= 30;
</PRE>

<DL COMPACT>

<DT><CODE>DAYOFWEEK(date)</CODE>
<DD>
<A NAME="IDX1245"></A>
 
Returns the weekday index

<CODE>date</CODE> の曜日を得ます (<CODE>1</CODE> = 日曜日, <CODE>2</CODE> = 月曜日, ... <CODE>7</CODE> =
 土曜日)
これは ODBC 標準に従います:


<PRE>
mysql&#62; select DAYOFWEEK('1998-02-03');
        -&#62; 3
</PRE>

<A NAME="IDX1246"></A>
<DT><CODE>WEEKDAY(date)</CODE>
<DD>
<CODE>date</CODE> の曜日を得ます (<CODE>0</CODE> = 月曜日, <CODE>1</CODE> = 火曜日, ... <CODE>6</CODE> =
 日曜日):


<PRE>
mysql&#62; select WEEKDAY('1997-10-04 22:23:00');
        -&#62; 5
mysql&#62; select WEEKDAY('1997-11-05');
        -&#62; 2
</PRE>

<A NAME="IDX1247"></A>
<DT><CODE>DAYOFMONTH(date)</CODE>
<DD>
月の日を返します (<CODE>1</CODE> - <CODE>31</CODE>):


<PRE>
mysql&#62; select DAYOFMONTH('1998-02-03');
        -&#62; 3
</PRE>

<A NAME="IDX1248"></A>
<DT><CODE>DAYOFYEAR(date)</CODE>
<DD>
年の日を返します (<CODE>1</CODE>-<CODE>366</CODE>):
<CODE>366</CODE>:


<PRE>
mysql&#62; select DAYOFYEAR('1998-02-03');
        -&#62; 34
</PRE>

<A NAME="IDX1249"></A>
<DT><CODE>MONTH(date)</CODE>
<DD>
月を返します (<CODE>1</CODE> - <CODE>12</CODE>):


<PRE>
mysql&#62; select MONTH('1998-02-03');
        -&#62; 2
</PRE>

<A NAME="IDX1250"></A>
<DT><CODE>DAYNAME(date)</CODE>
<DD>
曜日の名前を返します:


<PRE>
mysql&#62; select DAYNAME("1998-02-05");
        -&#62; 'Thursday'
</PRE>

<A NAME="IDX1251"></A>
<DT><CODE>MONTHNAME(date)</CODE>
<DD>
月の名前を返します:


<PRE>
mysql&#62; select MONTHNAME("1998-02-05");
        -&#62; 'February'
</PRE>

<A NAME="IDX1252"></A>
<DT><CODE>QUARTER(date)</CODE>
<DD>
<CODE>date</CODE> についての年の四半期を返します。範囲は <CODE>1</CODE> から 
<CODE>4</CODE> です:


<PRE>
mysql&#62; select QUARTER('98-04-01');
        -&#62; 2
</PRE>

<A NAME="IDX1253"></A>
<DT><CODE>WEEK(date)</CODE>
<DD>
<DT><CODE>WEEK(date,first)</CODE>
<DD>
引数が一つの場合、<CODE>date</CODE> についての週を返します。範囲は <CODE>0</CODE> から 
<CODE>53</CODE> (そう、53週の最初というのもありえます)で、日曜日が週の
最初の日です。引数が二つの形式の <CODE>WEEK()</CODE> は、週の開始を日曜日か月曜
日か指定できます。第2引数が <CODE>0</CODE> の場合、週の開始は日曜日です。第2引数
が <CODE>1</CODE> の場合、週の開始は月曜日です:


<PRE>
mysql&#62; select WEEK('1998-02-20');
        -&#62; 7
mysql&#62; select WEEK('1998-02-20',0);
        -&#62; 7
mysql&#62; select WEEK('1998-02-20',1);
        -&#62; 8
mysql&#62; select WEEK('1998-12-31',1);
        -&#62; 53
</PRE>

<A NAME="IDX1254"></A>
<DT><CODE>YEAR(date)</CODE>
<DD>
年を返します (<CODE>1000</CODE> - <CODE>9999</CODE>):


<PRE>
mysql&#62; select YEAR('98-02-03');
        -&#62; 1998
</PRE>

<DT><CODE>YEARWEEK(date)</CODE>
<DD>
<DT><CODE>YEARWEEK(date,first)</CODE>
<DD>
データの年と週を返します。第2引数は <CODE>WEEK()</CODE> の第2引数とまったく同じ
ように働きます。注意: 年の最初と最後の週では、年が date 引数内の年とは異な
ることがあります！


<PRE>
mysql&#62; select YEARWEEK('1987-01-01');
        -&#62; 198653
</PRE>

<A NAME="IDX1255"></A>
<DT><CODE>HOUR(time)</CODE>
<DD>
時を返します (<CODE>0</CODE> - <CODE>23</CODE>):


<PRE>
mysql&#62; select HOUR('10:05:03');
        -&#62; 10
</PRE>

<A NAME="IDX1256"></A>
<DT><CODE>MINUTE(time)</CODE>
<DD>
分を返します (<CODE>0</CODE>-<CODE>59</CODE>):


<PRE>
mysql&#62; select MINUTE('98-02-03 10:05:03');
        -&#62; 5
</PRE>

<A NAME="IDX1257"></A>
<DT><CODE>SECOND(time)</CODE>
<DD>
秒を返します (<CODE>0</CODE> to <CODE>59</CODE>)


<PRE>
mysql&#62; select SECOND('10:05:03');
        -&#62; 3
</PRE>

<A NAME="IDX1258"></A>
<DT><CODE>PERIOD_ADD(P,N)</CODE>
<DD>
<CODE>N</CODE> 月を期間 <CODE>P</CODE> (型 <CODE>YYMM</CODE> または <CODE>YYYYMM</CODE>) に追加
します。<CODE>YYYYMM</CODE> を返します。

注意: 期間引数 <CODE>P</CODE> は日付値では<EM>ありません</EM>。


<PRE>
mysql&#62; select PERIOD_ADD(9801,2);
        -&#62; 199803
</PRE>

<A NAME="IDX1259"></A>
<DT><CODE>PERIOD_DIFF(P1,P2)</CODE>
<DD>
期間 <CODE>P1</CODE> と <CODE>P2</CODE> の差の月を返します。<CODE>P1</CODE> と <CODE>P2</CODE> は形
式 <CODE>YYMM</CODE> または <CODE>YYYYMM</CODE> です。

注意: 期間引数 <CODE>P1</CODE> と <CODE>P2</CODE> は日付値では<EM>ありません</EM>。


<PRE>
mysql&#62; select PERIOD_DIFF(9802,199703);
        -&#62; 11
</PRE>

<A NAME="IDX1260"></A>
<A NAME="IDX1261"></A>
<A NAME="IDX1262"></A>
<A NAME="IDX1263"></A>
<A NAME="IDX1264"></A>
<DT><CODE>DATE_ADD(date,INTERVAL expr type)</CODE>
<DD>
<DT><CODE>DATE_SUB(date,INTERVAL expr type)</CODE>
<DD>
<DT><CODE>ADDDATE(date,INTERVAL expr type)</CODE>
<DD>
<DT><CODE>SUBDATE(date,INTERVAL expr type)</CODE>
<DD>
これら関数は日付の演算に使用します。 これらは <STRONG>MySQL</STRONG> バージョン 3.22 の
新しい機能です。 <CODE>ADDDATE()</CODE> と <CODE>SUBDATE()</CODE> は
<CODE>DATE_ADD()</CODE> , <CODE>DATE_SUB()</CODE> と同義です。

<STRONG>MySQL</STRONG> バージョン 3.23 では, <CODE>+</CODE> と <CODE>-</CODE> を
<CODE>DATE_ADD()</CODE> , <CODE>DATE_SUB()</CODE> の代わりに使用できます. (See example)

<CODE>date</CODE> には、<CODE>DATETIME</CODE> か <CODE>DATE</CODE> 型の値を指定します。
この値から演算が開始されます。
<CODE>expr</CODE> には、date から増減させる値を指定します。
<CODE>expr</CODE> が <SAMP>`-'</SAMP> から始まっていれば、負数を示します。
<CODE>type</CODE> はどれぐらいの期間かを示すキーワードです。

<CODE>EXTRACT(type FROM date)</CODE> 関数は、date から 'type' の部分を返します。

以下の表に、<CODE>type</CODE> と <CODE>expr</CODE> の関連を示します：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>type</CODE> <STRONG>value</STRONG> </TD><TD> <STRONG>Expected</STRONG> <CODE>expr</CODE> <STRONG>format</STRONG>
</TR NOSAVE>
<TR><TD><CODE>SECOND</CODE> </TD><TD> <CODE>SECONDS</CODE>
</TR NOSAVE>
<TR><TD><CODE>MINUTE</CODE> </TD><TD> <CODE>MINUTES</CODE>
</TR NOSAVE>
<TR><TD><CODE>HOUR</CODE> </TD><TD> <CODE>HOURS</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY</CODE> </TD><TD> <CODE>DAYS</CODE>
</TR NOSAVE>
<TR><TD><CODE>MONTH</CODE> </TD><TD> <CODE>MONTHS</CODE>
</TR NOSAVE>
<TR><TD><CODE>YEAR</CODE> </TD><TD> <CODE>YEARS</CODE>
</TR NOSAVE>
<TR><TD><CODE>MINUTE_SECOND</CODE> </TD><TD> <CODE>"MINUTES:SECONDS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>HOUR_MINUTE</CODE> </TD><TD> <CODE>"HOURS:MINUTES"</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY_HOUR</CODE> </TD><TD> <CODE>"DAYS HOURS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>YEAR_MONTH</CODE> </TD><TD> <CODE>"YEARS-MONTHS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>HOUR_SECOND</CODE> </TD><TD> <CODE>"HOURS:MINUTES:SECONDS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY_MINUTE</CODE> </TD><TD> <CODE>"DAYS HOURS:MINUTES"</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY_SECOND</CODE> </TD><TD> <CODE>"DAYS HOURS:MINUTES:SECONDS"</CODE>
</TR>
</TABLE>

<STRONG>MySQL</STRONG> は、 <CODE>expr</CODE> フォーマット内のいかなる句読点区切りをも許します。
上の表中の区切り文字は提案する区切り文字です。 もし <CODE>date</CODE> 引数が
 <CODE>DATE</CODE> 値で、<CODE>YEAR</CODE>, <CODE>MONTH</CODE>, <CODE>DAY</CODE> の部分のみを含む
計算をするなら、結果は <CODE>DATE</CODE> 値が返ります。 それ以外なら <CODE>DATETIME</CODE> 
値が返ります:


<PRE>
mysql&#62; SELECT "1997-12-31 23:59:59" + INTERVAL 1 SECOND;
        -&#62; 1998-01-01 00:00:00
mysql&#62; SELECT INTERVAL 1 DAY + "1997-12-31";
        -&#62; 1998-01-01
mysql&#62; SELECT "1998-01-01" - INTERVAL 1 SECOND;
       -&#62; 1997-12-31 23:59:59
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59",
                       INTERVAL 1 SECOND);
        -&#62; 1998-01-01 00:00:00
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59",
                       INTERVAL 1 DAY);
        -&#62; 1998-01-01 23:59:59
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59",
                       INTERVAL "1:1" MINUTE_SECOND);
        -&#62; 1998-01-01 00:01:00
mysql&#62; SELECT DATE_SUB("1998-01-01 00:00:00",
                       INTERVAL "1 1:1:1" DAY_SECOND);
        -&#62; 1997-12-30 22:58:59
mysql&#62; SELECT DATE_ADD("1998-01-01 00:00:00",
                       INTERVAL "-1 10" DAY_HOUR);
        -&#62; 1997-12-30 14:00:00
mysql&#62; SELECT DATE_SUB("1998-01-02", INTERVAL 31 DAY);
        -&#62; 1997-12-02
</PRE>

もしあなたの指定する interval 値が短すぎるなら( <CODE>type</CODE> キーワードから
類推される値を含んでいない場合)、 <STRONG>MySQL</STRONG> は interval 値の一番
左の部分を指定し忘れたものだと仮定します。
例えば、もし <CODE>type</CODE> を <CODE>DAY_SECOND</CODE> に指定した場合、
 <CODE>expr</CODE> の値は 日、時、分、秒 からなる物と期待されます。
ここであなたが <CODE>"1:10"</CODE> のような値を指定していたなら、
 <STRONG>MySQL</STRONG> は、日、時 の部分が忘れ去られて、分、秒 が与えられたと
推定します。
つまり、 <CODE>"1:10" DAY_SECOND</CODE> は <CODE>"1:10" MINUTE_SECOND</CODE> で
あると理解されるのです。
これは、<STRONG>MySQL</STRONG> が <CODE>TIME</CODE> 値を時刻ではなく経過時間の表現と解釈
する方法に類似しています。

注意: 時刻部を含む何かに対して、日付値の加算や減算を行なう場合、日付値は自
動的に日時値に変換されます:


<PRE>
mysql&#62; select date_add("1999-01-01", interval 1 day);
       -&#62; 1999-01-02
mysql&#62; select date_add("1999-01-01", interval 1 hour);
       -&#62; 1999-01-01 01:00:00
</PRE>

もし、不正な値が使用されたなら、結果は <CODE>NULL</CODE> です.
もし <CODE>MONTH</CODE> や <CODE>YEAR_MONTH</CODE> や <CODE>YEAR</CODE> を足し算して、
結果となる日付が新しい月の最大日よりも大きい日になるようなら、
その日は、新しい月の最大日に修正されます。


<PRE>
mysql&#62; select DATE_ADD('1998-01-30', Interval 1 month);
        -&#62; 1998-02-28
</PRE>

例のように、<CODE>INTERVAL</CODE> と <CODE>type</CODE> キーワードは
ケース依存ではありません.

<A NAME="IDX1265"></A>
<DT><CODE>EXTRACT(type FROM date)</CODE>
<DD>
The <CODE>EXTRACT()</CODE> function uses the same kinds of interval type
specifiers as <CODE>DATE_ADD()</CODE> or <CODE>DATE_SUB()</CODE>, but extracts parts
from the date rather than performing date arithmetic.


<PRE>
mysql&#62; SELECT EXTRACT(YEAR FROM "1999-07-02");
       -&#62; 1999
mysql&#62; SELECT EXTRACT(YEAR_MONTH FROM "1999-07-02 01:02:03");
       -&#62; 199907
mysql&#62; SELECT EXTRACT(DAY_MINUTE FROM "1999-07-02 01:02:03");
       -&#62; 20102
</PRE>

<A NAME="IDX1266"></A>
<DT><CODE>TO_DAYS(date)</CODE>
<DD>
日付 <CODE>date</CODE> を与えると、0年からの日数を返します。


<PRE>
mysql&#62; select TO_DAYS(950501);
        -&#62; 728779
mysql&#62; select TO_DAYS('1997-10-07');
        -&#62; 729669
</PRE>

<CODE>TO_DAYS()</CODE> はグレゴリオ歴の開始(1582)より前の値での使用を意図されて
いません。歴が変更された時に失われた日を考慮に入れてないからです。

<A NAME="IDX1267"></A>
<DT><CODE>FROM_DAYS(N)</CODE>
<DD>
与えられた日数 <CODE>N</CODE> から <CODE>DATE</CODE> 値を返します:


<PRE>
mysql&#62; select FROM_DAYS(729669);
        -&#62; '1997-10-07'
</PRE>

<CODE>FROM_DAYS()</CODE> はグレゴリオ歴の開始(1582)より前の値での使用を意図され
ていません。歴が変更された時に失われた日を考慮に入れてないからです。

<A NAME="IDX1268"></A>
<DT><CODE>DATE_FORMAT(date,format)</CODE>
<DD>
<CODE>date</CODE> 値を <CODE>format</CODE> 文字列に従って整形します。次の指定が 
<CODE>format</CODE> 文字列で使用できます:
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>%M</CODE> </TD><TD> 月名 (<CODE>January</CODE>..<CODE>December</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%W</CODE> </TD><TD> 曜日 (<CODE>Sunday</CODE>..<CODE>Saturday</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%D</CODE> </TD><TD> 英語サフィックス付き月の日 (<CODE>1st</CODE>, <CODE>2nd</CODE>, <CODE>3rd</CODE>, etc.)
</TR NOSAVE>
<TR><TD><CODE>%Y</CODE> </TD><TD> 4桁の年
</TR NOSAVE>
<TR><TD><CODE>%y</CODE> </TD><TD> 2桁の年
</TR NOSAVE>
<TR><TD><CODE>%X</CODE> </TD><TD> 週の年。週の最初の日は日曜日。4桁の数値。'%V' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%x</CODE> </TD><TD> 週の年。週の最初の日は月曜日。4桁の数値。'%v' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%a</CODE> </TD><TD> 省略された曜日名 (<CODE>Sun</CODE>..<CODE>Sat</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%d</CODE> </TD><TD> 月の日, 数値 (<CODE>00</CODE>..<CODE>31</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%e</CODE> </TD><TD> 月の日, 数値 (<CODE>0</CODE>..<CODE>31</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%m</CODE> </TD><TD> 月, 数値 (<CODE>01</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%c</CODE> </TD><TD> 月, 数値 (<CODE>1</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%b</CODE> </TD><TD> 省略された月名 (<CODE>Jan</CODE>..<CODE>Dec</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%j</CODE> </TD><TD> 年の日 (<CODE>001</CODE>..<CODE>366</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%H</CODE> </TD><TD> 時 (<CODE>00</CODE>..<CODE>23</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%k</CODE> </TD><TD> 時 (<CODE>0</CODE>..<CODE>23</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%h</CODE> </TD><TD> 時 (<CODE>01</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%I</CODE> </TD><TD> 時 (<CODE>01</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%l</CODE> </TD><TD> 時 (<CODE>1</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%i</CODE> </TD><TD> 分, 数値 (<CODE>00</CODE>..<CODE>59</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%r</CODE> </TD><TD> 時刻, 12時間 (<CODE>hh:mm:ss [AP]M</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%T</CODE> </TD><TD> 時刻, 24時間 (<CODE>hh:mm:ss</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%S</CODE> </TD><TD> 秒 (<CODE>00</CODE>..<CODE>59</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%s</CODE> </TD><TD> 秒 (<CODE>00</CODE>..<CODE>59</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%p</CODE> </TD><TD> <CODE>AM</CODE> or <CODE>PM</CODE>
</TR NOSAVE>
<TR><TD><CODE>%w</CODE> </TD><TD> 週の日 (<CODE>0</CODE>=Sunday..<CODE>6</CODE>=Saturday)
</TR NOSAVE>
<TR><TD><CODE>%U</CODE> </TD><TD> 週 (<CODE>0</CODE>..<CODE>53</CODE>), 週のはじまりを 日曜とした場合
</TR NOSAVE>
<TR><TD><CODE>%u</CODE> </TD><TD> 週 (<CODE>0</CODE>..<CODE>53</CODE>), 週のはじまりを 月曜とした場合
</TR NOSAVE>
<TR><TD><CODE>%V</CODE> </TD><TD> 週 (<CODE>1</CODE>..<CODE>53</CODE>), 週のはじまりは日曜日。'%X' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%v</CODE> </TD><TD> 週 (<CODE>1</CODE>..<CODE>53</CODE>), 週のはじまりは月曜日。'%x' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%%</CODE> </TD><TD> リテラル <SAMP>`%'</SAMP>。
</TR>
</TABLE>

他の全ての文字は解釈されずに結果にコピーされます:


<PRE>
mysql&#62; select DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');
        -&#62; 'Saturday October 1997'
mysql&#62; select DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');
        -&#62; '22:23:00'
mysql&#62; select DATE_FORMAT('1997-10-04 22:23:00',
                          '%D %y %a %d %m %b %j');
        -&#62; '4th 97 Sat 04 10 Oct 277'
mysql&#62; select DATE_FORMAT('1997-10-04 22:23:00',
                          '%H %k %I %r %T %S %w');
        -&#62; '22 22 10 10:23:00 PM 22:23:00 00 6'
mysql&#62; select DATE_FORMAT('1999-01-01', '%X %V');
        -&#62; '1998 52'
</PRE>

<STRONG>MySQL</STRONG> バージョン 3.23 では、 <CODE>%</CODE> 文字はフォーマット文字の前に必ず
必要とされます。
それより前のバージョンでは、 <CODE>%</CODE> 文字はオプションでした。

<A NAME="IDX1269"></A>
<DT><CODE>TIME_FORMAT(time,format)</CODE>
<DD>
これは上記の <CODE>DATE_FORMAT()</CODE> のように使用されますが、
<CODE>format</CODE> オプションでは、時,分,秒だけを操作できます。
他のオプションは <CODE>NULL</CODE> or <CODE>0</CODE> を与えます。

<A NAME="IDX1270"></A>
<A NAME="IDX1271"></A>
<DT><CODE>CURDATE()</CODE>
<DD>
<DT><CODE>CURRENT_DATE</CODE>
<DD>
今日の日付を返します。日付の形式は、<CODE>CURDATE()</CODE> が数値または文字列のどち
らの文脈で使用されたかに依存して <CODE>YYYYMMDD</CODE> または <CODE>'YYYY-MM-DD'</CODE> で返
されます:


<PRE>
mysql&#62; select CURDATE();
        -&#62; '1997-12-15'
mysql&#62; select CURDATE() + 0;
        -&#62; 19971215
</PRE>

<A NAME="IDX1272"></A>
<A NAME="IDX1273"></A>
<DT><CODE>CURTIME()</CODE>
<DD>
<DT><CODE>CURRENT_TIME</CODE>
<DD>
現在の時刻を <CODE>HHMMSS</CODE> または <CODE>'HH:MM:SS'</CODE> の形式で返します。こ
れは <CODE>CURTIME()</CODE> が数値または文字列のどちらの文脈で使用されたかに依
存します:


<PRE>
mysql&#62; select CURTIME();
        -&#62; '23:50:26'
mysql&#62; select CURTIME() + 0;
        -&#62; 235026
</PRE>

<A NAME="IDX1274"></A>
<A NAME="IDX1275"></A>
<A NAME="IDX1276"></A>
<DT><CODE>NOW()</CODE>
<DD>
<DT><CODE>SYSDATE()</CODE>
<DD>
<DT><CODE>CURRENT_TIMESTAMP</CODE>
<DD>
現在の時刻を返します。数値または文字列のどちらの文脈で使用されたかに依存して
 <CODE>YYYYMMDDHHMMSS</CODE> または <CODE>'YYYY-MM-DD HH:MM:SS'</CODE> 形式で返されます:


<PRE>
mysql&#62; select NOW();
        -&#62; '1997-12-15 23:50:26'
mysql&#62; select NOW() + 0;
        -&#62; 19971215235026
</PRE>

<A NAME="IDX1277"></A>
<DT><CODE>UNIX_TIMESTAMP()</CODE>
<DD>
<DT><CODE>UNIX_TIMESTAMP(date)</CODE>
<DD>
引数なしで呼び出された場合は、UNIX timestamp (GMT <CODE>'1970-01-01 00:00:00'</CODE> 
からの秒数) です。通常は、<CODE>TIMESTAMP</CODE> フィールドを引数として呼び出し、
フィールドの値を秒数で返します。<CODE>date</CODE> はローカル時刻での <CODE>DATE</CODE>
文字列、<CODE>DATETIME</CODE> 文字列、または <CODE>YYMMDD</CODE> または
<CODE>YYYYMMDD</CODE> 形式の数値です:


<PRE>
mysql&#62; select UNIX_TIMESTAMP();
        -&#62; 882226357
mysql&#62; select UNIX_TIMESTAMP('1997-10-04 22:23:00');
        -&#62; 875996580
</PRE>

<CODE>UNIX_TIMESTAMP</CODE> が <CODE>TIMESTAMP</CODE> フィールドに使用された場合、
この関数は、暗黙の ``文字から UNIX タイムスタンプ'' 変換をすることなく、
値を得ます。
If you give <CODE>UNIX_TIMESTAMP()</CODE> a wrong or out-of-range date, it will
return 0.

<A NAME="IDX1278"></A>
<DT><CODE>FROM_UNIXTIME(unix_timestamp)</CODE>
<DD>
文脈(数値/文字列)に依存して、<CODE>'YYYY-MM-DD HH:MM:SS'</CODE> または 
<CODE>YYYYMMDDHHMMSS</CODE> 形式の timestamp 文字列を返します:


<PRE>
mysql&#62; select FROM_UNIXTIME(875996580);
        -&#62; '1997-10-04 22:23:00'
mysql&#62; select FROM_UNIXTIME(875996580) + 0;
        -&#62; 19971004222300
</PRE>

<A NAME="IDX1279"></A>
<DT><CODE>FROM_UNIXTIME(unix_timestamp,format)</CODE>
<DD>
<CODE>format</CODE> に従って整形された UNIX timestamp 文字列を返します。
<CODE>format</CODE> は <CODE>DATE_FORMAT()</CODE> 関数のエントリに一覧されたのと同じ指
定子を含むことができます:


<PRE>
mysql&#62; select FROM_UNIXTIME(UNIX_TIMESTAMP(),
                            '%Y %D %M %h:%i:%s %x');
        -&#62; '1997 23rd December 03:43:30 x'
</PRE>

<A NAME="IDX1280"></A>
<DT><CODE>SEC_TO_TIME(seconds)</CODE>
<DD>
<CODE>seconds</CODE> 引数を時分秒に変換して返します。関数が文字列文脈または数値
文脈のどちらで使用されたかに依存して、<CODE>'HH:MM:SS'</CODE> または 
<CODE>HHMMSS</CODE> 形式で値を返します:


<PRE>
mysql&#62; select SEC_TO_TIME(2378);
        -&#62; '00:39:38'
mysql&#62; select SEC_TO_TIME(2378) + 0;
        -&#62; 3938
</PRE>

<A NAME="IDX1281"></A>
<DT><CODE>TIME_TO_SEC(time)</CODE>
<DD>
<CODE>time</CODE> を秒に変換します。


<PRE>
mysql&#62; select TIME_TO_SEC('22:23:00');
        -&#62; 80580
mysql&#62; select TIME_TO_SEC('00:39:38');
        -&#62; 2378
</PRE>

</DL>



<H3><A NAME="Other_Functions" HREF="manual.ja_toc.html#Other_Functions">6.3.5  その他の関数</A></H3>



<H4><A NAME="Bit_functions" HREF="manual.ja_toc.html#Bit_functions">6.3.5.1  ビット関数</A></H4>

<P>
<A NAME="IDX1282"></A>
<A NAME="IDX1283"></A>
<A NAME="IDX1284"></A>
<A NAME="IDX1285"></A>

</P>
<P>
これらは最大 64 ビットの範囲を持ちます。<STRONG>MySQL</STRONG> は <CODE>BIGINT</CODE> (64-bit)
 演算を使用するためです。

</P>
<DL COMPACT>

<DT><CODE>|</CODE>
<DD>
<A NAME="IDX1286"></A>
 <A NAME="IDX1287"></A>
 
ビット演算 OR:

<PRE>
mysql&#62; select 29 | 15;
        -&#62; 31
</PRE>

<A NAME="IDX1288"></A>
<A NAME="IDX1289"></A>
<DT><CODE>&#38;</CODE>
<DD>
ビット演算 AND:

<PRE>
mysql&#62; select 29 &#38; 15;
        -&#62; 13
</PRE>

<A NAME="IDX1290"></A>
<DT><CODE>&#60;&#60;</CODE>
<DD>
左に longlong (<CODE>BIGINT</CODE>) number 分、ビットをシフトします:

<PRE>
mysql&#62; select 1 &#60;&#60; 2;
        -&#62; 4
</PRE>

<A NAME="IDX1291"></A>
<DT><CODE>&#62;&#62;</CODE>
<DD>
右に longlong (<CODE>BIGINT</CODE>) number 分、ビットをシフトします:

<PRE>
mysql&#62; select 4 &#62;&#62; 2;
        -&#62; 1
</PRE>

<A NAME="IDX1292"></A>
<DT><CODE>~</CODE>
<DD>
Invert all bits:

<PRE>
mysql&#62; select 5 &#38; ~1;
        -&#62; 4
</PRE>

<A NAME="IDX1293"></A>
<DT><CODE>BIT_COUNT(N)</CODE>
<DD>
引数 <CODE>N</CODE> がいくつビットを持っているか(２進数表記したときの１の数):

<PRE>
mysql&#62; select BIT_COUNT(29);
        -&#62; 4
</PRE>

</DL>



<H4><A NAME="Miscellaneous_functions" HREF="manual.ja_toc.html#Miscellaneous_functions">6.3.5.2  その他の関数</A></H4>

<P>
<A NAME="IDX1294"></A>
<A NAME="IDX1295"></A>

</P>
<DL COMPACT>

<DT><CODE>DATABASE()</CODE>
<DD>
<A NAME="IDX1296"></A>
 
現在のデータベース名を返します


<PRE>
mysql&#62; select DATABASE();
        -&#62; 'test'
</PRE>

もしデータベースが選択されていないなら、<CODE>DATABASE()</CODE> は空文字を返します。

<A NAME="IDX1297"></A>
<A NAME="IDX1298"></A>
<A NAME="IDX1299"></A>
<DT><CODE>USER()</CODE>
<DD>
<DT><CODE>SYSTEM_USER()</CODE>
<DD>
<DT><CODE>SESSION_USER()</CODE>
<DD>
Returns the current MySQL user name:


<PRE>
mysql&#62; select USER();
        -&#62; 'davida@localhost'
</PRE>

<STRONG>MySQL</STRONG> バージョン 3.22.11 以降では、この関数はユーザー名とクライアントの
ホスト名を含みます。
ユーザー名の部分だけ取り出すには次のようにします。
（これはホスト名が含まれていなくとも動くでしょう）：


<PRE>
mysql&#62; select substring_index(USER(),"@",1);
        -&#62; 'davida'
</PRE>

<A NAME="IDX1300"></A>
<DT><CODE>PASSWORD(str)</CODE>
<DD>
プレーンテキストのパスワード <CODE>str</CODE> からパスワード文字列を計算します。
これは <CODE>user</CODE> 許可テーブルの <CODE>Password</CODE> フィールドに、
暗号化された <STRONG>MySQL</STRONG> パスワードを保存する際に使用されます:


<PRE>
mysql&#62; select PASSWORD('badpwd');
        -&#62; '7f84554057dd964b'
</PRE>

<A NAME="IDX1301"></A>
<CODE>PASSWORD()</CODE> 暗号は不可逆です。

<CODE>PASSWORD()</CODE> は UNIX のパスワードが暗号化するのと同じ方法で
暗号化を行うわけではありません。
UNIX のパスワードと <STRONG>MySQL</STRONG> のパスワードが同じと思ってはいけません。
UNIX のパスワードファイルに保存される値が <CODE>PASSWORD()</CODE> が返すと
考えてはいけません。
<CODE>ENCRYPT()</CODE> 参照。

<A NAME="IDX1302"></A>
<DT><CODE>ENCRYPT(str[,salt])</CODE>
<DD>
UNIX の <CODE>crypt()</CODE> システムコールで <CODE>str</CODE> を暗号化します。
<CODE>salt</CODE> は2文字の文字列です。
(<STRONG>MySQL</STRONG> バージョン 3.22.16 で, <CODE>salt</CODE> は2文字以上許されるようになり
ました。)


<PRE>
mysql&#62; select ENCRYPT("hello");
        -&#62; 'VxuFAJXVARROc'
</PRE>

システムで <CODE>crypt()</CODE> が利用できない場合は <CODE>ENCRYPT()</CODE> は常に 
<CODE>NULL</CODE> を返します。

少なくともいくつかのシステムでは、
<CODE>ENCRYPT()</CODE> は <CODE>str</CODE> 文字中の最初の 8 文字以外は全て無視します。
これは <CODE>crypt()</CODE> システムコールの振る舞いによって決定づけられます。

<A NAME="IDX1303"></A>
<DT><CODE>ENCODE(str,pass_str)</CODE>
<DD>
パスワードとして <CODE>pass_str</CODE> を用いて <CODE>str</CODE> を暗号化します。結果
を復号化するには、<CODE>DECODE()</CODE>を使用します。

結果はバイナリ文字列で、長さは <CODE>string</CODE> と同じです。
フィールドにそれを保存したい場合は <CODE>BLOB</CODE> フィールド型を使用してください。

<A NAME="IDX1304"></A>
<DT><CODE>DECODE(crypt_str,pass_str)</CODE>
<DD>
暗号化された文字列 <CODE>crypt_str</CODE> をパスワードとして <CODE>pass_str</CODE> を
用いて復号化します。<CODE>crypt_str</CODE> は <CODE>ENCODE()</CODE> から返された文字列
であるべきです。

<A NAME="IDX1305"></A>
<DT><CODE>MD5(string)</CODE>
<DD>
文字列を MD5 チェックサムした結果を返します。 値は 32 桁の 16進表示です。
例えばハッシュキーとして使用できるように:


<PRE>
mysql&#62; select MD5("testing");
        -&#62; 'ae2b1fca515949e5d54fb22b8ed95575'
</PRE>

これは "RSA Data Security, Inc. MD5 Message-Digest Algorithm".

<A NAME="IDX1306"></A>
<DT><CODE>LAST_INSERT_ID([expr])</CODE>
<DD>
最後に <CODE>AUTO_INCREMENT</CODE> フィールドに挿入されて自動的に生成された値を返しま
す。
 「<A HREF="manual.ja_Clients.html#mysql_insert_id">8.4.3.126  <CODE>mysql_insert_id()</CODE></A>」節参照.


<PRE>
mysql&#62; select LAST_INSERT_ID();
        -&#62; 195
</PRE>

最後の作成された ID はそれぞれのコネクション毎にサーバーに維持されます。
これは他のクライアントからは変更できないでしょう。
もし他の非マジック値をもつ <CODE>AUTO_INCREMENT</CODE> フィールド
（値が <CODE>NULL</CODE> でも <CODE>0</CODE> でもないということ）
を更新しても、これは 変更されません。

一つの INSERT 文で同時に多くのレコードを挿入する場合、
<CODE>LAST_INSERT_ID()</CODE> は最初に挿入されたレコードの値を返します。この理由
は、他のサーバに対して同じ <CODE>INSERT</CODE> を簡単に再現できるようにするため
です。

<A NAME="IDX1307"></A>
If <CODE>expr</CODE> is given as an argument to <CODE>LAST_INSERT_ID()</CODE>, then
the value of the argument is returned by the function, is set as the
next value to be returned by <CODE>LAST_INSERT_ID()</CODE> and used as the next
auto_increment value.  
これは シーケンス番号のシミュレーションに使用できます：

最初にテーブルを作成：


<PRE>
mysql&#62; create table sequence (id int not null);
mysql&#62; insert into sequence values (0);
</PRE>

そして以下のようにしてシーケンス番号を生成：


<PRE>
mysql&#62; update sequence set id=LAST_INSERT_ID(id+1);
</PRE>

<CODE>LAST_INSERT_ID()</CODE> の呼び出し無しでシーケンス番号を生成することが可能
ですが、この方法でこの関数を使用するユーティリティは、ID 値が最後に自動的
に生成された値としてサーバに管理されます。<STRONG>MySQL</STRONG> 内の通常の任意の 
<CODE>AUTO_INCREMENT</CODE> 値を読み込んで新しい ID を取り出すことができます。例
えば、<CODE>LAST_INSERT_ID()</CODE> (引数無し) は新しい ID を返します。C API 関
数 <CODE>mysql_insert_id()</CODE> もこの値を得るために使用できます。

Note that as <CODE>mysql_insert_id()</CODE> is only updated after
<CODE>INSERT</CODE> and <CODE>UPDATE</CODE> statements, you can't use this function
to retrieve the value for <CODE>LAST_INSERT_ID(expr)</CODE> after executing
other SQL statements like <CODE>SELECT</CODE> or <CODE>SET</CODE>.

<A NAME="IDX1308"></A>
<DT><CODE>FORMAT(X,D)</CODE>
<DD>
<CODE>'#,###,###.##'</CODE> のような形式(小数部 <CODE>X</CODE> 桁)で数値 <CODE>D</CODE> を整形
します。 もし <CODE>D</CODE> が <CODE>0</CODE> なら, 結果にはいかなる
小数点も小数部も含まれません。


<PRE>
mysql&#62; select FORMAT(12332.123456, 4);
        -&#62; '12,332.1235'
mysql&#62; select FORMAT(12332.1,4);
        -&#62; '12,332.1000'
mysql&#62; select FORMAT(12332.2,0);
        -&#62; '12,332'
</PRE>

<A NAME="IDX1309"></A>
<DT><CODE>VERSION()</CODE>
<DD>
<STRONG>MySQL</STRONG> サーバのバージョンを返します:


<PRE>
mysql&#62; select VERSION();
        -&#62; '3.23.13-log'
</PRE>

注意: バージョンが <CODE>-log</CODE> で終わる場合はロギングが有効であることを意
味します。

<A NAME="IDX1310"></A>
<DT><CODE>CONNECTION_ID()</CODE>
<DD>
接続の接続 ID (<CODE>thread_id</CODE>) を返します。すべての接続は接続自身の一意
な ID を持ちます:


<PRE>
mysql&#62; select CONNECTION_ID();
        -&#62; 1
</PRE>

<A NAME="IDX1311"></A>
<A NAME="IDX1312"></A>
<DT><CODE>GET_LOCK(str,timeout)</CODE>
<DD>
<CODE>timeout</CODE> 秒のタイムアウトで、<CODE>str</CODE> と名付けられたロックの獲得を試み
ます。ロックを獲得した場合は <CODE>1</CODE>, タイムアウトの場合は <CODE>0</CODE>, エラーの場
合(メ
モリ不足やスレッドが <CODE>mysqladmin kill</CODE> で殺された場合など)は <CODE>NULL</CODE>
が返ります。<CODE>RELEASE_LOCK</CODE> の実行、新しい <CODE>GET_LOCK</CODE> の実行、
スレッドの終了の場合に、ロックは解放されます。この関数はアプリケーション
ロックやレコードロックのシミュレートのために使用できます。
これは、同じ名前のロックを行おうとする他のクライアントからのリクエストを
ブロックします； 与えられた名前のロックに応じているクライアントは、
協調してロッキングを行うために、その文字列を使用できます:


<PRE>
mysql&#62; select GET_LOCK("lock1",10);
        -&#62; 1
mysql&#62; select GET_LOCK("lock2",10);
        -&#62; 1
mysql&#62; select RELEASE_LOCK("lock2");
        -&#62; 1
mysql&#62; select RELEASE_LOCK("lock1");
        -&#62; NULL
</PRE>

２つ目の <CODE>RELEASE_LOCK()</CODE> は <CODE>NULL</CODE> を返します。
なぜなら、 <CODE>"lock1"</CODE> は、２つ目の <CODE>GET_LOCK()</CODE> の呼び出し時点で、
自動的に解放されるからです。

<A NAME="IDX1313"></A>
<DT><CODE>RELEASE_LOCK(str)</CODE>
<DD>
<CODE>GET_LOCK</CODE> で獲得したロック <CODE>str</CODE> を解放します。ロックが解
放された場合は <CODE>1</CODE>, このスレッドによってロックされていない場合は <CODE>0</CODE> 
(この場合、ロックは解放されません), 
<CODE>str</CODE>が存在しない場合は <CODE>NULL</CODE> が返ります。
もし、 <CODE>GET_LOCK()</CODE> をコールして得られなかった場合、
あるいは、既に解放されている場合は、ロックは存在しないでしょう。

The <CODE>DO</CODE> statement is convinient to use with <CODE>RELEASE_LOCK()</CODE>.
 「<A HREF="manual.ja_Reference.html#DO">6.4.9  <CODE>DO</CODE> Syntax</A>」節参照.

<A NAME="IDX1314"></A>
<DT><CODE>BENCHMARK(count,expr)</CODE>
<DD>
<CODE>BENCHMARK()</CODE> 関数は <CODE>expr</CODE> で与えられた文を <CODE>count</CODE> 回
繰り返し実行します。 これは <STRONG>MySQL</STRONG> のその文の処理がどれぐらい
速いのか知るのに使用されるでしょう。 結果は常に <CODE>0</CODE> です。
想定している使用は、 <CODE>mysql</CODE> クライアントです。
あるクエリの実行時間を知るための使用です:


<PRE>
mysql&#62; select BENCHMARK(1000000,encode("hello","goodbye"));
+----------------------------------------------+
| BENCHMARK(1000000,encode("hello","goodbye")) |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+
1 row in set (4.74 sec)
</PRE>

報告された時間は、クライアントでの経過時間です。 サーバー側の CPU 時間では
ありません。<CODE>BENCHMARK()</CODE> を何回か実行して、サーバマシンの負荷の重さ
を考慮して結果を解釈することを勧めます。

<A NAME="IDX1315"></A>
<DT><CODE>INET_NTOA(expr)</CODE>
<DD>
数値表現に対するネットワークアドレス(4 または 8 バイト) を返します:


<PRE>
mysql&#62; select INET_NTOA(3520061480);
       -&#62;  "209.207.224.40"
</PRE>

<A NAME="IDX1316"></A>
<DT><CODE>INET_ATON(expr)</CODE>
<DD>
ネットワークアドレスに対する数値を表す整数を返します。アドレスは 4 または 
8 バイトアドレスです:


<PRE>
mysql&#62; select INET_ATON("209.207.224.40");
       -&#62;  3520061480
</PRE>

生成された数値は常にネットワークバイトオーダです; たとえば、上記の数値は
<CODE>209*255^3 + 207*255^2 + 224*255 +40</CODE> として計算されます。

<A NAME="IDX1317"></A>
<DT><CODE>MASTER_POS_WAIT(log_name, log_pos)</CODE>
<DD>
複製の間、マスターログの指定された位置にスレーブが到達するまでブロックしま
す。マスター情報が初期化されていない場合、NULL が返ります。スレーブが動作
していない場合ブロックし、スレーブが起動し、指定位置にくるまで待ちます。ス
レーブが既に指定位置を通り過ぎていた場合、即時復帰します。戻り値は指定位置
を得るために待つ必要のあるログイベントの数、またはエラーの場合 NULL です。
マスタースレーブ同期制御に有用ですが、元々は手軽な複製テストのために書かれ
ました。
</DL>



<H2><A NAME="Data_Manipulation" HREF="manual.ja_toc.html#Data_Manipulation">6.4  Data Manipulation: <CODE>SELECT</CODE>, <CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, <CODE>DELETE</CODE></A></H2>



<H3><A NAME="SELECT" HREF="manual.ja_toc.html#SELECT">6.4.1  <CODE>SELECT</CODE> 構文</A></H3>

<P>
<A NAME="IDX1318"></A>

</P>

<PRE>
SELECT [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
       [HIGH_PRIORITY]
       [DISTINCT | DISTINCTROW | ALL]
    select_expression,...
    [INTO {OUTFILE | DUMPFILE} 'file_name' export_options]
    [FROM table_references
        [WHERE where_definition]
        [GROUP BY {unsigned_integer | col_name | formula} [ASC | DESC], ...]
        [HAVING where_definition]
        [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] ,...]
        [LIMIT [offset,] rows]
        [PROCEDURE procedure_name]
        [FOR UPDATE | LOCK IN SHARE MODE]]
</PRE>

<P>
<CODE>SELECT</CODE>は通常、1つまたは1つ以上のテーブルからレコードを検索して抽出
するのに使用されます。
<CODE>select_expression</CODE> は取り出したいフィールドを示します。
<CODE>SELECT</CODE>はまた、テーブルの参照なしに計算によって求められたレコードを
取り出すために使用されます。例:

</P>

<PRE>
mysql&#62; SELECT 1 + 1;
         -&#62; 2
</PRE>

<P>
全てのキーワードの使用は、上記に示すような順序で正確に与えられる必要があります。
例えば、<CODE>HAVING</CODE>節は必ず<CODE>GROUP BY</CODE>節の後、<CODE>ORDER BY</CODE>節の前でなければなりません。

</P>

<UL>

<LI>

<A NAME="IDX1319"></A>
<A NAME="IDX1320"></A>
<CODE>SELECT</CODE>の表現では、<CODE>AS</CODE>による別名の指定が可能です。別名は、
フィールド名の表現として使われ、<CODE>ORDER BY</CODE>及び<CODE>HAVING</CODE>節とともに使用することができます。
例:


<PRE>
mysql&#62; select concat(last_name,', ',first_name) AS full_name
    from mytable ORDER BY full_name;
</PRE>

<LI>

<CODE>FROM table_references</CODE>節は、(例えば、選択するレコードにより、1つ又はそれ以上の)
結合するテーブルのリストを示します。
このリストはまた、<CODE>LEFT OUTER JOIN</CODE>参照を含むことがあります。
 「<A HREF="manual.ja_Reference.html#JOIN">6.4.1.1  <CODE>JOIN</CODE> 構文</A>」節. を参照してください。

<LI>

<CODE>col_name</CODE>、<CODE>tbl_name.col_name</CODE>、<CODE>db_name.tbl_name.col_name</CODE>の
ようにしてフィールドを表すことができます。
<CODE>SELECT</CODE>ステートメント内での列の参照が曖昧でなければ、<CODE>tbl_name</CODE>や
<CODE>db_name.tbl_name</CODE>のようなプリフィックスを詳細に記述する必要はありません。
より明示的なフィールドの指定形式をを必要とする曖昧な参照の例は、 「<A HREF="manual.ja_Reference.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A>」節を参照のこと。

<LI>

<A NAME="IDX1321"></A>
<A NAME="IDX1322"></A>
テーブル参照は、<CODE>tbl_name AS alias_name</CODE>又は<CODE>tbl_name alias_name</CODE>を
使って別名を使用することが可能です:


<PRE>
mysql&#62; select t1.name, t2.salary from employee AS t1, info AS t2
           where t1.name = t2.name;
mysql&#62; select t1.name, t2.salary from employee t1, info t2
           where t1.name = t2.name;
</PRE>

<LI>

出力用に選択されたフィールドは、<CODE>ORDER BY</CODE>節や<CODE>GROUP BY</CODE>節において、
フィールド名、フィールドのエイリアス名、又はフィールド番号にて指し示すことが
できます。フィールド番号は1から始まります。


<PRE>
mysql&#62; select college, region, seed from tournament
           ORDER BY region, seed;
mysql&#62; select college, region AS r, seed AS s from tournament
           ORDER BY r, s;
mysql&#62; select college, region, seed from tournament
           ORDER BY 2, 3;
</PRE>

逆順で並べたい場合には、 <CODE>ORDER BY</CODE> 節の中で、あなたが並べたいと思っている
フィールドの名前の後ろに、 <CODE>DESC</CODE> (descending) キーワードを
追加します。
デフォルトは昇順です； これは <CODE>ASC</CODE> キーワードを指定したことになります。

<LI>

<CODE>WHERE</CODE> 節で <STRONG>MySQL</STRONG> がサポートする任意の関数を使用することが
できます。 「<A HREF="manual.ja_Reference.html#Functions">6.3  <CODE>SELECT</CODE> と <CODE>WHERE</CODE> 節で使用する関数</A>」節参照.

<LI>

<CODE>HAVING</CODE>節は、<CODE>select_expression</CODE>においてどのフィールドの名前や
エイリアス名でも指し示すことができます。
これは最後に適用され、クライアントにアイテムが送られる直前に実行されるので、
最適化されません。
<CODE>WHERE</CODE>節で書くべきものに<CODE>HAVING</CODE>を用いてはいけません。
例えば、次のように書いてはいけません:


<PRE>
mysql&#62; select col_name from tbl_name HAVING col_name &#62; 0;
</PRE>

その代わりに、次のように書いてください:


<PRE>
mysql&#62; select col_name from tbl_name WHERE col_name &#62; 0;
</PRE>

<STRONG>MySQL</STRONG> バージョン 3.22.5以降では、次のようにクエリを記述することができます:


<PRE>
mysql&#62; select user,max(salary) from users
           group by user HAVING max(salary)&#62;10;
</PRE>

<STRONG>MySQL</STRONG>の古いバージョンでは、この代わりに次のように記述できます:


<PRE>
mysql&#62; select user,max(salary) AS sum from users
           group by user HAVING sum&#62;10;
</PRE>

<LI>

<CODE>SQL_SMALL_RESULT</CODE>, <CODE>SQL_BIG_RESULT</CODE>, <CODE>SQL_BUFFER_RESULT</CODE>,
<CODE>STRAIGHT_JOIN</CODE>, <CODE>HIGH_PRIORITY</CODE> は ANSI SQL92 に対する <STRONG>MySQL</STRONG> 拡張です。

<LI>

<CODE>HIGH_PRIORITY</CODE> は、テーブルの更新よりも <CODE>SELECT</CODE> を優先させます。
これは一度で完了する、とても速いクエリにのみ適用すべきです。
もしリードロックされているテーブルがあったとし、
たとえ update 文がこのテーブルの解除を待っていたとしても、
<CODE>SELECT HIGH_PRIORITY</CODE> クエリは実行されます。

<LI>

<CODE>SQL_BIG_RESULT</CODE> は <CODE>GROUP BY</CODE> や <CODE>DISTINCT</CODE> と共に使用する
事ができ、結果セットが多くのレコードを持つことをオプティマイザに知らせます。
この場合、必要なら <STRONG>MySQL</STRONG> はディスクベースの一時テーブルを直接使用
します。<CODE>MySQL</CODE> はこの場合、<CODE>GROUP BY</CODE> 要素上のキーで一時テーブ
ルを行なう代わりにソートを行なうことを選択します。

<LI>

<CODE>SQL_BUFFER_RESULT</CODE> は結果を一時テーブルへ強制的に置きます。これは 
<STRONG>MySQL</STRONG> がテーブルロックを速く解放して、クライアントに結果セットを
送るために長い時間が掛かる場合の助けになります。

<LI>

<CODE>SQL_SMALL_RESULT</CODE> (<STRONG>MySQL</STRONG> 固有のオプション) は <CODE>GROUP BY</CODE>
か <CODE>DISTINCT</CODE> と共に使用する事ができ、
結果セットが小さくなることをオプティマイザに知らせます。この場合、
<STRONG>MySQL</STRONG> はソートする代わりに、速い一時テーブルを結果の保存のた
めに使用します。 <STRONG>MySQL</STRONG> バージョン 3.23 では、これは通常必要ではありません。

<LI>

<A NAME="IDX1323"></A>
<CODE>GROUP BY</CODE> を使用する場合、<CODE>GROUP BY</CODE> 内のすべてのフィールドを 
<CODE>ORDER BY</CODE> に記述したかのように、出力レコードは <CODE>GROUP BY</CODE> に従っ
てソートされます。<STRONG>MySQL</STRONG> は、<CODE>ASC</CODE> と <CODE>DESC</CODE> を 
<CODE>GROUP BY</CODE> に記述できるように、<CODE>GROUP BY</CODE> を拡張しています:


<PRE>
SELECT a,COUNT(b) FROM test_table GROUP BY a DESC
</PRE>

<LI>

<STRONG>MySQL</STRONG> は、<CODE>GROUP BY</CODE> 節に記述されていないフィールドを 
select できるように <CODE>GROUP BY</CODE> の使用を拡張しています。あなたのクエリ
から期待した結果を得ない場合、<CODE>GROUP BY</CODE> の説明を読んでください。
 「<A HREF="manual.ja_Placeholder.html#Group_by_functions">M.3  Functions for Use with <CODE>GROUP BY</CODE> Clauses</A>」節参照.

<LI>

<CODE>STRAIGHT_JOIN</CODE>は、<CODE>FROM</CODE>節にて記述されたテーブルの順序に従って結合するよう、
オプティマイザに強制します。オプティマイザが、テーブルを最適な順序で結合しない
場合に、クエリのスピードアップのためにこれを使用することが可能です。
 「<A HREF="manual.ja_MySQL_Optimization.html#EXPLAIN">5.2.1  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.

<LI>

<CODE>LIMIT</CODE> 節は、 <CODE>SELECT</CODE> 構文で返されるレコード数を指定するのに
使用されます。 <CODE>LIMIT</CODE> は一つか二つの数字の引数を取ります。

引数が2つ与えられたならば、最初の引数は最初のレコードからのオフセットを示し、
2つめの引数は返すレコードの最大数を示します。
初めのレコードのオフセットは0です(1ではありません)。


<PRE>
mysql&#62; select * from table LIMIT 5,10;  # 6〜15行目を返す
</PRE>

もし引数が一つなら、返すべきレコードの最大行数を指定したことになります。


<PRE>
mysql&#62; select * from table LIMIT 5;     # 最初の5行を取り出す
</PRE>

いいかえれば、<CODE>LIMIT n</CODE> は <CODE>LIMIT 0,n</CODE> と同じです。

<LI>

<A NAME="IDX1324"></A>
<CODE>SELECT</CODE>の書式、<CODE>SELECT ... INTO OUTFILE 'file_name'</CODE>は、
選択されたレコードをファイルに書き込みます。
ファイルはサーバ機に作成され、既に存在するファイルであってはなりません
(<TT>`/etc/passwd'</TT>のようなファイルの破壊を防止します)。

<CODE>SELECT ... INTO OUTFILE</CODE> は主に、サーバマシン上でとても速くテーブル
をダンプすることを意図されています。サーバホストでない別のホスト上で結果ファ
イルを生成したい場合は、<CODE>SELECT ... INTO OUTFILE</CODE> を使用できません。
この場合は代わりに、<CODE>mysqldump --tab</CODE> や <CODE>mysql -e "SELECT
..." &#62; outfile</CODE> のようなクライアントプログラムを使用して、ファイルを生成す
べきです。

<CODE>SELECT ... INTO OUTFILE</CODE>は、<CODE>LOAD DATA INFILE</CODE>の逆です。
<CODE>export_options</CODE>の構文は、<CODE>LOAD DATA INFILE</CODE>ステートメントの一部で
使われる<CODE>FIELDS</CODE>節や<CODE>LINES</CODE>節と同じような構成です。
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.8  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.

結果として取り出されるテキストファイルでは、
以下に示す文字が <CODE>ESCAPED BY</CODE> 指定の文字によってエスケープされます：


<UL>
<LI><CODE>ESCAPED BY</CODE> 文字自身

<LI><CODE>FIELDS TERMINATED BY</CODE> の最初の文字

<LI><CODE>LINES TERMINATED BY</CODE> の最初の文字

</UL>

さらに、 <CODE>ASCII 0</CODE> は、<CODE>ESCAPED BY</CODE> 0 (<CODE>ASCII 48</CODE>) にコンバートされます。

いかなる <CODE>FIELDS TERMINATED BY</CODE>, <CODE>ESCAPED BY</CODE>, <CODE>LINES TERMINATED BY</CODE>
指定されている文字も、エスケープしなければならない理由は、
テキストファイルを読み返せれるようにするためなのです。
<CODE>ASCII 0</CODE> はいくつかのページャーでも見れるようにするために
エスケープされるのです。

結果のファイルは SQL の文を含んでいないので、何もエスケープする必要はありません。

次は、多くの古いプログラムによって使用されるフォーマットでファイルを得る例
です。


<PRE>
SELECT a,b,a+b INTO OUTFILE "/tmp/result.text"
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY "\n"
FROM test_table;
</PRE>

<LI>

<A NAME="IDX1325"></A>
<CODE>INTO OUTFILE</CODE> の代わりに <CODE>INTO DUMPFILE</CODE> を使用すると、
<STRONG>MySQL</STRONG> はファイルに１レコードだけを書きます。フィールドや行の終端
とすべてのエスケープを含みません。これはファイル内に BLOB を格納したい場合
に便利です。

<LI>

注意: <CODE>INTO OUTFILE</CODE> と <CODE>INTO DUMPFILE</CODE> によって生成されたファイ
ルは、すべてのユーザに読み出し可能になります！ この理由は、
<STRONG>MySQL</STRONG> サーバは、実行ユーザ以外の誰かによって所有されているファイ
ルを生成できないからです(<CODE>mysqld</CODE> を root として動かすべきではありま
せん)。あなたがレコードを取り出すことが可能なように、ファイルは全員に読み
出し可能にする必要があります。

<LI>

ページ／レコードロックとともにテーブルハンドラ上で <CODE>FOR UPDATE</CODE> を使
用すると、検査されるレコードは書き込みロックされます。
</UL>

<P>
<A NAME="IDX1326"></A>
<A NAME="IDX1327"></A>
<A NAME="IDX1328"></A>
<A NAME="IDX1329"></A>
<A NAME="IDX1330"></A>
<A NAME="IDX1331"></A>
<A NAME="IDX1332"></A>
<A NAME="IDX1333"></A>
<A NAME="IDX1334"></A>
<A NAME="IDX1335"></A>
<A NAME="IDX1336"></A>
<A NAME="IDX1337"></A>


<H4><A NAME="JOIN" HREF="manual.ja_toc.html#JOIN">6.4.1.1  <CODE>JOIN</CODE> 構文</A></H4>

<P>
<STRONG>MySQL</STRONG>は、以下に示す<CODE>SELECT</CODE>ステートメントにおける<CODE>JOIN</CODE>構文をサポートします:

</P>

<PRE>
table_reference, table_reference
table_reference [CROSS] JOIN table_reference
table_reference INNER JOIN table_reference join_condition
table_reference STRAIGHT_JOIN table_reference
table_reference LEFT [OUTER] JOIN table_reference join_condition
table_reference LEFT [OUTER] JOIN table_reference
table_reference NATURAL [LEFT [OUTER]] JOIN table_reference
{ oj table_reference LEFT OUTER JOIN table_reference ON conditional_expr }
table_reference RIGHT [OUTER] JOIN table_reference join_condition
table_reference RIGHT [OUTER] JOIN table_reference
table_reference NATURAL [RIGHT [OUTER]] JOIN table_reference
</PRE>

<P>
Where <CODE>table_reference</CODE> is defined as:

<PRE>
table_name [[AS] alias] [USE INDEX (key_list)] [IGNORE INDEX (key_list)]
</PRE>

<P>
and <CODE>join_condition</CODE> is defined as:

</P>

<PRE>
ON conditional_expr |
USING (column_list)
</PRE>

<P>
注意: 3.23.17 より前のバージョンでは、<CODE>INNER JOIN</CODE> は <CODE>join_condition</CODE>
を取りません！

</P>
<P>
<A NAME="IDX1338"></A>
<A NAME="IDX1339"></A>
上に示す最後の<CODE>LEFT OUTER JOIN</CODE>構文は、ODBCとの互換性のためだけに存在します:

</P>

<UL>
<LI>

table referenceは、<CODE>tbl_name AS alias_name</CODE>や<CODE>tblname alias_name</CODE>に
よる別名を指定することができます:


<PRE>
mysql&#62; select t1.name, t2.salary from employee AS t1, info AS t2
           where t1.name = t2.name;
</PRE>

<LI>

<CODE>INNER JOIN</CODE>と<CODE>,</CODE> (コンマ)は、同義語です。どちらも使用される
テーブル間の直積をとります。通常は<CODE>WHERE</CODE>条件にて、テーブルがどのように
リンクされるべきかを定義します。

<LI>

<CODE>ON</CODE>条件節は、<CODE>WHERE</CODE>節で使用されるような条件文の書式です。

<LI>

もし、<CODE>LEFT JOIN</CODE> の <CODE>ON</CODE> や <CODE>USING</CODE> において
右側のテーブルにマッチするレコードが無かった場合、
全てのフィールドが<CODE>NULL</CODE>である1つのレコードが、右側のテーブルとして使用されます。
この事実は、あるテーブルについて、他のテーブルに対応するレコードが存在しない
レコードを探すということに利用できます:


<PRE>
mysql&#62; select table1.* from table1
           LEFT JOIN table2 ON table1.id=table2.id
           where table2.id is NULL;
</PRE>

この例は、<CODE>table1</CODE>の内、<CODE>id</CODE>の値が<CODE>table2</CODE>に存在しない全ての
レコードを検索します。
(即ち、<CODE>table2</CODE>内のレコードと一致しない<CODE>table1</CODE>の全てのレコード。)
もちろん、この場合の<CODE>table2.id</CODE>は、<CODE>NOT NULL</CODE>と定義されているもの
と仮定します。
 「<A HREF="manual.ja_MySQL_Optimization.html#LEFT_JOIN_optimization">5.2.6  MySQL はどのように <CODE>LEFT JOIN</CODE> と <CODE>RIGHT JOIN</CODE> を最適化するか？</A>」節参照.

<LI>

<CODE>USING</CODE> <CODE>(column_list)</CODE>節のフィールド名リストは、両方のテーブルに
存在しなければなりません。<CODE>USING</CODE>節が次のように:


<PRE>
A LEFT JOIN B USING (C1,C2,C3,...)
</PRE>

定義されることは、<CODE>ON</CODE>式がこのように定義されるのと同義です:


<PRE>
A.C1=B.C1 AND A.C2=B.C2 AND A.C3=B.C3,...
</PRE>

<LI>

同じフィールド名を持つ2つのテーブルの <CODE>NATURAL [LEFT] JOIN</CODE> は、
<CODE>USING</CODE> 節を伴った <CODE>INNER JOIN</CODE> や <CODE>LEFT JOIN</CODE> と
同じとして定義されます。

<LI>

<CODE>RIGHT JOIN</CODE> works analogously as <CODE>LEFT JOIN</CODE>.  To keep code
portable across databases, it's recommended to use <CODE>LEFT JOIN</CODE>
instead of <CODE>RIGHT JOIN</CODE>.

<LI>

<CODE>STRAIGHT_JOIN</CODE>は、右側のテーブルの前に、常に左側のテーブルを読むことを
除けば、<CODE>JOIN</CODE>と全く同じことです。これは、結合オプティマイザが、不当な
順序でテーブルを出力するようなまれな事態に使用できます。

<LI>

<STRONG>MySQL</STRONG> バージョン 3.23.12 から、テーブルから情報を取り出す時に、
<STRONG>MySQL</STRONG> がどのインデックスを使用すべきかというヒントを与えることが
できるようになりました。これは、<STRONG>MySQL</STRONG> が間違ったインデックスを使
用していることを <CODE>EXPLAIN</CODE> が示す場合に有用です。<CODE>USE INDEX
(key_list)</CODE> を指定することによって、テーブルからレコードを見つけるために、
指定されたインデックスの一つだけを使用するように <STRONG>MySQL</STRONG> に伝えるこ
とができます。別の構文 <CODE>IGNORE INDEX (key_list)</CODE> は、<STRONG>MySQL</STRONG> 
に特定のインデックスを使用しないように伝えるために使用できます。
</UL>

<P>
例:

</P>

<PRE>
mysql&#62; select * from table1,table2 where table1.id=table2.id;
mysql&#62; select * from table1 LEFT JOIN table2 ON table1.id=table2.id;
mysql&#62; select * from table1 LEFT JOIN table2 USING (id);
mysql&#62; select * from table1 LEFT JOIN table2 ON table1.id=table2.id
           LEFT JOIN table3 ON table2.id=table3.id;
mysql&#62; select * from table1 USE INDEX (key1,key2) WHERE key1=1 and key2=2 AND
       key3=3;
mysql&#62; select * from table1 IGNORE INDEX (key3) WHERE key1=1 and key2=2 AND
       key3=3;
</PRE>

<P>
 「<A HREF="manual.ja_MySQL_Optimization.html#LEFT_JOIN_optimization">5.2.6  MySQL はどのように <CODE>LEFT JOIN</CODE> と <CODE>RIGHT JOIN</CODE> を最適化するか？</A>」節参照.

</P>



<H3><A NAME="INSERT" HREF="manual.ja_toc.html#INSERT">6.4.2  <CODE>INSERT</CODE> 構文</A></H3>

<P>
<A NAME="IDX1340"></A>

</P>

<PRE>
    INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...),(...),...
or  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
or  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name
        SET col_name=expression, col_name=expression, ...

</PRE>

<P>
<CODE>INSERT</CODE>は、既存のテーブルに新しいレコードを挿入します。
<CODE>INSERT ... VALUES</CODE>書式は、値の明示指定を基本としてレコードを挿入します。
<CODE>INSERT ... SELECT</CODE>書式は、他の表(複数可)から抽出したレコードを挿入します。
複数の値リストを用いる<CODE>INSERT ... VALUES</CODE>書式は、
<STRONG>MySQL</STRONG> バージョン 3.22.5以降でサポートされています。
<CODE>col_name=expression</CODE>構文は、
<STRONG>MySQL</STRONG> バージョン 3.22.10以降でサポートされています。

</P>
<P>
<CODE>tbl_name</CODE>は、レコードを挿入するテーブルです。フィールド名リストは、
後続の値定義ステートメントのフィールドを指し示します:

</P>

<UL>
<LI>

もしいかなるフィールドも <CODE>INSERT ... VALUES</CODE> や <CODE>INSERT ... SELECT</CODE>
などで明示しなければ、全てのフィールドの値が <CODE>VALUES()</CODE> の中に与えられ
なくてはなりません。テーブル内のフィールド順が不明な場合、
これを調べるために<CODE>DESCRIBE tbl_name</CODE>を使用して下さい。

<LI>

テーブル内の一部のフィールドしか指定しない場合、指定されなかったフィールドには、
それぞれの初期値が指定されます。初期値の割当ては、
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節. で述べられています。

<LI>

<CODE>NULL</CODE>を<CODE>TIMESTAMP</CODE>フィールドに挿入した場合、フィールドには
現在時刻がセットされます。他の値を挿入した場合、指定された値が単純にセットされます。

<LI>

<CODE>expression</CODE>は、値リスト内で先頭に近い方のフィールドを参照しなければなりません。
例えば、次のように記述できます:


<PRE>
mysql&#62; INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);
</PRE>

しかし、次のようには記述できません:


<PRE>
mysql&#62; INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);
</PRE>

<LI>

キーワード<CODE>LOW_PRIORITY</CODE>を指定した場合、<CODE>INSERT</CODE>の実行はそのテー
ブルから値を読み込むクライアントがいなくなるまで遅らされます。この場合、ク
ライアントは insert 文が完了するまで待たされます。テーブルが頻繁に使用され
る場合、長い時間かかります。これはクライアントを一度に継続させる 
<CODE>INSERT DELAYED</CODE> と対称的です。
 「<A HREF="manual.ja_Reference.html#INSERT_DELAYED">6.4.3  <CODE>INSERT DELAYED</CODE> 構文</A>」節参照.  Note that <CODE>LOW_PRIORITY</CODE>
should normally not be used with <CODE>MyISAM</CODE> tables as this disables
concurrent inserts.  「<A HREF="manual.ja_Table_types.html#MyISAM">7.1  MyISAM Tables</A>」節参照.

<LI>

もし <CODE>IGNORE</CODE> キーワードを <CODE>INSERT</CODE> に 値とともに 与えるなら、
テーブル内の <CODE>PRIMARY</CODE> や <CODE>UNIQUE</CODE> キーにすでに存在する重複した
ものは無視され、挿入されません。
多重行の値を含むレコードの <CODE>INSERT</CODE> にキーワード <CODE>IGNORE</CODE> を
指定しない場合、テーブルの <CODE>PRIMARY</CODE> キーや <CODE>UNIQUE</CODE> キーに
重複が起こる際に、挿入処理が異常終了します。
<CODE>IGNORE</CODE> を指定した場合、重複するキー値を持つレコードは挿入されません。
C API 関数 <CODE>mysql_info()</CODE> により、テーブルにいくつのレコードが挿入
されたかチェックすることができます。

<LI>

<STRONG>MySQL</STRONG>が、<CODE>DONT_USE_DEFAULT_FIELDS</CODE>オプションにより制限されていた
場合、<CODE>NULL</CODE>値を許さない全てのフィールドに明示的に値をしないと
<CODE>INSERT</CODE>ステートメントは、エラーを生成します。
 「<A HREF="manual.ja_Installing.html#configure_options">2.3.3  典型的な <CODE>configure</CODE> オプション</A>」節参照.

<LI>

<CODE>mysql_insert_id</CODE> 関数で <CODE>AUTO_INCREMENT</CODE> フィールドに使用された
値を見つけることができます。
 「<A HREF="manual.ja_Clients.html#mysql_insert_id">8.4.3.126  <CODE>mysql_insert_id()</CODE></A>」節参照.
</UL>

<P>
<A NAME="IDX1341"></A>
多重の値リストを持つ <CODE>INSERT ... SELECT ...</CODE> 又は <CODE>INSERT ... VALUES()</CODE>
ステートメントを使用する場合、クエリーに関する情報を得るために
C API関数 <CODE>mysql_info()</CODE> を使用することができます。
その情報の書式は以下に示す文字列のようになります:

</P>

<PRE>
Records: 100 Duplicates: 0 Warnings: 0
</PRE>

<P>
<CODE>Duplicates</CODE>は、既に存在するユニークインデックスの値と重複することにより、
挿入できなかったレコード数を表します。
<CODE>Warnings</CODE>は、挿入されたフィールドが何らかの疑わしい値であったという
数を表します。警告は、次のような条件の下で発生します:

</P>

<UL>
<LI>

<CODE>NOT NULL</CODE>定義されたフィールドへの<CODE>NULL</CODE>の挿入。フィールドには
初期値が設定されます。

<LI>

数値フィールドの範囲を超える値のセット。値は範囲内の限界値に補正されます。

<LI>

数値フィールドへの <CODE>`10.34 a'</CODE> のような値のセット。引きずっている
ゴミは取り除かれ、残りの数値部分が挿入されます。
値が数値として判断できなかった場合、フィールドには <CODE>0</CODE> がセットされます。

<LI>

<CODE>CHAR</CODE>、<CODE>VARCHAR</CODE>、<CODE>VARCHAR</CODE>、<CODE>TEXT</CODE>又は<CODE>BLOB</CODE>
フィールドへの最大長を超える文字列の挿入。値はフィールドの最大長に切り捨てられます。

<LI>

日付又は時刻フィールドへのフィールド属性に反した挿入。その属性に適した
``ゼロ''値がセットされます。
</UL>

<P>
<A NAME="IDX1342"></A>
<A NAME="IDX1343"></A>

</P>



<H4><A NAME="INSERT_SELECT" HREF="manual.ja_toc.html#INSERT_SELECT">6.4.2.1  <CODE>INSERT ... SELECT</CODE> 構文</A></H4>


<PRE>
INSERT [LOW_PRIORITY] [IGNORE] [INTO] tbl_name [(column list)] SELECT ...
</PRE>

<P>
With <CODE>INSERT ... SELECT</CODE> statement you can quickly insert many rows
into a table from one or many tables.

</P>

<PRE>
INSERT INTO tblTemp2 (fldID) SELECT tblTemp1.fldOrder_ID FROM tblTemp1 WHERE
tblTemp1.fldOrder_ID &#62; 100;
</PRE>

<P>
The following conditions hold for an <CODE>INSERT ... SELECT</CODE> statement:

</P>

<UL>
<LI>

The target table of the <CODE>INSERT</CODE> statement cannot appear in the
<CODE>FROM</CODE> clause of the <CODE>SELECT</CODE> part of the query because it's
forbidden in ANSI SQL to <CODE>SELECT</CODE> from the same table into which you are
inserting.  (The problem is that the <CODE>SELECT</CODE> possibly would
find records that were inserted earlier during the same run.  When using
sub-select clauses, the situation could easily be very confusing!)

<LI>

<CODE>AUTO_INCREMENT</CODE> columns work as usual.

<LI>

You can use the C API function <CODE>mysql_info()</CODE> to get information about
the query.  「<A HREF="manual.ja_Reference.html#INSERT">6.4.2  <CODE>INSERT</CODE> 構文</A>」節参照.

<LI>

To ensure that the update log/binary log can be used to re-create the
original tables, MySQL will not allow concurrent inserts during
<CODE>INSERT .... SELECT</CODE>.
</UL>

<P>
You can of course also use <CODE>REPLACE</CODE> instead of <CODE>INSERT</CODE> to
overwrite old rows.

</P>



<H3><A NAME="INSERT_DELAYED" HREF="manual.ja_toc.html#INSERT_DELAYED">6.4.3  <CODE>INSERT DELAYED</CODE> 構文</A></H3>

<P>
<A NAME="IDX1344"></A>
<A NAME="IDX1345"></A>

</P>
<P>
<A NAME="IDX1346"></A>

</P>

<PRE>
INSERT DELAYED ...
</PRE>

<P>
<CODE>INSERT</CODE> 構文の <CODE>DELAYED</CODE> オプションは <STRONG>MySQL</STRONG> 独自の
オプションで、これは <CODE>INSERT</CODE> が完全に終了することを待てない
クライアントを持つ場合に、とても役立ちます。
これは、ロギングのために <STRONG>MySQL</STRONG> を使用する時の一般的な問題で、完了
に長い時間がかかる <CODE>SELECT</CODE> ステートメントも定期的に実行できます。
<CODE>DELAYED</CODE> は <STRONG>MySQL</STRONG> 3.22.15 で導入されました。  これは
 ANSI SQL92 に対する <STRONG>MySQL</STRONG> 拡張です。

</P>
<P>
<CODE>INSERT DELAYED</CODE> only works with <CODE>ISAM</CODE> and <CODE>MyISAM</CODE>
tables.  Note that as <CODE>MyISAM</CODE> tables supports concurrent
<CODE>SELECT</CODE> and <CODE>INSERT</CODE>, if there is no free blocks in the
middle of the data file, you very seldom need to use <CODE>INSERT
DELAYED</CODE> with <CODE>MyISAM</CODE>.  「<A HREF="manual.ja_Table_types.html#MyISAM">7.1  MyISAM Tables</A>」節参照.

</P>
<P>
<CODE>INSERT DELAYED</CODE> を使用する時、クライアントは一度 ok となり、テーブル
が他のスレッドで使用中でない時にレコードが挿入されます。

</P>
<P>
<CODE>INSERT DELAYED</CODE> を使用して得られるほかの利益は、
多くのクライアントからの insert が同時に束ねられ、一つのブロックで
書かれることです。 これは多くの別々の insert を実行するより
とても速くなります。

</P>
<P>
現在、キューイングされたレコードは、それらがテーブルに代入されるまで
メモリーに保持されているだけです。 これは、もし <CODE>mysqld</CODE> を
強引な方法 (<CODE>kill -9</CODE>) でキルしたり、 <CODE>mysqld</CODE> が予期せず
死んだ場合、キューイングされているレコードはディスクに書かれず失われます！

</P>
<P>
<CODE>DELAYED</CODE> オプションを <CODE>INSERT</CODE> や <CODE>REPLACE</CODE> で使用する場合、
以下のことがおきます。
ここで ``スレッド'' とは <CODE>INSERT DELAYED</CODE> コマンドを受けたスレッドをさし、
``ハンドラー'' とは特定のテーブルのための全ての
<CODE>INSERT DELAYED</CODE> 構文を操作するスレッドを指します。

</P>

<UL>
<LI>

スレッドがあるテーブルに対し <CODE>DELAYED</CODE> 構文を実行するとき、
そのテーブルに対する全ての <CODE>DELAYED</CODE> 構文
を処理するためにハンドラースレッドが作成されます。
もしそのようなハンドラーが存在していない場合には。

<LI>

そのスレッドは、そのハンドラーが <CODE>DELAYED</CODE> ロックを既に持っているか
どうかをチェックします； もし持っていないなら、そうするように
ハンドラーに告げます。 
たとえ他のスレッドが <CODE>READ</CODE> か <CODE>WRITE</CODE> ロックをそのテーブルに
持っていたとしても、 <CODE>DELAYED</CODE> ロックを得ることができます。
しかし、そのハンドラーは全ての <CODE>ALTER TABLE</CODE> ロックか
 <CODE>FLUSH TABLES</CODE> を待ちます。 そのテーブル構造が最新であるのを
確実にするために。

<LI>

スレッドは <CODE>INSERT</CODE> ステートメントを実行しますが、レコードをテーブル
に書く代わりに、ハンドラスレッドによって管理されるキューに最後のレコードの
コピーを置きます。文法エラーはスレッドによって通知され、クライアントプログ
ラムに報告されます。

<LI>

クライアントは結果行の重複数や <CODE>AUTO_INCREMENT</CODE> の値を
報告できません； それはサーバーから得ることができません。 なぜなら、
 <CODE>INSERT</CODE> はインサートオペレーションが完全に終了する前に
返るからです。 もし C API を使用しているなら、 <CODE>mysql_info()</CODE> 関数は
同様の理由によりなにも返しません。

<LI>

更新ログは、レコードがそのテーブルに insert されたとき、そのハンドラースレッド
によって更新されます。 複数レコードの挿入の場合、 更新ログは最初の行が
挿入されたときに更新されます。

<LI>

それぞれの <CODE>delayed_insert_limit</CODE> レコードが書かれた後、そのハンドラーは
いかなる <CODE>SELECT</CODE> 文もまだ延期されていないかを確認します。
もしそうなら、続ける前にこれらに対して実行を可能にします。

<LI>

ハンドラーのキュー内にレコードがなくなったとき、テーブルはアンロックされます。
もし新しい <CODE>INSERT DELAYED</CODE> コマンドが <CODE>delayed_insert_timeout</CODE> 秒以内に
受け付けられなければ、ハンドラーは終了します。

<LI>

もし、特定のハンドラーのキュー内に <CODE>delayed_queue_size</CODE> 以上のレコードが
既に延期されているならば、そのスレッドは、キューに余裕がある間待ちます。
これは <CODE>mysqld</CODE> サーバーが delayed されたキューに全ての
メモリーを確実に使用しないようにするのに役立ちます。

<LI>

そのハンドラースレッドは  <STRONG>MySQL</STRONG> プロセスリストの <CODE>Command</CODE> 項
内に、 <CODE>delayed_insert</CODE> と共に表示されます。
これは <CODE>FLUSH TABLES</CODE> コマンドか <CODE>KILL thread_id</CODE> を実行することで、
kill できるでしょう。
しかし、これらは、終了する前に、キュー内の全てのレコードをテーブルに
保存しようとします。
この間、このスレッドは、他のスレッドから来たいかなる
新しい <CODE>INSERT</CODE> コマンドも受け付けません。
もし、この後に <CODE>INSERT DELAYED</CODE> コマンドを実行するなら、
新しいハンドラースレッドが作成されます。

<LI>

上記のことは、もし <CODE>INSERT DELAYED</CODE> コマンドが既に走っているなら、
 <CODE>INSERT DELAYED</CODE> コマンドは、普通の <CODE>INSERT</CODE> コマンドよりも高い
優先度を持つということです！
他の update コマンドは <CODE>INSERT DELAY</CODE> キューが空になるまで、
あるいは誰かが <CODE>KILL thread_id</CODE> や <CODE>FLUSH TABLES</CODE> を実行して
ハンドラーをキルするまで、
待たされます。

<LI>

以下のステータス変数は <CODE>INSERT DELAYED</CODE> コマンドについての情報を
与えます：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Variable</STRONG> </TD><TD> <STRONG>Meaning</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Delayed_insert_threads</CODE> </TD><TD> ハンドラースレッドの数
</TR NOSAVE>
<TR><TD><CODE>Delayed_writes</CODE> </TD><TD> <CODE>INSERT DELAYED</CODE> で書かれるレコード数
</TR NOSAVE>
<TR><TD><CODE>Not_flushed_delayed_rows</CODE> </TD><TD> 書き込みを待つレコード数
</TR>
</TABLE>

これらの変数は <CODE>SHOW STATUS</CODE> 構文を発行したり
 <CODE>mysqladmin extended-status</CODE> コマンドを実行することで見れます.
</UL>

<P>
注意: <CODE>INSERT DELAYED</CODE> は、テーブルが使用中でない場合、通常の 
INSERT よりも遅くなります。<CODE>INSERT DELAYED</CODE> を使用する各テーブルにつ
いて別のスレッドを操作するサーバの、追加のオーバーヘッドもあります。これは、
確実にそれを必要とする時にだけ <CODE>INSERT DELAYED</CODE> を使用すべきことを意
味します！

</P>



<H3><A NAME="UPDATE" HREF="manual.ja_toc.html#UPDATE">6.4.4  <CODE>UPDATE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1347"></A>

</P>

<PRE>
UPDATE [LOW_PRIORITY] [IGNORE] tbl_name
    SET col_name1=expr1, [col_name2=expr2, ...]
    [WHERE where_definition]
    [LIMIT #]
</PRE>

<P>
<CODE>UPDATE</CODE> はテーブルに存在するレコードのフィールドを、新しい値に更新します。
<CODE>SET</CODE> 節はどのフィールドをどういった値にすべきかを示します。
<CODE>WHERE</CODE> 節が与えられた場合、更新すべきレコードを特定することになります。
それ以外は、全てのレコードを更新します。
<CODE>ORDER BY</CODE> 節が指定された場合、レコードは指定された順に更新されます。

</P>
<P>
<CODE>LOW_PRIORITY</CODE> キーワードを指定した場合、<CODE>UPDATE</CODE> の実行は、
テーブルを読んでいるクライアントがなくなるまで、遅らされます。

</P>
<P>
<CODE>IGNORE</CODE> キーワードを指定した場合は、update 文は、
update 中に二重キーのエラーを得たとしても、異常終了しません。
衝突を引き起こすレコードは更新されません。

</P>
<P>
表記中の <CODE>tbl_name</CODE> からのフィールドをアクセスすると、<CODE>UPDATE</CODE> 
は現在のフィールド値を使用します。例えば、次のステートメントは 
<CODE>age</CODE> フィールドにその現在値より１大きい値を設定します:

</P>

<PRE>
mysql&#62; UPDATE persondata SET age=age+1;
</PRE>

<P>
<CODE>UPDATE</CODE> は左から右に評価されます。例えば、以下の文は <CODE>age</CODE> フィールド
を 2倍にし、そのあと1増やします：

</P>

<PRE>
mysql&#62; UPDATE persondata SET age=age*2, age=age+1;
</PRE>

<P>
もしフィールドに現在もっている値を指定した場合、<STRONG>MySQL</STRONG> はそれを通知し、
値は更新しません。

</P>
<P>
<A NAME="IDX1348"></A>
<CODE>UPDATE</CODE> は変更されたレコード数を返します。
<STRONG>MySQL</STRONG> バージョン 3.22 以上では、C API 関数 <CODE>mysql_info()</CODE> が
マッチし更新されたレコード数を返します。また <CODE>UPDATE</CODE> 中に起きた
ワーニングの数も返します。

</P>
<P>
<STRONG>MySQL</STRONG> バージョン 3.23 では、 <CODE>LIMIT #</CODE> で指定した数だけレコードを
変更できます。

</P>



<H3><A NAME="DELETE" HREF="manual.ja_toc.html#DELETE">6.4.5  <CODE>DELETE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1349"></A>

</P>

<PRE>
DELETE [LOW_PRIORITY] FROM tbl_name
    [WHERE where_definition]
    [LIMIT rows]
</PRE>

<P>
<CODE>DELETE</CODE>は、<CODE>tbl_name</CODE>より、<CODE>where_definition</CODE>にて与えられた条件
を満たすレコードを削除し、削除されたレコード数を返します。

</P>
<P>
<CODE>WHERE</CODE>節を指定することなしに<CODE>DELETE</CODE>を発行した場合、全てのレコードが
削除されます。
もし <CODE>AUTOCOMMIT</CODE> モードでこの操作を実行するならば、これは
<CODE>TRUNCATE</CODE> と同様に動作します。 「<A HREF="manual.ja_Reference.html#TRUNCATE">6.4.6  <CODE>TRUNCATE</CODE> 構文</A>」節参照.
一つの問題は、今、<CODE>DELETE</CODE> は削除したレコード数を 0 で返すことですが、
これはバージョン 4.0 で修正する予定です。

</P>
<P>
もし全てのレコードを削除している時に、いくつのレコードが消され、いくつのレコード
が
スピードを犠牲にしているのか、本当に知りたいならば、
<CODE>DELETE</CODE> 構文を以下のように使用します：

</P>

<PRE>
mysql&#62; DELETE FROM tbl_name WHERE 1&#62;0;
</PRE>

<P>
これは <CODE>DELETE FROM tbl_name</CODE> を <CODE>WHERE</CODE> 節なしで行うよりも、
とても遅いです。なぜなら一度で消そうとするからです。

</P>
<P>
キーワード<CODE>LOW_PRIORITY</CODE>を指定した場合、そのテーブルを読んでいるクライアン
トがいなくなるまで<CODE>DELETE</CODE>の実行は遅らせられます。

</P>
<P>
削除されたレコードはリンクリストで維持され、次の<CODE>INSERT</CODE>操作は、古いレコー
ド位置を再利用します。
ファイルをより小さくしたい場合は、<CODE>OPTIMIZE TABLE</CODE>ステートメントかテーブル
の再編成のために<CODE>myisamchk</CODE>ユティリティを使用してください。
<CODE>OPTIMIZE TABLE</CODE>の方が簡単ですが、<CODE>myisamchk</CODE>の方が早く動作します。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  <CODE>OPTIMIZE TABLE</CODE> 構文</A>」節参照.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Optimization">4.4.6.10  テーブルの最適化</A>」節.

</P>
<P>
<STRONG>MySQL</STRONG>-特化  <CODE>DELETE</CODE> の <CODE>LIMIT rows</CODE> オプションは
サーバーに消す最大のレコード数をつげます。これは <CODE>DELETE</CODE> コマンドが
あまりに多くの時間を取らないために使用されます。
<CODE>LIMIT</CODE> 値よりも affected row の数が少なくなるまで、
単純に <CODE>DELETE</CODE> コマンドを繰り返すだけです。

</P>



<H3><A NAME="TRUNCATE" HREF="manual.ja_toc.html#TRUNCATE">6.4.6  <CODE>TRUNCATE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1350"></A>

</P>

<PRE>
TRUNCATE TABLE table_name
</PRE>

<P>
3.23 では、<CODE>DELETE FROM table_name</CODE> と同じことです。  「<A HREF="manual.ja_Reference.html#DELETE">6.4.5  <CODE>DELETE</CODE> 構文</A>」節参照.
違いは:

</P>

<UL>
<LI>

テーブルを破棄して再生成するように実装されています。これは多くのレコードを
削除する時により速くなります。
<LI>

トランザクション安全ではありません; <CODE>COMMIT</CODE> が呼ばれたかのように 
<CODE>TRUNCATE TABLE</CODE> は自動的に現在のトランザクションを終了します。
<LI>

削除したレコード数を返しません。
<LI>

テーブル定義ファイル <TT>`table_name.frm'</TT> が正しい限り、たとえ、データや
インデックスファイルが汚れても、テーブルはこの方法で再生成できます。
</UL>

<P>
<CODE>TRUNCATE</CODE> は ORACLE SQL 拡張です。

</P>



<H3><A NAME="REPLACE" HREF="manual.ja_toc.html#REPLACE">6.4.7  <CODE>REPLACE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1351"></A>

</P>

<PRE>
    REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...),(...),...
or  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
or  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name
        SET col_name=expression, col_name=expression,...
</PRE>

<P>
<CODE>REPLACE</CODE>は、テーブル中の古いレコードがユニークインデックス上の
新しいレコードと同じ値を持つ場合に、新しいレコードを挿入する前に、
古いレコードを削除するということを除けば、<CODE>INSERT</CODE>と全く同じように
動作します。 
 「<A HREF="manual.ja_Reference.html#INSERT">6.4.2  <CODE>INSERT</CODE> 構文</A>」節参照.

</P>
<P>
In other words, you can't access the values of the old row from a
<CODE>REPLACE</CODE> statement.  In some old MySQL version it looked
like you could do this, but that was a bug that has been corrected.

</P>
<P>
When one uses a <CODE>REPLACE</CODE> command, <CODE>mysql_affected_rows()</CODE>
will return 2 if the new row replaced and old row.  This is because in
this case one row was inserted and then the duplicate was deleted.

</P>
<P>
The above makes it easy to check if <CODE>REPLACE</CODE> added or replaced a
row.

</P>



<H3><A NAME="LOAD_DATA" HREF="manual.ja_toc.html#LOAD_DATA">6.4.8  <CODE>LOAD DATA INFILE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1352"></A>

</P>

<PRE>
LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name.txt'
    [REPLACE | IGNORE]
    INTO TABLE tbl_name
    [FIELDS
        [TERMINATED BY '\t']
        [[OPTIONALLY] ENCLOSED BY '']
        [ESCAPED BY '\\' ]
    ]
    [LINES TERMINATED BY '\n']
    [IGNORE number LINES]
    [(col_name,...)]
</PRE>

<P>
<CODE>LOAD DATA INFILE</CODE>ステートメントは、テキストファイルからテーブルへと、
レコードを高速に読み込みます。 <CODE>LOCAL</CODE> キーワードが指定されれば、ファイルは
クライアント・ホストから読み込まれます。
<CODE>LOCAL</CODE>が指定されなければ、ファイルはサーバに位置する必要があります
(<CODE>LOCAL</CODE>は、<STRONG>MySQL</STRONG> バージョン 3.22.6以降で利用できます)。

</P>
<P>
セキュリティ上の理由から、サーバからテキストファイルを読み出す時は、
ファイルがデータベースディレクトリに存在するか、
全てに読み込み権限がある必要があります。
また、サーバファイルで <CODE>LOAD DATA INFILE</CODE> を使用するには、
データベースの <STRONG>file</STRONG> 権限も持たなければなりません。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Privileges_provided">4.2.6  MySQL が提供する権限</A>」節参照.

</P>
<P>
もし <CODE>LOW_PRIORITY</CODE> を指定した場合、<CODE>LOAD DATA</CODE> 構文は
そのテーブルから他のクライアントが読み込みを行っている間、
遅らされます。

</P>
<P>
If you specify the keyword <CODE>CONCURRENT</CODE> with a <CODE>MyISAM</CODE> table,
then other threads can retrieve data from the table while <CODE>LOAD
DATA</CODE> is executing. Using this option will of course affect the
performance of <CODE>LOAD DATA</CODE> a bit even if no other thread is using
the table at the same time.

</P>
<P>
<CODE>LOCAL</CODE> 使用をすると、クライアント・ホストからサーバ・ホストへ
ファイルの内容が転送される分、多少遅くなるでしょう。
いうならば、ローカルのファイルを読み込むのに、
<STRONG>file</STRONG> 権限は必要ないということです。

</P>
<P>
If you are using MySQL before Version 3.23.24 you can't read from a
FIFO with <CODE>LOAD DATA INFILE</CODE>.  If you need to read from a FIFO (for
example the output from gunzip), use <CODE>LOAD DATA LOCAL INFILE</CODE>
instead.

</P>
<P>
<A NAME="IDX1353"></A>
<CODE>mysqlimport</CODE>ユティリティは、データファイルの読み込みに使用することができま
す。; これは、サーバに<CODE>LOAD DATA INFILE</CODE>コマンドを送信することによって処理
を実現しています。
<CODE>--local</CODE>オプションは、<CODE>mysqlimport</CODE>に、クライアント・ホストからデータ
ファイルを読み込ませます。
クライアントとサーバが圧縮プロトコルをサポートしていれば、低速なネットワークでよ
り良いパフォーマンスを得るために、<CODE>--compress</CODE>オプションを指定することがで
きます。

</P>
<P>
サーバ・ホストにファイルを置く場合、サーバは、以下のルールを使用します:

</P>

<UL>
<LI>

完全なパスでファイル名が与えられた場合、サーバはパス名をそのまま使用します。

<A NAME="IDX1354"></A>
<A NAME="IDX1355"></A>
<LI>

１つ又は複数の構成要素から成る相対パスと共にファイル名が与えられた場合、サーバは
、サーバのデータディレクトリ以下からファイルを探します。

<LI>

ファイル名だけが単に与えられた場合、サーバは、
カレントのデータベースディレクトリを探します。
</UL>

<P>
これらのルールは、ファイルが <TT>`myfile.txt'</TT> のように与えられれば
データベースディレクトリからファイルが読み出され、
<TT>`./myfile.txt'</TT> のように与えられれば、現在選択しているデータベースのデータデ
ィレクトリから
ファイルが読み出されるという意味であることに注意して下さい。

</P>
<P>
例えば、以下の <CODE>LOAD DATA</CODE> 文は、<TT>`data.txt'</TT> ファイルを
<CODE>db1</CODE> データベースディレクトリから読みます。 なぜなら、<CODE>db1</CODE> は
現在選択されているデータベースだからです。 たとえ、<CODE>db2</CODE> データベース
のテーブルに、ファイルから読み込んだデータを挿入するとしても。：

</P>
<P>
以下に示すような構文では、ファイルは <CODE>db1</CODE> データベースディレクトリ
から読まれます。<CODE>db2</CODE> ではありません:

</P>

<PRE>
mysql&#62; USE db1;
mysql&#62; LOAD DATA INFILE "data.txt" INTO TABLE db2.my_table;
</PRE>

<P>
<CODE>REPLACE</CODE> と <CODE>IGNORE</CODE> キーワードは、すでに存在するユニークキーに
重複しているレコードの入力に対する制御です。
<CODE>REPLACE</CODE> 指定の場合、同じユニークキーを持つ既存のレコードは新しいレコード
で置き換えられます。
<CODE>IGNORE</CODE> 指定の場合、既存のレコードのユニークキーと重複するキーをもつ新しい
レコードは飛ばされます。 もし、どちらも指定しなかった場合、重複したキーが
見つかった場合エラーが発生し、テキストファイルは無視されます。

</P>
<P>
<CODE>LOCAL</CODE> キーワードを使用してデータをローカルからロードする場合、
サーバーは操作の途中で転送をとめる方法を知りません。
それでデフォルトの動作としては <CODE>IGNORE</CODE> が指定されたのと
同じになります。

</P>
<P>
If you use <CODE>LOAD DATA INFILE</CODE> on an empty <CODE>MyISAM</CODE> table,
all non-unique indexes are created in a separate batch (like in <CODE>REPAIR</CODE>).
This normally makes <CODE>LOAD DATA INFILE</CODE> much faster when you have many
indexes.

</P>
<P>
<CODE>LOAD DATA INFILE</CODE>は、<CODE>SELECT ... INTO OUTFILE</CODE>の逆です。
 「<A HREF="manual.ja_Reference.html#SELECT">6.4.1  <CODE>SELECT</CODE> 構文</A>」節参照.
データベースからファイルへデータを書き込むには、<CODE>SELECT ... INTO OUTFILE</CODE>を
使用します。
ファイルからデータベースに読み戻すには、<CODE>LOAD DATA INFILE</CODE>を使用します。
<CODE>FIELDS</CODE>と<CODE>LINES</CODE>節の構文は両方のコマンドとも同じです。
どちらの節もオプションですが、両方を指定する場合は、<CODE>FIELDS</CODE>は、<CODE>LINES</CODE>
より先に指定しなければなりません。

</P>
<P>
<CODE>FIELDS</CODE>節を指定した場合、その段落(<CODE>TERMINATED BY</CODE>、<CODE>[OPTIONALLY]
 ENCLOSED BY</CODE>及び<CODE>ESCAPED BY</CODE>)は、少なくとも１つを指定しなければならないこ
とを除いて、それらもまたオプションとなります。

</P>
<P>
<CODE>FIELDS</CODE>節を指定しなかった場合、初期値は以下のように記述したのと等価となり
ます:

</P>

<PRE>
FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
</PRE>

<P>
<CODE>LINES</CODE>節を指定しなかった場合、初期値は以下のように記述したのと等価となりま
す:

</P>

<PRE>
LINES TERMINATED BY '\n'
</PRE>

<P>
言い換えると、<CODE>LOAD DATA INFILE</CODE> の初期値は、出力へ書き込む際に以下のように
振舞います:

</P>

<UL>
<LI>

改行をレコードの境界とみなす

<LI>

タブ文字によってフィールドを区切る

<LI>

クォート文字でフィールドを囲んでいないものとする

<LI>

タブ文字や改行文字及び<SAMP>`\'</SAMP>の前に<SAMP>`\'</SAMP>があることにより、それらをフィールド
値の一部のリテラル文字であるとして処理する。
</UL>

<P>
逆に、<CODE>LOAD DATA INFILE</CODE>の初期値は、入力を読み込む際に以下のように振舞いま
す:

</P>

<UL>
<LI>

フィールド間にタブ文字を書く

<LI>

いずれのクォート文字でもフィールドを囲まない

<LI>

<SAMP>`\'</SAMP>の使用により、フィールド値の中で使用するタブ文字や改行文字、<SAMP>`\'</SAMP>をエ
スケープする

<LI>

レコードの終りに改行文字を書く
</UL>

<P>
 <CODE>FIELDS ESCAPED BY '\\'</CODE>と書いた場合、単一のバックスラッシュとして読み出さ
れる値とするために、２つのバックスラッシュを指定しなければならないことに注意して
下さい。

</P>
<P>
<CODE>IGNORE number LINES</CODE> オプションはファイルの先頭にあるレコードを無視するの
に使用されます：

</P>

<PRE>
mysql&#62; LOAD DATA INFILE "/tmp/file_name" into table test IGNORE 1 LINES;
</PRE>

<P>
データベースからファイルへデータを書き、それから後でそのファイルからデータベース
へデータを読み戻すために、<CODE>SELECT ... INTO OUTFILE</CODE>と対に<CODE>LOAD DATA IN
FILE</CODE>を使う場合、双方のフィールドとレコードの取扱いに関するオプションは、一致し
なければなりません。さもなければ、<CODE>LOAD DATA INFILE</CODE>は適切にファイルを処理
しないでしょう。
 フィールドをコンマで区切ってファイルへ書き出すために、<CODE>SELECT ... INTO OUT
FILE</CODE>を使用するとすれば:

</P>

<PRE>
mysql&#62; SELECT * INTO OUTFILE 'data.txt'
           FIELDS TERMINATED BY ','
           FROM ...;
</PRE>

<P>
コンマ区切りファイルから読み戻すため、正しいステートメントはこうなるでしょう:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE table2
           FIELDS TERMINATED BY ',';
</PRE>

<P>
その代わりとして次に示すようなステートメントでファイルを読み込もうとしても、正し
く動作しないでしょう。なぜなら、これは、<CODE>LOAD DATA INFILE</CODE>に対してフィール
ドの間にタブを探すよう指示するからです:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE table2
           FIELDS TERMINATED BY '\t';
</PRE>

<P>
おそらく、それぞれの入力行は単一のフィールドとして処理されるでしょう。

</P>
<P>
<CODE>LOAD DATA INFILE</CODE>は外部ソースからもファイルを読み出すことができます。
例えば、dBASEフォーマットのファイルは、フィールドをコンマで区切られ、ダブルクォ
ーテーションで囲まれています。
レコードが改行文字で区切られているとしたら、次に示すフィールド及びレコードの取扱
オプションを指定したコマンドが、このようなファイルを読み込むのに使用できます。

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name
           FIELDS TERMINATED BY ',' ENCLOSED BY '"'
           LINES TERMINATED BY '\n';
</PRE>

<P>
いくつかのフィールド及びレコードの取扱オプションに、空文字列(<CODE>''</CODE>)を
指定することがあります。空でないなら、
<CODE>FIELDS [OPTIONALLY] ENCLOSED BY</CODE>と<CODE>FIELDS ESCAPED BY</CODE>の値は
単一の文字でなければなりません。
<CODE>FIELDS TERMINATED BY</CODE>と<CODE>LINES TERMINATED BY</CODE>は２つ以上の文字となるで
しょう。

</P>
<P>
例えば、リターン文字と改行文字のペアで区切られたレコードを書き込んだり、
このようなレコードを含んだファイルを読み込んだりするには、
<CODE>LINES TERMINATED BY '\r\n'</CODE>節を指定します。

</P>

<PRE>
create table jokes (a int not null auto_increment primary key, joke text
not null);
load data infile "/tmp/jokes.txt" into table jokes fields terminated by ""
lines terminated by "\n%%\n" (joke);
</PRE>

<P>
<CODE>FIELDS [OPTIONALLY] ENCLOSED BY</CODE>は、フィールドの引用符を制御します。出力の
際(<CODE>SELECT ... INTO OUTFILE</CODE>)、<CODE>OPTIONALLY</CODE>語を省いたなら、全てのフィ
ールドは<CODE>ENCLOSED BY</CODE>文字で囲まれます。このような出力(フィールド区切りにコ
ンマを使用)の例を次に示します:

</P>

<PRE>
"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"
</PRE>

<P>
<CODE>OPTIONALLY</CODE>を指定すれば、<CODE>ENCLOSED BY</CODE>文字は、 <CODE>CHAR</CODE>フィールド
と<CODE>VARCHAR</CODE>フィールドのみ囲むのに使用されます:

</P>

<PRE>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
</PRE>

<P>
フィールド値の中における<CODE>ENCLOSED BY</CODE>文字の出現は、<CODE>ESCAPED BY</CODE>文字を
その前に置くことによりエスケープされることに注意して下さい。<CODE>ESCAPED BY</CODE>値
に空を指定すると、<CODE>LOAD DATA INFILE</CODE>により正しく読み込めない出力を生成する
でしょう。例えば、このようにエスケープ文字を空にした場合、以下に示すような出力と
なります。４行目の２つ目のフィールドに、(誤って)フィールドを区切るかのようなクォ
ートに続くコンマを含んでいることに注視して下さい:

</P>

<PRE>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20
</PRE>

<P>
入力において、<CODE>ENCLOSED BY</CODE>文字が指定されており、それがフィールド値の両端に
現れた場合、その文字は取り去られます。(これは、<CODE>OPTIONALLY</CODE>が指定されたかど
うかに拘らず、当てはまります;<CODE>OPTIONALLY</CODE>は入力解析には効果がありません。)
 <CODE>ESCAPED BY</CODE>文字を前置きされた<CODE>ENCLOSED BY</CODE>文字の出現は、現在のフィー
ルド値の一部として処理されます。具体的には、あるフィールドがそれ自身、た<CODE>EN
CLOSED BY</CODE>文字で始まっている場合、フィールドらの内部で発生する２重の<CODE>ENCLOS
ED BY</CODE>文字は、単一の<CODE>ENCLOSED BY</CODE>文字として処理されます。
 例えば、<CODE>ENCLOSED BY '"'</CODE>が指定されると、引用符は以下のように操作されます:

</P>

<PRE>
"The ""BIG"" boss"  -&#62; The "BIG" boss
The "BIG" boss      -&#62; The "BIG" boss
The ""BIG"" boss    -&#62; The ""BIG"" boss
</PRE>

<P>
<CODE>FIELDS ESCAPED BY</CODE>は、特殊文字をどのように書き込んだり読み込んだりするかを
制御します。
 <CODE>FIELDS ESCAPED BY</CODE>文字が空でない場合、出力において次のような文字(文字列)
のプリフィックスに使用されます:

<UL>
<LI>

<CODE>FIELDS ESCAPED BY</CODE>文字
<LI>

<CODE>FIELDS [OPTIONALLY] ENCLOSED BY</CODE>文字
<LI>

<CODE>FIELDS TERMINATED BY</CODE>値と<CODE>LINES TERMINATED BY</CODE>値の最初の文字
<LI>

ASCII 0 (エスケープ文字の後に続いて実際に書かれる文字はASCII <CODE>'0'</CODE>で、'ゼロ
値'バイトではありません)
</UL>

<P>
<CODE>FIELDS ESCAPED BY</CODE>文字が空であれば、どの文字もエスケープされません。
特に、フィールド値が上に示した文字を含んでいるならば、エスケープ文字に空を指定す
るのはあまり良い考えとは言えないでしょう。

</P>
<P>
入力において、<CODE>FIELDS ESCAPED BY</CODE>文字が空でない場合、この文字の出現は取り去
られ、後続の文字はフィールド値の一部としてそのまま受け取られます。
例外は、エスケープされた<SAMP>`0'</SAMP>や<SAMP>`N'</SAMP>です
(例えば、エスケープ文字が<SAMP>`\'</SAMP>である時の<CODE>\0</CODE>や<CODE>\N</CODE>)。
これらのシーケンスは、ASCII 0('ゼロ値'バイト) 、<CODE>NULL</CODE>として処理されます。
code{NULL}操作の規則は下を参照して下さい。

</P>
<P>
<SAMP>`\'</SAMP>-escape syntaxに関するこれ以外の情報は、 「<A HREF="manual.ja_Reference.html#Literals">6.1.1  文字列と数値をどのように書くか？</A>」節参照。

</P>
<P>
フィールドとレコード操作オプションが確実に相互作用する事例:

</P>

<UL>
<LI>

<CODE>LINES TERMINATED BY</CODE>が空文字列で<CODE>FIELDS TERMINATED BY</CODE>が空でない場合
、各レコードもまた<CODE>FIELDS TERMINATED BY</CODE>で終らせられます。

<LI>

<CODE>FIELDS TERMINATED BY</CODE>と<CODE>FIELDS ENCLOSED BY</CODE>値が両方とも空(<CODE>''</CODE>)
の時、(区切られない)固定長行フォーマットが使用されます。
固定長行フォーマットでは、フィールド間に区切り文字列が使用されません。
その代わり、フィールド値は、フィールドの``表示''幅を使って書き込まれたり、読み込
まれます。
例えば、あるフィールドが<CODE>INT(7)</CODE>で定義されている場合、フィールドの値は7文字
の桁を使って書き込まれます。
入力においてフィールドは、７文字の読み込みにより得られます。
固定長行フォーマットはまた、<CODE>NULL</CODE>値の操作に好んで用いられます;下を参照のこ
と。
注意: マルチバイト文字セットを使用している場合は固定長フォーマットは働きま
せん。
</UL>

<P>
<CODE>FIELDS</CODE>と<CODE>LINES</CODE>オプションによる<CODE>NULL</CODE>値の多様な取扱い:

</P>

<UL>
<LI>

<CODE>FIELDS</CODE>と<CODE>LINES</CODE>の初期値のために、出力時に<CODE>NULL</CODE>は<CODE>\N</CODE>とし
て書き込まれ、入力時に<CODE>\N</CODE>は<CODE>NULL</CODE>として読み込まれます(当然のことなが
ら、<CODE>ESCAPED BY</CODE>文字は<SAMP>`\'</SAMP>とします)。

<LI>

<CODE>FIELDS ENCLOSED BY</CODE>が空で無い時、定数<CODE>NULL</CODE>のフィールド値は<CODE>NULL
</CODE>値として読み込まれます(これは、文字列<CODE>'NULL'</CODE>として読み込まれる<CODE>FIELD
S ENCLOSED BY</CODE>文字列で囲まれた<CODE>NULL</CODE>とは異なります)。

<LI>

<CODE>FIELDS ESCAPED BY</CODE>が空の時、<CODE>NULL</CODE>は<CODE>NULL</CODE>として書き込まれます。

<LI>

固定長行フォーマット(<CODE>FIELDS TERMINATED BY</CODE>と<CODE>FIELDS ENCLOSED BY</CODE>がい
ずれも空の場合に起こります)において、<CODE>NULL</CODE>は、空白文字列として書き込まれま
す。
これは、ファイル内では、<CODE>NULL</CODE>値と空白値の見分けがつかないということを示し
ていることに注意して下さい。ファイルからデータを読み戻す時に両者を区別しなければ
ならない場合、固定長行フォーマットは使用すべきではありません。
</UL>

<P>
<CODE>LOAD DATA INFILE</CODE>でサポートされないケース:

<UL>

<LI>

固定長行(<CODE>FIELDS TERMINATED BY</CODE>と<CODE>FIELDS ENCLOSED BY</CODE>の両方が空)と
<CODE>BLOB</CODE>フィールド。
<LI>

あるセパレータを他と同じかもしくは他のプリフィックスとした場合、<CODE>LOAD DATA 
INFILE</CODE>は、正しい入力処理ができないでしょう。
例えば、以下の<CODE>FIELDS</CODE>節は問題の原因となります:


<PRE>
FIELDS TERMINATED BY '"' ENCLOSED BY '"'
</PRE>

<LI>

<CODE>FIELDS ESCAPED BY</CODE>が空で、フィールド値に、<CODE>FIELDS ENCLOSED BY</CODE>値や
<CODE>LINES TERMINATED BY</CODE>値の後に<CODE>FIELDS TERMINATED BY</CODE>値がくるようなものを含
む場合、フィールドや行の読み込みが早めに打ち切られてしまいます。
これは、<CODE>LOAD DATA INFILE</CODE>が、フィールドやレコードの終了位置を正しく決めら
れないことにより発生します。
</UL>

<P>
次の例は、<CODE>persondata</CODE>テーブルの全てのフィールドを読み込みます:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</PRE>

<P>
フィールドリストが指定されていませんから、<CODE>LOAD DATA INFILE</CODE>は、入力レコー
ドがテーブルのそれぞれのフィールドを含むものと想定します。
<CODE>FIELDS</CODE>と<CODE>LINES</CODE>の初期値が使用されます。

</P>
<P>
テーブルの一部のフィールドのみ読み込みたい場合、フィールドリストを指定します:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'persondata.txt'
           INTO TABLE persondata (col1,col2,...);
</PRE>

<P>
テーブル内のフィールド順と入力ファイルのフィールド順が異なる場合にも、<STRONG>My
SQL</STRONG>にテーブルのフィールドと入力フィールドの対応を教えるために、フィールドリスト
を指定しなければなりません。

</P>
<P>
入力レコードのフィールド数の方が少ない場合、入力フィールド値が与えられないフィー
ルドは、初期値が設定されます。
初期値の割当てについては、 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節.
で述べられています。

</P>
<P>
空のフィールド値は変換されます：

</P>

<UL>
<LI>

文字型の場合、 フィールドの値は空文字にセットされます。

<LI>

数値型の場合、フィールドの値は <CODE>0</CODE> にセットされます。

<LI>

日付と時刻の型の場合、 フィールドの値は ``zero'' の意味する値がセットされます。
 「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節参照.
</UL>

<P>
Note that these are the same values that result if you assign an empty
string explicitly to a string, numeric, or date or time type explicitly
in an <CODE>INSERT</CODE> or <CODE>UPDATE</CODE> statement.

</P>
<P>
<CODE>TIMESTAMP</CODE> フィールドは、フィールド値に <CODE>NULL</CODE> 値が指定されていた場合
もしくは、
フィールドリストが指定されている時に <CODE>TIMESTAMP</CODE> フィールドがそのリストから
除外されていた場合
(最初の<CODE>TIMESTAMP</CODE>フィールドのみ)、現在時刻が設定されるだけです。

</P>
<P>
入力レコードのフィールド数の方が多い場合、余分なフィールドは無視され、警告の数が
増やされます。

</P>
<P>
<CODE>LOAD DATA INFILE</CODE>は全ての入力を文字列と文字列とみなすことから、<CODE>INSER
T</CODE>ステートメントでできるような<CODE>ENUM</CODE>フィールドや<CODE>SET</CODE>フィールドへの数
値の指定はできません。全ての<CODE>ENUM</CODE>及び<CODE>SET</CODE>値は文字列として与えられな
ければいけません！

</P>
<P>
<A NAME="IDX1356"></A>
<CODE>LOAD DATA INFILE</CODE>クエリの終了時、クエリの情報を得るためにC API関数<CODE>my
sql_info()</CODE>を使用することができます。情報の書式は以下に示すようなものです:

</P>

<PRE>
Records: 1  Deleted: 0  Skipped: 0  Warnings: 0
</PRE>

<P>
<CODE>LOAD DATA INFILE</CODE> が、入力レコードのフィールド数の過不足があった時にも
警告を引き起こす事を除けば、<CODE>INSERT</CODE> ステートメント
( 「<A HREF="manual.ja_Reference.html#INSERT">6.4.2  <CODE>INSERT</CODE> 構文</A>」節参照. ) により値が挿入される時に
警告が発生するのと同じ状況下で、警告が発生します。
警告はどこにも保存されません； 警告の数は全てうまくいった場合にだけ
使用できます。 もし警告を知りたい、その警告の理由を知りたいのなら、
一つ方法があります。 <CODE>SELECT ... INTO OUTFILE</CODE> を使用して
他のファイルに落とし、オリジナルのファイルと比べます。

</P>
<P>
パイプからの読み込みで <CODE>LOAD DATA</CODE> の必要があれば、次のトリッ
クを使用できます:

</P>

<PRE>
mkfifo /mysql/db/x/x
chmod 666 /mysql/db/x/x
cat &#60; /dev/tcp/10.1.1.12/4711 &#62; /nt/mysql/db/x/x
mysql -e "LOAD DATA INFILE 'x' INTO TABLE x" x
</PRE>

<P>
If you are using a version of MySQL older than 3.23.25
you can only do the above with <CODE>LOAD DATA LOCAL INFILE</CODE>.

</P>
<P>
<CODE>INSERT</CODE>と比較した<CODE>LOAD DATA INFILE</CODE>の効率や<CODE>LOAD DATA INFILE</CODE>の
高速化についてのより詳しい情報は、 「<A HREF="manual.ja_MySQL_Optimization.html#Insert_speed">5.2.8  <CODE>INSERT</CODE> クエリの速度</A>」節参照を参照のこと。

</P>



<H3><A NAME="DO" HREF="manual.ja_toc.html#DO">6.4.9  <CODE>DO</CODE> Syntax</A></H3>

<P>
<A NAME="IDX1357"></A>

</P>

<PRE>
DO expression, [expression, ...]
</PRE>

<P>
Execute the expression but don't return any results.  This is a
shorthand of <CODE>SELECT expression, expression</CODE>, but has the advantage
that it's slightly faster when you don't care about the result.

</P>
<P>
This is mainly useful with functions that has side effects, like
<CODE>RELEASE_LOCK</CODE>.

</P>



<H2><A NAME="Data_Definition" HREF="manual.ja_toc.html#Data_Definition">6.5  Data Definition: <CODE>CREATE</CODE>, <CODE>DROP</CODE>, <CODE>ALTER</CODE></A></H2>



<H3><A NAME="CREATE_DATABASE" HREF="manual.ja_toc.html#CREATE_DATABASE">6.5.1  <CODE>CREATE DATABASE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1358"></A>

</P>

<PRE>
CREATE DATABASE [IF NOT EXISTS] db_name
</PRE>

<P>
<CODE>CREATE DATABASE</CODE> は与えられた名前のデータベースを作ります。データベースの
名前として許される命名規則は、 「<A HREF="manual.ja_Reference.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A>」節に依ります。
もし、データベースがすでに存在しているにもかかわらず <CODE>IF NOT EXISTS</CODE> を
指定していなかったら、エラーが発生します。

</P>
<P>
<STRONG>MySQL</STRONG>におけるデータベースは、データベース内のテーブルに相当するファイル
を含むディレクトリとして実装されます。初期作成後はデータベース内にテーブルは存在
せず、<CODE>CREATE DATABASE</CODE>ステートメントは、<STRONG>MySQL</STRONG>データディレクトリ下
にディレクトリを作成するだけです。

</P>
<P>
<A NAME="IDX1359"></A>
<CODE>mysqladmin</CODE>でもデータベースを作成することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  MySQL Client-Side Scripts and Utilities</A>」節参照.

</P>



<H3><A NAME="DROP_DATABASE" HREF="manual.ja_toc.html#DROP_DATABASE">6.5.2  <CODE>DROP DATABASE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1360"></A>

</P>

<PRE>
DROP DATABASE [IF EXISTS] db_name
</PRE>

<P>
<CODE>DROP DATABASE</CODE>は、データベース内の全てのテーブルと共にデータベースを破棄し
ます。
シンボリックリンクされた <CODE>DROP DATABASE</CODE> を行なうと、リンクとオリジナ
ルデータベースの両方が削除されます。
<STRONG>このコマンドの使用には万全の注意を払って下さい！</STRONG> 

</P>
<P>
<CODE>DROP DATABASE</CODE>は、データベースディレクトリから削除されたファイルの数を返し
ます。それぞれのテーブルは<TT>`.MYD'</TT>ファイル／<TT>`.MYI'</TT>ファイル／<TT>`.frm'</TT>
ファイルに相当することから、通常この値はテーブルの３倍の数となります。

</P>
<P>
<CODE>DROP DATABASE</CODE> コマンドは与えられたデータベースディレクトリから、次
の拡張子のすべてのファイルを削除します:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>.BAK </TD><TD> .DAT </TD><TD> .HSH </TD><TD> .ISD
</TR NOSAVE>
<TR><TD>.ISM </TD><TD> .ISM </TD><TD> .MRG </TD><TD> .MYD
</TR NOSAVE>
<TR><TD>.MYI </TD><TD> .db </TD><TD> .frm
</TR>
</TABLE>

<P>
2桁の数値のすべてのサブディレクトリ(<CODE>RAID</CODE> ディレクトリ)も削除されま
す。

</P>
<P>
<STRONG>MySQL</STRONG> 3.22以降では、データベースが存在しないことに起因するエラーを防ぐ
ために、キーワード <CODE>IF EXISTS</CODE> を使用することができます。

</P>
<P>
<A NAME="IDX1361"></A>
<CODE>mysqladmin</CODE>でもデータベースを破棄することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  MySQL Client-Side Scripts and Utilities</A>」節参照.

</P>



<H3><A NAME="CREATE_TABLE" HREF="manual.ja_toc.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1362"></A>

</P>


<PRE>
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)]
[table_options] [select_statement]

create_definition:
  col_name type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT]
            [PRIMARY KEY] [reference_definition]
  or    PRIMARY KEY (index_col_name,...)
  or    KEY [index_name] (index_col_name,...)
  or    INDEX [index_name] (index_col_name,...)
  or    UNIQUE [INDEX] [index_name] (index_col_name,...)
  or    FULLTEXT [INDEX] [index_name] (index_col_name,...)
  or    [CONSTRAINT symbol] FOREIGN KEY index_name (index_col_name,...)
            [reference_definition]
  or    CHECK (expr)

type:
        TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  or    SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  or    MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  or    INT[(length)] [UNSIGNED] [ZEROFILL]
  or    INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  or    BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  or    REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]
  or    NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]
  or    CHAR(length) [BINARY]
  or    VARCHAR(length) [BINARY]
  or    DATE
  or    TIME
  or    TIMESTAMP
  or    DATETIME
  or    TINYBLOB
  or    BLOB
  or    MEDIUMBLOB
  or    LONGBLOB
  or    TINYTEXT
  or    TEXT
  or    MEDIUMTEXT
  or    LONGTEXT
  or    ENUM(value1,value2,value3,...)
  or    SET(value1,value2,value3,...)

index_col_name:
        col_name [(length)]

reference_definition:
        REFERENCES tbl_name [(index_col_name,...)]
                   [MATCH FULL | MATCH PARTIAL]
                   [ON DELETE reference_option]
                   [ON UPDATE reference_option]

reference_option:
        RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

table_options:
	TYPE = {BDB | HEAP | ISAM | InnoDB | MERGE | MYISAM }
or	AUTO_INCREMENT = #
or	AVG_ROW_LENGTH = #
or	CHECKSUM = {0 | 1}
or	COMMENT = "string"
or	MAX_ROWS = #
or	MIN_ROWS = #
or	PACK_KEYS = {0 | 1}
or	PASSWORD = "string"
or	DELAY_KEY_WRITE = {0 | 1}
or      ROW_FORMAT= { default | dynamic | fixed | compressed }
or	RAID_TYPE= {1 | STRIPED | RAID0 } RAID_CHUNKS=#  RAID_CHUNKSIZE=#
or	UNION = (table_name,[table_name...])
or      DATA DIRECTORY="directory"
or      INDEX DIRECTORY="directory"

select_statement:
	[IGNORE | REPLACE] SELECT ...  (Some legal select statement)
</PRE>

<P>
<CODE>CREATE TABLE</CODE>はカレントデータベースに、与えられた名前のテーブルを
作成します。テーブルの名前として許される命名規則は、 「<A HREF="manual.ja_Reference.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A>」節参照に
依ります。
カレントデータベースが無い場合や、テーブルが既に存在している場合はエラーが
発生します。

</P>
<P>
<STRONG>MySQL</STRONG> バージョン 3.22 以降ではテーブル名は <CODE>db_name.tbl_name</CODE> とい
う形で与える事もできます。
これはカレントデータベースがあるかどうかにに関係なく動作します。

</P>
<P>
<STRONG>MySQL</STRONG> バージョン 3.23 では、テーブル作成時に <CODE>TEMPORARY</CODE> キーワー
ドを使用することができます。 
一時テーブルは、もし、コネクションが落ちた場合、自動で消去されます。
一時テーブルの名前はそれぞれの接続ごとです。
これは、二つの違う接続で、同じ名前の一時テーブルを
衝突することなく、使用できるという事です。
さらには、既に存在するテーブルと同名であっても、一時テーブルは使用できます。
(一時テーブルが削除されるまで、実在するテーブルは隠されます)

</P>
<P>
<STRONG>MySQL</STRONG> バージョン 3.23 以降では、 <CODE>IF NOT EXISTS</CODE> キーワードを使用
できます。
これは、もしテーブルが既に存在していた場合、エラーを発生させません。
テーブルの構造が一意かどうかまでは検査しないことに注意。

</P>
<P>
それぞれのテーブルは、データベースディレクトリにおける以下の複数の
ファイルで表されます。これは MyISAM 型 のテーブル場合：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>File</STRONG> </TD><TD> <STRONG>Purpose</STRONG>
</TR NOSAVE>
<TR><TD><CODE>tbl_name.frm</CODE> </TD><TD> Table definition (form) file
</TR NOSAVE>
<TR><TD><CODE>tbl_name.MYD</CODE> </TD><TD> Data file
</TR NOSAVE>
<TR><TD><CODE>tbl_name.MYI</CODE> </TD><TD> Index file
</TR>
</TABLE>

<P>
フィールドに対する種々の型属性の詳細は、 「<A HREF="manual.ja_Reference.html#Column_types">6.2  フィールド型</A>」節を参照のこと。

</P>

<UL>
<LI>

 <CODE>NULL</CODE>も<CODE>NOT NULL</CODE>も指定されなかった場合、フィールドは<CODE>NULL</CODE>が指
定されたものとして扱われます。

<LI>

   整数型のフィールドには付加属性<CODE>AUTO_INCREMENT</CODE>も指定することができます。
<CODE>AUTO_INCREMENT</CODE>のフィールドに値<CODE>NULL</CODE>又は<CODE>0</CODE>を挿入した場合、フィ
ールドには<CODE>value+1</CODE>の値がセットされます。<CODE>value</CODE>は、そのテーブル内の当
該フィールドにおける現在の最大値です。
<CODE>AUTO_INCREMENT</CODE> は <CODE>1</CODE> からはじまります.
 「<A HREF="manual.ja_Clients.html#mysql_insert_id">8.4.3.126  <CODE>mysql_insert_id()</CODE></A>」節参照.

 削除したレコードが、<CODE>AUTO_INCREMENT</CODE>フィールドの最大値を含んでいた場合、
その値は、<CODE>ISAM</CODE> と <CODE>BDB</CODE> テーブルでは、次に再利用されますが、
<CODE>MyISAM</CODE> と <CODE>InnoDB</CODE> テーブルでは再利用されません。
また、テーブル内の全てのレコードを <CODE>DELETE FROM table_name</CODE> (<CODE>WHERE</CODE>節
無しで) を
<CODE>AUTOCOMMIT</CODE> モードで使用して削除した場合は、すべてのテーブル型で始めから採
番し直します。

<STRONG>注意:</STRONG> 1つのテーブルには1つしか<CODE>AUTO_INCREMENT</CODE>フィールドを指定でき
ません。
また、インデックスを指定する必要があります。
<STRONG>MySQL</STRONG> 3.23 は auto_increment フィールドが正の数を持っている場合に
だけ、正しく動作します。負の数の挿入はとても大きな正の数の挿入とみなされま
す。これは、数値が正から負への 'wrap' over する時の精度の問題を回避するた
めと、アクシデント的に 0 を含む auto_increment フィールドを得ることがない
ことを確実にするために、行なわれます。

<A NAME="IDX1363"></A>
<A NAME="IDX1364"></A>
<STRONG>MySQL</STRONG> をいくつかの ODBC アプリケーションと互換にするために、次の
クエリで最後に挿入されたレコードを見つけることができます:


<PRE>
SELECT * FROM tbl_name WHERE auto_col IS NULL
</PRE>

<LI>

<CODE>TIMESTAMP</CODE>フィールドにおける<CODE>NULL</CODE>値は、他のフィールド属性と違った扱
われ方をします。定数<CODE>NULL</CODE>を<CODE>TIMESTAMP</CODE>フィールドに格納することはでき
ません。<CODE>NULL</CODE>値の指定は現在時刻をセットすることを意味します。<CODE>TIMESTA
MP</CODE>フィールドがこのように振舞うので、通常は<CODE>NULL</CODE>属性や<CODE>NOT NULL</CODE>属性
は適用できません。それらを指定しても無視されます。

 一方、<STRONG>MySQL</STRONG>クライアントからは、より安易に<CODE>TIMESTAMP</CODE>フィールドを
利用でき、サーバも<CODE>TIMESTAMP</CODE>フィールドへの<CODE>NULL</CODE>の適用を報告しますが
、<CODE>TIMESTAMP</CODE>フィールドは実際には<CODE>NULL</CODE>値を保存することはありません。
code{DESCRIBE tbl_name}を使用して、テーブル定義文を取得することにより、この現象
を確認することができます。

 <CODE>TIMESTAMP</CODE>フィールドに<CODE>0</CODE>を指定することは、<CODE>NULL</CODE>を指定すること
と等しくないことに注意してください。なぜなら、<CODE>0</CODE>は<CODE>TIMESTAMP</CODE>の値とし
て不正であるからです。

<LI>

フィールドに対して <CODE>DEFAULT</CODE> 値が指定されない場合は <STRONG>MySQL</STRONG> が
自動的にそれを割り当てます。

フィールドが <CODE>NULL</CODE> を値として取り得る場合は、デフォルト値は 
<CODE>NULL</CODE> です。

フィールドが <CODE>NOT NULL</CODE> として宣言された場合は、デフォルト値はフィー
ルド型に依存します:


<UL>
<LI>

<CODE>AUTO_INCREMENT</CODE> 定義された以外の数値型のフィールドに対しては、
初期値は<CODE>0</CODE>となります。
<CODE>AUTO_INCREMENT</CODE>フィールドでは、デフォルト値は次のシーケンス番号になります。

<LI>

<CODE>TIMESTAMP</CODE> 型以外の日付型と時刻型のフィールドに対しては、
初期値はその型において適切な``ゼロ''値となります。
例外: フィールドがそのテーブル内で最初の<CODE>TIMESTAMP</CODE>フィールドである場合、初
期値は現在時刻になります。
 「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節参照.

<LI>

<CODE>ENUM</CODE> 以外の文字列型のフィールドに対しては、初期値は空文字列となります。
<CODE>ENUM</CODE> では、デフォルト値は最初の列挙値です。
</UL>

Default values must be constants. This means, for example, that you cannot
set the default for a date column to be the value of a function such as
<CODE>NOW()</CODE> or <CODE>CURRENT_DATE</CODE>.

<LI>

<CODE>KEY</CODE>は、<CODE>INDEX</CODE>の同義語です。

<LI>

<STRONG>MySQL</STRONG>では、<CODE>UNIQUE</CODE>キーは固有値しか持つことができません。既に存在
するレコードとキーの値が重複するレコードを挿入しようとした場合、エラーが発生しま
す。

<LI>

<A NAME="IDX1365"></A>
<CODE>PRIMARY KEY</CODE> はユニーク <CODE>KEY</CODE> で、すべてのキーフィールドは 
<CODE>NOT NULL</CODE> として定義されなければならないという特別な制限を伴います。
<STRONG>MySQL</STRONG> ではキーは <CODE>PRIMARY</CODE> と名付けられます。テーブルは 
<CODE>PRIMARY KEY</CODE> を一つだけ持つことができます。<CODE>PRIMARY KEY</CODE> を持た
ない場合に、アプリケーションがテーブル内の <CODE>PRIMARY KEY</CODE> を尋ねると、
<STRONG>MySQL</STRONG> は <CODE>PRIMARY KEY</CODE> として、<CODE>NULL</CODE> フィールドを持た
ない最初の <CODE>UNIQUE</CODE> キーを返します。

<LI>

<CODE>PRIMARY KEY</CODE>は複数フィールドインデックスとできます。しかしながら、1つのフ
ィールド定義内では<CODE>PRIMARY KEY</CODE>属性を用いて複合インデックスを定義することが
できませんので、フィールド定義内における指定は、プライマリ・キーが単独フィールド
の場合のみとして下さい。複合フィールドの場合は、
<CODE>PRIMARY KEY(index_col_name,...)</CODE>文を使用しなければなりません。

<LI>

<CODE>PRIMARY</CODE> や <CODE>UNIQUE</CODE> キーが１つのフィールドだけからなり、その型が整数
の場合、それを <CODE>_rowid</CODE> としても参照することができます
(バージョン 3.23.11 での新機能)。

<LI>

インデックスに名前を割り当てない場合、一意な名前を付けるために、<CODE>index_col_
name</CODE>内の最初のフィールド名に(<CODE>_2</CODE>, <CODE>_3</CODE>, ...)のようなサフィックスを付
加したものが割り当てられます。テーブルが使用しているインデックス名は、<CODE>SHOW
 INDEX FROM tbl_name</CODE>により確認することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW">4.5.5  <CODE>SHOW</CODE> 構文</A>」節参照.

<LI>

<A NAME="IDX1366"></A>
<A NAME="IDX1367"></A>
<CODE>MyISAM</CODE> テーブルのみが、<CODE>NULL</CODE> 値をもつフィールドに対して
インデックスを持つことが出来ます。
その他のテーブル型の場合、フィールドを <CODE>NOT NULL</CODE> で定義しなくてはなりませ
ん。

<LI>

<CODE>col_name(length)</CODE>文を共に指定することで、<CODE>CHAR</CODE>フィールド又は
<CODE>VARCHAR</CODE>フィールドの一部分だけをインデックスとして定義できます。
これによりインデックスファイルを適度に小さくすることができます。
 「<A HREF="manual.ja_MySQL_Optimization.html#Indexes">5.4.4  Column Indexes</A>」節参照.

<LI>

<A NAME="IDX1368"></A>
<A NAME="IDX1369"></A>
<A NAME="IDX1370"></A>
<A NAME="IDX1371"></A>
<CODE>MyISAM</CODE> テーブル型のみが、 <CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィールド上に
インデックスを持つことが出来ます。 <CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィールドに
インデックスを張る場合、常に、インデックスの長さを指定しなくてはなりません：

<PRE>
CREATE TABLE test (blob_col BLOB, index(blob_col(10)));
</PRE>

<LI>

<CODE>TEXT</CODE>フィールドや<CODE>BLOB</CODE>フィールドで <CODE>ORDER BY</CODE> や
<CODE>GROUP BY</CODE> を使用すると、
最初の<CODE>max_sort_length</CODE>バイトだけが使用されます。
 「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<LI>

<STRONG>MySQL</STRONG> バージョン 3.23.23 以降では、特殊な <STRONG>FULLTEXT</STRONG> イン
デックスも生成できます。それらは全文検索に使用されます。<CODE>MyISAM</CODE> テー
ブル型だけが <CODE>FULLTEXT</CODE> インデックスをサポートします。それらは 
<CODE>VARCHAR</CODE> と <CODE>TEXT</CODE> フィールドからだけ生成できます。インデックス
は常にフィールド全体に起こります。部分インデックスはサポートされません。オ
ペレーションの詳細は  「<A HREF="manual.ja_Reference.html#Fulltext_Search">6.8  MySQL Full-text Search</A>」節 を見てください。

<LI>

<CODE>FOREIGN KEY</CODE>、<CODE>CHECK</CODE>及び<CODE>REFERENCES</CODE>節は実際には何も行いません。
これらの構文は、互換性のためだけに用意されており、他のSQLサーバからのコードの
移植を容易にしたり、参照情報と共にテーブルを作成するようなアプリケーションを動作
させることを目的としています。
 「<A HREF="manual.ja_Introduction.html#Missing_functions">1.4.4  MySQL に無い機能</A>」節参照.

<LI>

全ての<CODE>NULL</CODE>フィールドは、1ビット余計に消費し、直近のバイトに丸められます。

<LI>

レコードの最大長は、以下のようにして求められます:


<PRE>
レコードの長さ = 1
             + (フィールドの長さの合計)
             + (NULLフィールドの数 + 7)/8
             + (可変長フィールドの数)
</PRE>

<LI>

<CODE>table_options</CODE> と <CODE>SELECT</CODE> オプションは、
<STRONG>MySQL</STRONG> 3.23 以上でのみ実装されます。
 
テーブル型は：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>BDB または Berkeley_db </TD><TD> トランザクションセーフなテーブル  「<A HREF="manual.ja_Table_types.html#BDB">7.5  BDB or Berkeley_DB Tables</A>」節参照.
</TR NOSAVE>
<TR><TD>HEAP </TD><TD> このテーブルのデータは、メモリー内にのみ蓄えられる  「<A HREF="manual.ja_Table_types.html#HEAP">7.4  HEAP Tables</A>」節参照.
</TR NOSAVE>
<TR><TD>ISAM </TD><TD> オリジナルのテーブル  「<A HREF="manual.ja_Table_types.html#ISAM">7.3  ISAM Tables</A>」節参照.
</TR NOSAVE>
<TR><TD>InnoDB </TD><TD> レコードロッキングを持ったトランザクション安全テーブル  「<A HREF="manual.ja_Table_types.html#InnoDB">7.6  InnoDB テーブル</A>」節参照.
</TR NOSAVE>
<TR><TD>MERGE </TD><TD> 一つのテーブルとして使用される MyISAM テーブルの集まり  「<A HREF="manual.ja_Table_types.html#MERGE">7.2  MERGE Tables</A>」節参照.
</TR NOSAVE>
<TR><TD>MyISAM </TD><TD> ISAM にかわる 新しい バイナリ互換のテーブル。  「<A HREF="manual.ja_Table_types.html#MyISAM">7.1  MyISAM Tables</A>」節参照.
</TR>
</TABLE>
 「<A HREF="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</A>」節参照.

テーブル型が指定され、特定の型が有効でない場合、<STRONG>MySQL</STRONG> は指定され
たものに近いテーブル型を選択します。例えば、<CODE>TYPE=BDB</CODE> が指定されて、
<STRONG>MySQL</STRONG> のディストリビューションが <CODE>BDB</CODE> テーブルをサポートし
ない場合、代わりにテーブルは <CODE>MyISAM</CODE> として生成されます。

その他のテーブルオプションを使って、テーブルの振る舞いを最適化します。
たいていの場合は、オプションを明示する必要がありません。 
明示的に指定されなかった場合、オプションはすべてのテーブル型に作用します。

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>AUTO_INCREMENT</CODE> </TD><TD> あなたがこのテーブルにセットしたい、次の auto_increment 値
</TR NOSAVE>
<TR><TD><CODE>AVG_ROW_LENGTH</CODE> </TD><TD> テーブルに含まれるレコードの長さのおおよその平均値。 可変長のレコードを持つ大きなテーブルに対してのみ、これをセットします。
</TR NOSAVE>
<TR><TD><CODE>CHECKSUM</CODE> </TD><TD> <STRONG>MySQL</STRONG> に全てのレコードをチェックさせたい場合、これを 1 にセットします。 (これは更新を遅くさせますが、不整合の生じたテーブルを見つけ出しやすくなります) (MyISAM)
</TR NOSAVE>
<TR><TD><CODE>COMMENT</CODE> </TD><TD> テーブルの、60文字コメント
</TR NOSAVE>
<TR><TD><CODE>MAX_ROWS</CODE> </TD><TD> あなたがテーブルに保存したいと考えている最大レコード数。
</TR NOSAVE>
<TR><TD><CODE>MIN_ROWS</CODE> </TD><TD> あなたがテーブルに保存したいと考えている最低レコード数
</TR NOSAVE>
<TR><TD><CODE>PACK_KEYS</CODE> </TD><TD> より小さいインデックスにしたいなら、これを 1 にします。 これは更新を遅くしますが、読み出しは速くなります (MyISAM, ISAM).
</TR NOSAVE>
<TR><TD><CODE>PASSWORD</CODE> </TD><TD> <CODE>.frm</CODE> ファイルをパスワード付きで暗号化。 このオプションは、標準の <STRONG>MySQL</STRONG> バージョンではなにも行いません。
</TR NOSAVE>
<TR><TD><CODE>DELAY_KEY_WRITE</CODE> </TD><TD> テーブルがクローズされるまでキーテーブルの更新を送らせたい場合、1に設定します(MyISAM)。
</TR NOSAVE>
<TR><TD><CODE>ROW_FORMAT</CODE> </TD><TD> レコードがどのように格納されるかを定義します。現在 DYNAMIC と STATIC オプションが MyISAM テーブルのために使用できるだけです。
</TR>
</TABLE>

<CODE>MyISAM</CODE> テーブルを使用するならば、<STRONG>MySQL</STRONG> は
<CODE>max_rows * avg_row_length</CODE> の値を、テーブルがどのくらい大きくなるか
の推定に使用します。 
もし、上記のオプションをなにも指定しなかった場合、テーブルの最大サイズは
4G になります。(か、あなたの OS が 2G しかサポートしていなければ 2G まで)
この理由は、大きなファイルを本当に必要としない場合は、インデックスをより小
さく、より速くするため、ポインタサイズを小さく保持するためです。

<CODE>PACK_KEYS</CODE> を使用しない場合、デフォルトは文字列だけをパックし、数値
はパックしません。<CODE>PACK_KEYS=1</CODE> を使用するとさらに数値もパックされま
す。

バイナリ数値キーをパックする時、<STRONG>MySQL</STRONG> はプレフィックス圧縮を使用
します。これは、同じ数値を多く持つ場合にだけこの大きな恩恵を得るということ
を意味します。プレフィックス圧縮は、前のキーの何バイトが次のキーと同じであ
るかを示すための余計な1バイトがすべてのキーに必要となることを意味します(注
意: レコードへのポインタは、圧縮の向上のため high-byte-first-order でキー
の直後に格納されます)。これは、2つのレコードが同じキー多く持つ場合、後のす
べての'同じ'キーは通常2バイト(レコードへのポインタを含む)だけを必要とする
ということです。これを、通常のケースと比較してみてください。通常のケースは、
後のキーは'キーの格納サイズ' + ポインタサイズ(通常4)を必要とします。一方、
すべてのキーが全く異なっていると、キーが <CODE>NULL</CODE> 値を持つことができる
キーではない場合では、キー毎に1バイトを消費します(この場合、パックされたキー
の長さは、キーが <CODE>NULL</CODE> の時にマークのために使用されるのと同じバイト
数で格納されます)。

<LI>

もし <CODE>CREATE</CODE> ステートメントの後に <CODE>SELECT</CODE> を指定するならば、
<STRONG>MySQL</STRONG> は、<CODE>SELECT</CODE> で返ってくる全ての項目を収めるために、
新しいフィールドを作成します。
例えば：


<PRE>
mysql&#62; CREATE TABLE test (a int not null auto_increment,
           primary key (a), key(b))
           TYPE=MyISAM SELECT b,c from test2;
</PRE>

これは 3つのフィールド a, b, c を <CODE>MyISAM</CODE> テーブルに作成します。
<CODE>SELECT</CODE> ステートメントからのフィールドがテーブルの右側に追加され、上
書きされないことに注意してください。次の例を見てください:


<PRE>
mysql&#62; select * from foo;
+---+
| n |
+---+
| 1 |
+---+           

mysql&#62; create table bar (m int) select n from foo;
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0
 
mysql&#62; select * from bar;
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)                           
</PRE>

テーブル <CODE>foo</CODE> の各レコードについて、<CODE>foo</CODE> からの値と新しいフィー
ルドのデフォルト値を伴って <CODE>bar</CODE> のレコードが 挿入されます。

<CODE>CREATE TABLE ... SELECT</CODE> will not automatically create any indexes
for you.  This is done intentionally to make the command as flexible as
possible.  If you want to have indexes in the created table, you should
specify these before the <CODE>SELECT</CODE> statement:


<PRE>
mysql&#62; create table bar (unique (n)) select n from foo;
</PRE>

もしデータをテーブルにコピーしている最中にエラーが起きたなら、
このテーブルは自動的に消去されることに注意してください。

更新ログ／バイナリログはオリジナルテーブルを再生成するために使用できます。
<STRONG>MySQL</STRONG> は <CODE>CREATE TABLE .... SELECT</CODE> 中に並行しての挿入を許し
ません。

<LI>

<CODE>RAID_TYPE</CODE> オプションは、大規模ファイルをサポートしていない OS 上の
2G/4Gの制限を破る手助けをします。また、<CODE>RAID</CODE> ディレクトリを別の物理
ディスクに置くことにより、IO ボトルネックからさらに速度を得ることができま
す。<CODE>RAID_TYPE</CODE> は、<STRONG>MySQL</STRONG> を <CODE>--with-raid</CODE> でコンフィグ
すれば、どんな OS 上でも働きます。現在、<CODE>RAID_TYPE</CODE> は 
<CODE>STRIPED</CODE> だけが許されています(<CODE>1</CODE> と <CODE>RAID0</CODE> はこれの別名
です)。

<CODE>RAID_TYPE=STRIPED</CODE> を <CODE>MyISAM</CODE> テーブルに指定すると、
<CODE>MyISAM</CODE> はデータベースディレクトリ中に 00, 01, 02 という名前の 
<CODE>RAID_CHUNKS</CODE> サブディレクトリを生成します。これらのディレクトリのそ
れぞれに、<CODE>MyISAM</CODE> は <CODE>table_name.MYD</CODE> を生成します。データファ
イルにデータが書き込まれる時、<CODE>RAID</CODE> ハンドラは最初の 
<CODE>RAID_CHUNKSIZE</CODE> *1024 バイトを最初のファイルに、次の 
<CODE>RAID_CHUNKSIZE</CODE> *1024 バイトを次のファイルにマップします。

<LI>

<CODE>UNION</CODE> は同じテーブルの集まりを一つとして使用したい時に使用されます。
これは MERGE テーブルでだけ動作します。 「<A HREF="manual.ja_Table_types.html#MERGE">7.2  MERGE Tables</A>」節参照。

今のところ、<CODE>MERGE</CODE> テーブルをマップするテーブル上に <CODE>SELECT</CODE>,
<CODE>UPDATE</CODE>, <CODE>DELETE</CODE> 権限を持つことが必要です。マップされたすべて
のテーブルは <CODE>MERGE</CODE> テーブルとして、同じデータベース内にある必要があ
ります。

<LI>

生成されたテーブルでは、<CODE>PRIMARY</CODE> キーは最初に置かれ、次にすべての 
<CODE>UNIQUE</CODE> キー、それから通常のキーが続きます。これは <STRONG>MySQL</STRONG> オ
プティマイザを助け、どのキーを使用するかの優先度付けを行ない、重なった 
<CODE>UNIQUE</CODE> キーをさらにすばやく検出します。

<LI>

<CODE>DATA DIRECTORY="directory"</CODE> または <CODE>INDEX
DIRECTORY="directory"</CODE> を使用することで、テーブルハンドラがテーブルとイン
デックスファイルを置くべき場所を指定できます。<CODE>--skip-symlink</CODE> オプショ
ンを使用しない時、これは <CODE>MySQL</CODE> 4.0 で <CODE>MyISAM</CODE> テーブルでだけ
動作します。  「<A HREF="manual.ja_MySQL_Optimization.html#Symbolic_links_to_tables">5.6.1.2  Using Symbolic Links for Tables</A>」節参照.

</UL>



<H4><A NAME="Silent_column_changes" HREF="manual.ja_toc.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A></H4>

<P>
<A NAME="IDX1372"></A>

</P>
<P>
いくつかのケースにおいて<STRONG>MySQL</STRONG>は、<CODE>CREATE TABLE</CODE>ステートメントで与
えられたフィールド定義を暗黙の内に変更します
(これは <CODE>ALTER TABLE</CODE> で起きるかもしれません)

</P>

<UL>
<LI>

<CODE>VARCHAR</CODE> columns with a length less than four are changed to
<CODE>CHAR</CODE>.

<LI>

テーブル内にいくつかの可変長フィールドがある場合、結果的にレコード全体が可変長と
なります。
その結果、テーブルがいくつかの可変長フィールド(<CODE>VARCHAR</CODE>、<CODE>TEXT</CODE>及び
<CODE>BLOB</CODE>)を持つならば、3文字より大きいフィールド長の全ての<CODE>CHAR</CODE>フィールドは、
<CODE>VARCHAR</CODE>フィールドに変更されます。
このことは、フィールドの使用方法には影響しません。
<STRONG>MySQL</STRONG>では、<CODE>VARCHAR</CODE>は文字列を格納するための1つの手段に過ぎません。
<STRONG>MySQL</STRONG>は、スペース埋めのコンバージョンを行いますし、テーブル操作もより速
く行います。   「<A HREF="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</A>」節参照.

<LI>

<CODE>TIMESTAMP</CODE>フィールドの表示サイズは、2〜14の範囲の偶数でなければなりません。
表示サイズを0や14より大きく指定した場合、サイズは14に強制されます。1から13の範
囲の奇数の場合、大きい方の偶数値に強制されます。

<LI>

<CODE>TIMESTAMP</CODE> フィールドには <CODE>NULL</CODE> を代入できません； <CODE>NULL</CODE> は
現在の日時をセットします。
<CODE>NULL</CODE> and <CODE>NOT NULL</CODE> 属性は通常の方法では適用されず、それらを
与えた場合は無視されます。
<CODE>DESCRIBE tbl_name</CODE> は常に <CODE>TIMESTAMP</CODE> フィールドに <CODE>NULL</CODE> 値が割
り当てられた事を告げます。

<LI>

<STRONG>MySQL</STRONG> は他の SQL データベースの使用している型を <STRONG>MySQL</STRONG> 型に
マップします。  「<A HREF="manual.ja_Reference.html#Other-vendor_column_types">6.2.5  他のデータベースエンジンのフィールド型の使用</A>」節参照.
</UL>

<P>
もし <STRONG>MySQL</STRONG> がフィールドの型をあなたが指定したものと違うものにしたかどう
かを知りたい場合、テーブルの作成、alter 後に、 <CODE>DESCRIBE tbl_name</CODE> 構文
を発行します。

</P>
<P>
<A NAME="IDX1373"></A>
<CODE>myisampack</CODE>を使用してテーブルを圧縮した場合、別のフィールド定義変更がある
程度起こることがあります。  「<A HREF="manual.ja_Table_types.html#Compressed_format">7.1.2.3  Compressed Table Characteristics</A>」節参照.

</P>



<H3><A NAME="ALTER_TABLE" HREF="manual.ja_toc.html#ALTER_TABLE">6.5.4  <CODE>ALTER TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1374"></A>

</P>

<PRE>
ALTER [IGNORE] TABLE tbl_name alter_spec [, alter_spec ...]

alter_specification:
        ADD [COLUMN] create_definition [FIRST | AFTER column_name ]
  or    ADD [COLUMN] (create_definition, create_definition,...)
  or    ADD INDEX [index_name] (index_col_name,...)
  or    ADD PRIMARY KEY (index_col_name,...)
  or    ADD UNIQUE [index_name] (index_col_name,...)
  or    ADD FULLTEXT [index_name] (index_col_name,...)
  or	ADD [CONSTRAINT symbol] FOREIGN KEY index_name (index_col_name,...)
            [reference_definition]
  or    ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
  or    CHANGE [COLUMN] old_col_name create_definition
  or    MODIFY [COLUMN] create_definition
  or    DROP [COLUMN] col_name
  or    DROP PRIMARY KEY
  or    DROP INDEX index_name
  or    RENAME [TO] new_tbl_name
  or    ORDER BY col
  or    table_options
</PRE>

<P>
<CODE>ALTER TABLE</CODE>は、既存のテーブルの構造変更を可能にします。
例えば、フィールドの追加や削除、インデックスの作成や破棄、既存のフィールド属性の
変更、及びフィールドやテーブルそのものの名前の変更です。
また、テーブルのコメントやテーブルの型式を変更することも可能です。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照.

</P>
<P>
もし <CODE>ALTER TABLE</CODE> でフィールド定義を変えても <CODE>DESCRIBE tbl_name</CODE> が
フィールドを変更していないと示すなら、これは <STRONG>MySQL</STRONG> が
  「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節. に述べている理由の一つで変更していない可能性が
あります。 例えば、 <CODE>VARCHAR</CODE> フィールドを <CODE>CHAR</CODE> にしようとすると, 
<STRONG>MySQL</STRONG> はそのテーブルに他の可変長のフィールドがあるかぎり、
<CODE>VARCHAR</CODE> のままにしようとします。

</P>
<P>
<CODE>ALTER TABLE</CODE>はオリジナルのテーブルの一時的なコピーを作成することにより動作
します。
コピーへの変更作業が完了すると、オリジナルのテーブルは削除され新しく
作られた方の名前が変更されます。これは全ての変更が自動的に新しいテーブルに
対して実施されることにより、誤った変更無しに完了します。
<CODE>ALTER TABLE</CODE>が実行されている間、オリジナルのテーブルは他の
クライアントから読みだしが可能です。このテーブルへの更新や書き込みは、
新しいテーブルが準備完了となるまで遅らされます。

</P>
<P>
注意: <CODE>ALTER TABLE</CODE> に <CODE>RENAME</CODE> 以外のオプションを使用する場合、
<STRONG>MySQL</STRONG> は常に一時テーブルを生成します。データが厳密にコピーする必
要がないとしてもです(フィールドの名前を変更する時など)。
We plan to fix this in the future, but as one doesn't
normally do <CODE>ALTER TABLE</CODE> that often this isn't that high on our TODO.

</P>

<UL>
<LI>

<CODE>ALTER TABLE</CODE>を使うには、そのテーブルに <STRONG>ALTER</STRONG>、
<STRONG>INSERT</STRONG>、<STRONG>CREATE</STRONG> 権限が必要です。

<LI>

<CODE>IGNORE</CODE>はANSI SQL92に対する<STRONG>MySQL</STRONG>の拡張です。
これは、新しいテーブルのユニークキーで重複があった場合の動作を制御します。
<CODE>IGNORE</CODE>が指定されない場合、コピーは異常終了し、ロールバックされます。
<CODE>IGNORE</CODE>が指定された場合、ユニークキーの重複があったレコードに対し、最初の
レコードだけを使用し、他は削除されます。

<LI>

1つの<CODE>ALTER TABLE</CODE>ステートメントの中で、<CODE>ADD</CODE>、<CODE>ALTER</CODE>、
<CODE>DROP</CODE>、それから<CODE>CHANGE</CODE>節の複合的な発行が可能です。
これは、<CODE>ALTER TABLE</CODE>ステートメント毎に1つだけしかこれらの節を
許さないANSI SQL92に対する<STRONG>MySQL</STRONG>の拡張です。

<LI>

<CODE>CHANGE col_name</CODE>、<CODE>DROP col_name</CODE>及び<CODE>DROP
INDEX</CODE>はANSI SQL92に対する<STRONG>MySQL</STRONG>の拡張です。

<LI>

<CODE>MODIFY</CODE> は <CODE>Oracle</CODE> の <CODE>ALTER TABLE</CODE> 拡張です。

<LI>

オプション語<CODE>COLUMN</CODE>は蛇足であり、記述を省くことが可能です。

<LI>

他のオプション無しで<CODE>ALTER TABLE tbl_name RENAME TO new_name</CODE>を使用すると、
<STRONG>MySQL</STRONG>は<CODE>tbl_name</CODE>に一致するテーブルの名前を単純に変更します。
テンポラリテーブルの作成は必要としません。
 「<A HREF="manual.ja_Reference.html#RENAME_TABLE">6.5.5  <CODE>RENAME TABLE</CODE> 構文</A>」節参照.

<LI>

<CODE>create_definition</CODE>は、<CODE>CREATE TABLE</CODE>における<CODE>ADD</CODE>や<CODE>CHANGE</CODE>
と同じ構文を使用します。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照.

<LI>

<CODE>CHANGE old_col_name create_definition</CODE>節を使用することによりフィールドの名
前を変更することができます。
このようなことを行うためには、フィールドの旧名称と新名称、それからそのフィールド
の現在の型を指定する必要があります。例えば、ある<CODE>INTEGER</CODE>フィールドを<CODE>
a</CODE>から<CODE>b</CODE>に変更する場合、以下のように実行することができます:


<PRE>
mysql&#62; ALTER TABLE t1 CHANGE a b INTEGER;
</PRE>

もしフィールドの名前を変えることなく、型だけを変更したい場合であっても、
この <CODE>CHANGE</CODE> 構文は、たとえ同じ名前であっても、
２つの名前を指定するよう要求します。
例:


<PRE>
mysql&#62; ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;
</PRE>

しかし <STRONG>MySQL</STRONG> バージョン 3.22.16a からは,  <CODE>MODIFY</CODE> を使用して、
名称変更をすることなくフィールドの型を変更することができます。


<PRE>
mysql&#62; ALTER TABLE t1 MODIFY b BIGINT NOT NULL;
</PRE>

<LI>

<CODE>CHANGE</CODE> や <CODE>MODIFY</CODE> を使用して、フィールドの一部にインデックス
が存在するようなフィールドを短くしようとしても(例えば <CODE>VARCHAR</CODE> フィー
ルドの最初の10文字上ににインデックスがある場合)、インデックスされた文字数
よりもフィールドを短くすることはできません。

<LI>

<CODE>CHANGE</CODE> や <CODE>MODIFY</CODE> を用いてフィールドの型を変更する場合、
<STRONG>MySQL</STRONG>は可能な限り新しい型にデータをコンバートしようと試みます。

<LI>

<STRONG>MySQL</STRONG> バージョン 3.22以降では、
<CODE>FIRST</CODE>又は<CODE>ADD ... AFTER col_name</CODE>を使用して、
テーブルのレコード内の指定した位置に、フィールドを追加すること
ができます。
デフォルトでは、フィールドは(そのレコードの)最後に追加されます。

<A NAME="IDX1375"></A>
<LI>

<CODE>ALTER COLUMN</CODE>は、フィールドの新たな初期値を指定したり、フィールドの古い初
期値を削除したりします。
古い初期値が削除され、フィールドが<CODE>NULL</CODE>を許す場合、新たな初期値は<CODE>NUL
L</CODE>となります。
<CODE>NULL</CODE>が許されない場合、 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節 で
説明されている通り、<STRONG>MySQL</STRONG> は初期値を割り当てます。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節.

<A NAME="IDX1376"></A>
<LI>

<CODE>DROP INDEX</CODE>は、インデックスを削除します。これはANSI SQL92に対する
MySQL の拡張です。  「<A HREF="manual.ja_Reference.html#DROP_INDEX">6.5.8  <CODE>DROP INDEX</CODE> 構文</A>」節参照.

<LI>

フィールドがテーブルから削除されると、そのフィールドが含まれているインデックスか
らもそのフィールドが削除されます。
インデックスを構成する全てのフィールドが削除されると、そのインデックスも削除され
ます。

<LI>

テーブルが一つのフィールドだけを含む場合、フィールドは破棄できません。テー
ブルを削除するつもりなら、<CODE>DROP TABLE</CODE> を代わりに使用してください。

<A NAME="IDX1377"></A>
<LI>

<CODE>DROP PRIMARY KEY</CODE>は、プライマリ・インデックスを削除します。もしプライマリ
インデックスが存在しなければ、そのテーブルの最初の<CODE>UNIQUE</CODE>インデックスが削
除されます。
(<STRONG>MySQL</STRONG>は、明示的に<CODE>PRIMARY KEY</CODE>が指定されなければ最初の<CODE>UNIQU
E</CODE>キーを<CODE>PRIMARY KEY</CODE>として扱います。)

<A NAME="IDX1378"></A>
<A NAME="IDX1379"></A>
If you add a <CODE>UNIQUE INDEX</CODE> or <CODE>PRIMARY KEY</CODE> to a table, this
is stored before any not <CODE>UNIQUE</CODE> index so that MySQL can detect
duplicate keys as early as possible.

<A NAME="IDX1380"></A>
<LI>

<CODE>ORDER BY</CODE> は指定した順のレコードで新しいテーブルを生成することができ
ます。注意: 挿入と削除の後にはこの順序は保持されません。テーブルを、後で 
order をしたいフィールドの順にしておくと <STRONG>MySQL</STRONG> のソートがより簡単
になる場合があります。このオプションは、主に一定の順でレコードをクエリする
つもりであることを知っているときに、主に有用です; テーブルに大きな変更をし
た後にこのオプションを使用することで、より高い性能を得ることができるdしょ
う。

<A NAME="IDX1381"></A>
<LI>

<CODE>ALTER TABLE</CODE> を <CODE>MyISAM</CODE> テーブルに使用する場合、すべての非ユニー
クインデックスは(<CODE>REPAIR</CODE> のような)別のバッチで生成されます。これは多
くのインデックスがある場合、<CODE>ALTER TABLE</CODE> をより速くします。

<LI>

<A NAME="IDX1382"></A>
C API関数<CODE>mysql_info()</CODE>により、どれだけのレコードがコピーされたか、(<CODE>I
GNORE</CODE>が指定されている時は)どれだけのレコードがユニークキーの重複により削除され
たかを調べることができます。

<LI>

<A NAME="IDX1383"></A>
<A NAME="IDX1384"></A>
<CODE>FOREIGN KEY</CODE>、<CODE>CHECK</CODE>及び<CODE>REFERENCES</CODE>節は、実際には
何もしません。これらの構文は、互換性のためだけに用意されており、
他のSQLサーバからのコードの移植を容易にしたり、
参照情報と共にテーブルを作成するようなアプリケーションを動作
させることを目的としています。
 「<A HREF="manual.ja_Introduction.html#Missing_functions">1.4.4  MySQL に無い機能</A>」節参照.
</UL>

<P>
以下は、<CODE>ALTER TABLE</CODE>の使用例を表す例です。
次に示すように作成されたテーブル<CODE>t1</CODE>から始めます:

</P>

<PRE>
mysql&#62; CREATE TABLE t1 (a INTEGER,b CHAR(10));
</PRE>

<P>
テーブル<CODE>t1</CODE>の名前を<CODE>t2</CODE>に変更するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t1 RENAME t2;
</PRE>

<P>
フィールド <CODE>a</CODE>を <CODE>INTEGER</CODE> から <CODE>TINYINT NOT NULL</CODE> に
(名前は同じままで)変更し、
<CODE>b</CODE> を <CODE>CHAR(10)</CODE> から <CODE>CHAR(20)</CODE> に変更しつつ、
名前を <CODE>b</CODE> から <CODE>c</CODE>に変更するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</PRE>

<P>
<CODE>TIMESTAMP</CODE>を追加し、名前を<CODE>d</CODE>とするには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 ADD d TIMESTAMP;
</PRE>

<P>
フィールド<CODE>d</CODE>にインデックスを追加し、フィールド<CODE>a</CODE>をプライマリ・キーと
するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 ADD INDEX (d), ADD PRIMARY KEY (a);
</PRE>

<P>
フィールド<CODE>c</CODE>を削除するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 DROP COLUMN c;
</PRE>

<P>
To add a new <CODE>AUTO_INCREMENT</CODE> integer column named <CODE>c</CODE>:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
           ADD INDEX (c);
</PRE>

<P>
ここで我々が <CODE>c</CODE> をインデックス指定したのは、 <CODE>AUTO_INCREMENT</CODE> フィー
ルドはインデックスであるべきだからで、 <CODE>c</CODE> を <CODE>NOT NULL</CODE> 指定しているのは
インデックスフィールドは <CODE>NULL</CODE> にできないからです。

</P>
<P>
<CODE>AUTO_INCREMENT</CODE> フィールドを追加した場合、フィールドの値は
自動的にシーケンス番号で埋められます。
最初のシーケンス番号は、<CODE>ALTER TABLE</CODE> 前に <CODE>SET INSERT_ID=#</CODE> を
実行するか、または <CODE>AUTO_INCREMENT = #</CODE> テーブルオプションを使用する
ことで設定できます。
 「<A HREF="manual.ja_MySQL_Optimization.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節参照.

</P>
<P>
MyISAM テーブルでは、<CODE>AUTO_INCREMENT</CODE> フィールドを変更しない場合、シー
ケンス番号は影響を受けません。<CODE>AUTO_INCREMENT</CODE> フィールドを破棄し、そ
れから別の <CODE>AUTO_INCREMENT</CODE> フィールドを追加した場合、番号は再度 1 か
ら始まります。

</P>
<P>
 「<A HREF="manual.ja_Problems.html#ALTER_TABLE_problems">A.6.1  Problems with <CODE>ALTER TABLE</CODE>.</A>」節参照.

</P>



<H3><A NAME="RENAME_TABLE" HREF="manual.ja_toc.html#RENAME_TABLE">6.5.5  <CODE>RENAME TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1385"></A>

</P>

<PRE>
RENAME TABLE tbl_name TO new_table_name[, tbl_name2 TO new_table_name2,...]
</PRE>

<P>
リネームは自動的に行なわれます。これは、他のスレッドはリネームが動作中はテー
ブルのどこにもアクセスできないことを意味します。空のテーブルでテーブルを置
き換えることが可能です:

</P>

<PRE>
CREATE TABLE new_table (...);
RENAME TABLE old_table TO backup_table, new_table TO old_table;
</PRE>

<P>
リネームは左から右に行なわれます。２つのテーブルの名前を交換したい場合には、
次のようにする必要があることを意味します:

</P>

<PRE>
RENAME TABLE old_table    TO backup_table,
             new_table    TO old_table,
             backup_table TO new_table;
</PRE>

<P>
２つのデータベースが同じディスク上にあれば、あるデータベースから他のデータ
ベースにリネームすることも可能です:

</P>

<PRE>
RENAME TABLE current_database.table_name TO other_database.table_name;
</PRE>

<P>
<CODE>RENAME</CODE> 実行時には、ロックされたテーブルや有効なトランザクションを持
つことはできません。元のテーブルで <CODE>ALTER</CODE> と <CODE>DROP</CODE> 権限を、新
しいテーブルで <CODE>CREATE</CODE> と <CODE>INSERT</CODE> 権限を持つことも必要です。

</P>
<P>
<STRONG>MySQL</STRONG> が複数のテーブルのリネームで何らかのエラーに遭遇した場合、
リネームしたすべてのテーブルを逆にリネームし、すべてを元の状態に戻します。

</P>



<H3><A NAME="DROP_TABLE" HREF="manual.ja_toc.html#DROP_TABLE">6.5.6  <CODE>DROP TABLE</CODE> Syntax</A></H3>

<P>
<A NAME="IDX1386"></A>

</P>

<PRE>
DROP TABLE [IF EXISTS] tbl_name [, tbl_name,...] [RESTRICT | CASCADE]
</PRE>

<P>
<CODE>DROP TABLE</CODE>は、1つ又は1つ以上のテーブルを破棄します。テーブルの全てのデー
タとテーブル定義は<EM>破棄</EM>されますので、このコマンドの使用は慎重に行ってくだ
さい！

</P>
<P>
<STRONG>MySQL</STRONG> バージョン 3.22以降では、テーブルが存在しないことに起因するエラー
を防ぐために、キーワード <CODE>IF EXISTS</CODE> を使用することができます。

</P>
<P>
<CODE>RESTRICT</CODE> と <CODE>CASCADE</CODE> は移植を簡単にするために許されています。
しばらくはこれらは何も行ないません。

</P>
<P>
<STRONG>注意</STRONG>: <CODE>DROP TABLE</CODE> はトランザクション安全ではなく、自動的に
すべてのアクティブトランザクションをコミットします。

</P>



<H3><A NAME="CREATE_INDEX" HREF="manual.ja_toc.html#CREATE_INDEX">6.5.7  <CODE>CREATE INDEX</CODE> 構文</A></H3>

<P>
<A NAME="IDX1387"></A>

</P>
<P>
<A NAME="IDX1388"></A>
<A NAME="IDX1389"></A>
<A NAME="IDX1390"></A>

</P>

<PRE>
CREATE [UNIQUE|FULLTEXT] INDEX index_name ON tbl_name (col_name[(length)],... )
</PRE>

<P>
<CODE>CREATE INDEX</CODE> 構文は <STRONG>MySQL</STRONG> 3.22 より以前のバージョンではなにもし
ません。
バージョン 3.22 以降で、<CODE>CREATE INDEX</CODE> はインデックスの作成のために
<CODE>ALTER TABLE</CODE> を呼びだしています。
@xref{ALTER TABLE, , <CODE>ALTER TABLE</CODE>}.

</P>
<P>
通常、テーブル内の全てのインデックスは <CODE>CREATE TABLE</CODE> で
テーブルを作るときに一度に作成されます。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照.
<CODE>CREATE INDEX</CODE> は既に存在するテーブルに対し、インデックスを追加します。
<CODE>CREATE INDEX</CODE> allows you to add indexes to existing tables.

</P>
<P>
フィールドを <CODE>(col1,col2,...)</CODE> として指定すると、複数フィールドインデックス
を作成します。
インデックスの値は、与えられたフィールドの値を連結して、構成されます。

</P>
<P>
<CODE>CHAR</CODE> と <CODE>VARCHAR</CODE> フィールドでは、インデックスはフィールドの一部分だ
けを使用して
作成されます。これは <CODE>col_name(length)</CODE> 構文を使用します。
(<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 節では length が必要です)。
最初の10文字をインデックスとして使用するには、この構文は以下のようにして使用しま
す(<CODE>name</CODE> フィールドにインデックスを作ります)：

</P>

<PRE>
mysql&#62; CREATE INDEX part_of_name ON customer (name(10));
</PRE>

<P>
フィールドの一部分だけをインデックスに使用すれば、インデックスファイルをはるかに
小さくすることができます。
ほとんどの名前が最初の10文字において通常異なるので、
このインデックスは <CODE>name</CODE> フィールド全部を使用して創り出したインデックスに
比べて遅くなることはありません。また、多くのディスクスペースを節約でき、
 <CODE>INSERT</CODE> を速くするのです！

</P>
<P>
<STRONG>MySQL</STRONG> version 3.23.2 以上で <CODE>MyISAM</CODE> 型のテーブルを使用している
場合、<CODE>NULL</CODE> 値をもつフィールドや、 <CODE>BLOB</CODE>/<CODE>TEXT</CODE> フィールドに対して
インデックスを張ることが可能です。

</P>
<P>
<STRONG>MySQL</STRONG> がどのようにしてインデックスを使用するかは →
 「<A HREF="manual.ja_MySQL_Optimization.html#MySQL_indexes">5.4.3  MySQL はどのようにインデックスを使用するか？</A>」節.

</P>
<P>
<CODE>FULLTEXT</CODE> indexes can index only <CODE>VARCHAR</CODE> and
<CODE>TEXT</CODE> columns, and only in <CODE>MyISAM</CODE> tables. <CODE>FULLTEXT</CODE> indexes
are available in MySQL Version 3.23.23 and later.
 「<A HREF="manual.ja_Reference.html#Fulltext_Search">6.8  MySQL Full-text Search</A>」節.

</P>



<H3><A NAME="DROP_INDEX" HREF="manual.ja_toc.html#DROP_INDEX">6.5.8  <CODE>DROP INDEX</CODE> 構文</A></H3>

<P>
<A NAME="IDX1391"></A>

</P>

<PRE>
DROP INDEX index_name ON tbl_name
</PRE>

<P>
<CODE>DROP INDEX</CODE> は <CODE>index_name</CODE> という名前のインデックスをテーブル 
<CODE>tbl_name</CODE> から破棄します。
<CODE>DROP INDEX</CODE> は <STRONG>MySQL</STRONG> バージョン 3.22 より以前のバージョンではなに
もしません。
3.22 以降で、<CODE>DROP INDEX</CODE> はインデックスの破棄のために
<CODE>ALTER TABLE</CODE> を呼びだしています。
 「<A HREF="manual.ja_Reference.html#ALTER_TABLE">6.5.4  <CODE>ALTER TABLE</CODE> 構文</A>」節参照.

</P>



<H2><A NAME="Basic_User_Commands" HREF="manual.ja_toc.html#Basic_User_Commands">6.6  Basic MySQL User Utility Commands</A></H2>



<H3><A NAME="USE" HREF="manual.ja_toc.html#USE">6.6.1  <CODE>USE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1392"></A>

</P>

<PRE>
USE db_name
</PRE>

<P>
<CODE>USE db_name</CODE> 構文は、 <STRONG>MySQL</STRONG> に <CODE>db_name</CODE> データベースを
この後のクエリのデフォルトのデータベースにするように指示します。
指定されたデータベースは、セッションの最後まで、あるいは、他の <CODE>USE</CODE> 構文
が発行されるまで残ります：

</P>

<PRE>
mysql&#62; USE db1;
mysql&#62; SELECT count(*) FROM mytable;      # selects from db1.mytable
mysql&#62; USE db2;
mysql&#62; SELECT count(*) FROM mytable;      # selects from db2.mytable
</PRE>

<P>
<CODE>USE</CODE> 構文で特定のデータベースをカレントにしても、
他のデータベースのテーブルからアクセスすることを妨げません。
以下は <CODE>db1</CODE> データベースの <CODE>author</CODE> テーブルと、
 <CODE>db2</CODE> データベースの <CODE>editor</CODE> テーブルにアクセスする例です：

</P>

<PRE>
mysql&#62; USE db1;
mysql&#62; SELECT author_name,editor_name FROM author,db2.editor
           WHERE author.editor_id = db2.editor.editor_id;
</PRE>

<P>
<A NAME="IDX1393"></A>
<A NAME="IDX1394"></A>
<CODE>USE</CODE> 構文は Sybase の互換のために提供されています。

</P>



<H3><A NAME="DESCRIBE" HREF="manual.ja_toc.html#DESCRIBE">6.6.2  <CODE>DESCRIBE</CODE> 構文 (フィールドについての情報を得る)</A></H3>

<P>
<A NAME="IDX1395"></A>
<A NAME="IDX1396"></A>

</P>

<PRE>
{DESCRIBE | DESC} tbl_name {col_name | wild}
</PRE>

<P>
<CODE>DESCRIBE</CODE> is a shortcut for <CODE>SHOW COLUMNS FROM</CODE>.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_DATABASE_INFO">4.5.5.1  Retrieving information about Database, Tables, Columns, and Indexes</A>」節参照.

</P>
<P>
<CODE>DESCRIBE</CODE> はフィールドについての情報を与えます。
<CODE>col_name</CODE> はフィールドはフィールド名または文字列です。
文字列は SQL <SAMP>`%'</SAMP>,<SAMP>`_'</SAMP> ワイルドカードを含めます。

</P>
<P>
もしフィールドの型があなたが <CODE>CREATE TABLE</CODE> 文で与えた物と違っているなら、
これは <STRONG>MySQL</STRONG> がフィールドの型を変更していることに注意してください。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

</P>
<P>
<A NAME="IDX1397"></A>
<A NAME="IDX1398"></A>
このコマンドは Oracle の互換のためにあります。

</P>
<P>
<CODE>SHOW</CODE> 構文は似たような情報を提供します。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW">4.5.5  <CODE>SHOW</CODE> 構文</A>」節参照.

</P>



<H2><A NAME="Transactional_Commands" HREF="manual.ja_toc.html#Transactional_Commands">6.7  MySQL Transactional and Locking Commands</A></H2>



<H3><A NAME="COMMIT" HREF="manual.ja_toc.html#COMMIT">6.7.1  <CODE>BEGIN/COMMIT/ROLLBACK</CODE> 構文</A></H3>

<P>
<A NAME="IDX1399"></A>
<A NAME="IDX1400"></A>
<A NAME="IDX1401"></A>

</P>
<P>
デフォルトでは <STRONG>MySQL</STRONG> は <CODE>autocommit</CODE> モードで動作します。こ
れは、更新を実行するとすぐに <STRONG>MySQL</STRONG> が更新をディスクに格納すること
を意味します。

</P>
<P>
もし トランザクションセーフのテーブル(like <CODE>BDB</CODE>,
<CODE>InnoDB</CODE>) を使用するなら, 以下のコマンドで <STRONG>MySQL</STRONG> を
非 <CODE>autocommit</CODE> モード状態にすることができます：

</P>

<PRE>
SET AUTOCOMMIT=0
</PRE>

<P>
この後、ディスクに変更を格納するためには <CODE>COMMIT</CODE> を使用し、また、変
更を無視するためには <CODE>ROLLBACK</CODE> する必要があります。

</P>
<P>
ある一連のステートメントのために <CODE>AUTOCOMMIT</CODE> モードからスイッチし
たい場合は、<CODE>BEGIN</CODE> または <CODE>BEGIN WORK</CODE> ステートメントを使用で
きます。

</P>

<PRE>
BEGIN;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summmary=@A WHERE type=1;
COMMIT;
</PRE>

<P>
注意: トランザクション安全テーブルを使用していない場合は、<CODE>autocommit</CODE>
モードのステータスには依存せずに、変更はすぐに格納されます。

</P>
<P>
If you do a <CODE>ROLLBACK</CODE> when you have updated a non-transactional
table you will get an error (<CODE>ER_WARNING_NOT_COMPLETE_ROLLBACK</CODE>) as
a warning.  All transactional safe tables will be restored but any
non-transactional table will not change.

</P>
<P>
If you are using <CODE>BEGIN</CODE> or <CODE>SET AUTOCOMMIT=0</CODE>, you
should use the MySQL binary log for backups instead of the
older update log.  Transactions are stored in the binary log
in one chunk, upon <CODE>COMMIT</CODE>, to ensure that transactions which are
rolled back are not stored.   「<A HREF="manual.ja_MySQL_Database_Administration.html#Binary_log">4.9.4  The Binary Update Log</A>」節参照.

</P>
<P>
The following commands automatically end a transaction (as if you had done
a <CODE>COMMIT</CODE> before executing the command):

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>ALTER TABLE</CODE> </TD><TD> <CODE>BEGIN</CODE> </TD><TD> <CODE>CREATE INDEX</CODE>
</TR NOSAVE>
<TR><TD><CODE>DROP DATABASE</CODE> </TD><TD> <CODE>DROP TABLE</CODE> </TD><TD> <CODE>RENAME TABLE</CODE>
</TR NOSAVE>
<TR><TD><CODE>TRUNCATE</CODE>
</TR>
</TABLE>

<P>
You can change the isolation level for transactions with
<CODE>SET TRANSACTION ISOLATION LEVEL ...</CODE>.  「<A HREF="manual.ja_Reference.html#SET_TRANSACTION">6.7.3  <CODE>SET TRANSACTION</CODE> 構文</A>」節参照.

</P>



<H3><A NAME="LOCK_TABLES" HREF="manual.ja_toc.html#LOCK_TABLES">6.7.2  <CODE>LOCK TABLES/UNLOCK TABLES</CODE> 構文</A></H3>

<P>
<A NAME="IDX1402"></A>
<A NAME="IDX1403"></A>

</P>

<PRE>
LOCK TABLES tbl_name [AS alias] {READ | [READ LOCAL] | [LOW_PRIORITY] WRITE}
            [, tbl_name {READ | [LOW_PRIORITY] WRITE} ...]
...
UNLOCK TABLES
</PRE>

<P>
<CODE>LOCK TABLES</CODE> はカレントのスレッドのためにテーブルをロックします。
<CODE>UNLOCK TABLES</CODE> はこのスレッドの全てのロックを解除します。
カレントスレッドによってロックされた全てのテーブルは、
スレッドが他の <CODE>LOCK TABLES</CODE> を発行した場合やサーバーが接続を閉じた場合、
自動で解除されます。

</P>
<P>
The main reasons to use <CODE>LOCK TABLES</CODE> are for emulating transactions
or getting more speed when updating tables.  This is explained in more
detail later.

</P>
<P>
スレッドがテーブルに <CODE>READ</CODE> ロックを持つ場合、そのスレッド(と他の全てのスレ
ッド)はテーブルからの読み込みだけができます。スレッドがテーブルに
<CODE>WRITE</CODE> ロックを持つ場合、
このスレッドだけがテーブルの <CODE>READ</CODE> と <CODE>WRITE</CODE> ができます。
他のスレッドはブロックされます。

</P>
<P>
<CODE>READ LOCAL</CODE> と <CODE>READ</CODE> の違いは、<CODE>READ LOCAL</CODE> は、ロックが
保持されている間にコンフリクトしない <CODE>INSERT</CODE> ステートメントを実行で
きることです。ただし、これはロックを保持している間に <STRONG>MySQL</STRONG> の外で
データベースファイルを操作しようとする場合は使用できません。

</P>
<P>
When you use <CODE>LOCK TABLES</CODE>, you must lock all tables that you are
going to use and you must use the same alias that you are going to use
in your queries!  If you are using a table multiple times in a query
(with aliases), you must get a lock for each alias!

</P>
<P>
<CODE>WRITE</CODE> ロックは普通、できる限り更新を行わせるため、
 <CODE>READ</CODE> ロックよりも優先順位が高くなっています。
これはあるスレッドが <CODE>READ</CODE> ロックをかけ、それ以外のスレッドが <CODE>WRITE</CODE>
 を要求した場合、 <CODE>READ</CODE> は、<CODE>WRITE</CODE> スレッドがロックをし、それを解除
するまで待つということです。
<CODE>LOW_PRIORITY WRITE</CODE> を使用すれば、
<CODE>WRITE</CODE> ロックを待っているスレッドに <CODE>READ</CODE> ロックを得させることができ
ます。
<CODE>LOW_PRIORITY WRITE</CODE> は <CODE>READ</CODE> ロックをしているスレッドが一つもないと
わかっている場合に使用すべきです。

</P>
<P>
<CODE>LOCK TABLES</CODE> works as follows:

<OL>
<LI>

Sort all tables to be locked in a internally defined order (from the
user standpoint the order is undefined).
<LI>

If a table is locked with a read and a write lock, put the write lock
before the read lock.
<LI>

Lock one table at a time until the thread gets all locks.
</OL>

<P>
This policy ensures that table locking is deadlock free. There is
however other things one needs to be aware of with this schema:

</P>
<P>
If you are using a <CODE>LOW_PRIORITY_WRITE</CODE> lock for a table, this
means only that MySQL will wait for this particlar lock until
there is no threads that wants a <CODE>READ</CODE> lock.  When the thread has
got the <CODE>WRITE</CODE> lock and is waiting to get the lock for the next
table in the lock table list, all other threads will wait for the
<CODE>WRITE</CODE> lock to be released.  If this becomes a serious problem
with your application, you should consider converting some of your
tables to transactions safe tables.

</P>
<P>
You can safely kill a thread that is waiting for a table lock with
<CODE>KILL</CODE>.   「<A HREF="manual.ja_MySQL_Database_Administration.html#KILL">4.5.4  <CODE>KILL</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>INSERT DELAYED</CODE> で使用しているいかなるテーブルも、ロックすべきではありませ
ん。この場合 <CODE>INSERT</CODE> は別のスレッドで行なわれるからです。

</P>
<P>
通常、全ての単一の <CODE>UPDATE</CODE> 構文においては、テーブルをロックする必要はあり
ません；
スレッドは、他のスレッドが現在実行している SQL 文に干渉することができません。
これらはテーブルをロックした方がよい、まれな場合です：

</P>

<UL>
<LI>

テーブルをまとめて多くの操作を実行しようとする場合、使用しようとしているテー
ブルをロックするととても速くなります。もちろん、他のスレッドは <CODE>READ</CODE> ロッ
クされたテーブルの更新はできませんし、他のスレッドは <CODE>WRITE</CODE> ロックされた
テーブルを読むことはできません。

The reason some things are faster under <CODE>LOCK TABLES</CODE> is that
MySQL will not flush the key cache for the locked tables until
<CODE>UNLOCK TABLES</CODE> is called (normally the key cache is flushed after
each SQL statement). This speeds up inserting/updateing/deletes on
<CODE>MyISAM</CODE> tables.

<LI>

<CODE>MySQL</CODE> のトランザクションをサポートしないテーブルハンドラーを使用
している場合、他のスレッドが <CODE>SELECT</CODE>,<CODE>UPDATE</CODE> の間に来ないことを
保証したいならば、<CODE>LOCK TABLES</CODE> を使用する必要があります。
次の例は安全のためには <CODE>LOCK TABLES</CODE> を必要とします：


<PRE>
mysql&#62; LOCK TABLES trans READ, customer WRITE;
mysql&#62; select sum(value) from trans where customer_id= some_id;
mysql&#62; update customer set total_value=sum_from_previous_statement
           where customer_id=some_id;
mysql&#62; UNLOCK TABLES;
</PRE>

 <CODE>LOCK TABLES</CODE> を使用しない場合、<CODE>SELECT</CODE> の実行と <CODE>UPDATE</CODE> の
実行を行う間に、他のスレッドが新しい <CODE>trans</CODE> 行を挿入する隙ができます。
</UL>

<P>
インクリメント アップデイト (<CODE>UPDATE customer SET
value=value+new_value</CODE>) または 
<CODE>LAST_INSERT_ID()</CODE> 関数の使用により、多くの場合 <CODE>LOCK TABLES</CODE> を回避
できます。

</P>
<P>
いくつかの場合、ユーザレベルロック: <CODE>GET_LOCK()</CODE> と <CODE>RELEASE_LOCK()</CODE> 
の使用
によっても解決できます。これらのロックはサーバ内のハッシュテーブル内に保
持され、高速のため <CODE>pthread_mutex_lock()</CODE> で実装されました。
 「<A HREF="manual.ja_Reference.html#Miscellaneous_functions">6.3.5.2  その他の関数</A>」節参照.

</P>
<P>
ロックポリシーのさらなる情報については  「<A HREF="manual.ja_MySQL_Optimization.html#Internal_locking">5.3.1  MySQL はどのようにテーブルをロックするか</A>」節 を見てくださ
い。

</P>
<P>
You can lock all tables in all databases with read locks with the
<CODE>FLUSH TABLES WITH READ LOCK</CODE> command.  「<A HREF="manual.ja_MySQL_Database_Administration.html#FLUSH">4.5.3  <CODE>FLUSH</CODE> 構文</A>」節参照. This is very
convenient way to get backups if you have a file system, like Veritas,
that can take snapshots in time.

</P>
<P>
<STRONG>NOTE</STRONG>: <CODE>LOCK TABLES</CODE> is not transaction-safe and will
automatically commit any active transactions before attempting to lock the
tables.

</P>



<H3><A NAME="SET_TRANSACTION" HREF="manual.ja_toc.html#SET_TRANSACTION">6.7.3  <CODE>SET TRANSACTION</CODE> 構文</A></H3>

<P>
<A NAME="IDX1404"></A>

</P>

<PRE>
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL
[READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE]
</PRE>

<P>
Sets the transaction isolation level for the global, whole session or
the next transaction.

</P>
<P>
The default behavior is to set the isolation level for the next (not started)
transaction.

</P>
<P>
If you set the <CODE>GLOBAL</CODE> privilege it will affect all new created threads.
You will need the <CODE>PROCESS</CODE> privilege to do do this.

</P>
<P>
Setting the <CODE>SESSION</CODE> privilege will affect the following and all
future transactions.

</P>
<P>
You can set the default isolation level for <CODE>mysqld</CODE> with
<CODE>--transaction-isolation=...</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Command-line_options">4.1.1  mysqld コマンド行オプション</A>」節参照.

</P>



<H2><A NAME="Fulltext_Search" HREF="manual.ja_toc.html#Fulltext_Search">6.8  MySQL Full-text Search</A></H2>

<P>
<A NAME="IDX1405"></A>
<A NAME="IDX1406"></A>
<A NAME="IDX1407"></A>

</P>
<P>
Since Version 3.23.23, MySQL has support for full-text indexing
and searching.  Full-text indexes in MySQL are an index of type 
<CODE>FULLTEXT</CODE>.  <CODE>FULLTEXT</CODE> indexes can be created from <CODE>VARCHAR</CODE> 
and <CODE>TEXT</CODE> columns at <CODE>CREATE TABLE</CODE> time or added later with 
<CODE>ALTER TABLE</CODE> or <CODE>CREATE INDEX</CODE>.  For large datasets, adding 
<CODE>FULLTEXT</CODE> index with <CODE>ALTER TABLE</CODE> (or <CODE>CREATE INDEX</CODE>) would 
be much faster than inserting rows into the empty table with a <CODE>FULLTEXT</CODE> 
index.

</P>
<P>
Full-text search is performed with the <CODE>MATCH</CODE> function.

</P>

<PRE>
mysql&#62; CREATE TABLE articles (
    -&#62;   id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY, 
    -&#62;   title VARCHAR(200),
    -&#62;   body TEXT,
    -&#62;   FULLTEXT (title,body)
    -&#62; );
Query OK, 0 rows affected (0.00 sec)

mysql&#62; INSERT INTO articles VALUES
    -&#62; (0,'MySQL Tutorial', 'DBMS stands for DataBase Management ...'),
    -&#62; (0,'How To Use MySQL Efficiently', 'After you went through a ...'),
    -&#62; (0,'Optimizing MySQL','In this tutorial we will show how to ...'),
    -&#62; (0,'1001 MySQL Trick','1. Never run mysqld as root. 2. Normalize ...'),
    -&#62; (0,'MySQL vs. YourSQL', 'In the following database comparison we ...'),
    -&#62; (0,'MySQL Security', 'When configured properly, MySQL could be ...');
Query OK, 5 rows affected (0.00 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql&#62; SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('database');
+----+-------------------+---------------------------------------------+
| id | title             | body                                        |
+----+-------------------+---------------------------------------------+
|  5 | MySQL vs. YourSQL | In the following database comparison we ... |
|  1 | MySQL Tutorial    | DBMS stands for DataBase Management ...     |
+----+-------------------+---------------------------------------------+
2 rows in set (0.00 sec)
</PRE>

<P>
The function <CODE>MATCH</CODE> matches a natural language query <CODE>AGAINST</CODE> 
a text collection (which is simply the set of columns covered by a 
<CODE>FULLTEXT</CODE> index).  For every row in a table it returns relevance - 
a similarity measure between the text in that row (in the columns that are 
part of the collection) and the query.  When it is used in a <CODE>WHERE</CODE> 
clause (see example above) the rows returned are automatically sorted with 
relevance decreasing.  Relevance is a non-negative floating-point number. 
Zero relevance means no similarity.  Relevance is computed based on the 
number of words in the row, the number of unique words in that row, the 
total number of words in the collection, and the number of documents (rows) 
that contain a particular word.

</P>
<P>
The above is a basic example of using <CODE>MATCH</CODE> function. Rows are
returned with relevance decreasing.

</P>

<PRE>
mysql&#62; SELECT id,MATCH (title,body) AGAINST ('Tutorial') FROM articles;
+----+-----------------------------------------+
| id | MATCH (title,body) AGAINST ('Tutorial') |
+----+-----------------------------------------+
|  1 |                        0.64840710366884 |
|  2 |                                       0 |
|  3 |                        0.66266459031789 |
|  4 |                                       0 |
|  5 |                                       0 |
|  6 |                                       0 |
+----+-----------------------------------------+
5 rows in set (0.00 sec)
</PRE>

<P>
This example shows how to retrieve the relevances. As neither <CODE>WHERE</CODE>
nor <CODE>ORDER BY</CODE> clauses are present, returned rows are not ordered.

</P>

<PRE>
mysql&#62; SELECT id, body, MATCH (title,body) AGAINST (
    -&#62; 'Security implications of running MySQL as root') AS score
    -&#62; FROM articles WHERE MATCH (title,body) AGAINST
    -&#62; ('Security implications of running MySQL as root');
+----+-----------------------------------------------+-----------------+
| id | body                                          | score           |
+----+-----------------------------------------------+-----------------+
|  4 | 1. Never run mysqld as root. 2. Normalize ... | 1.5055546709332 |
|  6 | When configured properly, MySQL could be ...  |   1.31140957288 |
+----+-----------------------------------------------+-----------------+
2 rows in set (0.00 sec)
</PRE>

<P>
This is more complex example - the query returns the relevance and still
sorts the rows with relevance decreasing. To achieve it one should specify
<CODE>MATCH</CODE> twice. Note, that this will cause no additional overhead, as
MySQL optimizer will notice that these two <CODE>MATCH</CODE> calls are
identical and will call full-text search code only once.

</P>
<P>
MySQL uses a very simple parser to split text into words.  A
``word'' is any sequence of letters, numbers, <SAMP>`''</SAMP>, and <SAMP>`_'</SAMP>.  Any
``word'' that is present in the stopword list or just too short (3
characters or less) is ignored.

</P>
<P>
Every correct word in the collection and in the query is weighted,
according to its significance in the query or collection.  This way, a
word that is present in many documents will have lower weight (and may
even have a zero weight), because it has lower semantic value in this
particular collection.  Otherwise, if the word is rare, it will receive a
higher weight.  The weights of the words are then combined to compute the
relevance of the row.

</P>
<P>
Such a technique works best with large collections (in fact, it was
carefully tuned this way).  For very small tables, word distribution
does not reflect adequately their semantical value, and this model
may sometimes produce bizarre results.

</P>

<PRE>
mysql&#62; SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('MySQL');
Empty set (0.00 sec)
</PRE>

<P>
Search for the word <CODE>MySQL</CODE> produces no results in the above example.
Word <CODE>MySQL</CODE> is present in more than half of rows, and as such, is
effectively treated as a stopword (that is, with semantical value zero). 
It is, really, the desired behavior - a natural language query should not
return every second row in 1GB table.

</P>
<P>
A word that matches half of rows in a table is less likely to locate relevant
documents.  In fact, it will most likely find plenty of irrelevant documents.
We all know this happens far too often when we are trying to find something on
the Internet with a search engine.  It is with this reasoning that such rows 
have been assigned a low semantical value in <STRONG>this particular dataset</STRONG>.

</P>



<H3><A NAME="Fulltext_restrictions" HREF="manual.ja_toc.html#Fulltext_restrictions">6.8.1  Fulltext restrictions</A></H3>


<UL>
<LI>

All parameters to the <CODE>MATCH</CODE> function must be columns from the
same table that is part of the same fulltext index.
<LI>

The argument to <CODE>AGAINST</CODE> must be a constant string.
</UL>



<H3><A NAME="Fulltext_Fine-tuning" HREF="manual.ja_toc.html#Fulltext_Fine-tuning">6.8.2  Fine-tuning MySQL Full-text Search</A></H3>

<P>
Unfortunately, full-text search has no user-tunable parameters yet,
although adding some is very high on the TODO.  However, if you have a 
MySQL source distribution ( 「<A HREF="manual.ja_Installing.html#Installing_source">2.3  MySQL ソースディストリビューションのインストール</A>」節参照.), you can 
somewhat alter the full-text search behavior.

</P>
<P>
Note that full-text search was carefully tuned for the best searching
effectiveness.  Modifying the default behavior will, in most cases,
only make the search results worse.  Do not alter the MySQL sources
unless you know what you are doing!

</P>

<UL>

<LI>

Minimal length of word to be indexed is defined in
<CODE>myisam/ftdefs.h</CODE> file by the line

<PRE>
#define MIN_WORD_LEN 4
</PRE>

Change it to the value you prefer, recompile MySQL, and rebuild
your <CODE>FULLTEXT</CODE> indexes.

<LI>

The stopword list is defined in <CODE>myisam/ft_static.c</CODE>
Modify it to your taste, recompile MySQL and rebuild
your <CODE>FULLTEXT</CODE> indexes.

<LI>

The 50% threshold is caused by the particular weighting scheme chosen. To 
disable it, change the following line in <CODE>myisam/ftdefs.h</CODE>:

<PRE>
#define GWS_IN_USE GWS_PROB
</PRE>

to

<PRE>
#define GWS_IN_USE GWS_FREQ
</PRE>

and recompile MySQL.
There is no need to rebuild the indexes in this case.

</UL>



<H3><A NAME="Fulltext_Features_to_Appear_in_MySQL_4.0" HREF="manual.ja_toc.html#Fulltext_Features_to_Appear_in_MySQL_4.0">6.8.3  New Features of Full-text Search to Appear in MySQL 4.0</A></H3>

<P>
This section includes a list of the fulltext features that are already
implemented in the 4.0 tree. It explains
<STRONG>More functions for full-text search</STRONG> entry of  「<A HREF="manual.ja_Introduction.html#TODO_MySQL_4.0">1.6.1  Things that should be in 4.0</A>」節.

</P>

<UL>
<LI><CODE>REPAIR TABLE</CODE> with <CODE>FULLTEXT</CODE> indexes,

<CODE>ALTER TABLE</CODE> with <CODE>FULLTEXT</CODE> indexes, and
<CODE>OPTIMIZE TABLE</CODE> with <CODE>FULLTEXT</CODE> indexes are now
up to 100 times faster.

<LI><CODE>MATCH ... AGAINST</CODE> is going to supports the following

<STRONG>boolean operators</STRONG>:


<UL>
<LI><CODE>+</CODE>word means the that word <STRONG>must</STRONG> be present in every

row returned.
<LI><CODE>-</CODE>word means the that word <STRONG>must not</STRONG> be present in every

row returned.
<LI><CODE>&#60;</CODE> and <CODE>&#62;</CODE> can be used to decrease and increase word

weight in the query.
<LI><CODE>~</CODE> can be used to assign a <STRONG>negative</STRONG> weight to a noise

word.
<LI><CODE>*</CODE> is a truncation operator.

</UL>

Boolean search utilizes a more simplistic way of calculating the relevance,
that does not have a 50% threshold.

<LI>Searches are now up to 2 times faster due to optimized search algorithm.

<LI>Utility program <CODE>ft_dump</CODE> added for low-level <CODE>FULLTEXT</CODE>

index operations (querying/dumping/statistics).

</UL>



<H3><A NAME="Fulltext_TODO" HREF="manual.ja_toc.html#Fulltext_TODO">6.8.4  Full-text Search TODO</A></H3>


<UL>
<LI>Make all operations with <CODE>FULLTEXT</CODE> index <STRONG>faster</STRONG>.

<LI>Support for braces <CODE>()</CODE> in boolean full-text search.

<LI>Phrase search, proximity operators

<LI>Boolean search can work without <CODE>FULLTEXT</CODE> index

(yes, <STRONG>very</STRONG> slow).
<LI>Support for "always-index words". They could be any strings

the user wants to treat as words, examples are "C++", "AS/400", "TCP/IP", etc.
<LI>Support for full-text search in <CODE>MERGE</CODE> tables.

<LI>Support for multi-byte charsets.

<LI>Make stopword list to depend of the language of the data.

<LI>Stemming (dependent of the language of the data, of course).

<LI>Generic user-supplyable UDF (?) preparser.

<LI>Make the model more flexible (by adding some adjustable

parameters to <CODE>FULLTEXT</CODE> in <CODE>CREATE/ALTER TABLE</CODE>).
</UL>

<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_MySQL_Optimization.html">previous</A>, <A HREF="manual.ja_Table_types.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
