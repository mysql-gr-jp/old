  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 30 December 2001 -->

  <TITLE>MySQL Reference Manual for version 3.23.47. - 4  MySQL Database Administration</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=silver TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Tutorial.html">previous</A>, <A HREF="manual.ja_MySQL_Optimization.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="MySQL_Database_Administration" HREF="manual.ja_toc.html#MySQL_Database_Administration">4  MySQL Database Administration</A></H1>



<H2><A NAME="Configuring_MySQL" HREF="manual.ja_toc.html#Configuring_MySQL">4.1  Configuring MySQL</A></H2>



<H3><A NAME="Command-line_options" HREF="manual.ja_toc.html#Command-line_options">4.1.1  mysqld コマンド行オプション</A></H3>

<P>
<A NAME="IDX416"></A>
<A NAME="IDX417"></A>
<A NAME="IDX418"></A>

</P>
<P>
<CODE>mysqld</CODE> は次のコマンド行オプションを受け付けます:

</P>
<DL COMPACT>

<DT><CODE>--ansi</CODE>
<DD>
MySQL 構文の代わりに ANSI SQL 構文を使用します。 「<A HREF="manual.ja_Introduction.html#ANSI_mode">1.4.3  ANSI モードでの MySQL の実行</A>」節参照。

<DT><CODE>-b, --basedir=path</CODE>
<DD>
インストール先ディレクトリのパス。すべてのパスは通常ここからの相対パスで決
定されます。

<DT><CODE>--big-tables</CODE>
<DD>
ファイルにすべての一時セットを保存することにより、大きな結果セットを許しま
す。これは、多くの 'table full' エラーを解決します。しかし、メモリ内テーブ
ルでも十分なクエリは遅くなります。バージョン 3.23.2 からは、
<STRONG>MySQL</STRONG> は自動的にメモリを使用し、必要なときにディスクテーブルにス
イッチすることによって、これを解決します。

<DT><CODE>--bind-address=IP</CODE>
<DD>
bind する IP アドレス。

<DT><CODE>--character-sets-dir=path</CODE>
<DD>
キャラクタ・セット ディレクトリ。 「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_sets">4.6.1  データとソートに使用されるキャラクターセット</A>」節参照。

<DT><CODE>--chroot=path</CODE>
<DD>
起動中に <CODE>mysqld</CODE> デーモンを chroot します。推奨されるセキュリティ手法です。
これは <CODE>LOAD DATA INFILE</CODE> と <CODE>SELECT ... INTO OUTFILE</CODE> を制限し
ます。

<DT><CODE>--core-file</CODE>
<DD>
<CODE>mysqld</CODE> が死んだ場合 core ファイルを書き出します。いくつかのシステム
では、<CODE>--core-file-size</CODE> も <CODE>safe_mysqld</CODE> に記述する必要がありま
す。 「<A HREF="manual.ja_MySQL_Database_Administration.html#safe_mysqld">4.7.2  safe_mysqld, the wrapper around mysqld</A>」節参照.

<DT><CODE>-h, --datadir=path</CODE>
<DD>
データベースルートのパス。

<DT><CODE>--default-character-set=charset</CODE>
<DD>
デフォルト のキャラクタ・セットの設定。 「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_sets">4.6.1  データとソートに使用されるキャラクターセット</A>」節参照。

<DT><CODE>--default-table-type=type</CODE>
<DD>
テーブルのデフォルトテーブル型を設定する。  「<A HREF="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</A>」節参照.

<DT><CODE>--debug[...]=</CODE>
<DD>
<STRONG>MySQL</STRONG> が <CODE>--with-debug</CODE> つきで configure された場合、このオ
プション使用して、<CODE>mysqld</CODE> が何を行なっているかのトレースファイルを得
ることができます。  「<A HREF="manual.ja_Porting.html#Making_trace_files">G.1.2  Creating trace files</A>」節参照.

<DT><CODE>--delay-key-write-for-all-tables</CODE>
<DD>
任意の <CODE>MyISAM</CODE> テーブルについて書き込み間でキーバッファをフラッシュ
しません。  「<A HREF="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.

<DT><CODE>--enable-locking</CODE>
<DD>
システムロックを有効にします。注意: lockd() が完全に働かない(Linux のよう
な)システムでこのオプションを使用した場合、mysqld が簡単にデッドロックしま
す。

<DT><CODE>-T, --exit-info</CODE>
<DD>
mysqld サーバをデバッグするために使用できる、様々なフラグのビットマスクで
す; 何が行なわれるのか正確に知らない場合は、このオプションを使用すべきでは
ありません！

<DT><CODE>--flush</CODE>
<DD>
各 SQL コマンド後にすべての変更をディスクにフラッシュします。通常 
<STRONG>MySQL</STRONG> は各 SQL コマンドにすべての変更をディスクに書き出すだけで、
OS がディスクへの sync を処理します。
 「<A HREF="manual.ja_Problems.html#Crashing">A.4.1  What To Do If MySQL Keeps Crashing</A>」節参照.

<DT><CODE>-?, --help</CODE>
<DD>
短いへルプを表示して終了します。

<DT><CODE>--init-file=file</CODE>
<DD>
起動時にファイルから SQL コマンドを読み込みます。

<DT><CODE>-L, --language=...</CODE>
<DD>
与えられた言語のクライアントエラーメッセージ。フルパスで与えることもできます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Languages">4.6.2  Non-English Error Messages</A>」節参照.

<DT><CODE>-l, --log[=file]</CODE>
<DD>
接続とクエリをファイルに記録します。  「<A HREF="manual.ja_MySQL_Database_Administration.html#Query_log">4.9.2  The General Query Log</A>」節参照.

<DT><CODE>--log-isam[=file]</CODE>
<DD>
すべての ISAM/MyISAM 変更をファイルに記録します(ISAM/MyISAM のデバッグ時に
のみ使用できます)。

<DT><CODE>--log-slow-queries[=file]</CODE>
<DD>
実行に <CODE>long_query_time</CODE> 秒以上掛かるすべてのクエリをファイルに記録し
ます。  「<A HREF="manual.ja_MySQL_Database_Administration.html#Slow_query_log">4.9.5  The Slow Query Log</A>」節参照.

<DT><CODE>--log-update[=file]</CODE>
<DD>
更新を <CODE>file.#</CODE> に記録します。<CODE>#</CODE> は与えられなければ一意な番号で
す。  「<A HREF="manual.ja_MySQL_Database_Administration.html#Update_log">4.9.3  更新ログ</A>」節参照.

<DT><CODE>--log-long-format</CODE>
<DD>
更新ログに拡張情報を記録します。<CODE>--log-slow-queries</CODE> を使用すると、イ
ンデックスを使用しないクエリが slow query ログに記録されます。

<DT><CODE>--low-priority-updates</CODE>
<DD>
テーブル変更操作 (<CODE>INSERT</CODE>/<CODE>DELETE</CODE>/<CODE>UPDATE</CODE>) は SELECT よ
りも低い優先度になります。あるクエリだけ優先度を低くするには、
<CODE>{INSERT | REPLACE | UPDATE | DELETE} LOW_PRIORITY ...</CODE> によって行
なわれます。また、ひとつのスレッドの優先度を変更するには、<CODE>SET
OPTION SQL_LOW_PRIORITY_UPDATES=1</CODE> で行なわれます。
 「<A HREF="manual.ja_MySQL_Optimization.html#Table_locking">5.3.2  テーブル・ロッキングの問題</A>」節参照.

<DT><CODE>--memlock</CODE>
<DD>
メモリに <CODE>mysqld</CODE> プロセスをロックします。これはシステムが 
<CODE>mlockall()</CODE> システムコールをサポートしている時(Solaris のように)にだけ動作します。これ
は、OS が <CODE>mysqld</CODE> をディスク上にスワップさせる問題がある場合の助けに
なります。

<DT><CODE>--myisam-recover [=option[,option...]]] where option is any combination</CODE>
<DD>
of <CODE>DEFAULT</CODE>, <CODE>BACKUP</CODE>, <CODE>FORCE</CODE> or <CODE>QUICK</CODE>. 
このオプションを使用すると、<CODE>mysqld</CODE> はオープン時にテーブルがクラッシュ
したとマークされているかどうか、テーブルが適切にクローズされていないかどう
かチェックします。(最後のオプションは <CODE>--skip-locking</CODE> で起動している
場合にだけ働きます)。If this is the case <CODE>mysqld</CODE> will run check on the
table. テーブルが壊れている場合、<CODE>mysqld</CODE> はその修復を試みます。

次のオプションは修復の動作に影響します：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>DEFAULT </TD><TD> <CODE>--myisam-recover</CODE> にオプションを与えないのと同じです。
</TR NOSAVE>
<TR><TD>BACKUP </TD><TD> データテーブルが修復中に変更された場合、
                    <TT>`table_name.MYD'</TT> データファイルのバックアップを 
                    <TT>`table_name-datetime.BAK'</TT> に保存します。
</TR NOSAVE>
<TR><TD>FORCE </TD><TD> .MYD ファイルからひとつより多くのレコードが失われている
                    場合でも修復を実行します。
</TR NOSAVE>
<TR><TD>QUICK </TD><TD> 削除ブロックがない場合にテーブル内のレコードをチェック
                    しません。
</TR>
</TABLE>

テーブルが自動的に修復される前に、<STRONG>MySQL</STRONG> はエラーログにこれについ
てのメモを追加します。ユーザの介入なしで多くのことを修復したい場合は、オプ
ション <CODE>BACKUP,FORCE</CODE> を使用すべきです。いくつかのレコードが削除され
る場合でも、テーブルを強制的に修復しますが、古いデータファイルをバックアッ
プとして保存するため、あとで何が起こったか検証できます。

<DT><CODE>--pid-file=path</CODE>
<DD>
<CODE>safe_mysqld</CODE> によって使用される pid ファイルのパス。

<DT><CODE>-P, --port=...</CODE>
<DD>
TCP/IP 接続で listen するポート番号。

<DT><CODE>-o, --old-protocol</CODE>
<DD>
とても古いクライアントとの互換のために、3.20 プロトコルを使用します。
 「<A HREF="manual.ja_Installing.html#Upgrading-from-3.20">2.5.3  バージョン 3.20 から バージョン 3.21 へのアップグレード</A>」節参照.

<DT><CODE>--one-thread</CODE>
<DD>
一つのスレッドだけを使用します(Linux 下でデバックするため)。  「<A HREF="manual.ja_Porting.html#Debugging_server">G.1  MySQL server のデバッグ</A>」節参照.

<DT><CODE>-O, --set-variable var=option</CODE>
<DD>
変数に値を与えます。<CODE>--help</CODE> は変数をリストします。すべての変数の完全
な詳細はこのマニュアルの <CODE>SHOW VARIABLES</CODE> 節で見られます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.5.4  <CODE>SHOW VARIABLES</CODE></A>」節参照。サーバパラメータの調整についての節はこれらの最適化
方法の情報を含んでいます。  「<A HREF="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.

<DT><CODE>--safe-mode</CODE>
<DD>
いくつかの最適化ステージをスキップします。<CODE>--skip-delay-key-write</CODE> を
含みます。

<DT><CODE>--safe-show-database</CODE>
<DD>
ユーザが権限を何も持っていないデータベースを表示しません。

<DT><CODE>--safe-user-create</CODE>
<DD>
If this is enabled, a user can't create new users with the GRANT
command, if the user doesn't have <CODE>INSERT</CODE> privilege to the
<CODE>mysql.user</CODE> table or any column in this table.

<DT><CODE>--skip-concurrent-insert</CODE>
<DD>
同時に <CODE>MyISAM</CODE> テーブルに select と insert を行なう機能をオフにしま
す。(この機能にバグを見つけたと考える場合にだけ使用します)。

<DT><CODE>--skip-delay-key-write</CODE>
<DD>
すべてのテーブルに対し <CODE>delay_key_write</CODE> オプションを無視します。
 「<A HREF="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.

<DT><CODE>--skip-grant-tables</CODE>
<DD>
このオプションは、サーバをすべての権限システム使用しないようにします。これ
は全員にすべてのデータベースへの<EM>完全アクセス</EM>を与えます！
(<CODE>mysqladmin flush-privileges</CODE> や <CODE>mysqladmin reload</CODE> を実行する
ことで、権限テーブルを使用して起動するように実行中のサーバに伝えることがで
きます。)

<DT><CODE>--skip-host-cache</CODE>
<DD>
より速いホスト名-IP解決のためのホスト名キャッシュを使用しません。代わりに
すべての接続で DNS サーバへクエリします。  「<A HREF="manual.ja_MySQL_Optimization.html#DNS">5.5.5  How MySQL uses DNS</A>」節参照.

<DT><CODE>--skip-locking</CODE>
<DD>
システムロックを使用しません。<CODE>isamchk</CODE> または <CODE>myisamchk</CODE> を使
用するためには、サーバをシャットダウンする必要があります。
 「<A HREF="manual.ja_Introduction.html#Stability">1.1.7  <STRONG>MySQL</STRONG> はどれくらい安定か？</A>」節参照。注意: <STRONG>MySQL</STRONG> バージョン 3.23 では、
<CODE>REPAIR</CODE> と <CODE>CHECK</CODE> を <CODE>MyISAM</CODE> テーブルの修復／チェックに
使用できます。

<DT><CODE>--skip-name-resolve</CODE>
<DD>
ホスト名を解決しません。権限テーブルのすべての <CODE>Host</CODE> フィールド値は 
IP 番号か <CODE>localhost</CODE> でなければなりません。  「<A HREF="manual.ja_MySQL_Optimization.html#DNS">5.5.5  How MySQL uses DNS</A>」節参照.

<DT><CODE>--skip-networking</CODE>
<DD>
TCP/IP 接続の listen をまったく行ないません。<CODE>mysqld</CODE> との接続には 
UNIX ソケット経由で行なう必要があります。このオプションはローカル要求だけ
を許可するシステムでは、高く推奨されます。   「<A HREF="manual.ja_MySQL_Optimization.html#DNS">5.5.5  How MySQL uses DNS</A>」節参照.

<DT><CODE>--skip-new</CODE>
<DD>
Don't use new, possible wrong routines.  Implies <CODE>--skip-delay-key-write</CODE>.
This will also set default table type to <CODE>ISAM</CODE>.   「<A HREF="manual.ja_Table_types.html#ISAM">7.3  ISAM Tables</A>」節参照.

<DT><CODE>--skip-symlink</CODE>
<DD>
Don't delete or rename files that a symlinked file in the data directory
points to.

<DT><CODE>--skip-safemalloc</CODE>
<DD>
<STRONG>MySQL</STRONG> が <CODE>--with-debug=full</CODE> で configure されている場合、す
べてのプログラムがすべてのメモリ割り当てとメモリ解放をオーバーラン用にチェッ
クします。このチェックはとても遅いので、メモリチェックが不要な場合、このオ
プションを使用することでこれを無効にできます。

<DT><CODE>--skip-show-database</CODE>
<DD>
<STRONG>process</STRONG> 権限を持っていないユーザに 'SHOW DATABASE' コマンドを許し
ません。

<DT><CODE>--skip-stack-trace</CODE>
<DD>
スタックトレースを書き出しません。このオプションは、<CODE>mysqld</CODE> をデバッ
ガ下で実行している時に有用です。  「<A HREF="manual.ja_Porting.html#Debugging_server">G.1  MySQL server のデバッグ</A>」節参照.

<DT><CODE>--skip-thread-priority</CODE>
<DD>
より速いレスポンスタイム用のスレッド優先度の使用を無効にします。

<DT><CODE>--socket=path</CODE>
<DD>
デフォルト <CODE>/tmp/mysql.sock</CODE> の代わりに、ローカル接続用に使用されるソ
ケットファイル。

<DT><CODE>--sql-mode=option[,option[,option...]]</CODE>
<DD>
Option can be any combination of: <CODE>REAL_AS_FLOAT</CODE>,
<CODE>PIPES_AS_CONCAT</CODE>, <CODE>ANSI_QUOTES</CODE>, <CODE>IGNORE_SPACE</CODE>,
<CODE>SERIALIZE</CODE>, <CODE>ONLY_FULL_GROUP_BY</CODE>.  It can also be empty
(<CODE>""</CODE>) if you want to reset this.

By specifying all of the above options is same as using --ansi.
With this option one can turn on only needed SQL modes.  「<A HREF="manual.ja_Introduction.html#ANSI_mode">1.4.3  ANSI モードでの MySQL の実行</A>」節参照.

<DT><CODE>transaction-isolation= { READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE }</CODE>
<DD>
Sets the default transaction isolation level.   「<A HREF="manual.ja_Reference.html#SET_TRANSACTION">6.7.3  <CODE>SET TRANSACTION</CODE> 構文</A>」節参照.

<DT><CODE>-t, --tmpdir=path</CODE>
<DD>
一時ファイル用のパス。デフォルトの <CODE>/tmp</CODE> ディレクトリが一時テーブル
を保持するのに小さすぎるパーティション上にある場合に有用です。

<DT><CODE>-u, --user=user_name</CODE>
<DD>
ユーザ <CODE>user_name</CODE> で <CODE>mysqld</CODE> デーモンを実行します。このオプショ
ンは、<CODE>mysqld</CODE> を root で起動した時に <EM>強制</EM>されます。

<DT><CODE>-V, --version</CODE>
<DD>
バージョン情報を出力して終了します

<DT><CODE>-W, --warnings</CODE>
<DD>
<CODE>Aborted connection...</CODE> のような警告を <CODE>.err</CODE> ファイルに出力しま
す。  「<A HREF="manual.ja_Problems.html#Communication_errors">A.2.9  Communication Errors / Aborted Connection</A>」節参照.
</DL>



<H3><A NAME="Option_files" HREF="manual.ja_toc.html#Option_files">4.1.2  my.cnf オプションファイル</A></H3>

<P>
<A NAME="IDX419"></A>
<A NAME="IDX420"></A>
<A NAME="IDX421"></A>
<A NAME="IDX422"></A>

</P>
<P>
<STRONG>MySQL</STRONG> バージョン 3.22 のサーバー、クライアントともに、
オプションファイルからデフォルトの起動オプションを読み込むことができます。

</P>
<P>
UNIX では <STRONG>MySQL</STRONG> は以下のファイルからデフォルトオプションを読みます：

</P>
<P>
<A NAME="IDX423"></A>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>ファイル名</STRONG> </TD><TD> <STRONG>意味</STRONG>
</TR NOSAVE>
<TR><TD><CODE>/etc/my.cnf</CODE> </TD><TD> 全体のオプション
</TR NOSAVE>
<TR><TD><CODE>DATADIR/my.cnf</CODE> </TD><TD> サーバ固有オプション
</TR NOSAVE>
<TR><TD><CODE>defaults-extra-file</CODE> </TD><TD> --defaults-extra-file=# で指定されたファイル
</TR NOSAVE>
<TR><TD><CODE>~/.my.cnf</CODE> </TD><TD> ユーザ固有オプション
</TR>
</TABLE>

</P>
<P>
<CODE>DATADIR</CODE> は <STRONG>MySQL</STRONG> データディレクトリです (普通
バイナリ配布では <TT>`/usr/local/mysql/data'</TT> 、ソース配布では <TT>`/usr/local/var'</TT>).
このディレクトリはconfigure時に決定されており、 <CODE>--datadir</CODE> を
<CODE>mysqld</CODE> 起動時に指定しても変更されません。
(サーバーはコマンドラインの引数を処理する前にオプションファイルを探します。
よって、<CODE>--datadir</CODE> 引数を指定してもオプションファイルを探す場所を指定することにはなりません。)

</P>
<P>
Windows では <STRONG>MySQL</STRONG> は以下のファイルからデフォルトオプションを読みます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>ファイル名</STRONG> </TD><TD> <STRONG>意味</STRONG>
</TR NOSAVE>
<TR><TD><CODE>windows-system-directory\my.ini</CODE> </TD><TD> Global options
</TR NOSAVE>
<TR><TD><CODE>C:\my.cnf</CODE> </TD><TD> 全体のオプション
</TR NOSAVE>
<TR><TD><CODE>C:\mysql\data\my.cnf</CODE> </TD><TD> サーバ固有オプション
</TR>
</TABLE>

<P>
注意: Windows では <CODE>\</CODE> の代わりに <CODE>/</CODE> で全てのパスを記述すべきで
す。<CODE>\</CODE> を使用する場合、<CODE>\</CODE> は <STRONG>MySQL</STRONG> のエスケープ文字
なので、これを二重に記述する必要があります。

</P>
<P>
<A NAME="IDX424"></A>
<STRONG>MySQL</STRONG> は上記の表にかかれている順にオプションファイルを読みます。
もし複数オプションファイルがあった場合、後から読まれた設定が有効になります。
全てのオプションはコマンドラインの引数に上書きされます。
いくつかのオプションは環境変数に定義できます。
オプションファイルとコマンドラインの引数は環境変数を上書きします。
 「<A HREF="manual.ja_Environment_variables.html#Environment_variables">H  Environment Variables</A>」節参照.

</P>
<P>
次のプログラムはオプションファイルをサポートします：  <CODE>mysql</CODE>,
<CODE>mysqladmin</CODE>, <CODE>mysqld</CODE>, <CODE>mysqldump</CODE>, <CODE>mysqlimport</CODE>,
<CODE>mysql.server</CODE>, <CODE>myisamchk</CODE>, and <CODE>myisampack</CODE>.

</P>
<P>
オプションファイルには、プログラムがサポートしているコマンドラインの
 long オプション(例えば、<CODE>-u</CODE> ではなくて <CODE>--user</CODE> の方)を書くことができます。
プログラムを <CODE>--help</CODE> で起動すれば、設定可能な変数名が得られます。

</P>
<P>
オプションファイルの書式は以下です：

</P>
<DL COMPACT>

<DT><CODE>#comment</CODE>
<DD>
コメントは <SAMP>`#'</SAMP> か <SAMP>`;'</SAMP> 文字で始めます。空の行は無視します。

<DT><CODE>[group]</CODE>
<DD>
グループ宣言。
<CODE>group</CODE> はオプションを定義するプログラムかグループの名前です。
この宣言の後、<CODE>オプション</CODE> か <CODE>set-variable</CODE> 行で、このグループにオプションを与えます。
このセクションの範囲は、他のグループ宣言の行が来るか、ファイルの最後に来るまでです。

<DT><CODE>option</CODE>
<DD>
これはコマンドラインの <CODE>--option</CODE> と等価です。

<DT><CODE>option=value</CODE>
<DD>
これはコマンドラインの <CODE>--option=value</CODE> と等価です。

<DT><CODE>set-variable = variable=value</CODE>
<DD>
これはコマンドラインの <CODE>--set-variable variable=value</CODE> と等価です。
これは <CODE>mysqld</CODE> 変数で使用される形式です。
</DL>

<P>
<CODE>client</CODE> グループは、全ての <STRONG>MySQL</STRONG> クライアント(<CODE>mysqld</CODE>は除)に対してオプションを定義します。
これはサーバーに接続する際に使用するパスワードを指定できるグループです。
(この場合、オプションファイルは自分だけが読み書きできるようにしてください)

</P>
<P>
オプションや値の善後にある全てのブランク文字は自動で取り除かれます。
値として、<SAMP>`\b'</SAMP>,<SAMP>`\t'</SAMP>, <SAMP>`\n'</SAMP>, <SAMP>`\r'</SAMP>, <SAMP>`\\'</SAMP>, <SAMP>`\s'</SAMP>
 のエスケープシーケンスが使用できます。
(<SAMP>`\s'</SAMP> == blank).

</P>
<P>
オプションファイル例：

</P>

<PRE>
[client]
port=3306
socket=/tmp/mysql.sock

[mysqld]
port=3306
socket=/tmp/mysql.sock
set-variable = key_buffer_size=16M
set-variable = max_allowed_packet=1M

[mysqldump]
quick
</PRE>

<P>
ユーザーオプションファイル例：

</P>

<PRE>
[client]
# The following password will be sent to all standard MySQL clients
password=my_password

[mysql]
no-auto-rehash
set-variable = connect_timeout=2

[mysqlhotcopy]
interactive-timeout

</PRE>

<P>
<A NAME="IDX425"></A>
もしソース配布を持っているなら、 <TT>`my-xxxx.cnf'</TT> という名前のサンプルファイルを
<TT>`support-files'</TT> ディレクトリに見ることができます。
もしバイナリ配布を使用しているなら、 <TT>`DIR/support-files'</TT> ディレクトリを探してください
(ここで <CODE>DIR</CODE> は <STRONG>MySQL</STRONG> がインストールされたディレクトリのパス名で、
普通は <TT>`/usr/local/mysql'</TT>)。
この <TT>`my-xxxx.cnf'</TT> ファイルを自分のディレクトリに
 <TT>`.my.cnf'</TT> という名前でコピーして使用できます。

</P>
<P>
オプションファイルをサポートするすべての <STRONG>MySQL</STRONG> クライアントは次
のオプションをサポートします:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>--no-defaults </TD><TD> オプションファイルを読み込まない。
</TR NOSAVE>
<TR><TD>--print-defaults </TD><TD> プログラム名と得られる全てのオプションを出力する。
</TR NOSAVE>
<TR><TD>--defaults-file=full-path-to-default-file </TD><TD> 与えられたコンフィグレーションファイルだけを使用する。
</TR NOSAVE>
<TR><TD>--defaults-extra-file=full-path-to-default-file </TD><TD> グローバルコンフィグレーションファイルの後、ユーザコンフィグレーションファイルの前にこのコンフィグレーションファイルを読み込む。
</TR>
</TABLE>

<P>
注意: 上記のオプションはコマンドラインの先頭になければ働きません！ ただ
し、<CODE>--print-defualts</CODE>は <CODE>--defaults-xxx-file</CODE> コマンドの直後
にも置けます。

</P>
<P>
開発者向け情報：　オプションファイルの操作は全てのオプションをコマンドラインの
引数より先に処理するように簡単に埋め込まれています。
これはオプションを最後に処理するプログラムを複数立ちあげる場合に都合よく動きます。
もしオプションファイルを読み込む機能のない古いプログラムを使用しているなら、
たった二行だけ注意して書けばいいだけです。
この動作については <STRONG>MySQL</STRONG> クライアントプログラムのコードを参考にしてください。

</P>
<P>
シェルスクリプト内では、<TT>`my_print_defaults'</TT> コマンドを使用して、コ
ンフィグファイルを解析することができます:

</P>

<PRE>

shell&#62; my_print_defaults client mysql
--port=3306
--socket=/tmp/mysql.sock
--no-auto-rehash
</PRE>

<P>
上記は、'client' と 'mysql' グループ用の全オプションを出力します。

</P>



<H3><A NAME="Installing_many_servers" HREF="manual.ja_toc.html#Installing_many_servers">4.1.3  同じマシンに多くのサーバをインストールする</A></H3>

<P>
<A NAME="IDX426"></A>
<A NAME="IDX427"></A>
<A NAME="IDX428"></A>

</P>
<P>
同じマシン上で多くの異なる <CODE>mysqld</CODE> デーモン(サーバ)を動作させたい場
合があります。例えば、テスト用に <CODE>MySQL</CODE> の新しいバージョンを使用中の
古いバージョンと共に実行したい場合や、異なる <CODE>mysqld</CODE> サーバにそれを管理する
異なるユーザアクセスを与えたい場合などです。

</P>
<P>
一つの方法は、新しいサーバを次のように異なるソケットとポートで起動すること
です:

</P>
<P>
<A NAME="IDX429"></A>
<A NAME="IDX430"></A>
<A NAME="IDX431"></A>
<A NAME="IDX432"></A>

<PRE>
shell&#62; MYSQL_UNIX_PORT=/tmp/mysqld-new.sock
shell&#62; MYSQL_TCP_PORT=3307
shell&#62; export MYSQL_UNIX_PORT MYSQL_TCP_PORT
shell&#62; scripts/mysql_install_db
shell&#62; bin/safe_mysqld &#38;
</PRE>

<P>
The environment variables 付録は <CODE>mysqld</CODE> に影響する他の環境変数の
一覧を含んでいます。  「<A HREF="manual.ja_Environment_variables.html#Environment_variables">H  Environment Variables</A>」節参照.

</P>
<P>
The above is the quick and dirty way that one commonly uses for testing.
The nice thing with this is that all connections you do in the above shell
will automatically be directed to the new running server!

</P>
<P>
If you need to do this more permanently, you should create an option
file for each server.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.  In your startup script that
is executed at boot time (mysql.server?) you should specify for both
servers:

</P>
<P>
<CODE>safe_mysqld --default-file=path-to-option-file</CODE>

</P>
<P>
少なくとも、次のオプションはサーバごとに異なるようにすべきです:

</P>
<DL COMPACT>

<DT><CODE>port=#</CODE>
<DD>
<DT><CODE>socket=path</CODE>
<DD>
<DT><CODE>pid-file=path</CODE>
<DD>
</DL>

<P>
次のオプションが使用される場合、異なるようにすべきです:

</P>
<DL COMPACT>

<DT><CODE>log=path</CODE>
<DD>
<DT><CODE>log-bin=path</CODE>
<DD>
<DT><CODE>log-update=path</CODE>
<DD>
<DT><CODE>log-isam=path</CODE>
<DD>
<DT><CODE>bdb-logdir=path</CODE>
<DD>
</DL>

<P>
さらに性能を求める場合、次も異なるように記述できます:

</P>
<DL COMPACT>

<DT><CODE>tmpdir=path</CODE>
<DD>
<DT><CODE>bdb-tmpdir=path</CODE>
<DD>
</DL>

<P>
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Command-line_options">4.1.1  mysqld コマンド行オプション</A>」節参照.

</P>
<P>
バイナリの <STRONG>MySQL</STRONG> バージョン (.tar ファイル) をインストールして、
<CODE>./bin/safe_mysqld</CODE> で起動する場合、多くの場合では、追加/変更する必要
のあるオプションは <CODE>safe_mysqld</CODE> への <CODE>socket</CODE> と <CODE>port</CODE> 引
数だけです。

</P>



<H3><A NAME="Multiple_servers" HREF="manual.ja_toc.html#Multiple_servers">4.1.4  同一マシン上に複数の MySQL サーバーを走らせる</A></H3>

<P>
<A NAME="IDX433"></A>
<A NAME="IDX434"></A>
<A NAME="IDX435"></A>

</P>
<P>
同じマシン上で複数のサーバーを走らせたい場合があります。
例えば、すでに存在しているサーバーはそのままにしておいて、新しい <STRONG>MySQL</STRONG> をテストしたい場合や、
あるいは、インターネットプロバイダーを営んでいて、<STRONG>MySQL</STRONG> をそれぞれの顧客用に提供したい場合など。

</P>
<P>
複数のサーバーをたちあげる場合、簡単な方法として、
TCP/IP ポート、ソケットファイルを変えて、サーバーをコンパイルする方法があります。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqld_multi">4.7.3  mysqld_multi, program for managing multiple MySQL servers</A>」節参照.

</P>
<P>
そでに走っているサーバーがデフォルトのポート番号とソケットファイルで動作しているとします。
新しくサーバーを作るには、以下のように <CODE>configure</CODE> します：

</P>

<PRE>
shell&#62; ./configure  --with-tcp-port=port_number \
             --with-unix-socket-path=file_name \
             --prefix=/usr/local/mysql-3.22.9
</PRE>

<P>
<CODE>port_number</CODE> と <CODE>file_name</CODE> には、デフォルトのポート番号、
ソケットファイルとは違うものを指定します。
そして <CODE>--prefix</CODE> を、すでに走っている <STRONG>MySQL</STRONG> の
インストール先とは違うディレクトリーに指定します。

</P>
<P>
現在走っている <STRONG>MySQL</STRONG> サーバーが使用している
ソケットとポートをチェックするには、以下のようにします：

</P>

<PRE>
shell&#62; mysqladmin -h hostname --port=port_number variables
</PRE>

<P>
Note that if you specify ``<CODE>localhost</CODE>'' as a hostname, <CODE>mysqladmin</CODE>
will default to using Unix sockets instead of TCP/IP.

</P>
<P>
あなたが使用しているポートに <STRONG>MySQL</STRONG> サーバーが走っていれば、
これは変更可能な <STRONG>MySQL</STRONG> 変数を(ソケットファイルの名前も含んで)出力します。

</P>
<P>
この場合、 <STRONG>MySQL</STRONG> サーバーを再コンパイルする必要はありません。
<CODE>safe_mysqld</CODE> のオプションを指定してサーバーを起動すれば、
ポートとソケットを変更できます：

</P>

<PRE>
shell&#62; /path/to/safe_mysqld --socket=file_name --port=port_number
</PRE>

<P>
<CODE>mysqld_multi</CODE> can also take <CODE>safe_mysqld</CODE> (or <CODE>mysqld</CODE>)
as an argument and pass the options from a configuration file to
<CODE>safe_mysqld</CODE> and further to <CODE>mysqld</CODE>.

</P>
<P>
もし、他のサーバーがロギングを行っているディレクトリと同じデータベースディレクトリを、
新しいサーバーで使用するのであれば、ログファイルの名前を指定すべきです。
( <CODE>safe_mysqld</CODE> に <CODE>--log</CODE> , <CODE>--log-update</CODE> , <CODE>--log-slow-queries</CODE> を指定する)
そうしないと、両方のサーバーが同じログファイルに書き込もうとするからです。

</P>
<P>
<STRONG>WARNING</STRONG>: 通常、二つサーバーに同じデータベースを操作させてはいけません！
もし使用している OS が fault-free system locking をサポートしていないと、
これは悲惨なことになるでしょう！

</P>
<P>
もし二つ目のサーバーに違うデータベースディレクトリを使用させたい場合、
 <CODE>safe_mysqld</CODE> に <CODE>--datadir=path</CODE> オプションを指定します。

</P>
<P>
<STRONG>NOTE</STRONG> also that starting several MySQL servers
(<CODE>mysqlds</CODE>) in different machines and letting them access one data
directory over <CODE>NFS</CODE> is generally a <STRONG>BAD IDEA</STRONG>! The problem
is that the <CODE>NFS</CODE> will become the bottleneck with the speed. It is
not meant for such use. And last but not least, you would still have to
come up with a solution how to make sure that two or more <CODE>mysqlds</CODE>
are not interfering with each other. At the moment there is no platform
that would 100% reliable do the file locking (<CODE>lockd</CODE> daemon
usually) in every situation. Yet there would be one more possible risk
with <CODE>NFS</CODE>; it would make the work even more complicated for
<CODE>lockd</CODE> daemon to handle. So make it easy for your self and forget
about the idea. The working solution is to have one computer with an
operating system that efficiently handles threads and have several CPUs
in it.

</P>
<P>
もし違うポートで走っている <STRONG>MySQL</STRONG> サーバーに、
これまた違うポートを使用するように作られたクライアントから接続したい場合、
以下のようにします：

</P>

<UL>
<LI>

クライアントを TCP/IP での接続 <CODE>--host 'hostname' --port=port_numer</CODE> か
UNIX ソケット経由での接続 <CODE>[--host localhost] --socket=file_name</CODE>
オプションで起動します。

<LI>

C あるいは Perl プログラムの場合、ポートとソケットを与えることができます：

<LI>

If your are using the Perl <CODE>DBD::mysql</CODE> module you can read the options
from the MySQL option files.   「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.


<PRE>
$dsn = "DBI:mysql:test;mysql_read_default_group=client;mysql_read_default_file=/usr/local/mysql/data/my.cnf"
$dbh = DBI-&#62;connect($dsn, $user, $password);
</PRE>

<LI>

<A NAME="IDX436"></A>
<A NAME="IDX437"></A>
<A NAME="IDX438"></A>
<A NAME="IDX439"></A>
<CODE>MYSQL_UNIX_PORT</CODE> と <CODE>MYSQL_TCP_PORT</CODE> 環境変数に UNIX ソケットファイルと
 TCP/IP のポート番号とセットし、クライアントを立ちあげます。
もし、このポート番号やソケットファイルを常に使用するのであれば、
 <TT>`.login'</TT> ファイルかなにかに環境変数をセットするように書いておけばよいでしょう。
 「<A HREF="manual.ja_Environment_variables.html#Environment_variables">H  Environment Variables</A>」節参照.

<LI>

<A NAME="IDX440"></A>
あなたのホームディレクトリの <TT>`.my.cnf'</TT> ファイルに、
通常使用するポート番号とソケットファイルを書くこともできます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.
</UL>



<H2><A NAME="Privilege_system" HREF="manual.ja_toc.html#Privilege_system">4.2  General Security Issues and the MySQL Access Privilege System</A></H2>

<P>
<A NAME="IDX441"></A>
<A NAME="IDX442"></A>
<A NAME="IDX443"></A>
<A NAME="IDX444"></A>
<A NAME="IDX445"></A>

</P>
<P>
MySQL has an advanced but non-standard security/privilege
system.  This section describes how it works.

</P>



<H3><A NAME="General_security" HREF="manual.ja_toc.html#General_security">4.2.1  General Security Guidelines</A></H3>

<P>
よくあるセキュリティの間違いを避けるために、インターネットに接続されたコン
ピュータ上で <STRONG>MySQL</STRONG> を使用する誰もが、このセクションを読むべきです。

</P>
<P>
``セキュリティ'' の議論において、我々は、すべての該当するアタックタイプ
(eavesdropping, altering, playback, Denial of Service) に対して、すべてのサー
バホスト(<STRONG>MySQL</STRONG> サーバだけではなく)の完全な保護の必要性を強調しま
す。We do not cover all aspects of availability and fault tolerance
here.

</P>
<P>
<STRONG>MySQL</STRONG> は、ユーザが実行しようとするすべての接続、クエリ、その他の
オペレーションに対して、アクセス制御リスト(ACLs: Access Control Lists)セキュ
リティを使用します。<STRONG>MySQL</STRONG> クライアントとサーバの間で SSL 暗号化接
続のサポートもいくつかあります。ここで議論されるコンセプトの多くは、
<STRONG>MySQL</STRONG> に特有のものではありません; 同じ一般的なアイデアはほとんど
すべてのアプリケーションに適用します。

</P>
<P>
<STRONG>MySQL</STRONG> 実行時、可能な限りいつでもこれらのガイドラインに従ってくだ
さい:

</P>

<UL>
<LI>

(<STRONG>MySQL</STRONG> ROOT ユーザ以外の)誰にも <CODE>mysql</CODE> データベース内の 
<CODE>user</CODE> テーブルへのアクセスを与えないでください！ 暗号化されたパスワー
ドは <STRONG>MySQL</STRONG> の本当のパスワードです。もしあなたが与えられたユーザに
ついて <CODE>user</CODE> テーブルにリストされたパスワードを知ることができれば、
そのアカウントについてリストされたホストへアクセスすれば、あなたは簡単にそ
のユーザとしてログインできます。

<LI>

<STRONG>MySQL</STRONG> ACL システムの理解に努めるべきです。
<CODE>GRANT</CODE> と <CODE>REVOKE</CODE> コマンドは <STRONG>MySQL</STRONG> へのアクセスを制限するための物です。
必要以上の権限を誰にも与えないでください。
全てのホストに対して、何か出来るような許可を与えてはいけません。

Checklist:

<UL>
<LI>

<CODE>mysql -u root</CODE> を行ってみます。

パスワードを尋ねられること無しにサーバへの接続ができる場合、問題があります。
どのユーザでも(root でなくても)、<STRONG>MySQL</STRONG> サーバに完全な権限で接続で
きます！ <CODE>root</CODE> パスワードの設定についての項目に特別な注意を払って
<STRONG>MySQL</STRONG> インストール説明を見直してください。

<LI>

<CODE>SHOW GRANTS</CODE> を使用し、だれがなんのアクセスを持つかチェックします。
必要ない権限を、<CODE>REVOKE</CODE> コマンドを使用して削除してください。
</UL>

<LI>

いかなる平文パスワードもデータベースに保存しないようにします。
あなたのコンピュータが妥協される時、新入者はパスワードの完全なリストを得て、
それらを使用できます。代わりに <CODE>MD5()</CODE> や他の one-way hashing 関数を
使用してください。

<LI>

辞書からパスワードを選んではいけません。 それらを破る
プログラムがあるのです。 ``xfish98'' のようなパスワードは悪い例です。
これよりは ``duag98'' の方がよいでしょう。 これは "fish" を打つ際に、
キーを一つずつずらしたものです。 他の方法としては、 "Mhall" 、これは
"Mary had a little lamb" という文の頭文字を羅列したものです。
これを知っている物には打ちやすいパスワードですが、知らない者にとっては、
類推することが難しいパスワードです。

<LI>

ファイアーウォールを導入します。This protects you from at least 50% of
all types of exploits in any software. <STRONG>MySQL</STRONG> をファイアーウォール
で守られた方に置くか、DMZ (緩衝地帯, 非武装地帯) に置きます。

Checklist:

<UL>
<LI>

インターネットから <CODE>nmap</CODE> のようなツールを使用して、
あなたのマシンのポートをスキャンしてみます。
<STRONG>MySQL</STRONG> はデフォルトで 3306 番を使用しています。
このポートには信用できないホストからはアクセスできないようにすべきです。
<STRONG>MySQL</STRONG> ポートがオープンしているかどうかをチェックする他の簡単な方
法は、次のコマンドをいくつかのリモートマシンから試すことです。ここで 
<CODE>server_host</CODE> はあなたの <STRONG>MySQL</STRONG> サーバのホスト名です:


<PRE>
shell&#62; telnet server_host 3306
</PRE>

接続し、いくつかのゴミ文字が得られた場合、ポートはオープンして
います。それをオープンしておく正当な理由が本当にない限り、ファイアーウォー
ルやルータでクローズすべきです。<CODE>telnet</CODE> がハングしたり拒否されたり
する場合、すべて OK です。ポートはブロックされています。
</UL>

<LI>

ユーザーから入力されたデータは信頼しないで下さい。
ユーザーは、Webのフォーム、URL、あるいはあなたのカスタムプログラムから
特定の文字を入れることが可能です。 もしユーザーがフォームに
<CODE>; DROP ALL DATABASES ;</CODE> のような文字を入力しても、
あなたのアプリケーションは安全ですか？
これは極端な例ですが、それらに対して準備しない場合、似たようなテクニックを
使用するハッカーの結果として、大きなセキュリティリークとデータ喪失が発生し
得ます。

数値データのチェックも忘れないでください。よくある間違いは文字列しか保護し
ないことです。時々、人はデータベースが保護される必要のない公に有効なデータ
だけを含んでいるかどうかを考えます。これは間違いです。少なくとも、
denial-of-service タイプのアタックはそのようなデータベースでも実行されます。
このタイプのアタックから保護するもっとも簡単な方法は、数値定数の回りにアポ
ストロフィを使用することです: <CODE>SELECT * FROM table WHERE ID=234</CODE> の代
わりに <CODE>SELECT * FROM table WHERE ID='234'</CODE>。<STRONG>MySQL</STRONG> は自動的
にこの文字列を数値に変換し、そこからすべての非数値シンボルを取り除きます。

Checklist:

<UL>
<LI>

すべての Web アプリケーション:

<UL>
<LI>

あなたの WWW の全てのフォームに、<SAMP>`''</SAMP> と <SAMP>`"'</SAMP> を入力することを試みてください。
もしなんらかの <STRONG>MySQL</STRONG> エラーがでたら、あなたのサイトを停止したほうが
よいでしょう。
<LI>

あなたの URL に <CODE>%22</CODE> (<SAMP>`"'</SAMP>), <CODE>%23</CODE> (<SAMP>`#'</SAMP>) , <CODE>%27</CODE> (<SAMP>`''</SAMP>) をつけてみて、動的URLを
いろいろ変更して試してみてください。
<LI>

動的 URL のデータタイプを数値から上述の例の文字を含む文字列に修正してみて
ください。アプリケーションはこれと似たようなアタックに対して安全であるべき
です。
<LI>

数値フィールドに対して、文字、スペース、特殊文字の入力を試みてください。
アプリケーションは、それらを <STRONG>MySQL</STRONG> に送る前に取り除くか、
あるいはエラーを出すべきです。 検査しない値を <STRONG>MySQL</STRONG> に送ることは危険です。
<LI>

<STRONG>MySQL</STRONG> にデータを送る前に、そのサイズをチェックします。
<LI>

あなたのアプリケーションが、管理目的であなたが使用するのと異なるユーザ名を
使用してデータベースに接続することを考慮してください。必要以上のアクセス権
をアプリケーションに与えないで下さい。
</UL>

<LI>

Users of PHP:

<UL>
<LI>Check out the <CODE>addslashes()</CODE> function.

As of PHP 4.0.3, a <CODE>mysql_escape_string()</CODE> function is available
that is based on the function of the same name in the MySQL C API.
</UL>

<LI>

Users of MySQL C API:

<UL>
<LI>Check out the <CODE>mysql_escape_string()</CODE> API call.

</UL>

<LI>

Users of MySQL++:

<UL>
<LI>Check out the <CODE>escape</CODE> and <CODE>quote</CODE> modifiers for query streams.

</UL>

<LI>

Users of Perl DBI:

<UL>
<LI>Check out the <CODE>quote()</CODE> method or use placeholders.

</UL>

<LI>

Users of Java JDBC:

<UL>
<LI>Use a <CODE>PreparedStatement</CODE> object and placeholders.

</UL>

</UL>

<LI>

生のデータ(暗号化されていないデータ)をインターネット越しに送ってはいけませ
ん。このデータは、その情報をトラップして、どこかで再利用することに興味のあ
る誰にでもアクセス可能です。もし送る必要があるなら、SSL のような暗号化され
た通信を使用すべきです。<STRONG>MySQL</STRONG> はバージョン 3.23.9 から内部 SSL 接
続をサポートします。暗号化された(そして圧縮された)通信のトンネルを生成する
ために、SSH ポートフォワーディングを使用することができます。
<LI>

"tcpdump", "strings" ユーティリティを使うことを学んで下さい.
以下のコマンドで、ほとんどの場合、暗号化されていない
<STRONG>MySQL</STRONG> のデータが見えるでしょう：

<PRE>
shell&#62; tcpdump -l -i eth0 -w - src or dst port 3306 | strings
</PRE>

(この例は Linux のものです。他のシステムでは少し違うでしょう).
警告: データが見えなくても、実際に常に暗号化されているわけではありません。
高いセキュリティが必要なら、セキュリティエキスパートに相談すべきです。
</UL>



<H3><A NAME="Security" HREF="manual.ja_toc.html#Security">4.2.2  MySQL をクラッカーに対して安全にする方法</A></H3>

<P>
<A NAME="IDX446"></A>
<A NAME="IDX447"></A>

</P>
<P>
<STRONG>MySQL</STRONG> サーバーに接続するときは、パスワードを使用すべきです。
パスワードはコネクション間で、べたテキストでは流れません。
しかし、暗号化アルゴリズムはそんなに強力なわけではありません。クライアント
とサーバ間のトラフィックを sniff できれば、いくつかの試みで、賢いアタッカー
はパスワードをクラックできます。クライアントとサーバ間の接続が信頼できない
ネットワークを通るなら、通信を暗号化するために SSH トンネルを使用
すべきです。

</P>
<P>
その他の全ての情報はテキストで転送され、
これは接続を覗くことが出来る人に読まれます。
もしこれを心配するなら、圧縮プロトコル(<STRONG>MySQL</STRONG> バージョン 3.22 以上)を
使用することが出来ます。より安全にしたい場合、
<CODE>ssh</CODE> をインストールすべきです。
オープンソースの <CODE>ssh</CODE> クライアントは <a HREF="http://www.openssh.org">http://www.openssh.org</a> に、
商用の <CODE>ssh</CODE> クライアントは <a HREF="http://www.ssh.com">http://www.ssh.com</a> に見ることができます。
これを使用すれば、<STRONG>MySQL</STRONG> サーバーと <STRONG>MySQL</STRONG> クライアント
間の TCP/IP コネクションは全て暗号化されます。
 
<STRONG>MySQL</STRONG> システムを安全にするためには、次のことを考えるべきです:

</P>

<UL>
<LI>

全ての <STRONG>MySQL</STRONG> ユーザにパスワードを使用すべきです。
<CODE>other_user</CODE> にパスワードが設定されていない場合、
誰でも <CODE>mysql -u other_user db_name</CODE> として簡単に他の人としてログインでき
ることを覚えてください。これは全てのクライアント／サーバアプリケーション
で一般的な振る舞いです。全てのユーザのパスワードは、
<CODE>mysql_install_db</CODE> スクリプトを実行前に編集することで、または 
<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザだけは次のようにして変更することができます。


<PRE>
shell&#62; mysql -u root mysql
mysql&#62; UPDATE user SET Password=PASSWORD('new_password')
           WHERE user='root';
</PRE>

<LI>

<STRONG>MySQL</STRONG> デーモンを UNIX の <CODE>root</CODE> ユーザーで実行しないでください。
<CODE>FILE</CODE>権限を持つ任意のユーザが <CODE>root</CODE> としてファイル(例えば、
<CODE>~root/.bashrc</CODE>)を生成できるためとても危険です。これを防ぐために、
<CODE>mysqld</CODE> は、<CODE>--user=root</CODE> オプションで直接指定されない限り、 
<CODE>root</CODE> としての実行を拒否します。

代わりに <CODE>mysqld</CODE> は権限を持たない一般ユーザとして実行できます。
より安全にするため、新しく UNIX ユーザ <CODE>mysql</CODE> を追加することもできます。
<CODE>mysqld</CODE> を 他の Unix ユーザーで起動したとしても、
<STRONG>MySQL</STRONG> の <CODE>user</CODE> テーブルの <CODE>root</CODE> ユーザーの名前を変更する必要はありません。
なぜなら、 <STRONG>MySQL</STRONG> ユーザーの名前は Unix のユーザー名とはなんの関係もないからです。
root ユーザ名を変更する必要はありません。
<CODE>mysqld</CODE> を他の UNIX ユーザで起動するためには、<TT>`/etc/my.cnf'</TT> オ
プションファイルまたはサーバのデータディレクトリの <TT>`my.cnf'</TT> オプショ
ンファイルの、<CODE>[mysqld]</CODE> グループにユーザ名を記述した <CODE>user</CODE> 行
を追加してください。たとえば:


<PRE>
[mysqld]
user=mysql
</PRE>

これは、あなたが手動で起動したり <CODE>safe_mysqld</CODE> または 
<CODE>mysql.server</CODE> を使用して起動しても、指定されたユーザでサーバを起動さ
せます。詳細は、 「<A HREF="manual.ja_Problems.html#Changing_MySQL_user">A.3.2  一般ユーザで MySQL を動かす方法</A>」節 を見てください。

<LI>

Don't support symlinks to tables (This can be disabled with the
<CODE>--skip-symlink</CODE> option. This is especially important if you run
<CODE>mysqld</CODE> as root as anyone that has write access to the mysqld data
directories could then delete any file in the system!
 「<A HREF="manual.ja_MySQL_Optimization.html#Symbolic_links_to_tables">5.6.1.2  Using Symbolic Links for Tables</A>」節参照.

<LI>

データベースディレクトリは <CODE>mysqld</CODE> を実行している UNIX ユーザだけが
読み込み／書き込み可能なことをチェックしてください。

<LI>

<STRONG>process</STRONG> 権限を全てのユーザに与えないでください。この許可がある人は誰でも
<CODE>mysqladmin processlist</CODE> コマンドで実行されているクエリーの中身を見ることができます。
もし誰かが、<CODE>UPDATE user SET password=PASSWORD('not_secure')</CODE> クエリーを
実行していたとして、それが見えてしまいます。

<CODE>mysqld</CODE> は <STRONG>process</STRONG> 権限を持つユーザに対する特別な接続をリザーブします。
そのため、たとえ全ての通常接続が使われたとしても、<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザだけは、
ログインでき、いろいろチェックできます。

<LI>

<STRONG>file</STRONG> を全てのユーザに与えないでください。ユーザがこの権限を持つ場
合、<CODE>mysqld</CODE> デーモンを実行している Unix ユーザーの権限で
ファイルシステム内のどこにでもファイルを書き込むことができます！
これを少し安全にするために、<CODE>SELECT ... INTO OUTFILE</CODE> で作成される全てのファイルは
全員に読み込み可能で生成され、既存のファイルには上書きできません。

<A NAME="IDX448"></A>
<STRONG>file</STRONG> 権限はサーバーを走らせている UNIX ユーザーがアクセスできる
全てのファイルを読むために使用されかもしれません。
例えば、 <TT>`/etc/passwd'</TT> をテーブルに取り込むために <CODE>LOAD DATA</CODE> が
使用されると、 <CODE>SELECT</CODE> でその内容が読めることになります。

<LI>

あなたの DNS を信用しない場合、権限テーブル内にはホスト名の代わりに IP 
を使用すべきです。<CODE>mysqld</CODE> への <CODE>--secure</CODE> オプションは原理上はホスト名を安
全にします。どんな場合でも、ワイルドカードを含んだホスト名を、許可テーブルに登録する
事は本当に注意深くすべきです！

<LI>

一ユーザからの接続数を制限したい場合は、<CODE>mysqld</CODE> の 
<CODE>max_user_connections</CODE> 変数を設定することで、これを行なうことができま
す。
</UL>



<H3><A NAME="Privileges_options" HREF="manual.ja_toc.html#Privileges_options">4.2.3  セキュリティに関する <CODE>mysqld</CODE> の起動オプション</A></H3>

<P>
<CODE>mysqld</CODE> の次のオプションはセキュリティに影響します:

</P>
<DL COMPACT>

<DT><CODE>--safe-show-database</CODE>
<DD>
With this option,
<CODE>SHOW DATABASES</CODE> returns only those databases for which the user has
some kind of privilege.

<DT><CODE>--safe-user-create</CODE>
<DD>
If this is enabled, an user can't create new users with the <CODE>GRANT</CODE>
command, if the user doesn't have <CODE>INSERT</CODE> privilege to the
<CODE>mysql.user</CODE> table.  If you want to give a user access to just create
new users with those privileges that the user has right to grant, you should
give the user the following privilege:


<PRE>
GRANT INSERT(user) on mysql.user to 'user''hostname';
</PRE>

This will ensure that the user can't change any privilege columns directly,
but has to use the <CODE>GRANT</CODE> command to give privileges to other users.

<DT><CODE>--skip-grant-tables</CODE>
<DD>
特権システムを全く使用しません。これは全員に全てのデータベースへの 
<EM>完全なアクセス</EM> を与えます！
(<CODE>mysqladmin flush-privileges</CODE> か <CODE>mysqladmin reload</CODE> を実行することで、
起動しているサーバーは特権システムを使用するようになります。)

<DT><CODE>--skip-name-resolve</CODE>
<DD>
ホスト名を解析しません。権限テーブル中の全ての <CODE>Host</CODE>フィールドは IP アドレスか
<CODE>localhost</CODE> でなければなりません。

<DT><CODE>--skip-networking</CODE>
<DD>
ネットワーク (TCP/IP) 経由の接続を許可しません。<CODE>mysqld</CODE> への全ての接続は、
UNIX ソケットで行われます。MIT-pthreads は UNIX ソケットをサポートしない
ため、このオプションは MIT-pthreads を使用するシステム上では、うまく動きません。

<DT><CODE>--skip-show-database</CODE>
<DD>
このオプションを指定すると、<CODE>SHOW DATABASE</CODE> コマンドは何も返しません。

</DL>



<H3><A NAME="What_Privileges" HREF="manual.ja_toc.html#What_Privileges">4.2.4  特権システムの行うこと</A></H3>

<P>
<A NAME="IDX449"></A>
<A NAME="IDX450"></A>
<A NAME="IDX451"></A>

</P>
<P>
<STRONG>MySQL</STRONG> 特権システムの基本機能は、与えられたホストから接続する
ユーザを認証すること、そしてデータベースに対する
 <STRONG>select</STRONG>, <STRONG>insert</STRONG>, <STRONG>update</STRONG>, <STRONG>delete</STRONG> 等の権限を与えることです。

</P>
<P>
拡張機能は匿名ユーザをもつ能力を含み、<CODE>LOAD DATA INFILE</CODE> のような 
<STRONG>MySQL</STRONG> 固有の機能を使用する許可を与えます。

</P>



<H3><A NAME="Privileges" HREF="manual.ja_toc.html#Privileges">4.2.5  特権システムはどのように動くか？</A></H3>

<P>
<A NAME="IDX452"></A>

</P>
<P>
<STRONG>MySQL</STRONG> の特権システムは、全てのユーザーが与えられた許可の範囲内で動く事を保証します。
<STRONG>MySQL</STRONG> サーバーに接続するとき、本人の身元は、<STRONG>接続元のホスト</STRONG> と
 <STRONG>接続に使用するユーザー名</STRONG> によって確認されます。
このシステムは、あなたの身元と<STRONG>あなたが要求することが何か</STRONG> によって、権限を与えます。

</P>
<P>
<STRONG>MySQL</STRONG> はあなたのホスト名とユーザー名の両方をあわせてチェックします。
これはインターネット上に同じ名前のユーザーがどこかにいるかもしれないということからそうしています。
例えば、<CODE>whitehouse.gov</CODE> から接続してきた <CODE>bill</CODE> と、
 <CODE>microsoft.com</CODE> から接続してきた <CODE>bill</CODE> は同一人物である必要はありません。
<STRONG>MySQL</STRONG> はこの違うホストから接続してきた同名のユーザーを以下のようにして扱います：
 <CODE>whitehouse.gov</CODE> から接続した <CODE>bill</CODE> にある許可をあたえ、
それとは違う許可を <CODE>microsoft.com</CODE> から接続してきた <CODE>bill</CODE> に与えます。

</P>
<P>
<STRONG>MySQL</STRONG> のアクセスコントロールは以下の二つからなります：

</P>

<UL>
<LI>

Stage 1: サーバーは接続許可があるかどうかをチェックします。

<LI>

Stage 2: 接続許可後、サーバーはそれぞれのリクエストをチェックします。
あなたが要求してきた事柄を、あなたが実行できるかどうかをチェックします。
例えば、あるデータベースのテーブルの行の取り出しやテーブルの破棄をあなたが命令した場合、
サーバーは、あなたにそのテーブルに対する <STRONG>select</STRONG> 許可があるのか、
データベースに対して <STRONG>drop</STRONG> する許可が与えられているのか、を確認します。
</UL>

<P>
サーバーは <CODE>mysql</CODE> データベースの <CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE> ３つのテーブルから、
この２つのアクセス制限を決定します。
このテーブルのフィールドは以下のようになっています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table name</STRONG> </TD><TD> <CODE>user</CODE> </TD><TD> <CODE>db</CODE> </TD><TD> <CODE>host</CODE>

</TR NOSAVE>
<TR><TD><STRONG>Scope fields</STRONG> </TD><TD> <CODE>Host</CODE> </TD><TD> <CODE>Host</CODE> </TD><TD> <CODE>Host</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>User</CODE> </TD><TD> <CODE>Db</CODE> </TD><TD> <CODE>Db</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Password</CODE> </TD><TD> <CODE>User</CODE> </TD><TD>

</TR NOSAVE>
<TR><TD><STRONG>Privilege fields</STRONG> </TD><TD> <CODE>Select_priv</CODE> </TD><TD> <CODE>Select_priv</CODE> </TD><TD> <CODE>Select_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Insert_priv</CODE> </TD><TD> <CODE>Insert_priv</CODE> </TD><TD> <CODE>Insert_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Update_priv</CODE> </TD><TD> <CODE>Update_priv</CODE> </TD><TD> <CODE>Update_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Delete_priv</CODE> </TD><TD> <CODE>Delete_priv</CODE> </TD><TD> <CODE>Delete_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Index_priv</CODE> </TD><TD> <CODE>Index_priv</CODE> </TD><TD> <CODE>Index_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Alter_priv</CODE> </TD><TD> <CODE>Alter_priv</CODE> </TD><TD> <CODE>Alter_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Create_priv</CODE> </TD><TD> <CODE>Create_priv</CODE> </TD><TD> <CODE>Create_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Drop_priv</CODE> </TD><TD> <CODE>Drop_priv</CODE> </TD><TD> <CODE>Drop_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Grant_priv</CODE> </TD><TD> <CODE>Grant_priv</CODE> </TD><TD> <CODE>Grant_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>References_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Reload_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Shutdown_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Process_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>File_priv</CODE> </TD><TD> </TD><TD> 
</TR>
</TABLE>

<P>
　アクセスコントロールの第2段階(要求承認)のために、サーバーはこれら 3 つの
テーブルによって決められた許可を基本としますが、もしテーブルに対する要求で
あるならば、<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルを
さらに調べます。これらのテーブルのフィールドは以下のようになっています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table name</STRONG> </TD><TD> <CODE>tables_priv</CODE> </TD><TD> <CODE>columns_priv</CODE>

</TR NOSAVE>
<TR><TD><STRONG>Scope fields</STRONG> </TD><TD> <CODE>Host</CODE> </TD><TD> <CODE>Host</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Db</CODE> </TD><TD> <CODE>Db</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>User</CODE> </TD><TD> <CODE>User</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Table_name</CODE> </TD><TD> <CODE>Table_name</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> </TD><TD> <CODE>Column_name</CODE>

</TR NOSAVE>
<TR><TD><STRONG>Privilege fields</STRONG> </TD><TD> <CODE>Table_priv</CODE> </TD><TD> <CODE>Column_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Column_priv</CODE> </TD><TD>

</TR NOSAVE>
<TR><TD><STRONG>Other fields</STRONG> </TD><TD> <CODE>Timestamp</CODE> </TD><TD> <CODE>Timestamp</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Grantor</CODE> </TD><TD>
</TR>
</TABLE>

<P>
　テーブルの各フィールドを分類すると、２種類にわかれます：
適用範囲を指定するフィールド(以下　スコープフィールド)と許可を定義するフィールド(以下　権限フィールド)です。

</P>
<P>
　スコープフィールドは、権限テーブルの登録ごとに、その適用範囲を決めます。
例えば、 <CODE>user</CODE> テーブルの <CODE>Host</CODE> と <CODE>User</CODE> に
 <CODE>'thomas.loc.gov'</CODE> と <CODE>'bob'</CODE> が登録されている場合、
サーバーへの接続は ホスト <CODE>thomas.loc.gov</CODE> から来た <CODE>'bob'</CODE> に許可されます。
同様に、<CODE>db</CODE> テーブルの  <CODE>Host</CODE>, <CODE>User</CODE>, <CODE>Db</CODE> に
 <CODE>'thomas.loc.gov'</CODE>, <CODE>'bob'</CODE>, <CODE>'reports'</CODE> が登録されていると、
ホスト <CODE>thomas.loc.gov</CODE> から来た <CODE>bob</CODE> に対し <CODE>reports</CODE>
データベースへの接続が許されます。
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは、
テーブルか、テーブルとフィールドを対にしたスコープフィールドを含みます。

</P>
<P>
<A NAME="IDX453"></A>
　アクセスのチェックは、<CODE>Host</CODE> の値はケース非依存で比較されます。
<CODE>User</CODE>, <CODE>Password</CODE>, <CODE>Db</CODE>, <CODE>Table_name</CODE> の値はケース依存で比較されます。
<CODE>Column_name</CODE> の値は <STRONG>MySQL</STRONG> バージョン 3.22.12 以上ではケース非依存で比較されます。
(バージョン 3.22.11 までは ケース依存です)

</P>
<P>
権限フィールドは、テーブルに登録されることにより有効になった許可をしめし、
これはどの操作が実行できるかを示します。
サーバーは許可テーブルの情報をユーザーの権限を得るためにまとめます。
このユーザーの権限許可を割り出す方法は  「<A HREF="manual.ja_MySQL_Database_Administration.html#Request_access">4.2.9  Access Control, Stage 2: Request Verification</A>」節 に述べておきます。

</P>
<P>
スコープフィールドは文字で定義され、デフォルト値は空文字になっています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Field name</STRONG> </TD><TD> <STRONG>Type</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Host</CODE> </TD><TD> <CODE>CHAR(60)</CODE>
</TR NOSAVE>
<TR><TD><CODE>User</CODE> </TD><TD> <CODE>CHAR(16)</CODE>
</TR NOSAVE>
<TR><TD><CODE>Password</CODE> </TD><TD> <CODE>CHAR(16)</CODE>
</TR NOSAVE>
<TR><TD><CODE>Db</CODE> </TD><TD> <CODE>CHAR(64)</CODE> </TD><TD> (<CODE>CHAR(60)</CODE> for the
<CODE>tables_priv</CODE> and <CODE>columns_priv</CODE> tables)
</TR NOSAVE>
<TR><TD><CODE>Table_name</CODE> </TD><TD> <CODE>CHAR(60)</CODE>
</TR NOSAVE>
<TR><TD><CODE>Column_name</CODE> </TD><TD> <CODE>CHAR(60)</CODE>
</TR>
</TABLE>

<P>
<CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE> テーブルでは、
全ての権限フィールドは <CODE>ENUM('N','Y')</CODE> で定義されます。
この値は <CODE>'N'</CODE> か <CODE>'Y'</CODE> のどちらかで、デフォルト値は <CODE>'N'</CODE> です。

</P>
<P>
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルでは、
権限フィールドは <CODE>SET</CODE> フィールドとして定義されます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table name</STRONG> </TD><TD> <STRONG>Field name</STRONG> </TD><TD> <STRONG>Possible set elements</STRONG>
</TR NOSAVE>
<TR><TD><CODE>tables_priv</CODE> </TD><TD> <CODE>Table_priv</CODE> </TD><TD> <CODE>'Select', 'Insert',
'Update', 'Delete', 'Create', 'Drop', 'Grant', 'References', 'Index', 'Alter'</CODE>
</TR NOSAVE>
<TR><TD><CODE>tables_priv</CODE> </TD><TD> <CODE>Column_priv</CODE> </TD><TD> <CODE>'Select', 'Insert',
'Update', 'References'</CODE>
</TR NOSAVE>
<TR><TD><CODE>columns_priv</CODE> </TD><TD> <CODE>Column_priv</CODE> </TD><TD> <CODE>'Select', 'Insert',
'Update', 'References'</CODE>
</TR>
</TABLE>

<P>
サーバーは以下のように権限テーブルを使用します：

</P>

<UL>
<LI>

<CODE>user</CODE> テーブルのスコープフィールドは、接続要求を受け入れるか拒否するかを決定します。
許可された接続について、<CODE>user</CODE> テーブルで与えられたすべての権限は、ユー
ザのグローバル(スーパーユーザ)権限を示します。この権限はサーバ上の 
<STRONG>すべての</STRONG> データベースに適用されます。
(訳注：
例えば、<CODE>user</CODE> テーブル の権限を <CODE>'Y'</CODE> にした場合、
どんなに <CODE>db</CODE> テーブルや <CODE>host</CODE> テーブルで権限を <CODE>'N'</CODE> にしたとしても
権限は <CODE>'Y'</CODE> のままである。
ようは <CODE>user</CODE> テーブルの権限許可 <CODE>'Y'</CODE> が全てに反映されてしまうという事。
<CODE>user</CODE> テーブルには最低限の許可を与えるようにし、
<CODE>db</CODE> テーブルや <CODE>host</CODE> テーブルで、それぞれの権限許可を定義する方が無難。
)

<LI>

<CODE>db</CODE> と <CODE>host</CODE> テーブルは一緒に使用されます：


<UL>
<LI>

<CODE>db</CODE> テーブルのスコープフィールドはどのホストからどのデータベースのアクセスできるかを決定します。
権限フィールドは、どういった操作ができるか定義します。

<LI>

<CODE>host</CODE> テーブルは、<CODE>db</CODE> テーブルの登録をいくつかのホストに与えたい時に、
<CODE>db</CODE> テーブルの拡張として使用されます。
例えば、ネットワーク上の限定したマシンからデータベースを使用したい場合、
<CODE>db</CODE> テーブルの <CODE>Host</CODE> の値は空にしておきます。
そして <CODE>host</CODE> テーブルにそれぞれのホストについての登録を行います。
この機構は、  「<A HREF="manual.ja_MySQL_Database_Administration.html#Request_access">4.2.9  Access Control, Stage 2: Request Verification</A>」節 で詳細に述べられています。
</UL>

<LI>

<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは <CODE>db</CODE> テーブルに似ていますが、
それらはより細かく定義できます；
データベースレベルではなく、テーブルとフィールドのレベルで与えます。
</UL>

<P>
管理者権限 (<STRONG>reload</STRONG>, <STRONG>shutdown</STRONG>,など) は <CODE>user</CODE> テーブルにだけ定義するように。
これは、管理者操作はデータベースではなくサーバーへの操作であり、
他の許可テーブルにある必要がないからです。
またこうしておくと、管理者操作の許可は、<CODE>user</CODE> テーブルの定義だけを
見ればわかるようになります。

</P>
<P>
<STRONG>file</STRONG> 操作の権限は <CODE>user</CODE> テーブルにだけ定義するように。
これは管理者操作ではありませんが、アクセスしているデータベースにかかわらず、
サーバー内のファイルを読み書きできるのです。

</P>
<P>
<CODE>mysqld</CODE> サーバーは起動時にこれらのテーブルを読み込みます。
許可テーブルの変更を反映させる方法はこちらを参照のこと →  「<A HREF="manual.ja_MySQL_Database_Administration.html#Privilege_changes">4.3.3  いつ権限の変更が反映されるか</A>」節

</P>
<P>
これらのテーブルの登録を変更した場合、思ったとおりの権限状態になっている事を確認することはいいことです。
問題の解決には,  「<A HREF="manual.ja_MySQL_Database_Administration.html#Access_denied">4.2.10  何故 <CODE>Access denied</CODE> エラーになるのか</A>」節.  セキュリティに関するアドバイスは
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Security">4.2.2  MySQL をクラッカーに対して安全にする方法</A>」節.

</P>
<P>
便利なツールとして <CODE>mysqlaccess</CODE> スクリプト( Yves Carlier 作)が <STRONG>MySQL</STRONG> の配布に含まれています。
<CODE>mysqlaccess</CODE> を  <CODE>--help</CODE> オプションで起動するとヘルプが表示されます。
<CODE>mysqlaccess</CODE> は <CODE>user</CODE>,<CODE>db</CODE> and <CODE>host</CODE> テーブルだけしか
検査しません。テーブルレベルの権限、フィールドレベルの権限は調べません。

</P>



<H3><A NAME="Privileges_provided" HREF="manual.ja_toc.html#Privileges_provided">4.2.6  MySQL が提供する権限</A></H3>

<P>
<A NAME="IDX454"></A>

</P>
<P>
権限の設定は <CODE>mysql</CODE> データベースの <CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE>,
 <CODE>tables_priv</CODE>, <CODE>columns_priv</CODE> で行います。
(<CODE>mysql</CODE> はデータベースの名前です)
<STRONG>MySQL</STRONG> サーバーは、サーバーの起動時か
  「<A HREF="manual.ja_MySQL_Database_Administration.html#Privilege_changes">4.3.3  いつ権限の変更が反映されるか</A>」節 で説明されている方法により、
これらのテーブルから権限の設定を読み込みます。

</P>
<P>
<STRONG>MySQL</STRONG> が提供する権限の名称は,
本マニュアルでは以下の表の名称を用います。
この表の項目名がそれぞれの許可される権限とその説明に対応しています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Privilege</STRONG> </TD><TD> <STRONG>Column</STRONG> </TD><TD> <STRONG>Context</STRONG>
</TR NOSAVE>
<TR><TD><STRONG>select</STRONG> </TD><TD> <CODE>Select_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>insert</STRONG> </TD><TD> <CODE>Insert_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>update</STRONG> </TD><TD> <CODE>Update_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>delete</STRONG> </TD><TD> <CODE>Delete_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>index</STRONG> </TD><TD> <CODE>Index_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>alter</STRONG> </TD><TD> <CODE>Alter_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>create</STRONG> </TD><TD> <CODE>Create_priv</CODE> </TD><TD> databases, tables, or indexes
</TR NOSAVE>
<TR><TD><STRONG>drop</STRONG> </TD><TD> <CODE>Drop_priv</CODE> </TD><TD> databases or tables
</TR NOSAVE>
<TR><TD><STRONG>grant</STRONG> </TD><TD> <CODE>Grant_priv</CODE> </TD><TD> databases or tables
</TR NOSAVE>
<TR><TD><STRONG>references</STRONG> </TD><TD> <CODE>References_priv</CODE> </TD><TD> databases or tables
</TR NOSAVE>
<TR><TD><STRONG>reload</STRONG> </TD><TD> <CODE>Reload_priv</CODE> </TD><TD> server administration
</TR NOSAVE>
<TR><TD><STRONG>shutdown</STRONG> </TD><TD> <CODE>Shutdown_priv</CODE> </TD><TD> server administration
</TR NOSAVE>
<TR><TD><STRONG>process</STRONG> </TD><TD> <CODE>Process_priv</CODE> </TD><TD> server administration
</TR NOSAVE>
<TR><TD><STRONG>file</STRONG> </TD><TD> <CODE>File_priv</CODE> </TD><TD> file access on server
</TR>
</TABLE>

<P>
<STRONG>select</STRONG>, <STRONG>insert</STRONG>, <STRONG>update</STRONG>, <STRONG>delete</STRONG> の権限は、
存在しているデータベースのテーブルに対して許可されます。

</P>
<P>
もしテーブルから行を取り出すだけなら、<CODE>SELECT</CODE> 構文を実行するためには
 <STRONG>select</STRONG> 権限だけあればかまいません。
だけでなく、サーバーのどのデータベースにアクセスを許可されていない場合でも、
ある種の <CODE>SELECT</CODE> は実行することができます。
例えば、簡単な計算を <CODE>mysql</CODE> クライアントで行う場合です：

</P>

<PRE>
mysql&#62; SELECT 1+1;
mysql&#62; SELECT PI()*2;
</PRE>

<P>
<STRONG>index</STRONG> 権限はインデックスの作成と破棄(削除)を許可します。

</P>
<P>
<STRONG>alter</STRONG> 権限は <CODE>ALTER TABLE</CODE> の実行を許可します。

</P>
<P>
<STRONG>create</STRONG> と <STRONG>drop</STRONG> 権限は、新しいデータベースやテーブルの作成、
あるいは既に存在するデータベース、テーブルの破棄(削除)を許可します。

</P>
<P>
注意： <CODE>mysql</CODE> データベースに登録されているユーザーに <STRONG>drop</STRONG> 権限を与えると、
そのユーザーは <STRONG>MySQL</STRONG> のアクセス権限が格納されているデータベースを破棄できます！

</P>
<P>
<STRONG>grant</STRONG> 権限は、あなたが他のユーザーに対して自分の権限を持たせる事を許可します。

</P>
<P>
<STRONG>file</STRONG> の権限を与えると、<CODE>LOAD DATA INFILE</CODE> と <CODE>SELECT ... INTO OUTFILE</CODE> 構文を
使用して、サーバーのファイルを読み書きする事ができます。
<STRONG>MySQL</STRONG> サーバーがが読み書きできるファイルに対して、この権限が与えられたユーザーは
ファイルを読み書きできます。

</P>
<P>
残りの権限はアドミン操作に関する許可で、<CODE>mysqladmin</CODE> コマンドを使用して実行します。
次の表に <CODE>mysqladmin</CODE> コマンドのどれが、どの権限に対応しているかを示します：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Privilege</STRONG> </TD><TD> <STRONG>Commands permitted to privilege holders</STRONG>
</TR NOSAVE>
<TR><TD><STRONG>reload</STRONG> </TD><TD> <CODE>reload</CODE>, <CODE>refresh</CODE>,
<CODE>flush-privileges</CODE>, <CODE>flush-hosts</CODE>, <CODE>flush-logs</CODE>, and
<CODE>flush-tables</CODE>
</TR NOSAVE>
<TR><TD><STRONG>shutdown</STRONG> </TD><TD> <CODE>shutdown</CODE>
</TR NOSAVE>
<TR><TD><STRONG>process</STRONG> </TD><TD> <CODE>processlist</CODE>, <CODE>kill</CODE>
</TR>
</TABLE>

<P>
<CODE>reload</CODE> コマンドはサーバーに権限の設定を再読込させるように伝えます。
<CODE>refresh</CODE> コマンドは全てのテーブルをフラッシュし、ログファイルを開き直します。
<CODE>flush-privileges</CODE> は <CODE>reload</CODE> と同義です。
その他の <CODE>flush-*</CODE> コマンドは <CODE>refresh</CODE> の動作とよく似ていますが、
適用範囲を絞っており、ちょっとした場合に有効です。
例えば、ログファイルだけをフラッシュしたい場合、
<CODE>refresh</CODE> を行うよりも <CODE>flush-logs</CODE> がいいです。

</P>
<P>
<CODE>shutdown</CODE> コマンドは、サーバーをシャットダウンします。

</P>
<P>
<CODE>processlist</CODE> コマンドはサーバーが実行しているスレッドの情報を表示します。
 <CODE>kill</CODE> コマンドはサーバーのスレッドをkillします。
自分のスレッドは常に表示、killできますが、他人のスレッドをそうするには
<STRONG>process</STRONG> 権限が必要です。 「<A HREF="manual.ja_MySQL_Database_Administration.html#KILL">4.5.4  <CODE>KILL</CODE> 構文</A>」節参照.

</P>
<P>
ある権限を欲しがるユーザーだけにその権限を許可するのはよい考えですが、
権限を与えるときには、特定の事項を熟知していなければなりません：

</P>

<UL>
<LI>

<STRONG>grant</STRONG> 権限を許可されたユーザーは、他のユーザーの権限を変える事ができます。
二人のユーザー間で違っている権限と <CODE>grant</CODE> 権限を入れ換えることができます。

<LI>

<STRONG>alter</STRONG> 権限は、テーブル名の変更を行うことにより特権システムを破るために
使用されるかもしれません。

<LI>

<STRONG>file</STRONG> 権限は、サーバー上にある全ての読み込み可能なファイルを
データベースに取り込むことができ、これは <CODE>SELECT</CODE> 文でアクセスできます。
これはサーバに置かれているすべてのデータベースの内容を含みます！

<LI>

<STRONG>shutdown</STRONG> 権限は、他のユーザーに対するサービスを、サーバーを
停止することによって、拒否するようにできます。

<LI>

<STRONG>process</STRONG> 権限は実行されているクエリーをプレーンテキストで見ることに使えます。
パスワードの設定、変更のクエリーも含みます。

<LI>

 <CODE>mysql</CODE> データベースに対しての権限は、パスワードの変更と他の権限の設定を変更時に使用されます。
(パスワードは暗号化されて登録されており、悪意のあるユーザーでも
単純に読むことはできません).
<CODE>mysql.user</CODE> のパスワードフィールドにアクセスできれば、それを使用して 
<STRONG>MySQL</STRONG> サーバに与えられたユーザでログインすることができます。(十分
な権限があれば、同じユーザが別のものにパスワードを置き換えることもできます。
)
</UL>

<P>
以下は <STRONG>MySQL</STRONG> の特権システムで行うものではありません：

</P>

<UL>
<LI>

アクセスを拒否するユーザーを特定して設定することはできません。
完全に一致したユーザーからの接続を拒否できません。

<LI>

データベース内のテーブルの作成、破棄の権限を持つが、
データベースそのものを作成、破棄できる、そのようなユーザーを設定できません。
</UL>



<H3><A NAME="Connecting" HREF="manual.ja_toc.html#Connecting">4.2.7  MySQL サーバーに接続</A></H3>

<P>
<A NAME="IDX455"></A>
<A NAME="IDX456"></A>
<A NAME="IDX457"></A>
<A NAME="IDX458"></A>

</P>
<P>
<STRONG>MySQL</STRONG> クライアントプログラムは、共通の決まった引数を持ちます：
接続したいホスト名、接続ユーザー名、そしてパスワードです。
例えば、<CODE>mysql</CODE> コマンドは以下のような引数を持ちます
(オプションの引数は <SAMP>`['</SAMP> と <SAMP>`]'</SAMP> で囲まれている部分です)

</P>

<PRE>
shell&#62; mysql [-h host_name] [-u user_name] [-pyour_pass]
</PRE>

<P>
<CODE>-h</CODE>, <CODE>-u</CODE>, <CODE>-p</CODE> オプションは以下と等価です。
<CODE>--host=host_name</CODE>, <CODE>--user=user_name</CODE>, <CODE>--password=your_pass</CODE>
<CODE>-p</CODE> とパスワードの間にはスペースがないことに注意

</P>
<P>
<STRONG>注意:</STRONG> コマンドラインにパスワードを与えるのは安全ではありません！
システムに入っている如何なるユーザーも <CODE>ps auxww</CODE> のようなコマンドを
使用する事でパスワードを見付ける事ができます
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.

</P>
<P>
<CODE>mysql</CODE> コマンドはコマンドラインに引数がなければ接続にデフォルト値を用います。

</P>

<UL>
<LI>

デフォルトのホスト名は <CODE>localhost</CODE>

<LI>

デフォルトのユーザー名は UNIX のログイン名です。

<LI>

<CODE>-p</CODE> が指定されていなければパスワードは与えられません
</UL>

<P>
UNIX のログインユーザーが <CODE>joe</CODE> の場合、以下のコマンドは等価です：

</P>

<PRE>
shell&#62; mysql -h localhost -u joe
shell&#62; mysql -h localhost
shell&#62; mysql -u joe
shell&#62; mysql
</PRE>

<P>
他の <STRONG>MySQL</STRONG> クライアントも同じように動作します。

</P>
<P>
UNIX システムでは、ある値をデフォルト値にして接続に使用することができます。
そうすることにそり、毎回毎回コマンドラインに引数を与えなくてすむようになります：

</P>

<UL>
<LI>

<A NAME="IDX459"></A>
自分のホームディレクトリに <TT>`.my.cnf'</TT> を作り、そのファイルの中の
<CODE>[client]</CODE> セクションに接続用のパラメターを記述できます。
その記述は以下のようです：


<PRE>
[client]
host=host_name
user=user_name
password=your_pass
</PRE>

 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.

<LI>

<A NAME="IDX460"></A>
<A NAME="IDX461"></A>
<A NAME="IDX462"></A>
<A NAME="IDX463"></A>
<A NAME="IDX464"></A>
<A NAME="IDX465"></A>
接続のパラメターに環境変数を使用することもできます。
ホスト名は <CODE>MYSQL_HOST</CODE> 環境変数を使用します。
<STRONG>MySQL</STRONG> のユーザー名は <CODE>USER</CODE> (これは Windows のみ) に設定された値を使用します。
パスワードは <CODE>MYSQL_PWD</CODE> 環境変数を見ますが、これは危険です。(次の節参照)
 「<A HREF="manual.ja_Environment_variables.html#Environment_variables">H  Environment Variables</A>」節参照.
</UL>



<H3><A NAME="Connection_access" HREF="manual.ja_toc.html#Connection_access">4.2.8  Access Control, Stage 1: 接続の承認</A></H3>

<P>
<A NAME="IDX466"></A>
<A NAME="IDX467"></A>
<A NAME="IDX468"></A>
<A NAME="IDX469"></A>

</P>
<P>
<STRONG>MySQL</STRONG> サーバーに接続すると、あなたがパスワード認証して接続していようがいまいが、
サーバーはあなたの身元により接続の許可拒否を行います。
もし身元が一致しない場合接続を拒否し、接続許可した場合、
サーバーは Stage 2 へと進み、要求を待ちます。

</P>
<P>
身元は二つのものに基づいて確認されます：

</P>

<UL>
<LI>

あなたが接続しようとしているホスト

<LI>

あなたの <STRONG>MySQL</STRONG> ユーザー名
</UL>

<P>
身元の確認は <CODE>user</CODE> テーブルのスコープフィールド
(<CODE>Host</CODE>, <CODE>User</CODE>, <CODE>Password</CODE>) を使用して行います。
サーバーは <CODE>user</CODE> テーブルの登録に一致しているホスト名と
ユーザー名に限り接続を許可し、その後、パスワードを要求します。

</P>
<P>
<CODE>user</CODE> テーブルのスコープフィールドの登録は以下のようになります：

</P>

<UL>
<LI>

<CODE>Host</CODE> の値はホスト名か IP アドレスか <CODE>'localhost'</CODE>(ローカルホスト) です。

<LI>

<A NAME="IDX470"></A>
<CODE>Host</CODE> にはワイルドカード文字 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> を使用できます。

<LI>

<CODE>Host</CODE> に <CODE>'%'</CODE> を設定すると、全てのホストにマッチします。

<LI>

空の <CODE>Host</CODE> 値は、権限が <CODE>host</CODE> テーブル内の与えられたホスト名に
適合するエントリと AND されることを意味します。次の章にこれについての詳し
い情報を見つけられます。

<A NAME="IDX471"></A>
<LI>

MySQL バージョン 3.23 では、IPアドレスが記述された <CODE>Host</CODE> 値には、何
ビットがネットワークアドレスに使用されるかを示すネットマスクを記述すること
ができます。例えば:


<PRE>
GRANT ALL PRIVILEGES on db.* to david@'192.58.197.0/255.255.255.0';
</PRE>

これは、次が真になる IP からの接続をすべて許可します:


<PRE>
user_ip &#38; netmask = host_ip.
</PRE>

上記の例では、192.58.197.0～192.58.197.255 のすべての IP が 
<STRONG>MySQL</STRONG> サーバに接続できます。

<LI>

<A NAME="IDX472"></A>
ワイルドカード文字は <CODE>User</CODE> フィールドには設定できませんが、
<CODE>User</CODE> フィールドをブランク(空)にすることはできます。ブランクは全ての名前にマッチします。
これはユーザー名がない状態で接続してきたものに適用され、
クライアントがユーザー名を明記しない限り、匿名ユーザー(名前がブランク)として扱われます。
全てのアクセスのチェックにブランクのユーザー名が使用される事を意味します。(that is, during Stage 2)

<LI>

<CODE>Password</CODE> フィールドは空にできます。
これは、いかなるパスワードにもマッチするという意味ではなくて、
パスワードなして接続できるということになります。
</UL>

<P>
<A NAME="IDX473"></A>
非ブランクの <CODE>Password</CODE> 値はパスワードを暗号化したものです。
<STRONG>MySQL</STRONG> はだれもが見れるようにパスワードを平文では保存しません。
接続を試みようとしているユーザーのパスワードも、(<CODE>PASSWORD()</CODE> 関数で)
暗号化されます。
それから、暗号化パスワードは、クライアント／サーバがパスワードが正しいかチェッ
クする時に使用されます(This is done without the encrypted password ever
traveling over the connection)。注意: <STRONG>MySQL</STRONG> では、暗号化パスワー
ドが本当のパスワードです。そのため、それへのアクセスを誰にも与えるべきでは
ありません！ 特に、一般ユーザには<CODE>mysql</CODE> データベース内のテーブルの読
み取り権を与えないでください！

</P>
<P>
以下の表は、接続要求に対して与える、
<CODE>user</CODE> テーブルの <CODE>Host</CODE> と  <CODE>User</CODE> の設定例です：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>Host</CODE> <STRONG>value</STRONG> </TD><TD> <CODE>User</CODE> <STRONG>value</STRONG> </TD><TD> <STRONG>Connections matched by entry</STRONG>
</TR NOSAVE>
<TR><TD><CODE>'thomas.loc.gov'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>thomas.loc.gov</CODE> から接続
</TR NOSAVE>
<TR><TD><CODE>'thomas.loc.gov'</CODE> </TD><TD> <CODE>''</CODE> </TD><TD> <CODE>thomas.loc.gov</CODE> から接続してくる全てのユーザー
</TR NOSAVE>
<TR><TD><CODE>'%'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, 全てのホストから接続
</TR NOSAVE>
<TR><TD><CODE>'%'</CODE> </TD><TD> <CODE>''</CODE> </TD><TD> 全てのホストから接続してくる全ユーザー
</TR NOSAVE>
<TR><TD><CODE>'%.loc.gov'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>loc.gov</CODE> ドメイン内の全てのホストからの接続
</TR NOSAVE>
<TR><TD><CODE>'x.y.%'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>x.y.net</CODE>, <CODE>x.y.com</CODE>,<CODE>x.y.edu</CODE>, などからの接続. (あまり有効な使い方ではないです)
</TR NOSAVE>
<TR><TD><CODE>'144.155.166.177'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, IP address が <CODE>144.155.166.177</CODE> のホストからの接続
</TR NOSAVE>
<TR><TD><CODE>'144.155.166.%'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>144.155.166</CODE> class C subnet 内の全てのホストからの接続
</TR NOSAVE>
<TR><TD><CODE>'144.155.166.0/255.255.255.0'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> 上の例と同じ
</TR>
</TABLE>

<P>
<CODE>Host</CODE> に IP のワイルドカード(例えば <CODE>'144.155.166.%'</CODE> は
サブネットの全てのホストにマッチ) を使用することができます。
が、この場合、 <CODE>144.155.166.somewhere.com</CODE> というホスト名で
だれかが接続しようとしてくるかもしれません。
このような攻撃に対し、<STRONG>MySQL</STRONG> は数字やドットで始まるホスト名を拒否しています。
もし <CODE>1.2.foo.com</CODE> のような名前のホストを持っている場合、
許可テーブルの <CODE>Host</CODE> には絶対にマッチしません。
IPアドレスのみ、IP のワイルドカードにマッチする事になります。

</P>
<P>
サーバーに来る接続は、<CODE>user</CODE> テーブル内の登録に１つ以上
マッチするかもしれません。
例えば, <CODE>thomas.loc.gov</CODE> の <CODE>fred</CODE> からの接続は、上に示された
登録のうちのいくつかにマッチするでしょう。
サーバーは、複数の登録にマッチした場合、どのようにしてその中から
使用する登録を選ぶのでしょう？
サーバーは起動後に <CODE>user</CODE> テーブルをソートし、並び換えられた順に
登録を検索することにより、この問題を解決します。
最初にマッチした登録が使用されます。

</P>
<P>
<CODE>user</CODE> テーブルが以下のようにソートされていた場合：

</P>

<PRE>
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| %         | root     | ...
| %         | jeffrey  | ...
| localhost | root     | ...
| localhost |          | ...
+-----------+----------+-
</PRE>

<P>
サーバーがこのテーブルを読むと、<CODE>Host</CODE> に値が最も確実に特定できる
ホストを指定しているエントリを、最初に参照します。
(<CODE>Host</CODE> 項の <CODE>'%'</CODE> は ``すべてのホスト'' を意味し、
ホスト名をはっきりと特定しているものではありません)
<CODE>Host</CODE> の値が同じエントリがあった場合、もっとも明確に <CODE>User</CODE> の値が
ユーザーを指定しているエントリを最初に参照します。
(<CODE>User</CODE> の値が空の場合、``だれでも'' を意味します)
この結果、<CODE>user</CODE> テーブルは以下のようにソートされます：

</P>

<PRE>
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| localhost | root     | ...
| localhost |          | ...
| %         | jeffrey  | ...
| %         | root     | ...
+-----------+----------+-
</PRE>

<P>
<A NAME="IDX474"></A>
<A NAME="IDX475"></A>
<A NAME="IDX476"></A>
接続が試みられた場合、サーバーは並び換えられた登録を探し、最初に見つけたものを
使用します。
<CODE>'localhost'</CODE> の <CODE>jeffrey</CODE> からの接続は、まず最初に <CODE>Host</CODE> に
<CODE>localhost</CODE> を設定しているエントリにマッチします。
ユーザー名が空のエントリは、ホスト名とユーザー名の両方を指定した接続にもマッチします。
( <CODE>'%'/'jeffrey'</CODE> エントリもマッチします。が、これは最初にはマッチしません。)

</P>
<P>
もう一例。<CODE>user</CODE> が以下の設定と仮定します：

</P>

<PRE>
+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| %              | jeffrey  | ...
| thomas.loc.gov |          | ...
+----------------+----------+-
</PRE>

<P>
これは次のようにソートされます：

</P>

<PRE>
+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| thomas.loc.gov |          | ...
| %              | jeffrey  | ...
+----------------+----------+-
</PRE>

<P>
<CODE>thomas.loc.gov</CODE> の <CODE>jeffrey</CODE> からの接続は、最初のエントリにマッチし、
<CODE>whitehouse.gov</CODE> の <CODE>jeffrey</CODE> からの接続は、二つ目のエントリにマッチします。

</P>
<P>
最初にサーバが,接続のためのマッチを見つけるのを試みるとき,共通の誤解は与えられた
ユーザ名に明らかにそのユーザを命名するすべてのエントリが使用されると思うことです.
これは単に本当ではありません. jeffreyによるthomas.loc.govからの接続が最初に
エントリによってユーザ分野値として‘jeffrey'を含まないいずれのエントリによってる合わ
せられる場合,前の例はこれをユーザ名なしで例示します!

</P>
<P>
よくある考え違いは、ユーザー名を与えた場合、
サーバーが接続にマッチするものを探す際に、
そのユーザーが登録されている全てのルールが、
最初に使用されるだろうと考えることです。これは正しくありません。
前の例でこれを示しましたが、<CODE>thomas.loc.gov</CODE> の <CODE>jeffrey</CODE> からの接続が
最初にマッチするのは、 <CODE>User</CODE> フィールドの値が <CODE>'jeffrey'</CODE> に
なっているエントリではなく、ユーザー名なし(＝だれでも) のエントリの方が
先にマッチします！

</P>
<P>
もしサーバーへの接続がうまく行かない場合、 <CODE>user</CODE> テーブルを表示し、
マニュアルでソートしてみて、どのエントリに最初にマッチするか探してください。

</P>



<H3><A NAME="Request_access" HREF="manual.ja_toc.html#Request_access">4.2.9  Access Control, Stage 2: Request Verification</A></H3>

<P>
一度接続か確立されると、サーバーはステージ２に移ります。
このステージでは、サーバーはこの接続から来るそれぞれの要求が許可されて
いるかどうかをチェックします。
チェックは実行しようとしている操作のタイプにより行います。
その操作が許可テーブルのどの権限フィールドに当てはまるかを見ます。
これら権限は  <CODE>user</CODE>, <CODE>db</CODE>,<CODE>host</CODE>, <CODE>tables_priv</CODE> か
 <CODE>columns_priv</CODE> テーブルより導出されます。
許可テーブルは <CODE>GRANT</CODE> コマンドで操作します。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#GRANT">4.3.1  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照.  (You may find it helpful to refer to
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Privileges">4.2.5  特権システムはどのように動くか？</A>」節, which lists the fields present in each of the grant
tables.)

</P>
<P>
<CODE>user</CODE> テーブルは全てに対して基本となる権限をユーザーに割り当てます。
たとえカレントのデータベースが許可を与えていなくても、<CODE>user</CODE> テーブルの設定が有効になります。
例えば、<CODE>user</CODE> テーブルで <STRONG>delete</STRONG> を許可した場合、
サーバーにあるどんなデータベースの行も削除できるのです！ 
いうならば、<CODE>user</CODE> テーブルの権限はスーパーユーザーの権限と言ってもいいでしょう。
この権限はスーパーユーザー(サーバーやデーターベース管理者)のみに与えておく事が賢明です。
他のユーザーは、<CODE>user</CODE> テーブルの権限の設定を <CODE>'N'</CODE> のままにしておくべきですし、
また、<CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルを利用して、
データベースを指定した上でユーザーに権限を許可すべきです。

</P>
<P>
<A NAME="IDX477"></A>
<A NAME="IDX478"></A>
<A NAME="IDX479"></A>
<CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルは特定のデータベースに対する権限許可を行います。
スコープフィールドの値は次のように記述されます:

</P>

<UL>
<LI>

ワイルドカード文字 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> は <CODE>Db</CODE> テーブルと <CODE>Host</CODE> フィールドだけに使用できます。

<LI>

<CODE>'%'</CODE> <CODE>Host</CODE> 値は ``あらゆるホスト'' を意味します。
<CODE>db</CODE> テーブルの <CODE>Host</CODE> に空を設定すると、``さらに <CODE>host</CODE> テーブルに許可情報を探しにいく''
となります。

<LI>

<CODE>'%'</CODE> か 空値を <CODE>Host</CODE> テーブルに設定すると、それは ``あらゆるホスト'' となります。

<LI>

<CODE>'%'</CODE> か 空値を <CODE>host</CODE> テーブルの <CODE>Db</CODE> フィールドに設定すると、
それは ``あらゆるデータベース'' となります。

<LI>

<CODE>User</CODE> を空値にすると、匿名ユーザーにマッチします。
</UL>

<P>
<A NAME="IDX480"></A>
<A NAME="IDX481"></A>
<A NAME="IDX482"></A>
<A NAME="IDX483"></A>
サーバー起動時に、<CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルはサーバーに読み込まれます。
(<CODE>user</CODE> テーブルもこの時に同時に読まれます)
<CODE>db</CODE> テーブルは <CODE>Host</CODE>, <CODE>Db</CODE>, <CODE>User</CODE> のフィールドでソートされ、
<CODE>host</CODE> テーブルは <CODE>Host</CODE>, <CODE>Db</CODE> フィールドでソートされます。
<CODE>user</CODE> テーブルは、一番特定できるエントリを最初に、一番特定できないものを最後にソートします。
サーバーはソートされたものの中から、最初にマッチしたものを使用します。

</P>
<P>
<A NAME="IDX484"></A>
<A NAME="IDX485"></A>
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは、
特定のテーブルとフィールドに対する権限を許可します。
スコープフィールドの値は、いかにそって記述されます：

</P>

<UL>
<LI>

ワイルドカード文字 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> はどちらかのテーブルの
<CODE>Host</CODE> フィールドに使用できます。

<LI>

どちらかのテーブルの <CODE>Host</CODE> 値を <CODE>'%'</CODE> かブランクにすると、
``any host.'' を意味します。

<LI>

<CODE>Db</CODE>, <CODE>Table_name</CODE>, <CODE>Column_name</CODE> フィールドはどのテーブルにも
ワイルドカードやブランクは使用できません。
</UL>

<P>
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは
<CODE>Host</CODE>, <CODE>Db</CODE>, <CODE>User</CODE> フィールドで並び換えられます。
これは <CODE>db</CODE> テーブルのソートに似ていますが、 <CODE>Host</CODE> フィールドだけが
ワイルドカードを含むので、ソートはより単純なものになります。

</P>
<P>
この要求の承認は次のようにして行います。
もしアクセス承認を決定する部分のソースコードを理解できるなら、
ちょっと変わったアルゴリズムで承認の決定を行っている事に気づくでしょう。

</P>
<P>
管理者の要求(<STRONG>shutdown</STRONG>, <STRONG>reload</STRONG>, etc.)については、サーバーは
<CODE>user</CODE> テーブルだけを参照します。(<CODE>user</CODE> テーブルだけが管理者権限のフィールドを持つ)。
エントリに許可登録されている操作は受け入れられ、それ以外は拒否されます。
例えば、<CODE>mysqladmin shutdown</CODE> を実行しようとしても、
<CODE>user</CODE> テーブルの <STRONG>shutdown</STRONG> 権限が許されていなければ実行できません。
この時、<CODE>db</CODE> と <CODE>host</CODE> テーブルはチェックされません。
(これらのテーブルには <CODE>Shutdown_priv</CODE> フィールドが無いからです)

</P>
<P>
データベースへの要求 (<STRONG>insert</STRONG>, <STRONG>update</STRONG>, etc.) において、
サーバーはまず最初に、ユーザーのグローバルな権限(スーパーユーザー)を
 <CODE>user</CODE> の中から探しだします。
もし許可が与えられていれば、アクセスは成功します。

</P>
<P>
<CODE>user</CODE> テーブルのグローバルな権限の設定が不十分であるなら、
サーバーはユーザーのデータベースに対する権限を <CODE>db</CODE> テーブルと
<CODE>host</CODE> テーブルから決定します：

</P>

<OL>
<LI>

サーバーは <CODE>db</CODE> テーブルの <CODE>Host</CODE>,<CODE>Db</CODE>,<CODE>User</CODE>フィールドを参照します。
<CODE>Host</CODE> と <CODE>User</CODE> フィールドはユーザーの接続時のホスト名と <STRONG>MySQL</STRONG> ユーザー名にマッチします。
<CODE>Db</CODE> フィールドはユーザーがアクセスしたいデータベース名にマッチします。
<CODE>Host</CODE> と <CODE>User</CODE> にマッチするものが無かった場合、アクセスは拒否されます。

<LI>

<CODE>db</CODE> テーブル内の <CODE>Host</CODE> フィールドが空でないエントリにマッチした場合、
ユーザーの指定されているデータベースに対する権限が定義されます。

<LI>

<CODE>Host</CODE> フィールドが空値の <CODE>db</CODE> テーブルのエントリにマッチした場合、
どのホストがそのデータベースへアクセスできるかを <CODE>host</CODE> テーブルから探し出します。
この場合、<CODE>host</CODE> テーブル の <CODE>Host</CODE>, <CODE>Db</CODE> フィールドとマッチするものを探し出します。
<CODE>host</CODE> テーブルにエントリがなかった場合、アクセスは拒否されます。
もしマッチすると、ユーザーの特定データベースに対する権限は、
<CODE>host</CODE> テーブルと <CODE>db</CODE> テーブル両方にまたがった権限から割り出されます。
いうならば両方とも <CODE>'Y'</CODE> である権限。
(この方法を使用すると、まず <CODE>db</CODE> テーブルのエントリに大まかな権限を設定しておき、
それから <CODE>host</CODE> テーブルのエントリを使用して、ホスト情報もとに権限を限定していくという事ができます)
</OL>

<P>
特定データベースに対する権限が <CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルのエントリから決定された後、
サーバーはその割り出された権限に対し、<CODE>user</CODE> テーブルて設定されている権限を加えます。
この結果から得られた権限にマッチした要求は受け入れられます。
そうでなければ、サーバーはユーザーのテーブル、フィールドに対する許可を、
 <CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> 内に探します。
アクセスはこの結果により、許可、拒否されます。

</P>
<P>
先のユーザーの権限が計算される方法の記述は、boolean 表記で示すならば、
以下のようになるでしょう：

</P>

<PRE>
global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
</PRE>

<P>
これは少し分かりにくいかもしれません。もしグローバルの <CODE>user</CODE> エントリ
権限許可が、リクエストされたオペレーションには不十分だと最初に分かった際、
サーバーがこれらの権限を database-, table-, column-固有の権限の
後に、なぜ、追加してしまうのか。
 その理由は、リクエストが1個以上の権限を要求するだろうということです。
例えば、もしあなたが <CODE>INSERT ...  SELECT</CODE> 構文を実行するなら、
あなたには <STRONG>insert</STRONG> と <STRONG>select</STRONG> 許可が必要です。
あなたの権限が、 <CODE>user</CODE> テーブルエントリで一つの権限が許可され、
 <CODE>db</CODE> テーブルで、そのほかの権限が許可されていたとします。
この場合、あなたは、そのリクエストを実行するために、必要な権限を持っています。
しかし、サーバーはどちらのテーブル、それ単体からでは、権限を得ることが出来ません。
権限は、両方のエントリーを合わせなくてはならないのです。

</P>
<P>
<A NAME="IDX486"></A>
<A NAME="IDX487"></A>

</P>
<P>
<CODE>host</CODE> テーブルは ``安全な'' ホストのリストを維持するために使用できます。

</P>
<P>
TcX では、<CODE>host</CODE> テーブルにはローカルネット上の全てのホストが登録されています。
これらのホストは全ての権限が許可されています。

</P>
<P>
逆に <CODE>host</CODE> table で安全<EM>ではない</EM>ホストを指定することもできます。
 <CODE>public.your.domain</CODE> というマシンが安全ではない、公開されている場所にあるとします。
その場合以下のようにして、その公開マシン以外のネットワーク上のホストに対して、
アクセスを許可することができます：

</P>

<PRE>
+--------------------+----+-
| Host               | Db | ...
+--------------------+----+-
| public.your.domain | %  | ... (all privileges set to 'N')
| %.your.domain      | %  | ... (all privileges set to 'Y')
+--------------------+----+-
</PRE>

<P>
<A NAME="IDX488"></A>
<A NAME="IDX489"></A>
<A NAME="IDX490"></A>
<A NAME="IDX491"></A>

</P>
<P>
権限のテーブル設定は、あなたの思い通りに許可が得られるのか、
常に(<CODE>mysqlaccess</CODE>等を使用して)チェックすべきです。

</P>



<H3><A NAME="Access_denied" HREF="manual.ja_toc.html#Access_denied">4.2.10  何故 <CODE>Access denied</CODE> エラーになるのか</A></H3>

<P>
もし、<STRONG>MySQL</STRONG> サーバーに接続しようとして <CODE>Access denied</CODE> エラーに
遭遇してしまったら、以下に記すことが問題の解決のための指標となるでしょう:

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> をインストールした後に、スクリプト <CODE>mysql_install_db</CODE> を実行して
許可テーブルを初期化しましたか？
していなければ実行してください。 「<A HREF="manual.ja_MySQL_Database_Administration.html#Default_privileges">4.3.4  MySQL 権限許可の初期設定</A>」節参照
権限許可のテーブルが初期化されているかを試すには以下のようにします：


<PRE>
shell&#62; mysql -u root test
</PRE>

これは普通はエラーなしで接続できます。
<STRONG>MySQL</STRONG> データベースディレクトリ内に <TT>`user.MYD'</TT> ファイルが
あるかどうかでもチェックします。(普通は <TT>`PATH/var/mysql/user.MYD'</TT> です。
ここで <CODE>PATH</CODE> は <STRONG>MySQL</STRONG> をインストールしたディレクトリーパスを示します。)

<LI>

初めてインストールした後は、以下のようにしてサーバーに接続して
ユーザーとアクセス権を設定しなくてはなりません：


<PRE>
shell&#62; mysql -u root mysql
</PRE>

初期状態では、<STRONG>MySQL</STRONG> に <CODE>root</CODE> ユーザーをパスワードなしで登録しているので、
問題なく接続できるはずです。
しかしこれはセキュリティ上危険な状態なので、
他の <STRONG>MySQL</STRONG> ユーザーを登録している時に、
<CODE>root</CODE> のパスワードを設定しておいてください。

もし <CODE>root</CODE> で接続しようとして以下のエラーが出た場合：


<PRE>
Access denied for user: '@unknown' to database mysql
</PRE>

これは <CODE>user</CODE> テーブルに、 <CODE>User</CODE> フィールド = <CODE>root</CODE> かつ
<CODE>mysqld</CODE> がリゾルブできなかったホスト名で、クライアントが登録されていないからです。
この場合、 <TT>`/etc/hosts'</TT> ファイルあるいは <TT>`\windows\hosts'</TT> ファイルを編集して
ホスト名を追加し、<CODE>--skip-grant-tables</CODE> オプションでサーバーをリスタートします。

<LI>

次のようなエラーが出た場合:


<PRE>
shell&#62; mysqladmin -u root -pxxxx ver
Access denied for user: 'root@localhost' (Using password: YES)
</PRE>

これは間違ったパスワードを使用したことを意味します。  「<A HREF="manual.ja_MySQL_Database_Administration.html#Passwords">4.3.6  パスワードの設定法</A>」節参照.

root のパスワードを忘れた場合、<CODE>mysqld</CODE> を 
<CODE>--skip-grant-tables</CODE> で再起動して、パスワードを変更することができま
す。このオプションについての詳細は、マニュアルのこの節の後ろに見つけること
ができます。

パスワードを指定してないのに、上のエラーがでた場合は、<CODE>my.ini</CODE> ファイ
ルに間違ったパスワードがあることを意味します。 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照. このオ
プションファイルは、次のように <CODE>--no-defaults</CODE> オプションで回避できま
す:


<PRE>
shell&#62; mysqladmin --no-defaults -u root ver
</PRE>

<LI>

<A NAME="IDX492"></A>
もしバージョン 3.22.11 より前の <STRONG>MySQL</STRONG> から
バージョン 3.22.11 以上にバージョンアップしたなら、
<CODE>mysql_fix_privilege_tables</CODE> スクリプトを実行しましたか？
実行していないなら、このエラーになります。
許可テーブルの構造が <STRONG>MySQL</STRONG> バージョン 3.22.11 から変更され、
<CODE>GRANT</CODE> 構文が機能しています。

<LI>

もしあなたの権限がセッションの途中で変更されたように思ったなら、それは
スーパーユーザーが権限を変えたのかも知れません。許可テーブルの再読み込みは
新しいクライアントの接続から反映されますが、すでに接続している場合でも
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Privilege_changes">4.3.3  いつ権限の変更が反映されるか</A>」節. に示す条件下では影響を受けます。

<LI>

もしあなたのパスワードが働かないのであれば、
<CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, <CODE>SET PASSWORD</CODE> 構文でパスワードを設定するとき
 <CODE>PASSWORD()</CODE> 関数を使用しなければならないことを思い出してください。
しかし <CODE>PASSWORD()</CODE> 関数は、<CODE>GRANT ... INDENTIFIED BY</CODE> 構文や
<CODE>mysqladmin password</CODE> コマンドでは不要です。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Passwords">4.3.6  パスワードの設定法</A>」節参照.

<LI>

<CODE>localhost</CODE> はローカルのホスト名です。
もしクライアントがホストを指定せずに接続してきた場合、<CODE>localhost</CODE> がデフォルトで使用されます。
しかし、 MIT-pthreads を使用している場合、<CODE>localhost</CODE> への接続は失敗します。
(<CODE>localhost</CODE> への接続は、UNIXソケットを使用しますが、 
MIT-pthreads が ソケット接続をサポートしていないためです。)
この問題が起きるシステムでは、サーバー名を指定するために <CODE>--host</CODE> オプションを使用すべきです。
これは TCP/IP 接続を使用して <CODE>mysqld</CODE> サーバーに接続します。
この場合、<CODE>user</CODE> テーブルに、サーバーの実ホスト名を登録しておかなくてはなりません。
(これはクライアントプログラムをサーバーと同じホスト上で動かしている場合真となります)
例えば、<CODE>Using password: NO</CODE> を含むエラーメッセージを得た場合、これは
パスワードなしでログインしようとしたことを意味します。

<LI>

<CODE>mysql -u user_name db_name</CODE> を使用してデータベースに接続しているときに
 <CODE>Access denied</CODE> エラーが発生した場合、<CODE>user</CODE> テーブルの設定違いが考えられます。
<CODE>mysql -u root mysql</CODE> を実行し、以下の SQL 文を試してください：


<PRE>
mysql&#62; SELECT * FROM user;
</PRE>

<CODE>Host</CODE> と <CODE>User</CODE> にあなたのコンピュータ名と
<STRONG>MySQL</STRONG> ユーザー名にマッチする登録がなされていなければなりません。

<LI>

<CODE>Access denied</CODE> エラーは、どのユーザーで接続してきたか、
どのホストから接続しようとしているか、パスワードを使用しているのかをメッセージに出力します。
通常、エラーになっているホスト名とユーザー名がマッチするエントリが
<CODE>user</CODE> テーブルに一つはなければなりません。

<LI>

他のホストから <STRONG>MySQL</STRONG> サーバーに接続を試みた時に以下のエラーが出た場合、
<CODE>user</CODE> テーブルにあなたがアクセスしているホストにマッチする行がありません：


<PRE>
Host ... is not allowed to connect to this MySQL server
</PRE>

<CODE>mysql</CODE> コマンドをサーバーのホスト上で使用して、
<CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE> テーブルに接続しようとしている
ユーザー名／ホスト名 を加えて、<CODE>mysqladmin flush-privileges</CODE> を
実行すれば解決できるでしょう。
もしサーバーが <STRONG>MySQL</STRONG> バージョン 3.22 ではなく、接続しようとしている
ホストの IP もホスト名もわからない場合、
<CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドに <CODE>'%'</CODE> を設定し、
<CODE>mysqld</CODE> を <CODE>--log</CODE> オプションで再起動してください。
そしてクライアントホストから接続すれば、<STRONG>MySQL</STRONG> のログファイルに
そのホストの情報が記録されているはずです。
それがわかれば、先に設定した <CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドの <CODE>'%'</CODE> を
ログに記録されたホスト名に置き換えます。(しかしこれはシステムを危険にさらします)

Linux 上でこのエラーの他の原因は、あなたの使用しているのと異なる glibc バー
ジョンでコンパイルされた、バイナリ <STRONG>MySQL</STRONG> バージョンを使用している
ことを意味します。この場合、あなたの OS/glibc をアップグレードするか、ソー
ス <STRONG>MySQL</STRONG> バージョンをダウンロードしてコンパイルすべきです。ソース 
RPM は、通常コンパイルとインストールは簡単なので、これは大きな問題ではあり
ません。

<LI>

ホスト名で接続しようとしたのに、ホスト名が現れないか、ホスト名が IP でエラー
メッセージが出る場合:


<PRE>
shell&#62; mysqladmin -u root -pxxxx -h some-hostname ver
Access denied for user: 'root' (Using password: YES)
</PRE>

これは <STRONG>MySQL</STRONG> が IP をホスト名に解決しようとした時に何かエラーを得
たことを意味します。この場合、<CODE>mysqladmin flush-hosts</CODE> を実行して、内
部の DNS キャッシュをリセットできます。  「<A HREF="manual.ja_MySQL_Optimization.html#DNS">5.5.5  How MySQL uses DNS</A>」節参照.

いくつかの永久的な解決策は:


<UL>
<LI>

DNS サーバで何が間違っているのかを見つけ出し、それを修正する。

<LI>

<STRONG>MySQL</STRONG> 権限テーブル中に、ホスト名の代わりに IP を記述する。

<LI>

<CODE>--skip-name-resolve</CODE> で <CODE>mysqld</CODE> を起動する。

<LI>

<CODE>--skip-host-cache</CODE> で <CODE>mysqld</CODE> を起動する。

<LI>

同じマシン上でサーバとクライアントを起動している場合、<CODE>localhost</CODE> に
接続する。

<LI>

<CODE>/etc/hosts</CODE> にクライアントマシン名を置く。
</UL>

<LI>

<CODE>mysql -u root test</CODE> は動いたものの <CODE>mysql -h your_hostname -u root test</CODE> が
 <CODE>Access denied</CODE> を返した場合、
<CODE>user</CODE> テーブルに正しいホスト名が使用されていないと思われます。
<CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドにホスト名を確定できる形で指定していないか、
使用しているシステムのリゾルブが FQDN (or vice-versa) を返しているかだと思われます。
例えば、<CODE>user</CODE> テーブルに <CODE>'tcx'</CODE> ホストの定義があったとして、
DNS が <STRONG>MySQL</STRONG> に <CODE>'tcx.subnet.se'</CODE> をホスト名として返した場合、
これは動きません。
<CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドの値に、あなたのホストの IP 番号を加えてください。
(<CODE>user</CODE> テーブルの <CODE>Host</CODE> の値にワイルドカードを使用することができます。<CODE>'tcx.%'</CODE> のように。
しかしホスト名の値を <SAMP>`%'</SAMP> 文字で終わらせる設定は、<EM>安全ではなく</EM>、<EM>推奨されません</EM>)

<LI>

もし <CODE>mysql -u user_name test</CODE> が動作し <CODE>mysql -u user_name other_db_name</CODE> が
動作しない場合は、<CODE>db</CODE> テーブルに <CODE>other_db_name</CODE> のエントリが
登録されていません。

<LI>

<CODE>mysql -u user_name db_name</CODE> はザーバー上では動作するが、
<CODE>mysql -u host_name -u user_name db_name</CODE> がクライアントホスト上で動作しない場合、
<CODE>user</CODE> テーブルか <CODE>db</CODE> テーブルにクライアントホストの名前が登録されていません。

<LI>

<CODE>Access denied</CODE> の原因がもし上記に当てはまらない場合は、
<CODE>user</CODE> テーブルから <CODE>Host</CODE> にワイルドカードを使用しているエントリを
全て消去してみてください。(<SAMP>`%'</SAMP> や <SAMP>`_'</SAMP> を含む値です)
よくある間違いは、<CODE>localhost</CODE> に対して <CODE>localhost</CODE> と同じマシン上から
の接続を許可すると考えて
<CODE>Host</CODE>=<CODE>'%'</CODE> と <CODE>User</CODE>=<CODE>'some user'</CODE> を登録することです。
これは動きません。なぜなら、デフォルトの権限に
<CODE>Host</CODE>=<CODE>'localhost'</CODE> と <CODE>User</CODE>=<CODE>''</CODE> が含まれているからです。
<CODE>Host</CODE> の値が <CODE>'localhost'</CODE> の場合、これは <CODE>'%'</CODE> よりも
具体的に指定されているので、<CODE>localhost</CODE> からの接続にはこちらの方が
使用されるのです！ 正しい指定の仕方は、二番目の登録として
<CODE>Host</CODE>=<CODE>'localhost'</CODE> と <CODE>User</CODE>=<CODE>'some_user'</CODE> を追加するか、
あるいは、<CODE>Host</CODE>=<CODE>'localhost'</CODE> と <CODE>User</CODE>=<CODE>''</CODE> を削除することです。

<LI>

もし以下のエラーが出た場合
<CODE>db</CODE> か <CODE>host</CODE> テーブルに問題があるのかもしれません。：


<PRE>
Access to database denied
</PRE>

もし <CODE>db</CODE> テーブルに <CODE>Host</CODE> フィールドが空の登録がある場合には、
<CODE>host</CODE> テーブル中に、<CODE>db</CODE> テーブルに登録されている
ホストを明記した物が一つ以上あるかどうかを確認してください。

もし <CODE>SELECT ... INTO OUTFILE</CODE> や <CODE>LOAD DATA INFILE</CODE> SQL 文を
使用している時にこのエラーが出る場合、
<CODE>user</CODE> テーブルのあなたの登録に <STRONG>file</STRONG> 権限が
許可されていないと思われます。

<LI>

<A NAME="IDX493"></A>
<A NAME="IDX494"></A>
<A NAME="IDX495"></A>
クライアントプログラムは接続に際して、
設定ファイルで設定された値か環境変数の値を使用することに注意してください。
もしクライアントプログラムが誤った値を接続に使用しているようなら、
環境変数とホームディレクトリにある <TT>`.my.cnf'</TT> ファイルを確認してください。
もちろんシステムワイドの <STRONG>MySQL</STRONG> 設定ファイルも、パラメターが記述されていないか、
チェックしてみてください。 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.
もしクライアントをオプションなしで起動していて <CODE>Access denied</CODE> がでるなら、
オプションファイルに古いパスワードが書かれているか確認してください。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.

<LI>

権限テーブルを(<CODE>INSERT</CODE> または <CODE>UPDATE</CODE> ステートメントを使用して
)直接変更する場合、あなたの変更は無視されたように見えます。サーバに権限テー
ブルを再読み込みさせるために、<CODE>FLUSH PRIVILEGES</CODE> ステートメントの発行
か、<CODE>mysqladmin flush-privileges</CODE> コマンドの実行の必要があることを忘
れないでください。そうでないと、あなたの変更は次回のサーバ再起動まで効果が
ありません。<CODE>UPDATE</CODE> コマンドで <CODE>root</CODE> パスワードを設定後、権限
をフラッシュするまでそれを指定する必要がありません。サーバはまだパスワード
を変更したことを知らないからです！

<LI>

Perl, PHP, Python, ODBC プログラムでアクセスの問題があった場合、
<CODE>mysql -u user_name db_name</CODE> または <CODE>mysql -u user_name
-pyour_pass db_name</CODE> でサーバへの接続を試してください。<CODE>mysql</CODE> クライ
アントを使用して接続できれば、アクセス権でなく、あなたのプログラムに問題が
あります。(<CODE>-p</CODE> とパスワードの間に空白がないことに注意してください; 
パスワードを指定するのに、<CODE>--password=your_pass</CODE> 構文も使用できます。
単に <CODE>-p</CODE> オプションを使用すると、<STRONG>MySQL</STRONG> はパスワードの入力を
求めます。)

<LI>

テストのために、<CODE>mysqld</CODE> デーモンを <CODE>--skip-grant-tables</CODE> オプショ
ン付きで開始してください。<STRONG>MySQL</STRONG> 権限テーブルを変更し、あなたの変
更が望む効果があるかどうかのチェックに、<CODE>mysqlaccess</CODE> スクリプトを使
用できます。あなたの変更が満足できた時に、<CODE>mysqladmin
flush-privileges</CODE> を実行し、<CODE>mysqld</CODE> サーバに新しい権限テーブルを使用
して開始するように伝えてください。<STRONG>注意:</STRONG> 権限テーブルのリロードは 
<CODE>--skip-grant-tables</CODE> オプションを上書きします。これは、サーバを落と
して再起動することなしに、権限テーブルの使用を始めるようにサーバに伝えるこ
とができます。

<LI>

もし全て失敗するなら、<CODE>mysqld</CODE> デーモンをデバッグオプションで起動してください。
例えば、<CODE>--debug=d,general,query</CODE>。これはコネクションに試みたホストやユーザーの情報、
また実行したコマンドを表示します。  「<A HREF="manual.ja_Porting.html#Making_trace_files">G.1.2  Creating trace files</A>」節参照.

<LI>

もし <STRONG>MySQL</STRONG> の権限許可についてその他の問題が起こり、
メーリング・リストに問題をポストしなくてはいけないと感じれば、
いつも <STRONG>MySQL</STRONG> 許可テーブルのダンプを提供して下さい。
<CODE>mysqldump mysql</CODE> コマンドでダンプできます。
いつものように、 <CODE>mysqlbug</CODE> スクリプトでポストしてください。 「<A HREF="manual.ja_Introduction.html#Bug_reports">1.2.22.3  バグや問題を報告する方法</A>」節参照. 
ときにはは、 <CODE>mysqldump</CODE> を実行するために、
<CODE>mysqld</CODE> を <CODE>--skip-grant-tables</CODE> オプションで実行しないと
いけないかもしれません。
</UL>



<H2><A NAME="User_Account_Management" HREF="manual.ja_toc.html#User_Account_Management">4.3  MySQL User Account Management</A></H2>



<H3><A NAME="GRANT" HREF="manual.ja_toc.html#GRANT">4.3.1  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A></H3>

<P>
<A NAME="IDX496"></A>
<A NAME="IDX497"></A>

</P>
<P>
<A NAME="IDX498"></A>
<A NAME="IDX499"></A>
<A NAME="IDX500"></A>
<A NAME="IDX501"></A>
<A NAME="IDX502"></A>

</P>

<PRE>
GRANT priv_type [(column_list)] [, priv_type [(column_list)] ...]
    ON {tbl_name | * | *.* | db_name.*}
    TO user_name [IDENTIFIED BY 'password']
        [, user_name [IDENTIFIED BY 'password'] ...]
    [WITH GRANT OPTION]

REVOKE priv_type [(column_list)] [, priv_type [(column_list)] ...]
    ON {tbl_name | * | *.* | db_name.*}
    FROM user_name [, user_name ...]
</PRE>

<P>
<CODE>GRANT</CODE> は <STRONG>MySQL</STRONG> 3.22.11 以上で実装されています; 前の 
<STRONG>MySQL</STRONG> バージョンでは、<CODE>GRANT</CODE> ステートメントは何も行ないま
せん。

</P>
<P>
<CODE>GRANT</CODE> と <CODE>REVOKE</CODE> コマンドセットの主な目的は、システム管理者
がユーザを生成すること、<STRONG>MySQL</STRONG> ユーザに次の４つの権限レベルの権
利を与えたり取り消すことをできるようにすることです:

</P>
<DL COMPACT>

<DT><STRONG>Global レベル</STRONG>
<DD>
Global 権限は与えられたサーバ上の全てのデータベースに適用します。これらの権限は 
<CODE>mysql.user</CODE> テーブル内に格納されます。

<DT><STRONG>Database レベル</STRONG>
<DD>
Database 権限は与えられたデータベース内の全てのテーブルに適用します。こ
れらの権限は <CODE>mysql.db</CODE> テーブルと <CODE>mysql.host</CODE> テーブル内に格納されます。

<DT><STRONG>Table レベル</STRONG>
<DD>
Table 権限は与えられたテーブル内の全てのフィールドに適用します。これらの権限は 
<CODE>mysql.tables_priv</CODE> テーブル内に格納されます。

<DT><STRONG>Column レベル</STRONG>
<DD>
Column 権限は与えられたテーブル内の一つのフィールドに適用します。これらの権限は 
<CODE>mysql.columns_priv</CODE> テーブル内に格納されます。
</DL>

<P>
If you give a grant for a users that doesn't exists, that user is created.
For examples of how <CODE>GRANT</CODE> works, see  「<A HREF="manual.ja_MySQL_Database_Administration.html#Adding_users">4.3.5  新しいユーザを MySQL へ追加</A>」節.

</P>
<P>
<CODE>GRANT</CODE> と <CODE>REVOKE</CODE> ステートメントにおいて <CODE>priv_type</CODE> には
以下が指定できます:

</P>

<PRE>
ALL PRIVILEGES      FILE                RELOAD
ALTER               INDEX               SELECT
CREATE              INSERT              SHUTDOWN
DELETE              PROCESS             UPDATE
DROP                REFERENCES          USAGE
</PRE>

<P>
<CODE>ALL</CODE> は <CODE>ALL PRIVILEGES</CODE> の同義語です.
<CODE>REFERENCES</CODE> はまだ実行されません。
<CODE>USAGE</CODE> は ``no privileges'' と同義です.
これはなんの権限も持たないユーザーを作る場合に使用します.

</P>
<P>
ユーザーから権限許可を取り除くには、<CODE>GRANT OPTION</CODE> オプションの値に
<CODE>priv_type</CODE> を指定します：

</P>

<PRE>
REVOKE GRANT OPTION ON ... FROM ...;
</PRE>

<P>
テーブルに対する許可のために指定できる <CODE>priv_type</CODE> は次のフィールドだけです：
<CODE>SELECT</CODE>,<CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, <CODE>DELETE</CODE>, <CODE>CREATE</CODE>, <CODE>DROP</CODE>,
<CODE>GRANT</CODE>, <CODE>INDEX</CODE>, <CODE>ALTER</CODE>.

</P>
<P>
フィールドに対する許可のために指定できる <CODE>priv_type</CODE> は次のフィールドだけです
(これは <CODE>column_list</CODE> 節を使用する場合に適用されます)：
<CODE>SELECT</CODE>, <CODE>INSERT</CODE>, <CODE>UPDATE</CODE>.

</P>
<P>
<CODE>WITH GRANT OPTION</CODE> 節は、<CODE>GRANT</CODE> 構文を使用して
他のユーザーに権限を与えることができるようにします。

</P>
<P>
<CODE>ON *.*</CODE> を使用してグローバル権限を設定できます。
<CODE>ON db_name.*</CODE> を使用してデータベース権限を設定できます。<CODE>ON *</CODE> を
指定すると、現在のデータベースの権限を設定できます。
(<STRONG>警告：</STRONG> 現在のデータベースを持たない状態で <CODE>ON *</CODE> を指定した場合、
global 権限に影響します！)

</P>
<P>
ユーザへの権利の供与を他のホストから適応するために、<STRONG>MySQL</STRONG> は
 <CODE>user_name</CODE> の値を <CODE>user@host</CODE> の形で書けるようにしています。
特殊文字(<SAMP>`%'</SAMP> のような)で <CODE>user_name</CODE> の値を指定したい場合、
ユーザやホスト名をクォートできます;
(例えば <CODE>'test-user'@'test-hostname'</CODE>)。

</P>
<P>
ホスト名にワイルドカードを使用できます。例えば、<CODE>user@"%.loc.gov"</CODE> は
<CODE>loc.gov</CODE> ドメインの全てのホストの <CODE>user</CODE> を与え、
<CODE>user@"144.155.166.%"</CODE> は <CODE>144.155.166</CODE> クラスCサブネットの
あらゆるホストの <CODE>user</CODE> となります。

</P>
<P>
単に <CODE>user</CODE> と書くと <CODE>user@"%"</CODE> と同じです.
<STRONG>注意：</STRONG> もし匿名ユーザーからの <STRONG>MySQL</STRONG> サーバーへの接続を
許す場合(デフォルトです)、全てのローカルユーザー <CODE>username@localhost</CODE> を加えるべきです。
なぜなら、匿名ユーザーは同じマシンから <STRONG>MySQL</STRONG> サーバーに入ろうとした場合に
使用されるからです！
匿名ユーザーは <CODE>mysql.user</CODE> ユーザーテーブルに、 <CODE>User=''</CODE> として登録されています。
これを確認するには、以下のようにします：

</P>

<PRE>
mysql&#62; SELECT Host,User FROM mysql.user WHERE User='';
</PRE>

<P>
さしあたり, <CODE>GRANT</CODE> はホスト名、テーブル名、データベース名、フィールド名に
最大60文字まで使用できます。ユーザー名は最大16文字までです。

</P>
<P>
テーブル/フィールドの権限は global(ユーザとデータベース)権限と 
<CODE>GRANT</CODE> 権限と <CODE>OR</CODE> されます。例えば、ユーザが 
<CODE>mysql.user</CODE> テーブル内の global <STRONG>select</STRONG> 権限を持っている場合、
これはデータベースやテーブル/フィールドレベル内のエントリでは拒否できません。

</P>
<P>
フィールドの権利は次のように計算できます:

</P>

<PRE>
global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
</PRE>

<P>
多くの場合、異なる権限レベルの一つでユーザに権利を与えるので、人生は通常
上述のようには複雑ではありません。:)
アクセス制限のチェックの詳細は→ 「<A HREF="manual.ja_MySQL_Database_Administration.html#Privilege_system">4.2  General Security Issues and the MySQL Access Privilege System</A>」節.

</P>
<P>
ユーザへの権利の供与を他のホストから適応するために、<STRONG>MySQL</STRONG> はユー
ザ名が形式 <CODE>user@host</CODE> で指定できることをサポートします。簡単な形
式 <CODE>user</CODE> は <CODE>user@%</CODE> の同義語です。特殊文字(<CODE>.</CODE> のよう
な)でホスト名を指定したい場合、<CODE>"user"@"hostname"</CODE> 構文を使用でき
ます。

</P>
<P>
ユーザとホスト名の組が存在しない場合、エントリは <CODE>mysql.user</CODE> テー
ブルに追加され、<CODE>DELETE</CODE> コマンドで削除されるまでそこに残ります。
いうならば <CODE>GRANT</CODE> は <CODE>user</CODE> テーブルの登録を作りますが、
 <CODE>REVOKE</CODE> はそれらを削除できません;
そうするには <CODE>DELETE</CODE> を使用しなくてはなりません。

</P>
<P>
<A NAME="IDX503"></A>
<STRONG>MySQL</STRONG> バージョン 3.22.12 以上では、
新しいユーザーが作成された場合、あるいは、あなたがグローバルな権限を許可されている場合、
ユーザーのパスワードは <CODE>IDENTIFIED BY</CODE> 節を使用して設定できます。
すでにユーザーにパスワードがある場合、新しく設定されたパスワードに置き換えられます。

</P>
<P>
<STRONG>警告：</STRONG> もし新しいユーザーを作っても
<CODE>IDENTIFIED BY</CODE> 節を指定しなければ、 そのユーザーはノーパスワードです。
これは危険です。

</P>
<P>
パスワードは <CODE>SET PASSWORD</CODE> コマンドでも設定できます。
 「<A HREF="manual.ja_MySQL_Optimization.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節参照.

</P>
<P>
データベースに権限を <CODE>GRANT</CODE> する場合、<CODE>mysql.db</CODE> テーブル内の
エントリは必要な場合に生成されます。全てのデータベース権限が 
<CODE>REVOKE</CODE> で削除された時、このエントリは削除されます。

</P>
<P>
ユーザがテーブルに何も権限を持っていない場合、テーブルの一覧要求時(例え
ば、<CODE>SHOW TABLES</CODE> ステートメントで)には、テーブルは現れません。

</P>
<P>
<CODE>WITH GRANT OPTION</CODE> 節は、他のユーザーに、自分が持っている権限を与えることができます。
<STRONG>権限許可</STRONG>を他に与える場合は注意してください。
あなたと許可を与えるユーザーが違う権限を持っている場合、
与えられる権限の許可は、二つを合わせた物になります！

</P>
<P>
自分自身が持っていない権限を他のユーザーに与えることはできません；
<STRONG>権限許可</STRONG>はあなたが所有する権限の許可だけを与えることができます。

</P>
<P>
あなたがユーザーに格別の権限レベルを与えた場合、既にユーザーが持っているいかなる権限
(あるいは 将来持つ権限) はそのユーザーによっても許可が与えられます。
あなたがデータベースに対する <STRONG>insert</STRONG> 許可をあるユーザーに与えたと仮定します。
もし、データベースに対する <STRONG>select</STRONG> 権限を与えたり、
<CODE>WITH GRANT OPTION</CODE> を行うと、ユーザーは <STRONG>select</STRONG> 権限だけでなく
 <STRONG>insert</STRONG> も得ることになります。
もし <STRONG>update</STRONG> 権限をユーザーに与えると、そのユーザーは
<STRONG>insert</STRONG>, <STRONG>select</STRONG>, <STRONG>update</STRONG> が可能です。

</P>
<P>
<STRONG>alter</STRONG> 権限を一般ユーザに与えるべきではありません。この場合
ユーザはテーブルをリネームでき、この方法で権限を回ることを試みることがで
きます！

</P>
<P>
注意：もし table/column 権限を一人のユーザーにだけ与えた場合、
 <STRONG>MySQL</STRONG> は全てのユーザーに対してテーブルとフィールドの承認権限を検討します。
これは <STRONG>MySQL</STRONG> を少し遅くします。

</P>
<P>
<CODE>mysqld</CODE> 開始時、全ての権限はメモリに読み込まれます。データベース、
テーブル、フィールド権限は一度効果を得ます。ユーザレベル権限はユーザ再接続時に
効果を得ます。
これらの許可テーブルを <CODE>GRANT</CODE> や <CODE>REVOKE</CODE> を使って変更しても
サーバーにはすぐに反映されません。
もしこれらの許可テーブルを手動で変更した場合(<CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, 等で変更した場合)、
<CODE>FLUSH PRIVILEGES</CODE> 構文を実行するか、<CODE>mysqladmin flush-privileges</CODE> を実行して
サーバーに許可テーブルの再読み込みを行わせなくてはなりません。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Privilege_changes">4.3.3  いつ権限の変更が反映されるか</A>」節参照.

</P>
<P>
<A NAME="IDX504"></A>
<CODE>ANSI SQL GRANT</CODE> と <STRONG>MySQL</STRONG> <CODE>GRANT</CODE> との大きな違いは:
<CODE>GRANT</CODE> are:

</P>

<UL>
<LI>

In MySQL privileges are given for an username + hostname combination
and not only for an username.

<LI>

ANSI SQL はグローバルとデータベースレベル承認を持たず、ANSI SQL は
<STRONG>MySQL</STRONG> がサポートする全ての権限をサポートしません。
MySQL doesn't support the ANSI SQL <CODE>TRIGGER</CODE>, <CODE>EXECUTE</CODE> or
<CODE>UNDER</CODE> privileges.

<LI>

ANSI SQL privileges are structured in a hierarchal manner. If you remove
an user, all privileges the user has granted are revoked. In
MySQL the granted privileges are not automatically revoked, but
you have to revoke these yourself if needed.

<LI>

If you in MySQL have the <CODE>INSERT</CODE> grant on only part of the
columns in a table, you can execute <CODE>INSERT</CODE> statements on the
table; The columns for which you don't have the <CODE>INSERT</CODE> privilege
will set to their default values. ANSI SQL requires you to have the
<CODE>INSERT</CODE> privilege on all columns.

<LI>

ANSI SQL でテーブルを破棄する時、そのテーブルの全ての権限は破棄さ
れます。<CODE>ANSI SQL</CODE> で権限を取り消す場合、この権限に基づいて承認され
た全ての権限も取り消されます。<CODE>MySQL</CODE> では、全ての権限は明示的な 
<CODE>REVOKE</CODE> コマンドまたは <STRONG>MySQL</STRONG> 権限テーブルの操作によっての
み破棄されます。
</UL>



<H3><A NAME="User_names" HREF="manual.ja_toc.html#User_names">4.3.2  MySQL ユーザ名とパスワード</A></H3>

<P>
<A NAME="IDX505"></A>
<A NAME="IDX506"></A>

</P>
<P>
<STRONG>MySQL</STRONG> によって使用されるユーザー名とパスワードの使用のされ方と、
UNIX, Windows で使用される方法とは、いくつか異なる点があります。

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> データベースのアクセス認証に使用するユーザー名は、
UNIX のログインユーザやWindowsのユーザー名で行うことはありません(一致していません)。
利便性をはかるため、多くの <STRONG>MySQL</STRONG> クライアントは現在のログインしているユーザ名を
<STRONG>MySQL</STRONG>のユーザー名としてログインを試みます。
しかしこれは <CODE>-u</CODE> か <CODE>--user</CODE> スイッチで変更できます。
これは、全てのユーザに対しパスワードを設定しておかないと、
全くデータベースを安全にできないことを意味します。
もしパスワードを全ユーザーに設定しておかないと、そのユーザー名で認証なしにサーバーに接続できます。

<LI>

<STRONG>MySQL</STRONG> のユーザー名は 16文字まで(英数半角)使用できます。
UNIXはだいたい8文字ですが。(8文字をこえるシステムもある)

<LI>

<STRONG>MySQL</STRONG> ユーザーのパスワードは、UNIX のパスワードと違います。
よって、それらのマシン上で UNIX のログインパスワードと
データベースのパスワードは同じにする必要はありません。

<LI>

<STRONG>MySQL</STRONG> は UNIX のログインパスワードとは全く違う、
独自の暗号化されたパスワードだけを使用します。
<CODE>PASSWORD()</CODE> と <CODE>ENCRYPT()</CODE> 関数の説明を参照 →  「<A HREF="manual.ja_Reference.html#Miscellaneous_functions">6.3.5.2  その他の関数</A>」節.
注意: パスワードが '暗号化' されて格納されていても、あなたの '暗号化' され
たパスワードを知ることで、<STRONG>MySQL</STRONG> サーバに接続するのには十分です！
</UL>

<P>
MySQL ユーザーと彼らの権限は通常 <CODE>GRANT</CODE> コマンドで作成されます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#GRANT">4.3.1  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照。

</P>
<P>
<STRONG>MySQL</STRONG> サーバにコマンドラインクライアントでログインする時、
<CODE>--password=your-password</CODE> でパスワードを指定すべきです。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Connecting">4.2.7  MySQL サーバーに接続</A>」節参照.

</P>

<PRE>
mysql --user=monty --password=guess database_name
</PRE>

<P>
クライアントにパスワードをプロンプトして欲しければ、引数なしで 
<CODE>--password</CODE> を使用すべきです。

</P>

<PRE>
mysql --user=monty --password database_name
</PRE>

<P>
または次の短い形式:

</P>

<PRE>
mysql -u monty -p database_name
</PRE>

<P>
注意: 最後の例でのパスワードは 'database_name' では <STRONG>ありません</STRONG>。

</P>
<P>
パスワードを供給するために <CODE>-p</CODE> オプションを使用したい場合、次のようなことを
行なうべきです:

</P>

<PRE>
mysql -u monty -pguess database_name
</PRE>

<P>
いくつかのシステムでは、<STRONG>MySQL</STRONG> がパスワードをプロンプトするために
使用するライブラリ呼び出しは、自動的にパスワードを 8文字にカットします。内
部的に <STRONG>MySQL</STRONG> はパスワード長に何の制限もありません。

</P>



<H3><A NAME="Privilege_changes" HREF="manual.ja_toc.html#Privilege_changes">4.3.3  いつ権限の変更が反映されるか</A></H3>

<P>
<CODE>mysqld</CODE> の起動時、全ての許可テーブルはメモリーに読み込まれ、
この時点で有効になります。

</P>
<P>
<CODE>GRANT</CODE>, <CODE>REVOKE</CODE>, <CODE>SET PASSWORD</CODE> を使用して許可テーブルを
変更した場合、直にサーバに通知されます。

</P>
<P>
もし手動で許可テーブルを変更した場合(<CODE>INSERT</CODE>, <CODE>UPDATE</CODE> などで)、
<CODE>FLUSH PRIVILEGES</CODE> 構文か <CODE>mysqladmin flush-privileges</CODE> コマンド
か <CODE>mysqladmin reload</CODE> コマンドを実行して、
サーバーに許可テーブルの読み込みを指示しなければなりません。
そうしなければ、サーバーを再起動させるまで、変更は<EM>反映されません</EM>。
権限テーブルを手で変更して、権限のリロードを忘れた場合、変更が何も行なわれ
ないように見えるのがなぜかと不思議に思うでしょう！

</P>
<P>
サーバーが許可テーブルの変更を通知した場合、既に接続している
クライアントは、以下のような影響を受けます：

</P>

<UL>
<LI>

テーブルとフィールドの許可の変更は、次のクライアントの要求から反映されます。

<LI>

データベースに対する許可の変更は次の <CODE>USE db_name</CODE> コマンド以降から
有効になります。

</UL>

<P>
グローバル権限とパスワードの変更は、次のクライアントの接続時から反映されます。

</P>



<H3><A NAME="Default_privileges" HREF="manual.ja_toc.html#Default_privileges">4.3.4  MySQL 権限許可の初期設定</A></H3>

<P>
<A NAME="IDX507"></A>
<A NAME="IDX508"></A>
<A NAME="IDX509"></A>
<A NAME="IDX510"></A>
<A NAME="IDX511"></A>
<A NAME="IDX512"></A>
<A NAME="IDX513"></A>

</P>
<P>
<STRONG>MySQL</STRONG> インストール後、<CODE>scripts/mysql_install_db</CODE> を
実行して権限のアクセス許可を初期化します。
 「<A HREF="manual.ja_Installing.html#Quick_install">2.3.1  素早いインストールの概要</A>」節参照.
<CODE>mysql_install_db</CODE> スクリプトは <CODE>mysqld</CODE> サーバーを起動し、
以下のように権限を初期化してテーブルに登録します：

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーはスーパーユーザーとして登録され、
全ての操作ができます。
localhostからしか接続できません。

<STRONG>注意:</STRONG>
<CODE>root</CODE> のパスワードの初期値は空です。
全ての人が <EM>パスワードなしで</EM> <CODE>root</CODE> になれ、全ての権限許可を得ることができます。

<LI>

<A NAME="IDX514"></A>
<CODE>'test'</CODE> あるいは <CODE>'test_'</CODE> で名前がはじまっているデータベースに対して、
匿名ユーザーでもなんでもできるように許可が与えられます。
これは ローカルホストからの全てのユーザーは パスワード無しで接続ができ、
匿名ユーザーとして扱われるということです。

<LI>

その他の要求は拒否されます。例えば、一般ユーザーは <CODE>mysqladmin shutdown</CODE> や
 <CODE>mysqladmin processlist</CODE> を実行できません。
</UL>

<P>
<STRONG>注意:</STRONG> デフォルトの権限は Windows では違います。
 「<A HREF="manual.ja_Installing.html#Windows_running">2.6.2.3  Windows 上で MySQL を実行</A>」節参照.

</P>
<P>
初期インストールの状態ではかなりアクセスが解放されているので、
インストール後最初にすることは、<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーにパスワードを設定することです。
以下のようにします(パスワードは <CODE>PASSWORD()</CODE> 関数を使用することをお忘れなく)：

</P>

<PRE>
shell&#62; mysql -u root mysql
mysql&#62; UPDATE user SET Password=PASSWORD('new_password')
           WHERE user='root';
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
<STRONG>MySQL</STRONG> バージョン 3.22 以上では、<CODE>SET PASSWORD</CODE> 構文も使用できます:

</P>

<PRE>
shell&#62; mysql -u root mysql
mysql&#62; SET PASSWORD FOR root=PASSWORD('new_password');
</PRE>

<P>
password をセットする他の方法として、<CODE>mysqladmin</CODE> コマンドも使用できます：

</P>

<PRE>
shell&#62; mysqladmin -u root password new_password
</PRE>

<P>
<CODE>mysql</CODE> データベースに書き込み／更新アクセスのあるユーザだけが他のユーザのパ
スワードを変更できます。すべての通常のユーザ(匿名ユーザ以外)は、上記のコマ
ンドか、または <CODE>SET PASSWORD=PASSWORD('new password')</CODE> で、自分のパス
ワードだけを変更できます。

</P>
<P>
もし最初の方法で <CODE>user</CODE> テーブルのパスワードを直接更新したなら、
サーバーに許可テーブルの再読み込みを行わせなければなりません(<CODE>FLUSH PRIVILEGES</CODE> を使用して)。

</P>
<P>
一度 <CODE>root</CODE> のパスワードを設定したなら、<CODE>root</CODE> でサーバーに接続する場合は
常にパスワードを与えなければなりません。

</P>
<P>
追加設定やテストをしているためパスワードを入れたくない場合、
<CODE>root</CODE> パスワードをブランクのままにしておこうと考えるかも知れませんが、
実稼働させる前には必ず設定してください。

</P>
<P>
どのようにデフォルトの権限を設定しているか、<CODE>scripts/mysql_install_db</CODE> 見てみてください。
これは他のユーザーを設定するときに使えるでしょう。

</P>
<P>
もし権限の初期状態を違うものにして初期化したいなら、
<CODE>mysql_install_db</CODE> を実行する前に編集してもよいでしょう。

</P>
<P>
<A NAME="IDX515"></A>
<A NAME="IDX516"></A>
もしテーブルを完全に作り直したいなら、<CODE>mysql</CODE> データベースのディレクトリに存在する
全ての <TT>`*.frm'</TT>, <TT>`*.MYI'</TT>, <TT>`*.MYD'</TT> ファイルを削除します。
(このディレクトリーはデータベースディレクトリーの下に <CODE>mysql</CODE> という名前で存在します。
<CODE>mysqld --help</CODE> とすればデータベースのディレクトリーが表示されます。)
そして好みの許可状態に <CODE>mysql_install_db</CODE> を編集してから実行します。

</P>
<P>
<STRONG>注意:</STRONG> <STRONG>MySQL</STRONG> 3.22.10 以前のバージョンでは, 
<TT>`*.frm'</TT> ファイルを消してはいけません.  もしうっかり消してしまった場合、
<CODE>mysql_install_db</CODE> を実行する前に、 <STRONG>MySQL</STRONG> 配布からコピーしなおさ
なくてはなりません。

</P>



<H3><A NAME="Adding_users" HREF="manual.ja_toc.html#Adding_users">4.3.5  新しいユーザを MySQL へ追加</A></H3>

<P>
<A NAME="IDX517"></A>
<A NAME="IDX518"></A>

</P>
<P>
<A NAME="IDX519"></A>
<A NAME="IDX520"></A>
<A NAME="IDX521"></A>

</P>
<P>
ユーザーは２つの違った方法で追加できます：
<CODE>GRANT</CODE> 構文を使用して行う方法と、
<STRONG>MySQL</STRONG> の許可テーブルを直接操作する方法とです。
<CODE>GRANT</CODE> 構文の使用をお勧めします。 「<A HREF="manual.ja_MySQL_Database_Administration.html#GRANT">4.3.1  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照。

</P>
<P>
<CODE>phpmyadmin</CODE> のような、ユーザの生成と管理に使用できる contribute され
たプログラムも多くあります。 「<A HREF="manual.ja_Contrib.html#Contrib">D  Contributed Programs</A>」節参照。

</P>
<P>
以下の例では、いかにして <CODE>mysql</CODE> クライアントを使用して新規にユーザーを登録するかを示します。
以下の例では、権限は前節で述べたデフォルト値になっているとします。
よって変更を行うためには、あなたは <CODE>mysqld</CODE> が走っているマシン上にログインしていなくてはなりませんし、
かつ、<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーで接続していなければなりません。
さらに <STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーには
 <CODE>mysql</CODE> データベースに対して <STRONG>insert</STRONG> 権限を持ち、
<STRONG>reload</STRONG> のアドミニストレーター権限を持っていなければなりません。
もし <CODE>root</CODE> ユーザーのパスワードを変えていたならば、
 <CODE>mysql</CODE> コマンドにパスワード指定を与えなくてはなりません。

</P>
<P>
You can add new users by issuing <CODE>GRANT</CODE> statements:

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; GRANT ALL PRIVILEGES ON *.* TO monty@localhost
           IDENTIFIED BY 'some_pass' WITH GRANT OPTION;
mysql&#62; GRANT ALL PRIVILEGES ON *.* TO monty@"%"
           IDENTIFIED BY 'some_pass' WITH GRANT OPTION;
mysql&#62; GRANT RELOAD,PROCESS ON *.* TO admin@localhost;
mysql&#62; GRANT USAGE ON *.* TO dummy@localhost;
</PRE>

<P>
これら <CODE>GRANT</CODE> 構文では3つの新しいユーザを作ります:

</P>
<DL COMPACT>

<DT><CODE>monty</CODE>
<DD>
どこからでもサーバーに接続できる完全なスーパーユーザ。
しかし、<STRONG>MySQL</STRONG> を使用する時にはパスワード <CODE>'some_pass'</CODE> を
使用する必要があります。
<CODE>monty@localhost</CODE> と <CODE>monty@"%"</CODE> の両方に <CODE>GRANT</CODE> 構文を
発行しなくてはならない事に注意してください。
もし <CODE>localhost</CODE> からの許可をした登録がないと、<CODE>localhost</CODE> から接続した時、
<CODE>mysql_install_db</CODE> が自動で作成した <CODE>localhost</CODE> への匿名ユーザーが優先されます。
なぜなら、 <CODE>Host</CODE> フィールドの値が(ブランクやワールドカード以外に)明記されており、
許可登録が MySQL 内部でソートされる時に順番が上にソートされるからです。

<DT><CODE>admin</CODE>
<DD>
<CODE>localhost</CODE> からパスワードなしで接続できますが、<CODE>reload</CODE>, <CODE>process</CODE> の使用だけが許されます。
これは、<CODE>mysqladmin reload</CODE>, <CODE>mysqladmin refresh</CODE>, <CODE>mysqladmin flush-*</CODE> そして
 <CODE>mysqladmin processlist</CODE> コマンドの実行がこのユーザーに許可されます。
データベースへのアクセスは許可されていません。
しかしこれは後でテーブル <CODE>GRANT</CODE> 構文を発行すれば、
個々のデータベースへのアクセス権限が設定できます。

<DT><CODE>dummy</CODE>
<DD>
パスワードなしで localhost からのみ、接続できるユーザー。
グローバルな権限は全て <CODE>'N'</CODE> に設定されます。
<CODE>USAGE</CODE> 権限は権限無しユーザーの設定を許可する事になります。
これは、特定データーベースに対しての許可を後から与える事を想定しています。
</DL>

<P>
<A NAME="IDX522"></A>
<A NAME="IDX523"></A>
同じアクセス許可を <CODE>INSERT</CODE> 構文を使用して直接設定できます。
サーバーに許可テーブルの再読み込みを指示します：

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; INSERT INTO user VALUES('localhost','monty',PASSWORD('some_pass'),
                'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO user VALUES('%','monty',PASSWORD('some_pass'),
                'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO user SET Host='localhost',User='admin',
                 Reload_priv='Y', Process_priv='Y';
mysql&#62; INSERT INTO user (Host,User,Password)
                        VALUES('localhost','dummy','');
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
<STRONG>MySQL</STRONG> のバージョンにより、上の <CODE>'Y'</CODE> の数が違う事に注意してください。
(3.22.11 以前のバージョンでは項目数が少なくなります).
<CODE>admin</CODE> ユーザーを登録で使用している <CODE>INSERT</CODE> の拡張は
バージョン 3.22.11 以上で可能です。

</P>
<P>
スーパーユーザーを定義するためには、<CODE>user</CODE> テーブルの許可フィールドを
<CODE>'Y'</CODE> にするだけでかまいません。
<CODE>db</CODE> や <CODE>host</CODE> テーブルに登録は必要無いのです。

</P>
<P>
<CODE>user</CODE> テーブルの許可フィールドは最後の <CODE>INSERT</CODE> 文で(<CODE>dummy</CODE> ユーザーのために)
は設定されていません。これらのフィールドはデフォルト値の <CODE>'N'</CODE> になります。
これは <CODE>GRANT USAGE</CODE> が行うのと同じものです。

</P>
<P>
以下は、<CODE>localhost</CODE>, <CODE>server.domain</CODE>, <CODE>whitehouse.gov</CODE> から接続が可能な
 <CODE>custom</CODE> ユーザーの追加例です。
 <CODE>custom</CODE> ユーザーは <CODE>bankaccount</CODE> データーベースには <CODE>localhost</CODE> からの接続のみを許可され、
<CODE>expenses</CODE> データベースには <CODE>whitehouse.gov</CODE> からのみ接続が許可され、
<CODE>customer</CODE> データベースには全てのホストから接続できます。
<CODE>custom</CODE> ユーザーは、 <CODE>stupid</CODE> というパスワードを全てのホストで使用したいとします。

</P>
<P>
このユーザーの許可を <CODE>GRANT</CODE> 構文で定義するには、以下のようにします：

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON bankaccount.*
           TO custom@localhost
           IDENTIFIED BY 'stupid';
mysql&#62; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON expenses.*
           TO custom@whitehouse.gov
           IDENTIFIED BY 'stupid';
mysql&#62; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON customer.*
           TO custom@'%'
           IDENTIFIED BY 'stupid';
</PRE>

<P>
The reason that we do to grant statements for the user 'custom' is that
we want the give the user access to MySQL both from the local
machine with Unix sockets and from the remote machine 'whitehouse.gov'
over TCP/IP.

</P>
<P>
許可テーブルを直接変更してこのユーザーの権限を設定するにはいかのようにします
(<CODE>FLUSH PRIVILEGES</CODE> を最後に実行している事に注意)：

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('localhost','custom',PASSWORD('stupid'));
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('server.domain','custom',PASSWORD('stupid'));
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('whitehouse.gov','custom',PASSWORD('stupid'));
mysql&#62; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES
       ('localhost','bankaccount','custom','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES
       ('whitehouse.gov','expenses','custom','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES('%','customer','custom','Y','Y','Y','Y','Y','Y');
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
最初の３つの <CODE>INSERT</CODE> 文は、 <CODE>custom</CODE> ユーザーがそれぞれのホストから
パスワードつきで接続できるように <CODE>user</CODE> テーブルに追加しています。
しかしここでは権限は１つも与えられていません(権限のデフォルト値は <CODE>'N'</CODE> です)。
次の三つの <CODE>INSERT</CODE> 文は、<CODE>bankaccount</CODE>, <CODE>expenses</CODE>, <CODE>customer</CODE>
 データベースに対する該当ホストからのアクセス許可を <CODE>custom</CODE> ユーザーに与えるように、
<CODE>db</CODE> テーブルに追加しています。
許可テーブルが直接変更された場合、これらをサーバーに反映させるために、許可テーブルの
再読み込みを(<CODE>FLUSH PRIVILEGES</CODE>で) サーバーにつげなければなりません。

</P>
<P>
もし、あるドメインの全てのマシンに接続を許可したい場合、
以下のように <CODE>GRANT</CODE> 構文を発行します：

</P>

<PRE>
mysql&#62; GRANT ...
           ON *.*
           TO myusername@"%.mydomainname.com"
           IDENTIFIED BY 'mypassword';
</PRE>

<P>
許可テーブルを直接変更するには以下のようにします：

</P>

<PRE>
mysql&#62; INSERT INTO user VALUES ('%.mydomainname.com', 'myusername',
           PASSWORD('mypassword'),...);
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
もちろん、<CODE>xmysqladmin</CODE>, <CODE>mysql_webadmin</CODE>, そして <CODE>xmysql</CODE> を使って
も、権限テーブルへの値の挿入/変更/更新ができます。これらのユーティリティは 
<a HREF="http://www.mysql.com/Downloads/Contrib/">Contrib directory of the MySQL
Website</a>.
に見つけることができます。

</P>



<H3><A NAME="Passwords" HREF="manual.ja_toc.html#Passwords">4.3.6  パスワードの設定法</A></H3>

<P>
<A NAME="IDX524"></A>
<A NAME="IDX525"></A>

</P>
<P>
<A NAME="IDX526"></A>
<A NAME="IDX527"></A>

</P>
<P>
多くの場合、ユーザ／パスワードを設定するために、<CODE>GRANT</CODE> を使用すべき
です。以下は上級ユーザのためにだけあてはまります。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#GRANT">4.3.1  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照.

</P>
<P>
前節の例で述べた、とても重要な基本原則：
<CODE>INSERT</CODE> か <CODE>UPDATE</CODE> で空ではないパスワードを設定する場合、
暗号化するために <CODE>PASSWORD()</CODE> 関数を使用しなくてはなりません。
これは <CODE>user</CODE> テーブルはプレーンテキストでなく、暗号化されたパスワードであることを要求しているからです。
この原則を忘れてしまった場合、以下のようにしてパスワードをセットしてしまうかもしれません：

</P>

<PRE>
shell&#62; mysql -u root mysql
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('%','jeffrey','biscuit');
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
これは <CODE>user</CODE> テーブルにプレーンテキストの <CODE>'biscuit'</CODE> をパスワードとして登録してしまいます。
<CODE>jeffrey</CODE> ユーザーでこのパスワードを使用してサーバーに接続しようとすると、
 <CODE>mysql</CODE> クライアントは暗号化したパスワードをサーバーに送ります。
サーバーは暗号化されたパスワード(<CODE>'biscuit'</CODE> では<EM>ありません</EM>) と
 <CODE>user</CODE> テーブルに登録された値(<CODE>'biscuit'</CODE>) を比較します。
その結果、比較は失敗し、サーバーは接続を拒否します：

</P>

<PRE>
shell&#62; mysql -u jeffrey -pbiscuit test
Access denied
</PRE>

<P>
 <CODE>user</CODE> テーブルに登録されるパスワードは暗号化されたものでなくてはなりません。
<CODE>INSERT</CODE> 構文は以下のようにして使用しなくてはなりません：

</P>

<PRE>
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('%','jeffrey',PASSWORD('biscuit'));
</PRE>

<P>
<CODE>SET PASSWORD</CODE> 構文を使用する場合は、以下のようにしなくてはなりません：

</P>

<PRE>
mysql&#62; SET PASSWORD FOR jeffrey@"%" = PASSWORD('biscuit');
</PRE>

<P>
もし <CODE>GRANT ... IDENTIFIED BY</CODE> 構文や <CODE>mysqladmin password</CODE> コマンド
でパスワードを設定した場合、<CODE>PASSWORD()</CODE> 関数は必要ありません。
両方とも、パスワードを暗号化してくれますので、
以下のように<CODE>'biscuit'</CODE>と与えます：

</P>

<PRE>
mysql&#62; GRANT USAGE ON *.* TO jeffrey@"%" IDENTIFIED BY 'biscuit';
</PRE>

<P>
or

</P>

<PRE>
shell&#62; mysqladmin -u jeffrey password biscuit
</PRE>

<P>
<STRONG>注意</STRONG>： <CODE>PASSWORD()</CODE> がパスワードを暗号化することに注意してください。
この暗号化は UNIX のパスワードで使用されている暗号化と違うことにも留意してください。
UNIX パスワードファイルに記録されている暗号と <CODE>PASSWORD()</CODE> が暗号化した物が同じでも、
同じパスワードであるとは思わないでください。 「<A HREF="manual.ja_MySQL_Database_Administration.html#User_names">4.3.2  MySQL ユーザ名とパスワード</A>」節参照.

</P>



<H3><A NAME="Password_security" HREF="manual.ja_toc.html#Password_security">4.3.7  パスワードを安全にする</A></H3>

<P>
自分のパスワードを他人にさらけ出すのは勧められることではありません。
それぞれの方法に於ける危険度に応じ、以下に示す方法でクライアントプログラムに
あなたのパスワードをあたえて走らせることができます：

</P>

<UL>
<LI>

一般ユーザに <CODE>mysql.user</CODE> テーブルへのアクセスを与えてはいけません。
ユーザの暗号化されたパスワード知ることで、そのユーザとしてログインが可能に
なります。パスワードは、使用される本当のパスワードを見ることができないよう
に、スクランブルされているだけです(同じようなパスワードを他のアプリケーショ
ンでたまたま使用する場合のため)。

<LI>

<CODE>-pyour_pass</CODE> か <CODE>--password=your_pass</CODE> オプションをコマンドラインで使用します。
これは便利ですが安全ではありません。あなたのパスワードは (<CODE>ps</CODE> コマンドのような)
システムの状態を見るコマンドにて見ることができます。
(<STRONG>MySQL</STRONG> クライアントは初期化過程においてコマンドラインの引数をゼロで上書きして
見せないようにしているのですが、瞬間ですが値が見えてしまうのです)

<LI>

<CODE>-p</CODE> あるいは <CODE>--password</CODE> オプションを <CODE>your_pass</CODE> を与えないで使用します。
この場合、クライアントプログラムはターミナルを通じてパスワードの入力を促してきます:
<A NAME="IDX528"></A>
<A NAME="IDX529"></A>


<PRE>
shell&#62; mysql -u user_name -p
Enter password: ********
</PRE>

<SAMP>`*'</SAMP> 文字はパスワードを表しています。

クライアントはあなたの入力したパスワードを <SAMP>`*'</SAMP> 文字で端末に返していますので、
画面をのぞき込まれたとしてもパスワードはわかりません。

これはコマンドラインにパスワードを指定するより安全です。他のユーザーには見えませんから。
しかしこのパスワードを毎回入れる方法は対話式のプログラムを実行する場合だけに使用できる手です。
もし非対話式のスクリプトからクライアントプログラムを起動したい場合、
パスワードを端末から入れる機会がありません。
On some systems, you may even find that the first line of your
script is read and interpreted (incorrectly) as your password!
 
<LI>

<A NAME="IDX530"></A>
設定ファイルにパスワードを書いておくこともできます。
例えば、自分のホームディレクトリーにある <TT>`.my.cnf'</TT> ファイルの <CODE>[client]</CODE>
セクションに、以下のような形で書きます：


<PRE>
[client]
password=your_pass
</PRE>

もし <TT>`.my.cnf'</TT> ファイルにパスワードを書いているなら、ファイルはグループや
その他のユーザーが読み書きできないようにすべきです。ファイルのモードは <CODE>400</CODE>
か <CODE>600</CODE> にします。

 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.
<LI>

<CODE>MYSQL_PWD</CODE> 環境変数にパスワードを設定することもできます。しかしこの方法は
きわめて危険であるので、使用すべきではありません。
<CODE>ps</CODE> のあるバージョンでは、実行中のプロセスの環境変数を表示するオプションがあります；
もし <CODE>MYSQL_PWD</CODE> 環境変数にパスワードを設定していると全てべたで見れます。
このバージョンの <CODE>ps</CODE> を持っていないシステムだとしても、プロセスの環境変数を調べる
方法がないとはいえないので、この方法はあまりいい方法ではありません。
 「<A HREF="manual.ja_Environment_variables.html#Environment_variables">H  Environment Variables</A>」節参照.
</UL>

<P>
まとめると、より安全な方法は、
パスワードプロンプトを返すクライアントプログラムを実行するか、
適切なパーミッションをかけた <TT>`.my.cnf'</TT> ファイルにパスワードを書くか
です。

</P>



<H2><A NAME="Disaster_Prevention" HREF="manual.ja_toc.html#Disaster_Prevention">4.4  Disaster Prevention and Recovery</A></H2>



<H3><A NAME="Backup" HREF="manual.ja_toc.html#Backup">4.4.1  データベースのバックアップ</A></H3>

<P>
<A NAME="IDX531"></A>
<A NAME="IDX532"></A>

</P>
<P>
<STRONG>MySQL</STRONG> テーブルはファイルとして格納されるため、バックアップを行
うのは簡単です。矛盾のないバックアップを得るためには、
<CODE>FLUSH TABLES</CODE> をおこなって、<CODE>LOCK TABLES</CODE> 
を関連するテーブルで行ってください。 「<A HREF="manual.ja_Reference.html#LOCK_TABLES">6.7.2  <CODE>LOCK TABLES/UNLOCK TABLES</CODE> 構文</A>」節参照.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#FLUSH">4.5.3  <CODE>FLUSH</CODE> 構文</A>」節参照.
読み込みロックだ
けが必要なので、そのテーブルでデータベースディレクトリのファイルのコピー
が行われている間も、他のスレッドはクエリを継続できます。
The <CODE>FLUSH TABLE</CODE> is needed to ensure that
the all active index pages is written to disk before you start the backup.

</P>
<P>
もし、テーブルを
SQL レベルでバックアップしたいのであれば、<CODE>SELECT INTO OUTFILE</CODE> か
<CODE>BACKUP TABLE</CODE> を使用できます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#BACKUP_TABLE">4.4.2  <CODE>BACKUP TABLE</CODE> Syntax</A>」節参照.

</P>
<P>
他の方法は <CODE>mysqldump</CODE> プログラムか
<CODE>mysqlhotcopy スクリプト</CODE> を使用することです。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqldump">4.8.5  mysqldump, データベースとテーブルから、構造とデータをダンプ</A>」節参照.  「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqldump">4.8.5  mysqldump, データベースとテーブルから、構造とデータをダンプ</A>」節参照.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqlhotcopy">4.8.6  mysqlhotcopy, Copying MySQL Databases and Tables</A>」節参照.

</P>

<OL>
<LI>

フルバックアップをとるには：


<PRE>
shell&#62; mysqldump --tab=/path/to/some/dir --opt --full

or

shell&#62; mysqlhotcopy database /path/to/some/dir
</PRE>

You can also simply copy all table files (<TT>`*.frm'</TT>, <TT>`*.MYD'</TT>, and
<TT>`*.MYI'</TT> files) as long as the server isn't updating anything.
The script <CODE>mysqlhotcopy</CODE> does use this method.

<LI>

<A NAME="IDX533"></A>
<CODE>mysqld</CODE> を止め、そして <CODE>--log-update[=file_name]</CODE> オプションをつけて起動します。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Update_log">4.9.3  更新ログ</A>」節参照.  ログファイルは、 <CODE>mysqldump</CODE> 実行後に行われたデータベースの変更を
複製するための情報を与えてくれます。
</OL>

<P>
もしリストアをしなければならない場合、まず最初に <CODE>REPAIR TABLE</CODE> か
<CODE>myisamchk -r</CODE> を実行してテーブルの修復を試みてください。
ほとんどの場合、99.9% 修復はできるはずです。
もし <CODE>myisamchk</CODE> が失敗した場合、以下のようにします：
(This will only work if you have started MySQL with
<CODE>--log-update</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Update_log">4.9.3  更新ログ</A>」節参照.):

</P>

<OL>
<LI>

オリジナルの <CODE>mysqldump</CODE> バックアップデータをリストアします。
<LI>

次のコマンドを実行して、バイナリログ内の更新を再実行します。


<PRE>
shell&#62; mysqlbinlog hostname-bin.[0-9]* | mysql
</PRE>

更新ログを使用する場合は、次のようにできます:


<PRE>
shell&#62; ls -1 -t -r hostname.[0-9]* | xargs cat | mysql
</PRE>

</OL>

<P>
<CODE>ls</CODE> は、全ての更新ログファイルを正しい順で得るために行われます。

</P>
<P>
<CODE>SELECT * INTO OUTFILE 'file_name' FROM tbl_name</CODE> での選択的バックアップと 
<CODE>LOAD DATA FROM INFILE 'file_name' REPLACE ...</CODE> でのリストアを行う
こともできます。重複レコードを避けるためには、テーブル内に <CODE>PRIMARY KEY</CODE>
 or a <CODE>UNIQUE</CODE> が必要です。<CODE>REPLACE</CODE> は、'重複インデックス' 衝突があった場合、
新しいレコードを挿入する時に古いレコードが新しいものに置き換えられることを意味します。

</P>
<P>
If you get performance problems in making backups on your system, you can
solve this by setting up replication and do the backups on the slave
instead of on the master.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Replication_Intro">4.10.1  紹介</A>」節参照.

</P>
<P>
If you are using a Veritas file system, you can do:

</P>

<OL>
<LI>

Execute in a client (perl ?) <CODE>FLUSH TABLES WITH READ LOCK</CODE>

<LI>

Fork a shell or execute in another client <CODE>mount vxfs snapshot</CODE>.

<LI>

Execute in the first client <CODE>UNLOCK TABLES</CODE>

<LI>

Copy files from snapshot

<LI>

Unmount snapshot
</OL>



<H3><A NAME="BACKUP_TABLE" HREF="manual.ja_toc.html#BACKUP_TABLE">4.4.2  <CODE>BACKUP TABLE</CODE> Syntax</A></H3>

<P>
<A NAME="IDX534"></A>

</P>
<P>
<A NAME="IDX535"></A>

</P>

<PRE>
BACKUP TABLE tbl_name[,tbl_name...] TO '/path/to/backup/directory'
</PRE>

<P>
Make a copy of all the table files to the backup directory that are the
minimum needed to restore it. Currenlty only works for <CODE>MyISAM</CODE>
tables. For <CODE>MyISAM</CODE> table, copies <CODE>.frm</CODE> (definition)  and
<CODE>.MYD</CODE> (data) files. The index file can be rebuilt from those two.

</P>
<P>
Before using this command, please see  「<A HREF="manual.ja_MySQL_Database_Administration.html#Backup">4.4.1  データベースのバックアップ</A>」節参照.

</P>
<P>
During the backup, read lock will be held for each table, one at time,
as they are being backed up. If you want to backup several tables as
a snapshot, you must first issue <CODE>LOCK TABLES</CODE> obtaining a read
lock for each table in the group.

</P>
<P>
The command returns a table with the following columns:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Column</STRONG> </TD><TD> <STRONG>Value</STRONG>
</TR NOSAVE>
<TR><TD>Table </TD><TD> Table name
</TR NOSAVE>
<TR><TD>Op </TD><TD> Always ``backup''
</TR NOSAVE>
<TR><TD>Msg_type </TD><TD> One of <CODE>status</CODE>, <CODE>error</CODE>, <CODE>info</CODE> or <CODE>warning</CODE>.
</TR NOSAVE>
<TR><TD>Msg_text </TD><TD> The message.
</TR>
</TABLE>

<P>
Note that <CODE>BACKUP TABLE</CODE> is only available in MySQL
version 3.23.25 and later.

</P>



<H3><A NAME="RESTORE_TABLE" HREF="manual.ja_toc.html#RESTORE_TABLE">4.4.3  <CODE>RESTORE TABLE</CODE> Syntax</A></H3>

<P>
<A NAME="IDX536"></A>

</P>

<PRE>
RESTORE TABLE tbl_name[,tbl_name...] FROM '/path/to/backup/directory'
</PRE>

<P>
Restores the table(s) from the backup that was made with
<CODE>BACKUP TABLE</CODE>. Existing tables will not be overwritten - if you
try to restore over an existing table, you will get an error. Restore
will take  longer than BACKUP due to the need to rebuilt the index. The
more keys you have, the longer it is going to take. Just as
<CODE>BACKUP TABLE</CODE>, currently only works of <CODE>MyISAM</CODE> tables.

</P>

<P>
The command returns a table with the following columns:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Column</STRONG> </TD><TD> <STRONG>Value</STRONG>
</TR NOSAVE>
<TR><TD>Table </TD><TD> Table name
</TR NOSAVE>
<TR><TD>Op </TD><TD> Always ``restore''
</TR NOSAVE>
<TR><TD>Msg_type </TD><TD> One of <CODE>status</CODE>, <CODE>error</CODE>, <CODE>info</CODE> or <CODE>warning</CODE>.
</TR NOSAVE>
<TR><TD>Msg_text </TD><TD> The message.
</TR>
</TABLE>



<H3><A NAME="CHECK_TABLE" HREF="manual.ja_toc.html#CHECK_TABLE">4.4.4  <CODE>CHECK TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX537"></A>

</P>

<PRE>
CHECK TABLE tbl_name[,tbl_name...] [option [option...]]

option = QUICK | FAST | MEDIUM | EXTENDED | CHANGED
</PRE>

<P>
<CODE>CHECK TABLE</CODE> は <CODE>MyISAM</CODE> テーブルでだけ動作します。
<CODE>MyISAM</CODE> テーブルでは、テーブル上で <CODE>myisamchk -m table_name</CODE> を
実行するのと同じことです。

</P>
<P>
オプションを何も指定しない場合は <CODE>MEDIUM</CODE> が使用されます。

</P>
<P>
テーブルのエラーチェックを行ないます。<CODE>MyISAM</CODE> テーブルではキー統計が
更新されます。
このコマンドは次のフィールドを持つテーブルを返します:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Column</STRONG> </TD><TD> <STRONG>Value</STRONG>
</TR NOSAVE>
<TR><TD>Table </TD><TD> テーブル名
</TR NOSAVE>
<TR><TD>Op </TD><TD> 常に ``check''
</TR NOSAVE>
<TR><TD>Msg_type </TD><TD> code{status}, <CODE>error</CODE>, <CODE>info</CODE>, <CODE>warning</CODE> の一つ。
</TR NOSAVE>
<TR><TD>Msg_text </TD><TD> メッセージ。
</TR>
</TABLE>

<P>
注意: チェックされた各テーブルに対する情報の多くのレコードが得られます。
最後の１レコードは <CODE>Msg_type status</CODE> になり、通常は <CODE>OK</CODE> で
あるべきです。<CODE>OK</CODE> や <CODE>Not checked</CODE> が得られない場合は、
テーブルの修復を通常通り実行すべきです。  「<A HREF="manual.ja_MySQL_Database_Administration.html#Table_maintenance">4.4.6  テーブルのメンテナンス、クラッシュからの修復のための <CODE>myisamchk</CODE> 使用</A>」節参照.
<CODE>Not checked</CODE> means that the table the given <CODE>TYPE</CODE>
told MySQL that there wasn't any need to check the table.

</P>
<P>
様々なチェックタイプは次の意味です:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Type</STRONG> </TD><TD> <STRONG>Meaning</STRONG>
</TR NOSAVE>
<TR><TD><CODE>QUICK</CODE> </TD><TD> 間違ったリンクをチェックするレコードを走査しません。
</TR NOSAVE>
<TR><TD><CODE>FAST</CODE> </TD><TD> 正しくクローズされなかったテーブルだけをチェックします。
</TR NOSAVE>
<TR><TD><CODE>CHANGED</CODE> </TD><TD> 最後にチェックしてから変更されたテーブルと、正しくクローズされなかったテーブルだけをチェックします。
</TR NOSAVE>
<TR><TD><CODE>MEDIUM</CODE> </TD><TD> 削除されたリンクが OK であることを確かめるためにレコードを走査します。これはレコードのキーチェックサムも計算し、キーの計算されたチェックサムをで、これを確かめます。
</TR NOSAVE>
<TR><TD><CODE>EXTENDED</CODE> </TD><TD> 各レコードのすべてのキーを完全キー検索を行ないます。テーブルが 100% 正当なことを確実にしますが、長い時間が掛かります！
</TR>
</TABLE>

<P>
動的なサイズの <CODE>MyISAM</CODE> テーブルについて、開始されたチェックは常に 
<CODE>MEDIUM</CODE> チェックを行ないます。清適サイズレコードでは、レコードはめっ
たに壊れないので、<CODE>QUICK</CODE> と <CODE>FAST</CODE> ではレコードスキャンをスキッ
プします。

</P>
<P>
チェックオプションは次のように組み合わせられます:

</P>

<PRE>
CHECK TABLE test_table FAST QUICK;
</PRE>

<P>
これは、テーブルが正しくクローズされなかったかどうかだけを素早くチェックし
ます。

</P>
<P>
<STRONG>NOTE:</STRONG> いくつかのケースでは <CODE>CHECK TABLE</CODE> はテーブルを変更し
ます！ これはテーブルが '汚れている' か '正しくクローズされなかった' とマー
クされているのに、<CODE>CHECK TABLE</CODE> がテーブル内に何も問題を発見しなかっ
た場合に発生します。この場合、<CODE>CHECK TABLE</CODE> はテーブルを OK とマーク
します。

</P>
<P>
If a table is corrupted, then it's most likely that the problem is in
the indexes and not in the data part.  All of the above check types
checks the indexes throughly and should thus find most errors.

</P>
<P>
If you just want to check a table that you assume is ok, you should use
no check options or the <CODE>QUICK</CODE> option. The later should be used
when you are in a hurry and can take the very small risk that
<CODE>QUICK</CODE> didn't find an error in the data file (In most cases
MySQL should find, under normal usage, any error in the data
file. If this happens then the table will be marked as 'corrupted',
in which case the table can't be used until it's repaired).

</P>
<P>
<CODE>FAST</CODE> and <CODE>CHANGED</CODE> are mostly intended to be used from a
script (for example to be executed from cron) if you want to check your
table from time to time. In most cases you <CODE>FAST</CODE> is to be prefered
over <CODE>CHANGED</CODE>.  (The only case when it isn't is when you suspect a
bug you have found a bug in the <CODE>MyISAM</CODE> code.).

</P>
<P>
<CODE>EXTENDED</CODE> is only to be used after you have run a normal check but
still get strange errors from a table when MySQL tries to
update a row or find a row by key (this is VERY unlikely to happen if a
normal check has succeeded!).

</P>
<P>
Some things reported by check table, can't be corrected automatically:

</P>

<UL>
<LI>

<CODE>Found row where the auto_increment column has the value 0</CODE>.

This means that you have in the table a row where the
<CODE>auto_increment</CODE> index column contains the value 0.
(It's possible to create a row where the auto_increment column is 0 by
explicitely setting the column to 0 with an <CODE>UPDATE</CODE> statement)

This isn't an error in itself, but could cause trouble if you decide to
dump the table and restore it or do an <CODE>ALTER TABLE</CODE> on the
table. In this case the auto_increment column will change value,
according to the rules of auto_increment columns, which could cause
problems like a duplicate key error.

To get rid of the warning, just execute an <CODE>UPDATE</CODE> statement
to set the column to some other value than 0.
</UL>



<H3><A NAME="REPAIR_TABLE" HREF="manual.ja_toc.html#REPAIR_TABLE">4.4.5  <CODE>REPAIR TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX538"></A>

</P>

<PRE>
REPAIR TABLE tbl_name[,tbl_name...] [QUICK] [EXTENDED]
</PRE>

<P>
<CODE>REPAIR TABLE</CODE> は <CODE>MyISAM</CODE> テーブルだけで動作します。テーブルに 
<CODE>myisamchk -r table_name</CODE> を実行することと同じです。

</P>
<P>
Normally you should never have to run this command, but if disaster strikes
you are very likely to get back all your data from a MyISAM table with
<CODE>REPAIR TABLE</CODE>. If your tables get corrupted a lot you should
try to find the reason for this!  「<A HREF="manual.ja_Problems.html#Crashing">A.4.1  What To Do If MySQL Keeps Crashing</A>」節参照.  「<A HREF="manual.ja_Table_types.html#MyISAM_table_problems">7.1.3  MyISAM table problems.</A>」節参照.

</P>
<P>
<CODE>REPAIR TABLE</CODE> はなんとかなる壊れたテーブルを修復します。コマンドは次
のフィールドを含む表を返します:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Column</STRONG> </TD><TD> <STRONG>Value</STRONG>
</TR NOSAVE>
<TR><TD>Table </TD><TD> テーブル名
</TR NOSAVE>
<TR><TD>Op </TD><TD> Always ``repair''
</TR NOSAVE>
<TR><TD>Msg_type </TD><TD> <CODE>status</CODE>, <CODE>error</CODE>, <CODE>info</CODE>, <CODE>warning</CODE> のどれか
</TR NOSAVE>
<TR><TD>Msg_text </TD><TD> メッセージ
</TR>
</TABLE>

<P>
注意: 修復された各テーブルの情報の多くのレコードを得ることがあります。最後
の１レコードは <CODE>Msg_type status</CODE> になり、通常は <CODE>OK</CODE> であるべき
です。<CODE>OK</CODE> が得られなければ、<CODE>myisamchk -o</CODE> でテーブルの修復を試
みるべきです。<CODE>REPAIR TABLE</CODE> はまだ、<CODE>myisamchk</CODE> のオプションの
全てを持っていないからです。 In the near
future, we will make it more flexible.

</P>
<P>
<CODE>QUICK</CODE> が与えられた場合は、<STRONG>MySQL</STRONG> はインデックスツリー
の <CODE>REPAIR</CODE> だけを試みます。

</P>
<P>
If you use <CODE>EXTENDED</CODE> then MySQL will create the index row
by row instead of creating one index at a time with sorting;  This may be
better than sorting on fixed-length keys if you have long <CODE>char()</CODE>
keys that compress very good.

</P>



<H3><A NAME="Table_maintenance" HREF="manual.ja_toc.html#Table_maintenance">4.4.6  テーブルのメンテナンス、クラッシュからの修復のための <CODE>myisamchk</CODE> 使用</A></H3>

<P>
Starting with MySQL Version 3.23.13, you can check MyISAM
tables with the <CODE>CHECK TABLE</CODE> command.  「<A HREF="manual.ja_MySQL_Database_Administration.html#CHECK_TABLE">4.4.4  <CODE>CHECK TABLE</CODE> 構文</A>」節参照.  You can
repair tables with the <CODE>REPAIR TABLE</CODE> command.  「<A HREF="manual.ja_MySQL_Database_Administration.html#REPAIR_TABLE">4.4.5  <CODE>REPAIR TABLE</CODE> 構文</A>」節参照.

</P>
<P>
MyISAM テーブル (<CODE>.MYI</CODE> and <CODE>.MYD</CODE>) の検査・修復には <CODE>myisamchk</CODE> を
使用します。
ISAM テーブル (<CODE>.ISM</CODE> and <CODE>.ISD</CODE>) の検査・修復には <CODE>isamchk</CODE> を
使用します。  「<A HREF="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</A>」節参照.

</P>
<P>
以下の文は <CODE>myisamchk</CODE> について述べていますが、<CODE>isamchk</CODE> にもすべて
当てはまります。

</P>
<P>
<CODE>myisamchk</CODE> ユーティリティは、データベースのテーブルの情報を得たり、
チェックしたり、テーブルの修復や最適化に使用します。
以下のセクションでは、 <CODE>myisamchk</CODE> の起動方法(オプションの説明も含む)、
テーブルの保守スケジュールのたて方、
<CODE>myisamchk</CODE> の色々な機能の使い方を述べます。

</P>
<P>
テーブルの修復と最適化のために、ほとんどの場合、 <CODE>OPTIMIZE TABLES</CODE> 
コマンドが使用できます。しかしこれは <CODE>myisamchk</CODE> に比べて、
遅くて確実でもありません。(fatal error発生時の場合)。これは
その反面、使用方法が簡単でテーブルのフラッシュを気にかける必要がありません。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  <CODE>OPTIMIZE TABLE</CODE> 構文</A>」節参照.

</P>
<P>
Even that the repair in <CODE>myisamchk</CODE> is quite secure, it's always a
good idea to make a backup BEFORE doing a repair (or anything that could
make a lot of changes to a table)

</P>



<H4><A NAME="myisamchk_syntax" HREF="manual.ja_toc.html#myisamchk_syntax">4.4.6.1  <CODE>myisamchk</CODE> 起動構文</A></H4>

<P>
<CODE>myisamchk</CODE> は以下のようにして起動します:

</P>

<PRE>
shell&#62; myisamchk [options] tbl_name
</PRE>

<P>
<CODE>options</CODE> に、あなたが <CODE>myisamchk</CODE> にさせたいことを指定します。
その説明は後述します。(<CODE>myisamchk --help</CODE> と実行すれば、オプションの一覧が取れます)。
オプションがなければ、 <CODE>myisamchk</CODE> は単にテーブルを検査するだけです。
より多くの情報を得たい、あるいは、 <CODE>myisamchk</CODE> に誤り訂正の行動を
取らせる事については、後述します。

</P>
<P>
<CODE>tbl_name</CODE> は検査/修復したいテーブル名です。
もしどこか違うディレクトリにあるデータベースに対して <CODE>myisamchk</CODE> を走らせたいなら、
 <CODE>myisamchk</CODE> にはファイルがどこにあるかわからないので、
ファイルのパスを指定しなければなりません。
実際、 <CODE>myisamchk</CODE> はあなたが使用しているファイルがデータベースのディレクトリにある
かどうかは考慮しません；
ほかの場所にデータベーステーブルのファイルをコピーし、そのコピーしたファイルに対して
回復操作を実行することができます。

</P>
<P>
<CODE>myisamchk</CODE> コマンドラインには、複数のテーブル名が指定できます。
また、インデックスファイル名(<TT>`.MYI'</TT> 接尾語のついたファイル)も指定でき、
さらに <TT>`*.MYI'</TT> とすれば、ディレクトリ内の全てのテーブルが指定できます。
例えば、現在のカレントディレクトリがデーターベースディレクトリならば、
そのディレクトリ内の全てのテーブルは、以下のようにして検査できます：

</P>

<PRE>
shell&#62; myisamchk *.MYI
</PRE>

<P>
データベースディレクトリに入っていない場合、
パスを指定することにより全てのテーブルが検査できます：

</P>

<PRE>
shell&#62; myisamchk /path/to/database_dir/*.MYI
</PRE>

<P>
<STRONG>MySQL</STRONG> データディレクトリのパスにワイルドカードを使用することにより、
データベースの全てのテーブルも検査できます：

</P>

<PRE>
shell&#62; myisamchk /path/to/datadir/*/*.MYI
</PRE>

<P>
The recommended way to quickly check all tables is:

</P>

<PRE>
myisamchk --silent --fast /path/to/datadir/*/*.MYI
isamchk --silent /path/to/datadir/*/*.ISM
</PRE>

<P>
If you want to check all tables and repair all tables that are corrupted,
you can use the following line:

</P>

<PRE>
myisamchk --silent --force --fast --update-state -O key_buffer=64M -O sort_buffer=64M -O read_buffer=1M -O write_buffer=1M /path/to/datadir/*/*.MYI
isamchk --silent --force -O key_buffer=64M -O sort_buffer=64M -O read_buffer=1M -O write_buffer=1M /path/to/datadir/*/*.ISM
</PRE>

<P>
The above assumes that you have more than 64 M free.

</P>
<P>
Note that if you get an error like:

</P>

<PRE>
myisamchk: warning: 1 clients is using or hasn't closed the table properly
</PRE>

<P>
This means that you are trying to check a table that has been updated by
the another program (like the <CODE>mysqld</CODE> server) that hasn't yet closed
the file or that has died without closing the file properly.

</P>
<P>
If you <CODE>mysqld</CODE> is running, you must force a sync/close of all
tables with <CODE>FLUSH TABLES</CODE> and ensure that no one is using the
tables while you are running <CODE>myisamchk</CODE>.  In MySQL Version 3.23
the easiest way to avoid this problem is to use <CODE>CHECK TABLE</CODE>
instead of <CODE>myisamchk</CODE> to check tables.

</P>



<H4><A NAME="myisamchk_general_options" HREF="manual.ja_toc.html#myisamchk_general_options">4.4.6.2  <CODE>myisamchk</CODE> の一般オプション</A></H4>

<P>
<A NAME="IDX539"></A>
<A NAME="IDX540"></A>

</P>
<P>
<CODE>myisamchk</CODE> supports the following options.

</P>
<DL COMPACT>

<DT><CODE>-# or --debug=debug_options</CODE>
<DD>
デバッグログの出力。
<CODE>debug_options</CODE> はよく <CODE>'d:t:o,filename'</CODE> とされます。

<DT><CODE>-? or --help</CODE>
<DD>
ヘルプを表示して終了。

<DT><CODE>-O var=option, --set-variable var=option</CODE>
<DD>
変数に値を入れます。可能な変数は <CODE>myisamchk --help</CODE> で確認できます:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>key_buffer_size </TD><TD> 523264
</TR NOSAVE>
<TR><TD>read_buffer_size </TD><TD> 262136
</TR NOSAVE>
<TR><TD>write_buffer_size </TD><TD> 262136
</TR NOSAVE>
<TR><TD>sort_buffer_size </TD><TD> 2097144
</TR NOSAVE>
<TR><TD>sort_key_blocks </TD><TD> 16
</TR NOSAVE>
<TR><TD>decode_bits </TD><TD> 9
</TR>
</TABLE>

<CODE>sort_buffer_size</CODE> is used when the keys are repaired by sorting
keys, which is the normal case when you use <CODE>--recover</CODE>.

<CODE>key_buffer_size</CODE> is used when you are checking the table with
<CODE>--extended-check</CODE> or when the keys are repaired by inserting key
row by row in to the table (like when doing normal inserts). Repairing
through the key buffer is used in the following cases:


<UL>
<LI>

If you use <CODE>--safe-recover</CODE>.
<LI>

If you are using a <CODE>FULLTEXT</CODE> index.
<LI>

If the temporary files needed to sort the keys would be more than twice
as big as when creating the key file directly.  This is often the case
when you have big <CODE>CHAR</CODE>, <CODE>VARCHAR</CODE> or <CODE>TEXT</CODE> keys as the
sort needs to store the whole keys during sorting. If you have lots
of temporary space and you can force <CODE>myisamchk</CODE> to repair by sorting
you can use the <CODE>--sort-recover</CODE> option.
</UL>

Reparing through the key buffer takes much less disk space than using
sorting, but is also much slower.

もし速い修復を望むなら、メモリの 1/4 を上記の変数にセットします。
You can set both variables to big values, as only one
of the above buffers will be used at a time.

<DT><CODE>-s or --silent</CODE>
<DD>
静粛モード。
エラーのみを出力します。
二度 <CODE>-s</CODE> を指定すると(<CODE>-ss</CODE>)、<CODE>myisamchk</CODE> は
ほとんど出力をしなくなります。

<DT><CODE>-v or --verbose</CODE>
<DD>
冗長モード。より多く情報を出力します。
<CODE>-d</CODE> と <CODE>-e</CODE> オプションと共に使用できます。
<CODE>-v</CODE> を複数指定すると(<CODE>-vv</CODE>, <CODE>-vvv</CODE>)、もっと出力が多くなります！

<DT><CODE>-V or --version</CODE>
<DD>
<CODE>myisamchk</CODE> バージョンを表示して終了。

<DT><CODE>-w or, --wait</CODE>
<DD>
Instead of giving an error if the table is locked, wait until the table
is unlocked before continuing.  Note that if you are running <CODE>mysqld</CODE>
on the table with <CODE>--skip-locking</CODE>, the table can only be locked
by another <CODE>myisamchk</CODE> command.
</DL>



<H4><A NAME="myisamchk_check_options" HREF="manual.ja_toc.html#myisamchk_check_options">4.4.6.3  <CODE>myisamchk</CODE> の検査オプション</A></H4>

<P>
<A NAME="IDX541"></A>
<A NAME="IDX542"></A>

</P>
<DL COMPACT>

<DT><CODE>-c or --check</CODE>
<DD>
テーブルのエラーをチェック。 これは <CODE>myisamchk</CODE> にオプションを
与えていない時のデフォルトです。

<DT><CODE>-e or --extend-check</CODE>
<DD>
テーブルを非常に徹底的に検査します。 (ただし多くのインデックスがある場合、
とても遅くなります。). 極端な場合にだけで必要とされます。
通常 <CODE>myisamchk</CODE> や <CODE>myisamchk --medium-check</CODE> は、
このオプションなしで全てのエラーを見つけるはずです。

多くのメモリがマシンにあるなら、<CODE>--extended-check</CODE> を使用する際には
<CODE>key_buffer_size</CODE> の値を多く増やします。

<DT><CODE>-F or --fast</CODE>
<DD>
Check only tables that haven't been closed properly.

<DT><CODE>-C or --check-only-changed</CODE>
<DD>
Check only tables that have changed since the last check.

<DT><CODE>-f or --force</CODE>
<DD>
Restart <CODE>myisamchk</CODE> with <CODE>-r</CODE> (repair) on the table, if
<CODE>myisamchk</CODE> finds any errors in the table.

<DT><CODE>-i or --information</CODE>
<DD>
検査されたテーブルの統計情報を表示。

<DT><CODE>-m or --medium-check</CODE>
<DD>
Faster than extended-check, but only finds 99.99% of all errors.
Should, however, be good enough for most cases.

<DT><CODE>-U or --update-state</CODE>
<DD>
Store in the <TT>`.MYI'</TT> file when the table was checked and if the table crashed.  This should be used to get full benefit of the
<CODE>--check-only-changed</CODE> option, but you shouldn't use this
option if the <CODE>mysqld</CODE> server is using the table and you are
running <CODE>mysqld</CODE> with <CODE>--skip-locking</CODE>.

<DT><CODE>-T or --read-only</CODE>
<DD>
Don't mark table as checked. This is useful if you use <CODE>myisamchk</CODE>
to check a table that is in use by some other application that doesn't
use locking (like <CODE>mysqld --skip-locking</CODE>).
</DL>



<H4><A NAME="myisamchk_repair_options" HREF="manual.ja_toc.html#myisamchk_repair_options">4.4.6.4  myisamchk の修復オプション</A></H4>

<P>
<A NAME="IDX543"></A>
<A NAME="IDX544"></A>

</P>
<P>
以下のオプションは <CODE>myisamchk</CODE> を <CODE>-r</CODE> か <CODE>-o</CODE> オプションで
実行した場合に使用できます:

</P>
<DL COMPACT>

<DT><CODE>-D # or --data-file-length=#</CODE>
<DD>
Max length of data file (when re-creating data file when it's 'full').

<DT><CODE>-e or --extend-check</CODE>
<DD>
Try to recover every possible row from the data file.
Normally this will also find a lot of garbage rows. Don't use this option
if you are not totally desperate.

<DT><CODE>-f or --force</CODE>
<DD>
Overwrite old temporary files (<CODE>table_name.TMD</CODE>) instead of aborting.
<DT><CODE>-k # or keys-used=#</CODE>
<DD>
If you are using ISAM, tells the ISAM table handler to update only the
first <CODE>#</CODE> indexes.  If you are using <CODE>MyISAM</CODE>, tells which keys
to use, where each binary bit stands for one key (first key is bit 0).
これはインサートを速くします！
非アクティブになったインデックスは、<CODE>myisamchk -r</CODE> を使用すれば再びアクティ
ブになります。

<DT><CODE>-l or --no-symlinks</CODE>
<DD>
修復時にシンボリックリンクを追いません。
通常、<CODE>myisamchk</CODE> はシンボリックリンクが指し示すテーブルも修復します。
This option doesn't exist in MySQL 4.0,
as MySQL 4.0 will not remove symlinks during repair.

<DT><CODE>-r or --recover</CODE>
<DD>
Can fix almost anything except unique keys that aren't unique
(which is an extremely unlikely error with ISAM/MyISAM tables).
If you want to recover a table, this is the option to try first. Only if
myisamchk reports that the table can't be recovered by <CODE>-r</CODE>, you
should then try <CODE>-o</CODE>.  (Note that in the unlikely case that <CODE>-r</CODE>
fails, the data file is still intact.)
If you have lots of memory, you should increase the size of
<CODE>sort_buffer_size</CODE>!

<DT><CODE>-o or --safe-recover</CODE>
<DD>
古い修復方法を使用します (reads through all rows in order and updates
all index trees based on the found rows); これは <CODE>-r</CODE> よりも遅いですが、
 <CODE>-r</CODE> が扱えないものも扱えます。
This recovery method also uses much less disk
space than <CODE>-r</CODE>. Normally one should always first repair with
<CODE>-r</CODE>, and only if this fails use <CODE>-o</CODE>.

If you have lots of memory, you should increase the size of
<CODE>key_buffer_size</CODE>!
<DT><CODE>-n or --sort-recover</CODE>
<DD>
Force <CODE>myisamchk</CODE> to use sorting to resolve the keys even if the
temporary files should be very big.  This will not have any effect if you have
fulltext keys in the table.

<DT><CODE>--character-sets-dir=...</CODE>
<DD>
Directory where character sets are stored.

<DT><CODE>--set-character-set=name</CODE>
<DD>
Change the character set used by the index

<DT><CODE>.t or --tmpdir=path</CODE>
<DD>
一時ファイルを保存する先のパス。 もしセットされなければ、 <CODE>myisamchk</CODE> は
<CODE>TMPDIR</CODE> 環境変数の値をこのパスとします。

<DT><CODE>-q or --quick</CODE>
<DD>
Faster repair by not modifying the data file. One can give a second
<CODE>-q</CODE> to force <CODE>myisamchk</CODE> to modify the original datafile in case
of duplicate keys

<DT><CODE>-u or --unpack</CODE>
<DD>
<CODE>myisampack</CODE> でパックされたテーブルファイルをアンパックします。
</DL>



<H4><A NAME="myisamchk_other_options" HREF="manual.ja_toc.html#myisamchk_other_options">4.4.6.5  <CODE>myisamchk</CODE> の他のオプション</A></H4>

<P>
Other actions that <CODE>myisamchk</CODE> can do, besides repair and check tables:

</P>
<DL COMPACT>

<DT><CODE>-a or --analyze</CODE>
<DD>
キーの分布(配置)を分析します。 This improves join performance by
enabling the join optimizer to better choose in which order it should
join the tables and which keys it should use:
<CODE>myisamchk --describe --verbose table_name'</CODE> or using <CODE>SHOW KEYS</CODE> in
MySQL.

<DT><CODE>-d or --description</CODE>
<DD>
テーブルに関するいくらかの情報を表示します

<DT><CODE>-A or --set-auto-increment[=value]</CODE>
<DD>
Force auto_increment to start at this or higher value. If no value is
given, then sets the next auto_increment value to the highest used value
for the auto key + 1.

<DT><CODE>-S or --sort-index</CODE>
<DD>
インデックスブロックのソート。
これは、アプリケーションでの ``read-next'' を速くします。

<DT><CODE>-R or --sort-records=#</CODE>
<DD>
インデックスに従ってソート。
これはあなたのデータをよりよく配置し、このインデックスへの
 <CODE>SELECT</CODE>, <CODE>ORDER BY</CODE> オペレーションを速くします。
(この操作の最初のソートは非常に遅くなるかもしれません！)
テーブルのインデックスの番号をみつけるには <CODE>SHOW INDEX</CODE> を使用しますが、
これは <CODE>myisamchk</CODE> がテーブルのインデックスを見つけるのと同じ順序で行います。
インデックス番号は 1 から始まります。
</DL>



<H4><A NAME="myisamchk_memory" HREF="manual.ja_toc.html#myisamchk_memory">4.4.6.6  <CODE>myisamchk</CODE> メモリ使用</A></H4>

<P>
<A NAME="IDX545"></A>

</P>
<P>
<CODE>myisamchk</CODE> を走らす上でメモリーの配分は重要です。
<CODE>myisamchk</CODE> は <CODE>-O</CODE> オプションで定義した以上のメモリは使用しません。
とても大きなファイルのたいして <CODE>myisamchk</CODE> をかけたいなら、
メモリーをどれくらい使用するかを最初に決めなくてはなりません。
デフォルトは固定で約 3M だけを使用します。大きな値を使用することで、
<CODE>myisamchk</CODE> をより速く動作できます。
例えば、32MBytesのRAMがあるなら、以下のように指定できます
(他のオプションも指定して):

</P>

<PRE>
shell&#62; myisamchk -O sort=16M -O key=16M -O read=1M -O write=1M ...
</PRE>

<P>
<CODE>-O sort=16M</CODE> の使用は多くの場合おそらく十分でしょう。

</P>
<P>
しかし、<CODE>myisamchk</CODE> は <CODE>TMPDIR</CODE> 内に一時ファイルを使用します。
<CODE>TMPDIR</CODE> がメモリファイルシステムを指している場合は、簡単に out of
memory エラーを得るでしょう。
If this happens, set <CODE>TMPDIR</CODE> to point at some directory
with more space and restart <CODE>myisamchk</CODE>.

</P>
<P>
When repairing, <CODE>myisamchk</CODE> will also need a lot of disk space:

</P>

<UL>
<LI>

Double the size of the record file (the original one and a copy).  This
space is not needed if one does a repair with <CODE>--quick</CODE>, as in this
case only the index file will be re-created.  This space is needed on the
same disk as the original record file!
<LI>

Space for the new index file that replaces the old one. The old
index file is truncated at start, so one usually ignore this space.
This space is needed on the same disk as the original index file!
<LI>

When using <CODE>--recover</CODE> or <CODE>--sort-recover</CODE>
(but not when using <CODE>--safe-recover</CODE>, you will need space for a
sort buffer for:
<CODE>(largest_key + row_pointer_length)*number_of_rows * 2</CODE>.
You can check the length of the keys and the row_pointer_length with
<CODE>myisamchk -dv table</CODE>.
This space is allocated on the temporary disk (specified by <CODE>TMPDIR</CODE> or
<CODE>--tmpdir=#</CODE>).
</UL>

<P>
If you have a problem with disk space during repair, you can try to use
<CODE>--safe-recover</CODE> instead of <CODE>--recover</CODE>.

</P>



<H4><A NAME="Crash_recovery" HREF="manual.ja_toc.html#Crash_recovery">4.4.6.7  Using <CODE>myisamchk</CODE> for Crash Recovery</A></H4>

<P>
<A NAME="IDX546"></A>
<A NAME="IDX547"></A>

</P>
<P>
If you run <CODE>mysqld</CODE> with <CODE>--skip-locking</CODE> (which is the default on
some systems, like Linux), you can't reliably use <CODE>myisamchk</CODE> to
check a table when <CODE>mysqld</CODE> is using the same table.  If you
can be sure that no one is accessing the tables through <CODE>mysqld</CODE>
while you run <CODE>myisamchk</CODE>, you only have to do <CODE>mysqladmin
flush-tables</CODE> before you start checking the tables.  If you can't
guarantee the above, then you must take down <CODE>mysqld</CODE> while you
check the tables.  If you run <CODE>myisamchk</CODE> while <CODE>mysqld</CODE> is updating
the tables, you may get a warning that a table is corrupt even if it
isn't.

</P>
<P>
If you are not using <CODE>--skip-locking</CODE>, you can use <CODE>myisamchk</CODE>
to check tables at any time.  While you do this, all clients that try
to update the table will wait until <CODE>myisamchk</CODE> is ready before
continuing.

</P>
<P>
If you use <CODE>myisamchk</CODE> to repair or optimize tables, you
<STRONG>MUST</STRONG> always ensure that the <CODE>mysqld</CODE> server is not using
the table (this also applies if you are using <CODE>--skip-locking</CODE>).
If you don't take down <CODE>mysqld</CODE> you should at least do a
<CODE>mysqladmin flush-tables</CODE> before you run <CODE>myisamchk</CODE>.

</P>
<P>
This chapter describes how to check for and deal with data corruption
in MySQL databases.  If your tables get corrupted a lot you should
try to find the reason for this!  「<A HREF="manual.ja_Problems.html#Crashing">A.4.1  What To Do If MySQL Keeps Crashing</A>」節参照.

</P>
<P>
The <CODE>MyISAM</CODE> table section contains reason for why a table could be
corrupted.  「<A HREF="manual.ja_Table_types.html#MyISAM_table_problems">7.1.3  MyISAM table problems.</A>」節参照.

</P>
<P>
When performing crash recovery, it is important to understand that each table
<CODE>tbl_name</CODE> in a database corresponds to three files in the database
directory:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>File</STRONG> </TD><TD> <STRONG>Purpose</STRONG>
</TR NOSAVE>
<TR><TD><TT>`tbl_name.frm'</TT> </TD><TD> Table definition (form) file
</TR NOSAVE>
<TR><TD><TT>`tbl_name.MYD'</TT> </TD><TD> Data file
</TR NOSAVE>
<TR><TD><TT>`tbl_name.MYI'</TT> </TD><TD> Index file
</TR>
</TABLE>

<P>
Each of these three file types is subject to corruption in various ways, but
problems occur most often in data files and index files.

</P>
<P>
<CODE>myisamchk</CODE> works by creating a copy of the <TT>`.MYD'</TT> (data) file
row by row. It ends the repair stage by removing the old <TT>`.MYD'</TT>
file and renaming the new file to the original file name.  If you use
<CODE>--quick</CODE>, <CODE>myisamchk</CODE> does not create a temporary <TT>`.MYD'</TT>
file, but instead assumes that the <TT>`.MYD'</TT> file is correct and only
generates a new index file without touching the <TT>`.MYD'</TT> file. This
is safe, because <CODE>myisamchk</CODE> automatically detects if the
<TT>`.MYD'</TT> file is corrupt and aborts the repair in this case.  You can
also give two <CODE>--quick</CODE> options to <CODE>myisamchk</CODE>.  In this case,
<CODE>myisamchk</CODE> does not abort on some errors (like duplicate key) but
instead tries to resolve them by modifying the <TT>`.MYD'</TT>
file. Normally the use of two <CODE>--quick</CODE> options is useful only if
you have too little free disk space to perform a normal repair.  In this
case you should at least make a backup before running <CODE>myisamchk</CODE>.

</P>



<H4><A NAME="Check" HREF="manual.ja_toc.html#Check">4.4.6.8  How to Check Tables for Errors</A></H4>

<P>
<A NAME="IDX548"></A>
<A NAME="IDX549"></A>
<A NAME="IDX550"></A>

</P>
<P>
To check a MyISAM table, use the following commands:

</P>
<DL COMPACT>

<DT><CODE>myisamchk tbl_name</CODE>
<DD>
This finds 99.99% of all errors. What it can't find is corruption that
involves <STRONG>ONLY</STRONG> the data file (which is very unusual). If you want
to check a table, you should normally run <CODE>myisamchk</CODE> without options or
with either the <CODE>-s</CODE> or <CODE>--silent</CODE> option.

<DT><CODE>myisamchk -m tbl_name</CODE>
<DD>
This finds 99.999% of all errors. It checks first all index entries for errors and
then it reads through all rows. It calculates a checksum for all keys in
the rows and verifies that they checksum matches the checksum for the keys
in the index tree.

<DT><CODE>myisamchk -e tbl_name</CODE>
<DD>
This does a complete and thorough check of all data (<CODE>-e</CODE> means
``extended check''). It does a check-read of every key for each row to verify
that they indeed point to the correct row.  This may take a LONG time on a
big table with many keys.  <CODE>myisamchk</CODE> will normally stop after the first
error it finds. If you want to obtain more information, you can add the
<CODE>--verbose</CODE> (<CODE>-v</CODE>) option.  This causes <CODE>myisamchk</CODE> to keep
going, up through a maximum of 20 errors.  In normal usage, a simple
<CODE>myisamchk</CODE> (with no arguments other than the table name) is sufficient.

<DT><CODE>myisamchk -e -i tbl_name</CODE>
<DD>
Like the previous command, but the <CODE>-i</CODE> option tells <CODE>myisamchk</CODE> to
print some informational statistics, too.
</DL>



<H4><A NAME="Repair" HREF="manual.ja_toc.html#Repair">4.4.6.9  テーブルの修復方法</A></H4>

<P>
<A NAME="IDX551"></A>
<A NAME="IDX552"></A>

</P>
<P>
In the following section we only talk about using <CODE>myisamchk</CODE> on
<CODE>MyISAM</CODE> tables (extensions <CODE>.MYI</CODE> and <CODE>.MYD</CODE>).  If you
are using <CODE>ISAM</CODE> tables (extensions <CODE>.ISM</CODE> and <CODE>.ISD</CODE>),
you should use <CODE>isamchk</CODE> instead.

</P>
<P>
Starting with MySQL Version 3.23.14, you can repair MyISAM
tables with the <CODE>REPAIR TABLE</CODE> command.  「<A HREF="manual.ja_MySQL_Database_Administration.html#REPAIR_TABLE">4.4.5  <CODE>REPAIR TABLE</CODE> 構文</A>」節参照.

</P>
<P>
テーブル破壊の兆しとして、クエリが予期せず中断したり、以下のようなエラーが出たり
します：

</P>

<UL>
<LI>

<TT>`tbl_name.frm'</TT> is locked against change
<LI>

Can't find file <TT>`tbl_name.MYI'</TT> (Errcode: ###)
<LI>

Unexpected end of file
<LI>

Record file is crashed
<LI>

Got error ### from table handler

To get more information about the error you can run <CODE>perror ###</CODE>. Here 
is the most common errors that indicates a problem with the table:


<PRE>
shell&#62; perror 126 127 132 134 135 136 141 144 145
126 = Index file is crashed / Wrong file format
127 = Record-file is crashed
132 = Old database file
134 = Record was already deleted (or record file crashed)
135 = No more room in record file
136 = No more room in index file
141 = Duplicate unique key or constraint on write or update
144 = Table is crashed and last repair failed
145 = Table was marked as crashed and should be repaired
</PRE>

Note that error 135, no more room in record file, is not an error that
can be fixed by a simple repair. In this case you have to do:


<PRE>
ALTER TABLE table MAX_ROWS=xxx AVG_ROW_LENGTH=yyy;
</PRE>

</UL>

<P>
この他の場合、あなたは自分のテーブルを修理しなければなりません。
<CODE>myisamchk</CODE> はほとんどの問題を見つけ出し修正します。

</P>
<P>
修復過程は以下で記述する最大4つの段階を踏みます。
これを始める前に、あなたはデータベースディレクトリに <CODE>cd</CODE> して
テーブルファイルのパーミッションを確認すべきです。
これらファイルは <CODE>mysqld</CODE> を実行している UNIX ユーザーが読み込み可能
であるようにしてください(検査のするのにあなたにファイルのアクセス権も必要)。
もしファイルの変更をする必要があるならば、ファイルへの書き込み許可も必要です。

</P>
<P>
If you are using MySQL Version 3.23.16 and above, you can (and 
should) use the <CODE>CHECK</CODE> and <CODE>REPAIR</CODE> commands to check and repair 
<CODE>MyISAM</CODE> tables.   「<A HREF="manual.ja_MySQL_Database_Administration.html#CHECK_TABLE">4.4.4  <CODE>CHECK TABLE</CODE> 構文</A>」節参照.   「<A HREF="manual.ja_MySQL_Database_Administration.html#REPAIR_TABLE">4.4.5  <CODE>REPAIR TABLE</CODE> 構文</A>」節参照.

</P>
<P>
The manual section about table maintenance includes the options to
<CODE>isamchk</CODE>/<CODE>myisamchk</CODE>.   「<A HREF="manual.ja_MySQL_Database_Administration.html#Table_maintenance">4.4.6  テーブルのメンテナンス、クラッシュからの修復のための <CODE>myisamchk</CODE> 使用</A>」節参照.

</P>
<P>
The following section is for the cases where the above command fails or
if you want to use the extended features that <CODE>isamchk</CODE>/<CODE>myisamchk</CODE> provides.

</P>
<P>
If you are going to repair a table from the command line, you must first
take down the <CODE>mysqld</CODE> server. Note that when you do
<CODE>mysqladmin shutdown</CODE> on a remote server, the <CODE>mysqld</CODE> server
will still be alive for a while after <CODE>mysqladmin</CODE> returns, until
all queries are stopped and all keys have been flushed to disk.

</P>
<P>
<STRONG>Stage 1: テーブルをチェックする</STRONG>

</P>
<P>
<CODE>myisamchk *.MYI</CODE> (時間がかかってもよいなら <CODE>myisamchk -e *.MYI</CODE>)
を実行します。
<CODE>-s</CODE> (silent) オプションは不要な情報の出力をおさえます。

</P>
<P>
If the <CODE>mysqld</CODE> server is done you should use the --update option to tell
<CODE>myisamchk</CODE> to mark the table as 'checked'.

</P>
<P>
<CODE>myisamchk</CODE> がエラーを返した場合にだけ、テーブルを修復する必要があります。
この場合、Stage 2 へ進みます。

</P>
<P>
チェック時に奇妙なエラー(<CODE>out of memory</CODE> エラーのような) が起きた場合、
あるいは <CODE>myisamchk</CODE> が落ちた場合、Stage 3 に進んでください。

</P>
<P>
<STRONG>Stage 2: 簡単で安全な修復</STRONG>

</P>
<P>
NOTE: If you want repairing to go much faster, you should add: <CODE>-O
sort_buffer=# -O key_buffer=#</CODE> (where # is about 1/4 of the available
memory) to all <CODE>isamchk/myisamchk</CODE> commands.

</P>
<P>
まず最初に <CODE>myisamchk -r -q tbl_name</CODE> を試みてください
(<CODE>-r -q</CODE> は ``quick recovery mode''の意)。
これはデータファイルに触れないでインデックスファイルの修理を試みます。
もしデータファイルが全てとデータファイル中の正しい場所での削除リンクポイントを
含んでいるなら、これは動作してテーブルを修復します。
成功後、次のテーブルの修復に進んでください。
失敗した場合は、以下の手順で試みてください：

</P>

<OL>
<LI>

続ける前にデータファイルをバックアップしてください。

<LI>

<CODE>myisamchk -r tbl_name</CODE> を使用します(<CODE>-r</CODE> は ``recovery mode''の意)。
これは不正なレコードと削除されたレコードをデータファイルから消去し、
インデックスファイル(.MYI)を再構築します。

<LI>

上記が失敗した場合、<CODE>myisamchk --safe-recover tbl_name</CODE> を使用して下さい。
Safe recovery モードは古い方法を使用して修復します。
これは普通の修復モードでは行わない操作をいくつかもっています。(遅いですが)
</OL>

<P>
If you get weird errors when repairing (such as <CODE>out of
memory</CODE> errors), or if <CODE>myisamchk</CODE> crashes, go to Stage 3.

</P>
<P>
<STRONG>Stage 3: 難しい修復</STRONG>

</P>
<P>
インデックスファイル(.MYI)の最初の 16K ブロックが破壊された場合、
または不正な情報を含む場合、またはインデックスファイルがない場合にだけ、
本修復段階を経ます。
この場合、新しいインデックスファイルファイルを作成する必要があります。
次のようにしてください:

</P>

<OL>
<LI>

データファイルをどこか安全場所に移動します。

<LI>

新しい(空の)データとインデックスファイルを作るために、
テーブルディスクリプタファイルを使用します：


<PRE>
shell&#62; mysql db_name
mysql&#62; SET AUTOCOMMIT=1;
mysql&#62; TRUNCATE TABLE table_name;
mysql&#62; quit
</PRE>

If your SQL version doesn't have <CODE>TRUNCATE TABLE</CODE>, use <CODE>DELETE FROM
table_name</CODE> instead.

<LI>

古いデータファイルを新しく作ったデータファイルにコピーします。
(Don't just move the old file back onto the new file; you want to retain
a copy in case something goes wrong.)
</OL>

<P>
Go back to Stage 2.  <CODE>myisamchk -r -q</CODE> should work now.  (This shouldn't
be an endless loop.)

</P>
<P>
<STRONG>Stage 4: とても難しい修復</STRONG>

</P>
<P>
これは、ディスクリプタファイル(.frm)もクラッシュした場合にだけ発生します。
これは発生することはありません。なぜならディスクリプタファイルは
テーブルが生成された後に書かれることはないからです。

</P>

<OL>
<LI>

ディスクリプタファイルをバックアップからリストアして、Stage 3 に戻ってください。
インデックスファイルのリストアもできます。そして Stage 2 に戻ってください。
後者の場合、<CODE>myisamchk -r</CODE> で開始すべきです。

<LI>

バックアップを持っていなくても、テーブルがどのように作成されたかを正確に知って
いれば、他のデータベース内にテーブルのコピーを生成します。
新しいデータファイルを削除し、先ほど作ったデータベースの中の
ディスクリプタファイルとインデックスファイルを、壊れたデータベース内に
移動します。これは新しいディスクリプタファイルとインデックスファイルを
与えることになりますが、データファイルはそのまま残っています。
Stage 2 に進み、インデックスファイルの修復を行ってください。
</OL>



<H4><A NAME="Optimization" HREF="manual.ja_toc.html#Optimization">4.4.6.10  テーブルの最適化</A></H4>

<P>
<A NAME="IDX553"></A>
<A NAME="IDX554"></A>

</P>
<P>
断片化されたレコードの結合と、
レコードの削除と更新から生じる無駄なスペースの排除、
これら行うには、修復モード(recovery mode)で <CODE>myisamchk</CODE> を実行します：

</P>

<PRE>
shell&#62; myisamchk -r tbl_name
</PRE>

<P>
SQL <CODE>OPTIMIZE TABLE</CODE> でも同様にテーブルを最適化できます。
  <CODE>OPTIMIZE TABLE</CODE> does a repair of the table, a key
analyzes and also sorts the index tree to give faster key lookups.
There is also no possibility of unwanted interaction between a utility
and the server, because the server does all the work when you use
<CODE>OPTIMIZE TABLE</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  <CODE>OPTIMIZE TABLE</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>myisamchk</CODE> には、あなたがテーブルの性能を向上させるのに使用することができる
他の多くのオプションがあります:

</P>
<DL COMPACT>

<DT><CODE>-S, --sort-index</CODE>
<DD>
<DT><CODE>-R index_num, --sort-records=index_num</CODE>
<DD>
<DT><CODE>-a, --analyze</CODE>
<DD>
</DL>

<P>
For a full description of the option.  「<A HREF="manual.ja_MySQL_Database_Administration.html#myisamchk_syntax">4.4.6.1  <CODE>myisamchk</CODE> 起動構文</A>」節参照.

</P>



<H3><A NAME="Maintenance_regimen" HREF="manual.ja_toc.html#Maintenance_regimen">4.4.7  テーブルの保守体制の設定</A></H3>

<P>
<A NAME="IDX555"></A>
<A NAME="IDX556"></A>

</P>
<P>
Starting with MySQL Version 3.23.13, you can check MyISAM
tables with the <CODE>CHECK TABLE</CODE> command.  「<A HREF="manual.ja_MySQL_Database_Administration.html#CHECK_TABLE">4.4.4  <CODE>CHECK TABLE</CODE> 構文</A>」節参照.  You can
repair tables with the <CODE>REPAIR TABLE</CODE> command.  「<A HREF="manual.ja_MySQL_Database_Administration.html#REPAIR_TABLE">4.4.5  <CODE>REPAIR TABLE</CODE> 構文</A>」節参照.

</P>
<P>
問題が発生するまで待つより、定期的にテーブルを検査する方がよりよい考えです。
保守目的には、<CODE>myisamchk -s</CODE> でテーブルを検査するのがよいでしょう。
<CODE>-s</CODE> オプション(short for <CODE>--silent</CODE>) はサイレントモードなので、
エラーが起きた場合にだけメッセージを出力します。

</P>
<P>
<A NAME="IDX557"></A>
サーバーを開始するときにテーブルを検査するのもよい考えです。
例えば、更新最中にマシンがリブートされたなら、全てのテーブルに関して
その影響がないか検査する必要があります。（これは``expected crashed table''です）
リブート後にもし古い <TT>`.pid'</TT> ファイル(プロセスID) があるならば、
24時間以内に変更されたテーブルに対して <CODE>myisamchk</CODE> を走らせて検査させるよう
に、
<CODE>safe_mysqld</CODE> にテストを追加しても構いません。
(<TT>`.pid'</TT> ファイルは <CODE>mysqld</CODE> 起動時に作られ、通常修了時に消されます。
スタート時に <TT>`.pid'</TT> ファイルが存在するなら <CODE>mysqld</CODE> が異常終了したこと
を示します。)

</P>
<P>
良いテストは、<TT>`.pid'</TT> ファイルの作成時間以降に変更された
全てのテーブルを検査するテストです。

</P>
<P>
通常のシステム運用中にもテーブルを検査すべきです。
<STRONG>MySQL AB</STRONG> では、週に一度、 <CODE>cron</CODE> を使用して重要なテーブルを検査し
ています。
<TT>`crontab'</TT> ファイルには以下のように記述します：

</P>

<PRE>
35 0 * * 0 /path/to/myisamchk --fast --silent /path/to/datadir/*/*.MYI
</PRE>

<P>
これは壊れたテーブルの情報を出力しますので、必要とあらば検査、修復が行えるわけで
す。

</P>
<P>
予想外の事故で壊れたテーブル(ハードウェアのトラブルが原因で崩壊)を除き、
2,3年間、テーブルは壊れたことはありません(これは本当に本当です)。
ので、一週間に一度のチェックでも十分です。

</P>
<P>
24時間以内に変更された全てのテーブルに対して、
<CODE>myisamchk -s</CODE> を毎晩実行する事を勧めます。
そうすれば、あなたは我々と同じぐらいに <STRONG>MySQL</STRONG> を
信頼することになります。

</P>
<P>
<A NAME="IDX558"></A>
Normally you don't need to maintain MySQL tables that much.  If 
you are changing tables with dynamic size rows (tables with <CODE>VARCHAR</CODE>,
<CODE>BLOB</CODE> or <CODE>TEXT</CODE> columns) or have tables with many deleted rows
you may want to from time to time (once a month?) defragment/reclaim space
from the tables.

</P>
<P>
You can do this by using <CODE>OPTIMIZE TABLE</CODE> on the tables in question or
if you can take the <CODE>mysqld</CODE> server down for a while do:

</P>

<PRE>
isamchk -r --silent --sort-index -O sort_buffer_size=16M */*.ISM
myisamchk -r --silent --sort-index  -O sort_buffer_size=16M */*.MYI
</PRE>



<H3><A NAME="Table-info" HREF="manual.ja_toc.html#Table-info">4.4.8  テーブル情報取得</A></H3>

<P>
<A NAME="IDX559"></A>

</P>
<P>
テーブルから詳細/統計を得るためには、次の方法を使用します。後でさらに詳細な情
報をいくつか説明します。

</P>
<DL COMPACT>

<DT><CODE>myisamchk -d tbl_name</CODE>
<DD>
<CODE>myisamchk</CODE> を ``describe mode'' で実行し、テーブルの説明記述を作ります。
<CODE>--skip-locking</CODE> を指定して <STRONG>MySQL</STRONG> サーバーを起動した場合、
<CODE>myisamchk</CODE> は myisamchk 実行中に更新されたテーブルについてエラーを報告します.
しかし <CODE>myisamchk</CODE> は describe mode ではテーブルを変えないので、
データを破壊する危険性はありません。

<DT><CODE>myisamchk -d -v tbl_name</CODE>
<DD>
<CODE>myisamchk</CODE> がしていることに関する、より多くの情報を作り出すには、
<CODE>-v</CODE> をつけて冗長モードで走らせるようにします。

<DT><CODE>myisamchk -eis tbl_name</CODE>
<DD>
テーブルから最も重要な情報だけを示します。
テーブル全体を読まなければならないので、遅いです。

<DT><CODE>myisamchk -eiv tbl_name</CODE>
<DD>
<CODE>-eis</CODE> と似ているが、何を行っているかを表示します。
</DL>

<P>
<A NAME="IDX560"></A>
<A NAME="IDX561"></A>
<CODE>myisamchk -d</CODE> 出力の例:

<PRE>
MyISAM file:     company.MYI
Record format:   Fixed length
Data records:    1403698  Deleted blocks:         0
Recordlength:    226

table description:
Key Start Len Index   Type
1   2     8   unique  double
2   15    10  multip. text packed stripped
3   219   8   multip. double
4   63    10  multip. text packed stripped
5   167   2   multip. unsigned short
6   177   4   multip. unsigned long
7   155   4   multip. text
8   138   4   multip. unsigned long
9   177   4   multip. unsigned long
    193   1           text
</PRE>

<P>
<CODE>myisamchk -d -v</CODE> 出力の例:

<PRE>
MyISAM file:         company
Record format:       Fixed length
File-version:        1
Creation time:       1999-10-30 12:12:51
Recover time:        1999-10-31 19:13:01
Status:              checked
Data records:           1403698  Deleted blocks:              0
Datafile parts:         1403698  Deleted data:                0
Datafilepointer (bytes):      3  Keyfile pointer (bytes):     3
Max datafile length: 3791650815  Max keyfile length: 4294967294
Recordlength:               226

table description:
Key Start Len Index   Type                  Rec/key     Root Blocksize
1   2     8   unique  double                      1 15845376      1024
2   15    10  multip. text packed stripped        2 25062400      1024
3   219   8   multip. double                     73 40907776      1024
4   63    10  multip. text packed stripped        5 48097280      1024
5   167   2   multip. unsigned short           4840 55200768      1024
6   177   4   multip. unsigned long            1346 65145856      1024
7   155   4   multip. text                     4995 75090944      1024
8   138   4   multip. unsigned long              87 85036032      1024
9   177   4   multip. unsigned long             178 96481280      1024
    193   1           text
</PRE>

<P>
<CODE>myisamchk -eis</CODE> 出力の例:

<PRE>
Checking MyISAM file: company
Key:  1:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
Key:  2:  Keyblocks used:  98%  Packed:   50%  Max levels:  4
Key:  3:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
Key:  4:  Keyblocks used:  99%  Packed:   60%  Max levels:  3
Key:  5:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  6:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  7:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  8:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
Key:  9:  Keyblocks used:  98%  Packed:    0%  Max levels:  4
Total:    Keyblocks used:  98%  Packed:   17%

Records:          1403698    M.recordlength:     226   Packed:             0%
Recordspace used:     100%   Empty space:          0%  Blocks/Record:   1.00
Record blocks:    1403698    Delete blocks:        0
Recorddata:     317235748    Deleted data:         0
Lost space:             0    Linkdata:             0

User time 1626.51, System time 232.36
Maximum resident set size 0, Integral resident set size 0
Non physical pagefaults 0, Physical pagefaults 627, Swaps 0
Blocks in 0 out 0, Messages in 0 out 0, Signals 0
Voluntary context switches 639, Involuntary context switches 28966
</PRE>

<P>
<CODE>myisamchk -eiv</CODE> 出力の例:

<PRE>
Checking MyISAM file: company
Data records: 1403698   Deleted blocks:       0
- check file-size
- check delete-chain
block_size 1024:
index  1:
index  2:
index  3:
index  4:
index  5:
index  6:
index  7:
index  8:
index  9:
No recordlinks
- check index reference
- check data record references index: 1
Key:  1:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
- check data record references index: 2
Key:  2:  Keyblocks used:  98%  Packed:   50%  Max levels:  4
- check data record references index: 3
Key:  3:  Keyblocks used:  97%  Packed:    0%  Max levels:  4
- check data record references index: 4
Key:  4:  Keyblocks used:  99%  Packed:   60%  Max levels:  3
- check data record references index: 5
Key:  5:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 6
Key:  6:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 7
Key:  7:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 8
Key:  8:  Keyblocks used:  99%  Packed:    0%  Max levels:  3
- check data record references index: 9
Key:  9:  Keyblocks used:  98%  Packed:    0%  Max levels:  4
Total:    Keyblocks used:   9%  Packed:   17%

- check records and index references
[LOTS OF ROW NUMBERS DELETED]

Records:          1403698    M.recordlength:     226   Packed:             0%
Recordspace used:     100%   Empty space:          0%  Blocks/Record:   1.00
Record blocks:    1403698    Delete blocks:        0
Recorddata:     317235748    Deleted data:         0
Lost space:             0    Linkdata:             0

User time 1639.63, System time 251.61
Maximum resident set size 0, Integral resident set size 0
Non physical pagefaults 0, Physical pagefaults 10580, Swaps 0
Blocks in 4 out 0, Messages in 0 out 0, Signals 0
Voluntary context switches 10604, Involuntary context switches 122798
</PRE>

<P>
上で使用されたテーブルのデータファイルサイズをここに示します:

</P>

<PRE>
-rw-rw-r--   1 monty    tcx     317235748 Jan 12 17:30 company.MYD
-rw-rw-r--   1 davida   tcx      96482304 Jan 12 18:35 company.MYM
</PRE>

<P>
<CODE>myisamchk</CODE> が生成する情報の説明を以下に示します。
``keyfile'' はインデックスファイルです。
``Record'' と ``row'' は同義です。

</P>
<DL COMPACT>

<DT><CODE>ISAM file</CODE>
<DD>
ISAM (index) ファイルの名前

<DT><CODE>Isam-version</CODE>
<DD>
ISAM 形式のバージョン。現在は常に 2 

<DT><CODE>Creation time</CODE>
<DD>
データファイルが生成された時。

<DT><CODE>Recover time</CODE>
<DD>
インデックス/データファイルが最後に再構築された時。

<DT><CODE>Data records</CODE>
<DD>
レコード/行の数。

<DT><CODE>Deleted blocks</CODE>
<DD>
予約された領域をまだ持っている削除ブロック数。
このスペースを最小にするために自分のテーブルを最適化することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Optimization">4.4.6.10  テーブルの最適化</A>」節参照.

<DT><CODE>Datafile: Parts</CODE>
<DD>
動的なレコード形式にいくつのデータブロックがあるかを表示します。
分割なしで最適化されたテーブルでは <CODE>Data records</CODE> と同じです。

<DT><CODE>Deleted data</CODE>
<DD>
改善されていない削除データのバイト数。
このスペースを最小にするために自分のテーブルを最適化することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Optimization">4.4.6.10  テーブルの最適化</A>」節参照.

<DT><CODE>Datafile pointer</CODE>
<DD>
データファイルポインタの大きさ(バイト数)。これは普通 2, 3, 4 または 5 バ
イトです。多くのテーブルは 2 バイトで管理されますが、これはまだ 
<STRONG>MySQL</STRONG> から制御できません。固定テーブルではこれはレコードアドレ
スです。動的テーブルではこれはバイトアドレスです。

<DT><CODE>Keyfile pointer</CODE>
<DD>
データファイルポインタのバイト数。これは普通 1, 2 または 3 バイトです。
多くのテーブルは 2 バイトで管理されますが、これは <STRONG>MySQL</STRONG> では自動的に
計算されます。これは常にブロックアドレスです。

<DT><CODE>Max datafile length</CODE>
<DD>
テーブルのデータファイル (<CODE>.MYD</CODE> ファイル) が獲得できる長さ (バイト数)。

<DT><CODE>Max keyfile length</CODE>
<DD>
テーブルのキーファイル (<CODE>.MYI</CODE> ファイル) が獲得できる長さ (バイト数)。

<DT><CODE>Recordlength</CODE>
<DD>
各レコード/行が使用する領域の大きさ(バイト数)。

<DT><CODE>Record format</CODE>
<DD>
各テーブルの行が持つ形式。この例では <CODE>Fixed length</CODE> を使用します。
他の値で可能な物は<CODE>圧縮</CODE>、<CODE>パック</CODE>します。

<DT><CODE>table description</CODE>
<DD>
テーブル内の全てのキーのリスト。各キーについて、いくつかの低レベル情報が提供さ
れます:

<DL COMPACT>

<DT><CODE>Key</CODE>
<DD>
このキー番号。

<DT><CODE>Start</CODE>
<DD>
このインデックス部が開始するレコード/行内の位置。

<DT><CODE>Len</CODE>
<DD>
インデックス部の長さ。
パックされた数値では、これは常に項目の完全な長さになります。
文字型においては、文字型の項目の頭の部分にインデックスがつく事になりますので、
インデックス項目の最大長さよりもこの値は短くなるでしょう。

<DT><CODE>Index</CODE>
<DD>
<CODE>unique</CODE> or <CODE>multip.</CODE> (multiple). このインデックス内では1つの値が複数
回存在し得ます。

<DT><CODE>Type</CODE>
<DD>
このインデックス部が持つデータ型。
これは NISAM データ型で、
<CODE>packed</CODE>, <CODE>stripped</CODE> か <CODE>empty</CODE> オプションを持ちます。

<DT><CODE>Root</CODE>
<DD>
ルートインデックスブロックのアドレス。

<DT><CODE>Blocksize</CODE>
<DD>
各インデックスブロックのサイズ。これはデフォルトでは 1024 ですが、コンパ
イル時に変更できます。

<DT><CODE>Rec/key</CODE>
<DD>
これはオプティマイザによって使用される統計値です。このキーの値ごとのレコー
ド数を知らせます。ユニークキーは常に1の値を持ちます。これはテーブルがロードさ
れた(または大きく変更された)後に <CODE>myisamchk -a</CODE> で更新されます。これ
が全く更新されない場合はデフォルト値の 30 が与えられます。
</DL>

<DT><CODE></CODE>
<DD>
上の最初の例では、9番目のキーは2つの部分をもったマルチパートキーです。

<DT><CODE>Keyblocks used</CODE>
<DD>
使用されたキーブロックのパーセンテージ。このテーブルは <CODE>myisamchk</CODE> で再配置
されるため、値はとても高くなります (理論的な最大にとても近くなります)。

<DT><CODE>Packed</CODE>
<DD>
<STRONG>MySQL</STRONG> は一般の接尾辞でキーのパックを試みます。これは
<CODE>CHAR</CODE>/<CODE>VARCHAR</CODE>/<CODE>DECIMAL</CODE> キーでだけ使用できます。名前の
ような長い文字列では、これは使用領域を顕著に減らします。上の三番目の例では4番目
のキーが10文字長で、領域の60%の減少を得ます。

<DT><CODE>Max levels</CODE>
<DD>
このキーの Btree の深さ。長いキーを持つ大きなテーブルは高い値を得ます。

<DT><CODE>Records</CODE>
<DD>
テーブルが持っている行数。

<DT><CODE>M.recordlength</CODE>
<DD>
平均の行長。固定テーブルでは、これはレコード長です。

<DT><CODE>Packed</CODE>
<DD>
<STRONG>MySQL</STRONG> は文字列の最後から空白を除きます。これによって節約された
パーセンテージを <CODE>Packed</CODE> は示します。

<DT><CODE>Recordspace used</CODE>
<DD>
データファイルが使用されたパーセンテージ。

<DT><CODE>Empty space</CODE>
<DD>
データファイルが使用されていないパーセンテージ。

<DT><CODE>Blocks/Record</CODE>
<DD>
レコード毎のブロック数 (断片化レコードの構成数)。
これは固定形式テーブルでは常に1です。この値は可能な限
り 1.0 に留まります。これが大きすぎる場合は、<CODE>myisamchk</CODE> でテーブルを再配置
できます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Optimization">4.4.6.10  テーブルの最適化</A>」節参照.

<DT><CODE>Recordblocks</CODE>
<DD>
使用されたブロック (links) 数。固定型式ではこれはレコード数と同じです。

<DT><CODE>Deleteblocks</CODE>
<DD>
削除されたブロック (links) 数。

<DT><CODE>Recorddata</CODE>
<DD>
データファイル中にある実際のユーザデータのバイト数。

<DT><CODE>Deleted data</CODE>
<DD>
データファイル中にある削除された(unused)データのバイト数。 

<DT><CODE>Lost space</CODE>
<DD>
レコードがより短い長さに更新された場合、いくつかの領域が失われます。これ
はそのような消失の全ての合計です。in bytes.

<DT><CODE>Linkdata</CODE>
<DD>
動的形式の使用時、ブロックはポインタ(4～7バイト)にリンクされます。<CODE>Linkdata</CODE>は
そのポインタの全ての合計です。
</DL>

<P>
テーブルが <CODE>pack_isam</CODE> で圧縮されているなら、<CODE>myisamchk -d</CODE> は
それぞれのテーブルコラムに関する追加情報を出力します。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#myisampack">4.7.4  myisampack, MySQL の圧縮された読み込み専用テーブルジェネレータ</A>」節. を参照してください。
この情報例と説明記述の意味があります。

</P>



<H2><A NAME="Database_Administration" HREF="manual.ja_toc.html#Database_Administration">4.5  Database Administration Language Reference</A></H2>



<H3><A NAME="OPTIMIZE_TABLE" HREF="manual.ja_toc.html#OPTIMIZE_TABLE">4.5.1  <CODE>OPTIMIZE TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX562"></A>

</P>
<P>
<A NAME="IDX563"></A>
<A NAME="IDX564"></A>

</P>

<PRE>
OPTIMIZE TABLE tbl_name[,tbl_name]...
</PRE>

<P>
<CODE>OPTIMIZE TABLE</CODE>は、テーブルの大部分を削除したり、可変長となっているテーブ
ル(<CODE>VARCHAR</CODE>、<CODE>BLOB</CODE>もしくは<CODE>TEXT</CODE>フィールドを持つテーブル)に多く
の変更を加えた場合に使用すべきです。
削除されたレコードはリンクリストで維持され、次の<CODE>INSERT</CODE>操作は、古いレコー
ド位置を再利用します。
未使用領域を再生するために<CODE>OPTIMIZE TABLE</CODE>を使用することができます。

</P>
<P>
今のところ、<CODE>OPTIMIZE TABLE</CODE> は <STRONG>MyISAM</STRONG> と <CODE>BDB</CODE> テーブ
ル上でだけ動作します。<CODE>BDB</CODE> テーブルでは、<CODE>OPTIMIZE TABLE</CODE> が現
在 <CODE>ANALYZE TABLE</CODE> にマップされます。 「<A HREF="manual.ja_MySQL_Database_Administration.html#ANALYZE_TABLE">4.5.2  <CODE>ANALYZE TABLE</CODE> Syntax</A>」節参照。

</P>
<P>
<CODE>--skip-new</CODE> または <CODE>--safe-mode</CODE> で <CODE>mysqld</CODE> を起動するこ
とで、他のテーブル型で optimize table を動作するようにできます。しかし、こ
の場合 <CODE>OPTIMIZE TABLE</CODE> は <CODE>ALTER TABLE</CODE> にマップされるだけです。

</P>
<P>
<CODE>OPTIMIZE TABLE</CODE> は次の方法で動作します:

<UL>
<LI>

テーブルが削除されているかレコードが分割する場合、テーブルを修復します。
<LI>

インデックスページがソートされていない場合、ソートします。
<LI>

統計が更新されていない（そしてインデックスをソートすることで修復が行なわれ
なかった）場合、それを更新します。
</UL>

<P>
<CODE>MyISAM</CODE> テーブルの <CODE>OPTIMIZE TABLE</CODE> はテーブル上で 
<CODE>myisamchk --quick --check-changed-tables --sort-index --analyze</CODE> を
実行することと同等です。

</P>
<P>
注意: テーブルは <CODE>OPTIMIZE TABLE</CODE> 実行中はロックされます！

</P>



<H3><A NAME="ANALYZE_TABLE" HREF="manual.ja_toc.html#ANALYZE_TABLE">4.5.2  <CODE>ANALYZE TABLE</CODE> Syntax</A></H3>

<P>
<A NAME="IDX565"></A>

</P>

<PRE>
ANALYZE TABLE tbl_name[,tbl_name...]
</PRE>

<P>
Analyze and store the key distribution for the table.  During the
analyze the table is locked with a read lock.  This works on
<CODE>MyISAM</CODE> and <CODE>BDB</CODE> tables.

</P>
<P>
This is equivalent to running <CODE>myisamchk -a</CODE> on the table.

</P>
<P>
MySQL uses the stored key distribution to decide in which order
tables should be joined when one does a join on something else than a
constant.

</P>
<P>
The command returns a table with the following columns:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Column</STRONG> </TD><TD> <STRONG>Value</STRONG>
</TR NOSAVE>
<TR><TD>Table </TD><TD> Table name
</TR NOSAVE>
<TR><TD>Op </TD><TD> Always ``analyze''
</TR NOSAVE>
<TR><TD>Msg_type </TD><TD> One of <CODE>status</CODE>, <CODE>error</CODE>, <CODE>info</CODE> or <CODE>warning</CODE>.
</TR NOSAVE>
<TR><TD>Msg_text </TD><TD> The message.
</TR>
</TABLE>

<P>
You can check the stored key distribution with the <CODE>SHOW INDEX</CODE> command.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_DATABASE_INFO">4.5.5.1  Retrieving information about Database, Tables, Columns, and Indexes</A>」節参照.

</P>
<P>
If the table hasn't changed since the last <CODE>ANALYZE TABLE</CODE> command,
the table will not be analyzed again.

</P>



<H3><A NAME="FLUSH" HREF="manual.ja_toc.html#FLUSH">4.5.3  <CODE>FLUSH</CODE> 構文</A></H3>

<P>
<A NAME="IDX566"></A>

</P>
<P>
<A NAME="IDX567"></A>
<A NAME="IDX568"></A>
<A NAME="IDX569"></A>

</P>

<PRE>
FLUSH flush_option [,flush_option]
</PRE>

<P>
<CODE>FLUSH</CODE> コマンドで <STRONG>MySQL</STRONG> が使用している内部キャッシュの
いくつかをきれいに消すことができます。
<CODE>FLUSH</CODE> を実行するには、 <STRONG>RELOAD</STRONG> 権限がなければなりません。

</P>
<P>
<CODE>flush_option</CODE> には以下の内一つが指定できます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>HOSTS</CODE> </TD><TD> ホストキャッシュテーブルを空にします。あなたのホストの
IP アドレスを変えたり、<CODE>Host ... is blocked</CODE> というエラーメッセージが
出る場合はホストテーブルキャッシュを一度空にしなくてはなりません。
（指定したホストに対して <CODE>max_connect_errors</CODE> 以上の接続エラーが出る場合、
<STRONG>MySQL</STRONG> は何か起きたと推定し、そのホストからのいかなる接続要求も
拒否します。ホストテーブルキャッシュの消去は、再び接続を許すようにします。
 「<A HREF="manual.ja_Problems.html#Blocked_host">A.2.4  <CODE>Host '...' is blocked</CODE> Error</A>」節参照.）
<CODE>mysqld</CODE> を <CODE>-O max_connection_errors=999999999</CODE> 開始し、
このエラーメッセージを回避できます

</TR NOSAVE>
<TR><TD><CODE>LOGS</CODE> </TD><TD> 標準のログファイルと更新ログファイルを
一度閉じて再び開きます。
もし更新ログファイルを拡張子無しで指定している場合、新しい更新ログファイルの
拡張子の番号は、一つ前のファイルより 1 増やした数になります。
ファイル名に拡張を使用した場合、<STRONG>MySQL</STRONG> は更新ログファイルを閉じて開きま
す。  「<A HREF="manual.ja_MySQL_Database_Administration.html#Update_log">4.9.3  更新ログ</A>」節参照. This is the same thing as sending the <CODE>SIGHUP</CODE>
signal to the <CODE>mysqld</CODE> server.

</TR NOSAVE>
<TR><TD><CODE>PRIVILEGES</CODE> </TD><TD> <CODE>mysql</CODE> データベースの許可テーブルから、権限情報を再読込します。

</TR NOSAVE>
<TR><TD><CODE>TABLES</CODE> </TD><TD> 全ての開いているテーブルを閉じます。使用中のテーブルに
も close を強制します。

</TR NOSAVE>
<TR><TD><CODE>[TABLE | TABLES] table_name [,table_name...]</CODE> </TD><TD> Flushes only the given tables.

</TR NOSAVE>
<TR><TD><CODE>TABLES WITH READ LOCK</CODE> </TD><TD> 全ての開いているテーブルを閉じ、
<CODE>UNLOCK TABLES</CODE> を実行するまで全てのテーブルを読み込みロックします。 This is very convenient way to get backups if you have a file system, like Veritas,that can take snapshots in time.

</TR NOSAVE>
<TR><TD><CODE>STATUS</CODE> </TD><TD> ほとんどのステータス変数を 0 にします。 This is something one should only use when debugging a query.
</TR>
</TABLE>

<P>
上に示したコマンドは、<CODE>mysqladmin</CODE> を使用しても実行できます。
<CODE>mysqladmin</CODE> の引数はそれぞれ、
<CODE>flush-hosts</CODE>, <CODE>flush-logs</CODE>, <CODE>reload</CODE>, <CODE>flush-tables</CODE> と
なります。

</P>
<P>
Take also a look at the <CODE>RESET</CODE> command used with
replication.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Replication_SQL">4.10.6  レプリケーションに関連する SQL コマンド</A>」節参照.

</P>



<H3><A NAME="KILL" HREF="manual.ja_toc.html#KILL">4.5.4  <CODE>KILL</CODE> 構文</A></H3>

<P>
<A NAME="IDX570"></A>

</P>
<P>
<A NAME="IDX571"></A>

</P>

<PRE>
KILL thread_id
</PRE>

<P>
<CODE>thread_id</CODE> には、<CODE>mysqld</CODE> に接続して走っているスレッドの ID を
空白で区切って指定します。
<CODE>SHOW PROCESSLIST</CODE> コマンドで走っているスレッドを知ることができ、
 <CODE>KILL thread_id</CODE> コマンドでスレッドを KILL できます。

</P>
<P>
もし <STRONG>process</STRONG> 権限があるなら、全てのスレッドを確認し、KILL 出来ます。
そうでなければ、自分のスレッドだけを、
確認し、KILL する事ができます。

</P>
<P>
<CODE>mysqladmin processlist</CODE> と <CODE>mysqladmin kill</CODE> をスレッドの
検査と KILL に使用できます。

</P>
<P>
In most cases it may take some time for the thread to die as the kill
flag is only checked at specific intervals.

</P>

<UL>
<LI>

In <CODE>SELECT</CODE>, <CODE>ORDER BY</CODE> and <CODE>GROUP BY</CODE> loops, the flag is
checked after reading a block of rows. If the kill flag is set the
statement is aborted
<LI>

When doing an <CODE>ALTER TABLE</CODE> the kill flag is checked before each block of
rows are read from the original table. If the kill flag was set the command
is aborted and the temporary table is deleted.
<LI>

When doing an <CODE>UPDATE TABLE</CODE> and <CODE>DELETE TABLE</CODE>, the kill flag
is checked after each block read and after each updated or delete
row. If the kill flag is set the statement is aborted.  Note that if you
are not using transactions, the changes will not be rolled back!
<LI>

<CODE>GET_LOCK()</CODE> will abort with <CODE>NULL</CODE>.
<LI>

An <CODE>INSERT DELAYED</CODE> thread will quickly flush all rows it has in
memory and die.
<LI>

If the thread is in the table lock handler (state: <CODE>Locked</CODE>),
the table lock will be quickly aborted.
<LI>

If the thread is waiting for free disk space in a <CODE>write</CODE> call, the
write is aborted with an disk full error message.
</UL>



<H3><A NAME="SHOW" HREF="manual.ja_toc.html#SHOW">4.5.5  <CODE>SHOW</CODE> 構文</A></H3>

<P>
<A NAME="IDX572"></A>
<A NAME="IDX573"></A>
<A NAME="IDX574"></A>
<A NAME="IDX575"></A>
<A NAME="IDX576"></A>
<A NAME="IDX577"></A>
<A NAME="IDX578"></A>
<A NAME="IDX579"></A>
<A NAME="IDX580"></A>
<A NAME="IDX581"></A>
<A NAME="IDX582"></A>
<A NAME="IDX583"></A>
<A NAME="IDX584"></A>
<A NAME="IDX585"></A>
<A NAME="IDX586"></A>
<A NAME="IDX587"></A>

</P>

<PRE>
   SHOW DATABASES [LIKE wild]
or SHOW [OPEN] TABLES [FROM db_name] [LIKE wild]
or SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [LIKE wild]
or SHOW INDEX FROM tbl_name [FROM db_name]
or SHOW TABLE STATUS [FROM db_name] [LIKE wild]
or SHOW STATUS [LIKE wild]
or SHOW VARIABLES [LIKE wild]
or SHOW LOGS
or SHOW [FULL] PROCESSLIST
or SHOW GRANTS FOR user
or SHOW CREATE TABLE table_name
or SHOW MASTER STATUS
or SHOW MASTER LOGS
or SHOW SLAVE STATUS
</PRE>

<P>
<CODE>SHOW</CODE> はデータベース、テーブル、フィールド、サーバーについての情報を与えます。
<CODE>LIKE wild</CODE> が使用された場合、<CODE>wild</CODE> 文字列は通常の SQL ワイルドカード
 (<SAMP>`%'</SAMP> と <SAMP>`_'</SAMP>) です。

</P>



<H4><A NAME="SHOW_DATABASE_INFO" HREF="manual.ja_toc.html#SHOW_DATABASE_INFO">4.5.5.1  Retrieving information about Database, Tables, Columns, and Indexes</A></H4>

<P>
<A NAME="IDX588"></A>

</P>
<P>
<CODE>tbl_name FROM db_name</CODE> の代わりに、<CODE>db_name.tbl_name</CODE> が使用できます。
これら二つは同じです：

</P>

<PRE>
mysql&#62; SHOW INDEX FROM mytable FROM mydb;
mysql&#62; SHOW INDEX FROM mydb.mytable;
</PRE>

<P>
<CODE>SHOW DATABASES</CODE> は <STRONG>MySQL</STRONG> サーバー上のデータベースを示します。
<CODE>mysqlshow</CODE> コマンドでも同じ情報が得られます。

</P>
<P>
<CODE>SHOW TABLES</CODE> は指定されたデータベースのテーブルを一覧表示します。
<CODE>mysqlshow db_name</CODE> コマンドでも同じ情報が得られます。

</P>
<P>
<STRONG>NOTE</STRONG>: もしユーザーにテーブルに対する権限が無い場合、
テーブルは <CODE>SHOW TABLES</CODE> や <CODE>mysqlshow db_name</CODE> の要求で
表示されません。

</P>
<P>
<CODE>SHOW OPEN TABLES</CODE> はテーブルキャッシュに現在オープン去れているテーブ
ルを一覧表示します。 「<A HREF="manual.ja_MySQL_Optimization.html#Table_cache">5.4.6  MySQL はどのようにテーブルのオープン &#38; クローズを行なうか？</A>」節参照. <CODE>Comment</CODE> フィールドはテーブ
ルが何回 <CODE>cached</CODE> と <CODE>in_use</CODE> になったかを知らせます。

</P>
<P>
<CODE>SHOW COLUMNS</CODE> は与えられたテーブルのフィールドを表示します。
<CODE>FULL</CODE> オプションを指定した場合、各フィールドに持つ権限も得られます。
もしそのフィールドの型が、あなたが <CODE>CREATE TABLE</CODE> 構文実行時に与えたものと
違う場合は、 <STRONG>MySQL</STRONG> は、フィールドの型をときおり変更することが
あることに注意してください。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

</P>
<P>
<CODE>DESCRIBE</CODE> 文は <CODE>SHOW COLUMNS</CODE> と似たような情報を提供します。
 「<A HREF="manual.ja_Reference.html#DESCRIBE">6.6.2  <CODE>DESCRIBE</CODE> 構文 (フィールドについての情報を得る)</A>」節参照.

</P>
<P>
<CODE>SHOW FIELDS</CODE> は <CODE>SHOW COLUMNS</CODE> の別名として使用され、
<CODE>SHOW KEYS</CODE> は <CODE>SHOW INDEX</CODE> の別名として使用されます。
テーブルのフィールドやインデックスは <CODE>mysqlshow db_name tbl_name</CODE>
か <CODE>mysqlshow -k db_name tbl_name</CODE> でも見れます。

</P>
<P>
<CODE>SHOW INDEX</CODE> は ODBC でいう <CODE>SQLStatistics</CODE> 
に近い形式で、インデックスの情報を表示します。
以下の項目が返ります：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Column</STRONG> </TD><TD> <STRONG>意味</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Table</CODE> </TD><TD> テーブル名
</TR NOSAVE>
<TR><TD><CODE>Non_unique</CODE> </TD><TD> インデックスが重複を含まないなら 0
</TR NOSAVE>
<TR><TD><CODE>Key_name</CODE> </TD><TD> インデックス名
</TR NOSAVE>
<TR><TD><CODE>Seq_in_index</CODE> </TD><TD> インデックスの項目番号。1 から始まります。
</TR NOSAVE>
<TR><TD><CODE>Column_name</CODE> </TD><TD> フィールド名。
</TR NOSAVE>
<TR><TD><CODE>Collation</CODE> </TD><TD> どのようにこのフィールドがインデックス中で
                                      ソートされるか.  MySQL ではこれは
                                      <CODE>A</CODE> (Ascending) か <CODE>NULL</CODE> (Not sorted) に
                                      なります。
</TR NOSAVE>
<TR><TD><CODE>Cardinality</CODE> </TD><TD> インデックス中のユニークな値の数。
                                      これは <CODE>isamchk -a</CODE> の実行で更新されます。
</TR NOSAVE>
<TR><TD><CODE>Sub_part</CODE> </TD><TD> もしこのフィールドがインデックスに一部分だけ使用
している場合、そのインデックスに使用しているキャラクター数をしめす。 もしキー全
体がインデックスされているなら <CODE>NULL</CODE> 。
</TR NOSAVE>
<TR><TD><CODE>Comment</CODE> </TD><TD> Various remarks.  For now, it tells
                                      whether index is FULLTEXT or not.
</TR>
</TABLE>

<P>
Note that as the <CODE>Cardinality</CODE> is counted based on statistics
stored as integers, it's not necessarily accurate for small tables.

</P>



<H4><A NAME="SHOW_TABLE_STATUS" HREF="manual.ja_toc.html#SHOW_TABLE_STATUS">4.5.5.2  <CODE>SHOW TABLE STATUS</CODE></A></H4>

<P>
<A NAME="IDX589"></A>
<A NAME="IDX590"></A>
<A NAME="IDX591"></A>

</P>

<PRE>
SHOW TABLE STATUS [FROM db_name] [LIKE wild]
</PRE>

<P>
<CODE>SHOW TABLE STATUS</CODE> (バージョン 3.23 の新機能) は <CODE>SHOW STATUS</CODE> 
のようですが、それぞれのテーブルについてより多くの情報を提供します。
<CODE>mysqlshow --status db_name</CODE> コマンドを実行しても同じものが得られます。
以下の項目が返ってきます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>項目</STRONG> </TD><TD> <STRONG>意味</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Name</CODE> </TD><TD> テーブル名
</TR NOSAVE>
<TR><TD><CODE>Type</CODE> </TD><TD> テーブルの種類  「<A HREF="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</A>」節参照.
</TR NOSAVE>
<TR><TD><CODE>Row_format</CODE> </TD><TD> レコードの保存形式 (Fixed, Dynamic, or Compressed)
</TR NOSAVE>
<TR><TD><CODE>Rows</CODE> </TD><TD> レコード数
</TR NOSAVE>
<TR><TD><CODE>Avg_row_length</CODE> </TD><TD> レコードの平均長
</TR NOSAVE>
<TR><TD><CODE>Data_length</CODE> </TD><TD> データファイルの大きさ
</TR NOSAVE>
<TR><TD><CODE>Max_data_length</CODE> </TD><TD> データファイルの最大値
</TR NOSAVE>
<TR><TD><CODE>Index_length</CODE> </TD><TD> インデックスファイルの大きさ
</TR NOSAVE>
<TR><TD><CODE>Data_free</CODE> </TD><TD> 割り当てられたが使用されていないバイト数
</TR NOSAVE>
<TR><TD><CODE>Auto_increment</CODE> </TD><TD> 次の autoincrement 値
</TR NOSAVE>
<TR><TD><CODE>Create_time</CODE> </TD><TD> テーブル作成時刻
</TR NOSAVE>
<TR><TD><CODE>Update_time</CODE> </TD><TD> 一番最後に更新された時刻
</TR NOSAVE>
<TR><TD><CODE>Check_time</CODE> </TD><TD> 一番最後にチェックされた時刻
</TR NOSAVE>
<TR><TD><CODE>Create_options</CODE> </TD><TD> <CODE>CREATE TABLE</CODE> で使用された拡張オプション
</TR NOSAVE>
<TR><TD><CODE>Comment</CODE> </TD><TD> テーブル作成時につけられたコメント (あるいは、なぜこの
テーブルに<STRONG>MySQL</STRONG> がアクセスできないかのいくつかの情報).
</TR>
</TABLE>

<P>
<CODE>InnoDB</CODE> tables will report the free space in the tablespace
in the table comment.

</P>



<H4><A NAME="SHOW_STATUS" HREF="manual.ja_toc.html#SHOW_STATUS">4.5.5.3  <CODE>SHOW STATUS</CODE></A></H4>

<P>
<A NAME="IDX592"></A>
<CODE>SHOW STATUS</CODE> は <CODE>mysqladmin extended-status</CODE> と同様に、
サーバからのステータス情報を与えます。出力は次とは異なるかもしれません:

</P>

<PRE>
+--------------------------+------------+
| Variable_name            | Value      |
+--------------------------+------------+
| Aborted_clients          | 0          |
| Aborted_connects         | 0          |
| Bytes_received           | 155372598  |
| Bytes_sent               | 1176560426 |
| Connections              | 30023      |
| Created_tmp_disk_tables  | 0          |
| Created_tmp_tables       | 8340       |
| Created_tmp_files        | 60         |
| Delayed_insert_threads   | 0          |
| Delayed_writes           | 0          |
| Delayed_errors           | 0          |
| Flush_commands           | 1          |
| Handler_delete           | 462604     |
| Handler_read_first       | 105881     |
| Handler_read_key         | 27820558   |
| Handler_read_next        | 390681754  |
| Handler_read_prev        | 6022500    |
| Handler_read_rnd         | 30546748   |
| Handler_read_rnd_next    | 246216530  |
| Handler_update           | 16945404   |
| Handler_write            | 60356676   |
| Key_blocks_used          | 14955      |
| Key_read_requests        | 96854827   |
| Key_reads                | 162040     |
| Key_write_requests       | 7589728    |
| Key_writes               | 3813196    |
| Max_used_connections     | 0          |
| Not_flushed_key_blocks   | 0          |
| Not_flushed_delayed_rows | 0          |
| Open_tables              | 1          |
| Open_files               | 2          |
| Open_streams             | 0          |
| Opened_tables            | 44600      |
| Questions                | 2026873    |
| Select_full_join         | 0          |
| Select_full_range_join   | 0          |
| Select_range             | 99646      |
| Select_range_check       | 0          |
| Select_scan              | 30802      |
| Slave_running            | OFF        |
| Slave_open_temp_tables   | 0          |
| Slow_launch_threads      | 0          |
| Slow_queries             | 0          |
| Sort_merge_passes        | 30         |
| Sort_range               | 500        |
| Sort_rows                | 30296250   |
| Sort_scan                | 4650       |
| Table_locks_immediate    | 1920382    |
| Table_locks_waited       | 0          |
| Threads_cached           | 0          |
| Threads_created          | 30022      |
| Threads_connected        | 1          |
| Threads_running          | 1          |
| Uptime                   | 80380      |
+--------------------------+------------+
</PRE>

<P>
<A NAME="IDX593"></A>
上に示したステータス変数は以下に示すの意味を持ちます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Variable</STRONG> </TD><TD> <STRONG>Meaning</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Aborted_clients</CODE> </TD><TD> クライアントが接続を閉じる前に死んでしまったために中断されたコネクション数。  「<A HREF="manual.ja_Problems.html#Communication_errors">A.2.9  Communication Errors / Aborted Connection</A>」節参照.
</TR NOSAVE>
<TR><TD><CODE>Aborted_connects</CODE> </TD><TD> MySQL サーバーに接続を試みて失敗した数。  「<A HREF="manual.ja_Problems.html#Communication_errors">A.2.9  Communication Errors / Aborted Connection</A>」節参照.
</TR NOSAVE>
<TR><TD><CODE>Bytes_received</CODE> </TD><TD> クライアントから受信したバイト数
</TR NOSAVE>
<TR><TD><CODE>Bytes_sent</CODE> </TD><TD> クライアントに送信したバイト数
</TR NOSAVE>
<TR><TD><CODE>Com_xxxx</CODE> </TD><TD> Number of times the xxx commands has been executed.
</TR NOSAVE>
<TR><TD><CODE>Connections</CODE> </TD><TD> MySQL サーバーに接続を試みた数
</TR NOSAVE>
<TR><TD><CODE>Created_tmp_disk_tables</CODE> </TD><TD> ステートメント実行中に暗黙のうちに作成されたメモり内にある一時テーブルの数
</TR NOSAVE>
<TR><TD><CODE>Created_tmp_tables</CODE> </TD><TD> Number of implicit temporary tables in memory created while executing statements.
</TR NOSAVE>
<TR><TD><CODE>Created_tmp_files</CODE> </TD><TD> How many temporary files <CODE>mysqld</CODE> have created.
</TR NOSAVE>
<TR><TD><CODE>Delayed_insert_threads</CODE> </TD><TD> Number of delayed insert handler threads in use.
</TR NOSAVE>
<TR><TD><CODE>Delayed_writes</CODE> </TD><TD> Number of rows written with <CODE>INSERT DELAYED</CODE>.
</TR NOSAVE>
<TR><TD><CODE>Delayed_errors</CODE> </TD><TD> Number of rows written with <CODE>INSERT DELAYED</CODE> for which some error occurred (probably <CODE>duplicate key</CODE>).
</TR NOSAVE>
<TR><TD><CODE>Flush_commands</CODE> </TD><TD> <CODE>FLUSH</CODE> コマンドの実行回数
</TR NOSAVE>
<TR><TD><CODE>Handler_delete</CODE> </TD><TD> Number of times a row was deleted from a table.
</TR NOSAVE>
<TR><TD><CODE>Handler_read_first</CODE> </TD><TD> Number of times the first entry was read from an index.
If this is high, it suggests that the server is doing a lot of full index scans, for example,
<CODE>SELECT col1 FROM foo</CODE>, assuming that col1 is indexed.
</TR NOSAVE>
<TR><TD><CODE>Handler_read_key</CODE> </TD><TD> Number of requests to read a row based on a key. If this
is high, it is a good indication that your queries and tables are properly indexed.
</TR NOSAVE>
<TR><TD><CODE>Handler_read_next</CODE> </TD><TD> Number of requests to read next row in key order. This
will be incremented if you are querying an index column with a range constraint. This also
will be incremented if you are doing an index scan.
</TR NOSAVE>
<TR><TD><CODE>Handler_read_rnd</CODE> </TD><TD> Number of requests to read a row based on a fixed position.
This will be high if you are doing a lot of queries that require sorting of the result.
</TR NOSAVE>
<TR><TD><CODE>Handler_read_rnd_next</CODE> </TD><TD> Number of requests to read the next row in the datafile.
This will be high if you are doing a lot of table scans. Generally this suggests that your tables
are not properly indexed or that your queries are not written to take advantage of the indexes you
have.
</TR NOSAVE>
<TR><TD><CODE>Handler_update</CODE> </TD><TD> Number of requests to update a row in a table.
</TR NOSAVE>
<TR><TD><CODE>Handler_write</CODE> </TD><TD> Number of requests to insert a row in a table.
</TR NOSAVE>
<TR><TD><CODE>Key_blocks_used</CODE> </TD><TD> The number of used blocks in the key cache.
</TR NOSAVE>
<TR><TD><CODE>Key_read_requests</CODE> </TD><TD> The number of requests to read a key block from the cache.
</TR NOSAVE>
<TR><TD><CODE>Key_reads</CODE> </TD><TD> The number of physical reads of a key block from disk.
</TR NOSAVE>
<TR><TD><CODE>Key_write_requests</CODE> </TD><TD> The number of requests to write a key block to the cache.
</TR NOSAVE>
<TR><TD><CODE>Key_writes</CODE> </TD><TD> The number of physical writes of a key block to disk.
</TR NOSAVE>
<TR><TD><CODE>Max_used_connections</CODE> </TD><TD> The maximum number of connections in use simultaneously.
</TR NOSAVE>
<TR><TD><CODE>Not_flushed_key_blocks</CODE> </TD><TD> Keys blocks in the key cache that has changed but hasn't yet been flushed to disk.
</TR NOSAVE>
<TR><TD><CODE>Not_flushed_delayed_rows</CODE> </TD><TD> Number of rows waiting to be written in <CODE>INSERT DELAY</CODE> queues.
</TR NOSAVE>
<TR><TD><CODE>Open_tables</CODE> </TD><TD> オープンされているテーブル数
</TR NOSAVE>
<TR><TD><CODE>Open_files</CODE> </TD><TD> Number of files that are open.
</TR NOSAVE>
<TR><TD><CODE>Open_streams</CODE> </TD><TD> Number of streams that are open (used mainly for logging).
</TR NOSAVE>
<TR><TD><CODE>Opened_tables</CODE> </TD><TD> Number of tables that have been opened.
</TR NOSAVE>
<TR><TD><CODE>Select_full_join</CODE> </TD><TD> Number of joins without keys (Should be 0).
</TR NOSAVE>
<TR><TD><CODE>Select_full_range_join</CODE> </TD><TD> Number of joins where we used a range search on reference table.
</TR NOSAVE>
<TR><TD><CODE>Select_range</CODE> </TD><TD> Number of joins where we used ranges on the first table. (It's normally not critical even if this is big.)
</TR NOSAVE>
<TR><TD><CODE>Select_scan</CODE> </TD><TD> Number of joins where we scanned the first table.
</TR NOSAVE>
<TR><TD><CODE>Select_range_check</CODE> </TD><TD> Number of joins without keys where we check for key usage after each row (Should be 0).
</TR NOSAVE>
<TR><TD><CODE>Questions</CODE> </TD><TD> サーバーに送られたクエリの数
</TR NOSAVE>
<TR><TD><CODE>Slave_open_temp_tables</CODE> </TD><TD> Number of temporary tables currently
open by the slave thread
</TR NOSAVE>
<TR><TD><CODE>Slow_launch_threads</CODE> </TD><TD> Number of threads that have taken more than <CODE>slow_launch_time</CODE> to connect.
</TR NOSAVE>
<TR><TD><CODE>Slow_queries</CODE> </TD><TD> code{long_query_time} 以上に時間のかかったクエリの数  「<A HREF="manual.ja_MySQL_Database_Administration.html#Slow_query_log">4.9.5  The Slow Query Log</A>」節参照.
</TR NOSAVE>
<TR><TD><CODE>Sort_merge_passes</CODE> </TD><TD> Number of merges the sort has to do. If this value is large you should consider increasing <CODE>sort_buffer</CODE>.
</TR NOSAVE>
<TR><TD><CODE>Sort_range</CODE> </TD><TD> Number of sorts that where done with ranges.
</TR NOSAVE>
<TR><TD><CODE>Sort_rows</CODE> </TD><TD> Number of sorted rows.
</TR NOSAVE>
<TR><TD><CODE>Sort_scan</CODE> </TD><TD> Number of sorts that where done by scanning the table.
</TR NOSAVE>
<TR><TD><CODE>Table_locks_immediate</CODE> </TD><TD> Number of times a table lock was
acquired immediately. Available after 3.23.33.
</TR NOSAVE>
<TR><TD><CODE>Table_locks_waited</CODE> </TD><TD> Number of times a table lock could not
be acquired immediately and a wait was needed. If this is high, and you
have performance problems, you should first optimize your queries, and then
either split your table(s) or use replication. Available after 3.23.33.
</TR NOSAVE>
<TR><TD><CODE>Threads_cached</CODE> </TD><TD> Number of threads in the thread cache.
</TR NOSAVE>
<TR><TD><CODE>Threads_connected</CODE> </TD><TD> 現在開いている接続数
</TR NOSAVE>
<TR><TD><CODE>Threads_created</CODE> </TD><TD> Number of threads created to handle connections.
</TR NOSAVE>
<TR><TD><CODE>Threads_running</CODE> </TD><TD> スリープ状態になっていないスレッドの数
</TR NOSAVE>
<TR><TD><CODE>Uptime</CODE> </TD><TD> サーバーが走っている秒数
</TR>
</TABLE>

<P>
上についてのいくつかコメント：

</P>

<UL>
<LI>

もし <CODE>Opened_tables</CODE> が大きければ、 <CODE>table_cache</CODE> 変数が小さすぎる
のでしょう。

<LI>

もし <CODE>key_reads</CODE> が大きければ、 <CODE>key_cache</CODE> が少なすぎるでしょう。
キャッシュヒットレートは
<CODE>key_reads</CODE>/<CODE>key_read_requests</CODE> で計算できます。

<LI>

If <CODE>Handler_read_rnd</CODE> is big, then you probably have a lot of
queries that require MySQL to scan whole tables or you have
joins that don't use keys properly.

<LI>

If <CODE>Threads_created</CODE> is big, you may want to increase the
<CODE>thread_cache_size</CODE> variable.
</UL>



<H4><A NAME="SHOW_VARIABLES" HREF="manual.ja_toc.html#SHOW_VARIABLES">4.5.5.4  <CODE>SHOW VARIABLES</CODE></A></H4>


<PRE>
SHOW VARIABLES [LIKE wild]
</PRE>

<P>
<CODE>SHOW VARIABLES</CODE> は <STRONG>MySQL</STRONG> システム変数のいくつかの値を示します。
<CODE>mysqlshow variables</CODE> コマンドでも同じ情報が得られます。
もし標準値が適さないなら、ほとんどの変数を <CODE>mysqld</CODE> 起動時に
コマンドラインのオプションとして与えることにより、変更できます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Command-line_options">4.1.1  mysqld コマンド行オプション</A>」節参照.

</P>
<P>
出力は以下のようになりますが、フォーマットや数はいくぶん違うでしょう：

</P>

<PRE>
+-------------------------+---------------------------+
| Variable_name           | Value                     |
+-------------------------+---------------------------+
| ansi_mode               | OFF                       |
| back_log                | 50                        |
| basedir                 | /my/monty/                |
| bdb_cache_size          | 16777216                  |
| bdb_log_buffer_size     | 32768                     |
| bdb_home                | /my/monty/data/           |
| bdb_max_lock            | 10000                     |
| bdb_logdir              |                           |
| bdb_shared_data         | OFF                       |
| bdb_tmpdir              | /tmp/                     |
| binlog_cache_size       | 32768                     |
| concurrent_insert       | ON                        |
| connect_timeout         | 5                         |
| datadir                 | /my/monty/data/           |
| delay_key_write         | ON                        |
| delayed_insert_limit    | 100                       |
| delayed_insert_timeout  | 300                       |
| delayed_queue_size      | 1000                      |
| flush                   | OFF                       |
| flush_time              | 0                         |
| have_bdb                | YES                       |
| have_innodb             | YES                       |
| have_raid               | YES                       |
| have_ssl                | NO                        |
| init_file               |                           |
| interactive_timeout     | 28800                     |
| join_buffer_size        | 131072                    |
| key_buffer_size         | 16776192                  |
| language                | /my/monty/share/english/  |
| large_files_support     | ON                        |
| log                     | OFF                       |
| log_update              | OFF                       |
| log_bin                 | OFF                       |
| log_slave_updates       | OFF                       |
| long_query_time         | 10                        |
| low_priority_updates    | OFF                       |
| lower_case_table_names  | 0                         |
| max_allowed_packet      | 1048576                   |
| max_binlog_cache_size   | 4294967295                |
| max_connections         | 100                       |
| max_connect_errors      | 10                        |
| max_delayed_threads     | 20                        |
| max_heap_table_size     | 16777216                  |
| max_join_size           | 4294967295                |
| max_sort_length         | 1024                      |
| max_tmp_tables          | 32                        |
| max_write_lock_count    | 4294967295                |
| myisam_recover_options  | DEFAULT                   |
| myisam_sort_buffer_size | 8388608                   |
| net_buffer_length       | 16384                     |
| net_read_timeout        | 30                        |
| net_retry_count         | 10                        |
| net_write_timeout       | 60                        |
| open_files_limit        | 0                         |
| pid_file                | /my/monty/data/donna.pid  |
| port                    | 3306                      |
| protocol_version        | 10                        |
| record_buffer           | 131072                    |
| query_buffer_size       | 0                         |
| safe_show_database      | OFF                       |
| server_id               | 0                         |
| skip_locking            | ON                        |
| skip_networking         | OFF                       |
| skip_show_database      | OFF                       |
| slow_launch_time        | 2                         |
| socket                  | /tmp/mysql.sock           |
| sort_buffer             | 2097116                   |
| table_cache             | 64                        |
| table_type              | MYISAM                    |
| thread_cache_size       | 4                         |
| thread_stack            | 65536                     |
| tmp_table_size          | 1048576                   |
| tmpdir                  | /tmp/                     |
| version                 | 3.23.29a-gamma-debug      |
| wait_timeout            | 28800                     |
+-------------------------+---------------------------+
</PRE>

<P>
これらのオプションは以下のように決めてください。
buffer size, buffer length, stack size は byte 単位で与えます。
これらの値の後ろに <SAMP>`K'</SAMP> や <SAMP>`M'</SAMP> を追加すると、キロバイト、
メガバイトになります。
例えば、<CODE>16M</CODE> は16メガバイトを示します。大文字小文字の区別はなく、
<CODE>16M</CODE> と <CODE>16m</CODE> は同じ意味になります。

</P>
<P>
<A NAME="IDX594"></A>
<DL COMPACT>

<DT><CODE><CODE>ansi_mode</CODE>.</CODE>
<DD>
もし <CODE>mysqld</CODE> が <CODE>--ansi</CODE> オプションで起動されているなら、<CODE>ON</CODE>.
 「<A HREF="manual.ja_Introduction.html#ANSI_mode">1.4.3  ANSI モードでの MySQL の実行</A>」節参照.

<DT><CODE><CODE>back_log</CODE></CODE>
<DD>
<STRONG>MySQL</STRONG> が持てる未解決の接続要求の数です。これは <STRONG>MySQL</STRONG> 
スレッドが<STRONG>ものすごく</STRONG>多くの接続要求をとても短い時間に得た時に、働き
ます。接続のチェックと新しいスレッドの開始はメインスレッドにすこし時間
(しかしほんのわずか)がかかります。back_log は、<STRONG>MySQL</STRONG> が瞬間的に新
しい要求への回答を停止する前に、この短い時間の間にスタックできる接続数です。
短い期間に多くの接続を期待する場合にだけ、これを増加する必要があります。

いいかえるなら、これは TCP/IP 接続の入力 listen キューのサイズです。
オペレーティングシステムはこのキューの大きさを制限しています。
UNIX システムコール <CODE>listen(2)</CODE> のマニュアルページに、さらに詳細があります。
この値を最大限にしたい場合、お使いのOSのドキュメントを見てください。
<CODE>back_log</CODE> をこのOSの制限値より多く取ってもは全く効果ありません。

<DT><CODE><CODE>basedir</CODE></CODE>
<DD>
The value of the <CODE>--basedir</CODE> option.

<DT><CODE><CODE>bdb_cache_size</CODE></CODE>
<DD>
The buffer that is allocated to cache index and rows for <CODE>BDB</CODE>
tables.  If you don't use <CODE>BDB</CODE> tables, you should start
<CODE>mysqld</CODE> with <CODE>--skip-bdb</CODE> to not waste memory for this
cache.

<DT><CODE><CODE>bdb_log_buffer_size</CODE></CODE>
<DD>
The buffer that is allocated to cache index and rows for <CODE>BDB</CODE>
tables.  If you don't use <CODE>BDB</CODE> tables, you should set this to 0 or
start <CODE>mysqld</CODE> with <CODE>--skip-bdb</CODE> to not waste memory for this
cache.

<DT><CODE><CODE>bdb_home</CODE></CODE>
<DD>
The value of the <CODE>--bdb-home</CODE> option.

<DT><CODE><CODE>bdb_max_lock</CODE></CODE>
<DD>
The maximum number of locks (1000 by default) you can have active on a
BDB table. You should increase this if you get errors of type <CODE>bdb:
Lock table is out of available locks</CODE> or <CODE>Got error 12 from ...</CODE>
when you have do long transactions or when <CODE>mysqld</CODE> has to examine
a lot of rows to calculate the query.

<DT><CODE><CODE>bdb_logdir</CODE></CODE>
<DD>
The value of the <CODE>--bdb-logdir</CODE> option.

<DT><CODE><CODE>bdb_shared_data</CODE></CODE>
<DD>
Is <CODE>ON</CODE> if you are using <CODE>--bdb-shared-data</CODE>.

<DT><CODE><CODE>bdb_tmpdir</CODE></CODE>
<DD>
The value of the <CODE>--bdb-tmpdir</CODE> option.

<DT><CODE><CODE>binlog_cache_size</CODE>.  The size of the cache to hold the SQL</CODE>
<DD>
statements for the binary log during a transaction.  If you often use
big, multi-statement transactions you can increase this to get more
performance.  「<A HREF="manual.ja_Reference.html#COMMIT">6.7.1  <CODE>BEGIN/COMMIT/ROLLBACK</CODE> 構文</A>」節参照.

<DT><CODE><CODE>character_set</CODE></CODE>
<DD>
The default character set.

<DT><CODE><CODE>character_sets</CODE></CODE>
<DD>
The supported character sets.

<DT><CODE><CODE>concurrent_inserts</CODE></CODE>
<DD>
もし <CODE>ON</CODE> (これはデフォルトです) なら、<STRONG>MySQL</STRONG> は、
<CODE>SELECT</CODE> クエリが実行されている <CODE>MyISAM</CODE> テーブルに対して、
同時に <CODE>INSERT</CODE> が使用できるようにします。
このオプションは <CODE>mysqld</CODE> のオプションに <CODE>--safe</CODE> か <CODE>--skip-new</CODE> を
指定することで  <CODE>OFF</CODE> にできます。

<A NAME="IDX595"></A>
<DT><CODE><CODE>connect_timeout</CODE></CODE>
<DD>
<CODE>mysqld</CODE> サーバーが接続パケットを待つ秒数。 (<CODE>Bad handshake</CODE> を返すま
での秒数)

<DT><CODE><CODE>datadir</CODE></CODE>
<DD>
The value of the <CODE>--datadir</CODE> option.

<DT><CODE><CODE>delay_key_write</CODE></CODE>
<DD>
もし enabled であれば(これがデフォルト)、<STRONG>MySQL</STRONG> は <CODE>CREATE TABLE</CODE> 文の
<CODE>DELAY_KEY_WRITE</CODE> オプションを尊重します。
<CODE>DELAY_KEY_WRITE</CODE>オプションを指定されて作られたテーブルのキーバッファは、
毎回のインデックスの更新にはフラッシュされず、ただテーブルが閉じられたときにだけ
フラッシュされます。 これはキーの書き出しを速くしますが、もしこれを使用するなら、
全てのテーブルを <CODE>myisamchk --fast --force</CODE> で自動的に検査するようにすべき
です。
もし <CODE>mysqld</CODE> を <CODE>--delay-key-write_for_all_tables</CODE> オプション付きで
起動した場合、これは、全てのテーブルが <CODE>delay_key_write</CODE> オプション指定されて
作成されたものとして扱われる事に注意してください。
このフラグは、<CODE>mysqld</CODE> を <CODE>--skip-new</CODE> や <CODE>--safe-mode</CODE> オプション
で起動すれば無効にすることも出来ます。

<DT><CODE><CODE>delayed_insert_limit</CODE></CODE>
<DD>
<CODE>delayed_insert_limit</CODE> 個のレコードを挿入した後、 <CODE>INSERT DELAYED</CODE>
ハンドラーは待たされている <CODE>SELECT</CODE> 文がないかチェックします。 もしあるなら、
挿入を続ける前にそれらの実行を許します。

<DT><CODE><CODE>delayed_insert_timeout</CODE></CODE>
<DD>
どれぐらい <CODE>INSERT DELAYED</CODE> スレッドが <CODE>INSERT</CODE> 文を待つべきか。

<DT><CODE><CODE>delayed_queue_size</CODE></CODE>
<DD>
What size queue (in rows) should be allocated for handling <CODE>INSERT
DELAYED</CODE>.  If the queue becomes full, any client that does <CODE>INSERT
DELAYED</CODE> will wait until there is room in the queue again.

<DT><CODE><CODE>flush</CODE></CODE>
<DD>
This is <CODE>ON</CODE> if you have started MySQL with the <CODE>--flush</CODE>
option.

<DT><CODE><CODE>flush_time</CODE></CODE>
<DD>
これがもし、非ゼロにセットされたなら、毎 <CODE>flush_time</CODE> 秒ごとに
全てのテーブルが閉じられます。 (リソースの解放とDiskへのsyncのために)
We
only recommend this option on Win95, Win98, or on systems where you have
very little resources.

<DT><CODE><CODE>have_bdb</CODE></CODE>
<DD>
<CODE>YES</CODE> if <CODE>mysqld</CODE> supports Berkeley DB tables. <CODE>DISABLED</CODE>
if <CODE>--skip-bdb</CODE> is used.
<DT><CODE><CODE>have_innodb</CODE></CODE>
<DD>
<CODE>YES</CODE> if <CODE>mysqld</CODE> supports InnoDB tables. <CODE>DISABLED</CODE>
if <CODE>--skip-innodb</CODE> is used.
<DT><CODE><CODE>have_raid</CODE></CODE>
<DD>
<CODE>YES</CODE> if <CODE>mysqld</CODE> supports the <CODE>RAID</CODE> option.
<DT><CODE><CODE>have_ssl</CODE></CODE>
<DD>
<CODE>YES</CODE> if <CODE>mysqld</CODE> supports SSL (encryption) on the client/server
protocol.

<DT><CODE><CODE>init_file</CODE></CODE>
<DD>
サーバー起動時に、<CODE>--init-file</CODE> オプションに与えたファイルの名前です。
このファイルには、サーバー起動時に実行したい SQL 文を書いておきます。

<DT><CODE><CODE>interactive_timeout</CODE></CODE>
<DD>
The number of seconds the server waits for activity on an interactive
connection before closing it.  An interactive client is defined as a
client that uses the <CODE>CLIENT_INTERACTIVE</CODE> option to
<CODE>mysql_real_connect()</CODE>.  See also <CODE>wait_timeout</CODE>.

<DT><CODE><CODE>join_buffer_size</CODE></CODE>
<DD>
このバッファは(インデックス無しの)完全な結合に使用されます。それは2つの
テーブル間の完全な結合ごとに1回割り当てられます。インデックスの追加がで
きない時、より速い完全な結合を得るために、これを増加してください。通常、
速い結合を得る一番良い方法は、インデックスを追加することです。

<A NAME="IDX596"></A>
<DT><CODE><CODE>key_buffer_size</CODE></CODE>
<DD>
インデックス・ブロックはバッファされ、そして全てのスレッドに共有されます。
<CODE>key_buffer_size</CODE> はインデックス・ブロックのためのバッファ・サイズです。

Increase this to get better index handling (for all reads and multiple
writes) to as much as you can afford; 64M on a 256M machine that mainly
runs MySQL is quite common.  If you, however, make this too big
(more than 50% of your total memory?) your system may start to page and
become REALLY slow. Remember that because MySQL does not cache
data read, that you will have to leave some room for the OS filesystem
cache.

You can check the performance of the key buffer by doing <CODE>show
status</CODE> and examine the variables <CODE>Key_read_requests</CODE>,
<CODE>Key_reads</CODE>, <CODE>Key_write_requests</CODE>, and <CODE>Key_writes</CODE>.  The
<CODE>Key_reads/Key_read_request</CODE> ratio should normally be &#60; 0.01.
The <CODE>Key_write/Key_write_requests</CODE> is usually near 1 if you are
using mostly updates/deletes but may be much smaller if you tend to
do updates that affect many at the same time or if you are
using <CODE>delay_key_write</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW">4.5.5  <CODE>SHOW</CODE> 構文</A>」節参照.

To get even more speed when writing many rows at the same time, use
<CODE>LOCK TABLES</CODE>.   「<A HREF="manual.ja_Reference.html#LOCK_TABLES">6.7.2  <CODE>LOCK TABLES/UNLOCK TABLES</CODE> 構文</A>」節参照.

<DT><CODE><CODE>language</CODE></CODE>
<DD>
The language used for error messages.

<DT><CODE><CODE>large_file_support</CODE></CODE>
<DD>
If <CODE>mysqld</CODE> was compiled with options for big file support.

<DT><CODE><CODE>locked_in_memory</CODE></CODE>
<DD>
If <CODE>mysqld</CODE> was locked in memory with <CODE>--memlock</CODE>

<DT><CODE><CODE>log</CODE></CODE>
<DD>
If logging of all queries is enabled.

<DT><CODE><CODE>log_update</CODE></CODE>
<DD>
If the update log is enabled.

<DT><CODE><CODE>log_bin</CODE></CODE>
<DD>
If the binary log is enabled.

<DT><CODE><CODE>log_slave_updates</CODE></CODE>
<DD>
If the updates from the slave should be logged.

<DT><CODE><CODE>long_query_time</CODE></CODE>
<DD>
もしあるクエリがこの値(秒)より時間がかかれば、<CODE>Slow_queries</CODE> カウンター
が増やされます。
If you are using <CODE>--log-slow-queries</CODE>, the query
will be logged to the slow query logfile.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Slow_query_log">4.9.5  The Slow Query Log</A>」節参照.

<DT><CODE><CODE>lower_case_table_names</CODE></CODE>
<DD>
If set to 1 table names are stored in lowercase on disk and table
names will be case-insensitive.
 「<A HREF="manual.ja_Reference.html#Name_case_sensitivity">6.1.3  名前のケース依存性</A>」節参照.

<DT><CODE><CODE>max_allowed_packet</CODE></CODE>
<DD>
一つのパケットの最大サイズ。メッセージバッファは <CODE>net_buffer_length</CODE> バイト
に初期化されますが、
<CODE>max_allowed_packet</CODE>まで大きくすることができます。このデフォルト値は、
大きなパケット、間違ったパケットをを受けるには小さい値です。
大きな <CODE>BLOB</CODE> を使用している場合は、これを増加する必要があります。使用した
い最大の <CODE>BLOB</CODE> と同じくらい大きくするべきです。
The current protocol limits <CODE>max_allowed_packet</CODE> to 16M.

<DT><CODE><CODE>max_binlog_cache_size</CODE></CODE>
<DD>
If a multi-statement transaction requires more than this amount of memory,
one will get the error "Multi-statement transaction required more than
'max_binlog_cache_size' bytes of storage".

<DT><CODE><CODE>max_binlog_size</CODE></CODE>
<DD>
Available after 3.23.33. If a write to the binary (replication) log exceeds 
the given value, rotate the logs. You cannot set it to less than 1024 bytes, 
or more than 1 GB. Default is 1 GB.

<DT><CODE><CODE>max_connections</CODE></CODE>
<DD>
許される同時クライアントの数。これを増加する場合は、<CODE>mysqld</CODE> が持つファイ
ルディスクリプタの数を増やす必要があるでしょう。
後述のファイルデスクリプターの制限の説明を参照のこと。  「<A HREF="manual.ja_Problems.html#Too_many_connections">A.2.5  <CODE>Too many connections</CODE> Error</A>」節参照.

<DT><CODE><CODE>max_connect_errors</CODE></CODE>
<DD>
もしあるホストからの接続中断がこの値を以上になった場合、これ以後、
そのホストからの接続を拒絶します。<CODE>FLUSH HOSTS</CODE> コマンドで
ホストの拒否を解除できます。

<DT><CODE><CODE>max_delayed_threads</CODE></CODE>
<DD>
この値を超えて <CODE>INSERT DELAYED</CODE> を扱うスレッドを起動できません。
もし全ての <CODE>INSERT DELAYED</CODE> スレッドが使用されていて、さらに新しいテーブルに
データを挿入しようとすると、そのレコードは <CODE>DELAYED</CODE> が与えられていない
場合と同様に挿入されます。

<DT><CODE><CODE>max_heap_table_size</CODE></CODE>
<DD>
Don't allow creation of heap tables bigger than this.

<DT><CODE><CODE>max_join_size</CODE></CODE>
<DD>
<CODE>max_join_size</CODE> より多いレコードを触るとエラーが返ります。長い時間をかけて
百万行を返すような <CODE>WHERE</CODE> なしの結合を作成するようなユーザを持って
いる場合にこれを設定してください。

<DT><CODE><CODE>max_sort_length</CODE></CODE>
<DD>
<CODE>BLOB</CODE> または <CODE>TEXT</CODE> 項目上でソートする時に使用するバイト数。
(最初の <CODE>max_sort_length</CODE> バイトだけがそれぞれの値で使用でき、残りは無視さ
れます)

<DT><CODE><CODE>max_user_connections</CODE></CODE>
<DD>
The maximum number of active connections for a single user (0 = no limit).

<DT><CODE><CODE>max_tmp_tables</CODE></CODE>
<DD>
(このオプションはまだなにも行いません).
クライアントが同時にオープンできるテーブル数の最大値。

<DT><CODE><CODE>max_write_lock_count</CODE></CODE>
<DD>
After this many write locks, allow some read locks to run in between.

<DT><CODE><CODE>myisam_recover_options</CODE></CODE>
<DD>
The value of the <CODE>--myisam-recover</CODE> option.

<DT><CODE><CODE>myisam_sort_buffer_size</CODE></CODE>
<DD>
The buffer that is allocated when sorting the index when doing a
<CODE>REPAIR</CODE> or when creating indexes with <CODE>CREATE INDEX</CODE> or
<CODE>ALTER TABLE</CODE>.

<DT><CODE><CODE>myisam_max_extra_sort_file_size</CODE>.</CODE>
<DD>
If the creating of the temporary file for fast index creation would be
this much bigger than using the key cache, then prefer the key cache
method.  This is mainly used to force long character keys in large
tables to use the slower key cache method to create the index.
<STRONG>NOTE</STRONG> that this parameter is given in megabytes!

<DT><CODE><CODE>myisam_max_sort_file_size</CODE></CODE>
<DD>
The maximum size of the temporary file MySQL is allowed to use
while recreating the index (during <CODE>REPAIR</CODE>, <CODE>ALTER TABLE</CODE>
or <CODE>LOAD DATA INFILE</CODE>.  If the file size would be bigger than this,
the index will be created through the key cache (which is slower).
<STRONG>NOTE</STRONG> that this parameter is given in megabytes!

<DT><CODE><CODE>net_buffer_length</CODE></CODE>
<DD>
通信バッファがクエリ間でこのサイズにリセットされます。これは通常は変更す
べきではありませんが、とても小さなメモリしかない場合は、これを期待される
クエリのサイズに設定してください。
( これは、クライアントから送られてくるSQL文の長さ分あればいいでしょう。
もし構文がこの値をこえた場合、バッファは自動的に大きくなります。
ただし <CODE>max_allowed_packet</CODE> バイトまでです)

<DT><CODE><CODE>net_read_timeout</CODE></CODE>
<DD>
Number of seconds to wait for more data from a connection before aborting
the read.  Note that when we don't expect data from a connection, the timeout
is defined by <CODE>write_timeout</CODE>. See also <CODE>slave_read_timeout</CODE>.

<DT><CODE><CODE>net_retry_count</CODE></CODE>
<DD>
If a read on a communication port is interrupted, retry this many times
before giving up.  This value should be quite high on <CODE>FreeBSD</CODE> as
internal interrupts are sent to all threads.

<DT><CODE><CODE>net_write_timeout</CODE></CODE>
<DD>
Number of seconds to wait for a block to be written to a connection before
aborting the write.

<DT><CODE><CODE>open_files_limit</CODE></CODE>
<DD>
If this is not 0, then <CODE>mysqld</CODE> will use this value to reserve file
descriptors to use with <CODE>setrlimit()</CODE>.  If this value is 0 then
<CODE>mysqld</CODE> will reserve <CODE>max_connections*5</CODE> or
<CODE>max_connections + table_cache*2</CODE> (whichever is larger) number of
files.  You should try increasing this if <CODE>mysqld</CODE> gives you the
error 'Too many open files'.

<DT><CODE><CODE>pid_file</CODE></CODE>
<DD>
The value of the <CODE>--pid-file</CODE> option.

<DT><CODE><CODE>port</CODE></CODE>
<DD>
The value of the <CODE>--port</CODE> option.

<DT><CODE><CODE>protocol_version</CODE></CODE>
<DD>
The protocol version used by the MySQL server.

<DT><CODE><CODE>record_buffer</CODE></CODE>
<DD>
順序スキャンを行う各スレッドが、スキャンするテーブル毎に、このサイズのバッ
ファを割り当てます。多くの順序スキャンを行う場合は、これを増加させてくだ
さい。

<DT><CODE><CODE>record_rnd_buffer</CODE></CODE>
<DD>
When reading rows in sorted order after a sort, the rows are read through this
buffer to avoid a disk seeks.  If not set, then it's set to the value of
<CODE>record_buffer</CODE>.

<DT><CODE><CODE>query_buffer_size</CODE></CODE>
<DD>
The initial allocation of the query buffer. If most of your queries are
long (like when inserting blobs), you should increase this!

<DT><CODE><CODE>safe_show_databases</CODE></CODE>
<DD>
Don't show databases for which the user doesn't have any database or
table privileges. This can improve security if you're concerned about
people being able to see what databases other users have. See also
<CODE>skip_show_databases</CODE>.

<DT><CODE><CODE>server_id</CODE></CODE>
<DD>
The value of the <CODE>--server-id</CODE> option.

<DT><CODE><CODE>skip_locking</CODE></CODE>
<DD>
Is OFF if <CODE>mysqld</CODE> uses external locking.

<DT><CODE><CODE>skip_networking</CODE></CODE>
<DD>
Is ON if we only allow local (socket) connections.

<DT><CODE><CODE>skip_show_databases</CODE></CODE>
<DD>
これは、 <CODE>PROCESS_PRIV</CODE> 権限を持っていないユーザーが
 <CODE>SHOW DATABASES</CODE> する事を阻止します。 もし、他人のデータベースや
テーブルを見ようとする人がいる事を、あなたが心配するならば、
これはセキュリティを強化できます。
See also <CODE>safe_show_databases</CODE>.

<DT><CODE><CODE>slave_read_timeout</CODE></CODE>
<DD>
Number of seconds to wait for more data from a master/slave connection
before aborting the read.

<DT><CODE><CODE>slow_launch_time</CODE></CODE>
<DD>
If creating the thread takes longer than this value (in seconds), the
<CODE>Slow_launch_threads</CODE> counter will be incremented.

<DT><CODE><CODE>socket</CODE></CODE>
<DD>
The Unix socket used by the server.

<DT><CODE><CODE>sort_buffer</CODE></CODE>
<DD>
ソートを行う必要がある各スレッドがこのサイズのバッファを割り当てます。よ
り速い <CODE>ORDER BY</CODE> または <CODE>GROUP BY</CODE> のためにはこれを増やしてく
ださい。
 「<A HREF="manual.ja_Problems.html#Temporary_files">A.4.4  MySQL が一時ファイルを格納する場所</A>」節参照.

<DT><CODE><CODE>table_cache</CODE></CODE>
<DD>
全てのスレッドについてのオープンテーブルの数。これを増加する場合は、
<CODE>mysqld</CODE>が要求するオープンファイルディスクリプタの数も
増加することに注意しないといけません。
<STRONG>MySQL</STRONG> はユニークテーブル毎に2つのファイルディスクリプタを必要と
します。
See below for comments on file descriptor limits. You can check if you
need to increase the table cache by checking the <CODE>Opened_tables</CODE>
variable.  「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW">4.5.5  <CODE>SHOW</CODE> 構文</A>」節参照.  If this variable is big and you don't do
<CODE>FLUSH TABLES</CODE> a lot (which just forces all tables to be closed and
reopenend), then you should increase the value of this variable.

Make sure that your operating system can handle the number of open file
descriptors implied by the <CODE>table_cache</CODE> setting.  If <CODE>table_cache</CODE>
is set too high, MySQL may run out of file descriptors and refuse
connections, fail to perform queries, and be very unreliable.

テーブルキャッシュがどのように働くかはこちらを参照  「<A HREF="manual.ja_MySQL_Optimization.html#Table_cache">5.4.6  MySQL はどのようにテーブルのオープン &#38; クローズを行なうか？</A>」節.

<DT><CODE><CODE>table_type</CODE></CODE>
<DD>
The default table type

<DT><CODE><CODE>thread_cache_size</CODE></CODE>
<DD>
How many threads we should keep in a cache for reuse.  When a
client disconnects, the client's threads are put in the cache if there
aren't more than <CODE>thread_cache_size</CODE> threads from before.  All new
threads are first taken from the cache, and only when the cache is empty
is a new thread created.  This variable can be increased to improve
performance if you have a lot of new connections. (Normally this doesn't
give a notable performance improvement if you have a good
thread implementation.)  By examing the difference between
the <CODE>Connections</CODE> and <CODE>Threads_created</CODE> you can see how efficient
the current thread cache is for you.

<DT><CODE><CODE>thread_concurrency</CODE></CODE>
<DD>
On Solaris, <CODE>mysqld</CODE> will call <CODE>thr_setconcurrency()</CODE> with
this value.  <CODE>thr_setconcurrency()</CODE> permits the application to give
the threads system a hint for the desired number of threads that should
be run at the same time.

<DT><CODE><CODE>thread_stack</CODE></CODE>
<DD>
各スレッドのスタックの大きさ。<CODE>crash-me</CODE> によって検出される多く
の制限がこれに依存します。デフォルトでは、通常のオペレーションに対して
十分とってあります。  「<A HREF="manual.ja_MySQL_Optimization.html#MySQL_Benchmarks">5.1.4  The MySQL Benchmark Suite</A>」節参照.

<DT><CODE><CODE>timezone</CODE></CODE>
<DD>
The timezone for the server.

<DT><CODE><CODE>tmp_table_size</CODE></CODE>
<DD>
メモリー内の 一時テーブルがこの値を超えようとした場合、<STRONG>MySQL</STRONG> は
自動的に、これを、disk ベースの <CODE>MyISAM</CODE> テーブルに変換します。
多くの先進的な <CODE>GROUP BY</CODE> クエリを行う場合は、
この <CODE>tmp_table_size</CODE> を増加してください。

<DT><CODE><CODE>tmpdir</CODE></CODE>
<DD>
The directory used for temporary files and temporary tables.

<DT><CODE><CODE>version</CODE></CODE>
<DD>
The version number for the server.

<DT><CODE><CODE>wait_timeout</CODE></CODE>
<DD>
サーバーがコネクションを閉じるまでにアクティブなコネクションを待つ秒数。
See also <CODE>interactive_timeout</CODE>.
</DL>

<P>
The manual section that describes tuning MySQL contains some
information of how to tune the above variables.  「<A HREF="manual.ja_MySQL_Optimization.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.

</P>



<H4><A NAME="SHOW_LOGS" HREF="manual.ja_toc.html#SHOW_LOGS">4.5.5.5  <CODE>SHOW LOGS</CODE></A></H4>

<P>
<CODE>SHOW LOGS</CODE> shows you status information about existing log
files.  It currently only displays information about Berkeley DB log
files.

</P>

<UL>
<LI><CODE>File</CODE> shows the full path to the log file

<LI><CODE>Type</CODE> shows the type of the log file (<CODE>BDB</CODE> for Berkeley

DB log files)
<LI><CODE>Status</CODE> shows the status of the log file (<CODE>FREE</CODE> if the

file can be removed, or <CODE>IN USE</CODE> if the file is needed by the transaction
subsystem)
</UL>



<H4><A NAME="SHOW_PROCESSLIST" HREF="manual.ja_toc.html#SHOW_PROCESSLIST">4.5.5.6  <CODE>SHOW PROCESSLIST</CODE></A></H4>

<P>
<A NAME="IDX597"></A>
<A NAME="IDX598"></A>

</P>
<P>
<A NAME="IDX599"></A>
<A NAME="IDX600"></A>

</P>
<P>
<CODE>SHOW PROCESSLIST</CODE> はどのスレッドが走っているかを表示します。
<CODE>mysqlshow processlist</CODE> コマンドでも同じ情報が得られます。
もし <STRONG>process</STRONG> 権限があるなら、全てのスレッドがみれます。
しかし権限がないなら、自分のスレッドしか見れません。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#KILL">4.5.4  <CODE>KILL</CODE> 構文</A>」節参照.
<CODE>FULL</CODE> オプションを使用しない場合、各クエリの最初の100文字だけが表示
されます。

</P>
<P>
This command is very useful if you get the 'too many connections' error
message and want to find out what's going on. MySQL reserves
one extra connection for a client with the <CODE>Process_priv</CODE> privilege
to ensure that you should always be able to login and check the system
(assuming you are not giving this privilege to all your users).

</P>



<H4><A NAME="SHOW_GRANTS" HREF="manual.ja_toc.html#SHOW_GRANTS">4.5.5.7  <CODE>SHOW GRANTS</CODE></A></H4>

<P>
<A NAME="IDX601"></A>

</P>
<P>
<CODE>SHOW GRANTS FOR user</CODE> はユーザの許可を複製するために発行する必要があ
る grant コマンドをリストします。

</P>

<PRE>
mysql&#62; SHOW GRANTS FOR root@localhost;
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
+---------------------------------------------------------------------+
</PRE>



<H4><A NAME="SHOW_CREATE_TABLE" HREF="manual.ja_toc.html#SHOW_CREATE_TABLE">4.5.5.8  <CODE>SHOW CREATE TABLE</CODE></A></H4>

<P>
Shows a <CODE>CREATE TABLE</CODE> statement that will create the given table:

</P>

<PRE>
mysql&#62; show create table t\G
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE t (
  id int(11) default NULL auto_increment,
  s char(60) default NULL,
  PRIMARY KEY (id)
) TYPE=MyISAM

</PRE>

<P>
<CODE>SHOW CREATE TABLE</CODE> will quote table and column names according to
<CODE>SQL_QUOTE_SHOW_CREATE</CODE> option.
 「<A HREF="manual.ja_MySQL_Optimization.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節.

</P>



<H2><A NAME="Localization" HREF="manual.ja_toc.html#Localization">4.6  MySQL Localization and International Usage</A></H2>



<H3><A NAME="Character_sets" HREF="manual.ja_toc.html#Character_sets">4.6.1  データとソートに使用されるキャラクターセット</A></H3>

<P>
<A NAME="IDX602"></A>
<A NAME="IDX603"></A>
<A NAME="IDX604"></A>

</P>
<P>
デフォルトでは、<STRONG>MySQL</STRONG> は スウェーデン語／フィンランド語に一致する 
ISO8859-1 (Latin1) キャラクターセットをソートに使用します。これは USA と西
ヨーロッパに適したキャラクターセットです。

</P>
<P>
All standard MySQL binaries are compiled with
<CODE>--with-extra-charsets=complex</CODE>.  This will add code to all
standard programs to be able to handle <CODE>latin1</CODE> and all multi-byte
character sets within the binary. Other character sets will be
loaded from a character-set definition file when needed.

</P>
<P>
キャラクターセットは名前として許される文字と、<CODE>ORDER BY</CODE> と <CODE>GROUP BY</CODE>
コマンドによってソートされる方法を決定します。
キャラクターセットは、名前として使用してもよい文字と <CODE>SELECT</CODE> 構文中の
 <CODE>ORDER BY</CODE> と <CODE>GROUP BY</CODE> コマンドを用いたソート方法を決定します。

</P>
<P>
You can change the character set with the <CODE>--default-character-set</CODE>
option when you start the server.  The character sets available depend
on the <CODE>--with-charset=charset</CODE> and <CODE>--with-extra-charset=
list-of-charset | complex | all</CODE> options to <CODE>configure</CODE>, and the
character set configuration files listed in
<TT>`SHAREDIR/charsets/Index'</TT>.   「<A HREF="manual.ja_Installing.html#configure_options">2.3.3  典型的な <CODE>configure</CODE> オプション</A>」節参照.

</P>
<P>
もし <STRONG>MySQL</STRONG> が実行中にキャラクタ・セットを変更するならば、
（これはソートの順番も変わります）、全てのテーブルに対して
myisamchk -r -q を実行しなくてはなりません。
インデックスがただしい順番で並んでいないかもしれないからです。

</P>
<P>
クライアントが <STRONG>MySQL</STRONG> サーバに接続したとき、サーバは使用している
デフォルトのキャラクタ・セットをクライアントに送ります。
これを受け取ったクライアントは、キャラクタセットを切り替えます。

</P>
<P>
SQL クエリの文字列をエスケープする場合には、 <CODE>mysql_real_escape_string()</CODE> 
を
使用するべきです。
<CODE>mysql_real_escape_string()</CODE> は、最初のパラメタとして
MySQL へのコネクション・ハンドルを与える以外は、
古い <CODE>mysql_escape_string()</CODE> 関数と同じです。

</P>
<P>
もしクライアントがサーバがインストールされているところ(パス)とは違う
パスでコンパイルされていて、 <STRONG>MySQL</STRONG> をコンフィギャしたユーザーが
すべてのキャラクタ・セットを <STRONG>MySQL</STRONG> バイナリに含めていない場合には、
どこに必要とされるキャラクタ・セットの追加情報があるかを、クライアントに
教えなくてはなりません。もしサーバとクライアントが違うキャラクタ・セットで動作し
ているならば。

</P>
<P>
これは <STRONG>MySQL</STRONG> オプションファイルに次のように記述することで可能です：

</P>

<PRE>
[client]
character-sets-dir=/usr/local/mysql/share/mysql/charsets
</PRE>

<P>
ここで、パスはダイナミック <STRONG>MySQL</STRONG> キャラクタ・セットが保存されている場所
です。

</P>
<P>
クライアントに、キャラクタ・セットを強制することも可能です：

</P>

<PRE>
[client]
default-character-set=character-set-name
</PRE>

<P>
しかし通常はこれは不要です。

</P>



<H3><A NAME="Languages" HREF="manual.ja_toc.html#Languages">4.6.2  Non-English Error Messages</A></H3>

<P>
<A NAME="IDX605"></A>
<A NAME="IDX606"></A>
<A NAME="IDX607"></A>
<A NAME="IDX608"></A>

</P>
<P>
<CODE>mysqld</CODE> は次の言語でエラーメッセージを提供できます: チェコ語, デンマーク語,
オランダ語, 英語(デフォルト), Estonia, フランス語, ドイツ語, ギリシャ語,
ハンガリー語, イタリア語, 日本語, 韓国語,
ノルウェー語, 新ノルウェー
語,ポーランド語, ポルトガル語, スペイン語そしてスウェーデン語。

</P>
<P>
ある言語で <CODE>mysqld</CODE> を開始するためには <CODE>--language=lang</CODE> また
は <CODE>-L lang</CODE> スイッチの一つを使います:

</P>

<PRE>
shell&#62; mysqld --language=swedish
</PRE>

<P>
or:

</P>

<PRE>
shell&#62; mysqld --language=/usr/local/share/swedish
</PRE>

<P>
言語名は全て小文字であることに注意してください。

</P>
<P>
言語ファイルは(デフォルトでは)次の場所にあります。
<TT>`<VAR>mysql_base_dir</VAR>/share/<VAR>LANGUAGE</VAR>/'</TT>.

</P>
<P>
エラーメッセージファイルを更新したい場合は、 <TT>`errmsg.txt'</TT> ファイルを編集し、
 <TT>`errmsg.sys'</TT> ファイルを作成するために以下のように実行します:

</P>

<PRE>
shell&#62; comp_err errmsg.txt errmsg.sys
</PRE>

<P>
もし <STRONG>MySQL</STRONG> を新しいものにアップグレードしたなら、以前修正した部分と同じ
ところに、
新しい <TT>`errmsg.txt'</TT> ファイルに修正をほどこしてください。

</P>



<H3><A NAME="Adding_character_set" HREF="manual.ja_toc.html#Adding_character_set">4.6.3  新しいキャラクターセットの追加</A></H3>

<P>
<A NAME="IDX609"></A>
<A NAME="IDX610"></A>

</P>
<P>
他のキャラクタ・セットを <STRONG>MySQL</STRONG> に追加するには、
以下の手順で行ないます。

</P>
<P>
そのキャラクタセットが、simple か complex かを決めます。
もしそのキャラクタ・セットがソートを行なうために特別な文字参照の
ルーチンを必要としなくて、マルチバイト文字のサポートも必要としないのであれば、
そのキャラクタ・セットは simple です。
もしどちらかの特徴を必要とするのであれば、それは complex です。

</P>
<P>
例えば、<CODE>latin1</CODE> と <CODE>danish</CODE> は simple キャラクタ・セットで、
<CODE>big5</CODE> や <CODE>czech</CODE> は complex キャラクタ・セットです。

</P>
<P>
以下のセクションでは、あなたがキャラクタ・セットに <CODE>MYSET</CODE> という名前を
つけていると仮定します。

</P>
<P>
simple complex キャラクタ・セットの場合には以下のようにします：

</P>

<OL>
<LI>

MYSET を <TT>`sql/share/charsets/Index'</TT> ファイルの最後に追加。
一意な番号を与えます。

<LI>

<TT>`sql/share/charsets/MYSET.conf'</TT> ファイルを作成.
(<TT>`sql/share/charsets/latin1.conf'</TT> をベースにしてよいでしょう).

The syntax for the file very simple:


<UL>
<LI>

Comments start with a '#' character and proceed to the end of the line.
<LI>

Words are separated by arbitrary amounts of whitespace.
<LI>

When defining the character set, every word must be a number in hexadecimal
format
<LI>

The <CODE>ctype</CODE> array takes up the first 257 words. The
<CODE>to_lower</CODE>, <CODE>to_upper</CODE> and <CODE>sort_order</CODE> arrays take up
256 words each after that.
</UL>

 「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_arrays">4.6.4  The character definition arrays</A>」節参照.

<LI>

Add the character set name to the <CODE>CHARSETS_AVAILABLE</CODE> and
<CODE>COMPILED_CHARSETS</CODE> lists in <CODE>configure.in</CODE>.

<LI>

Reconfigure, recompile, and test.

</OL>

<P>
complex キャラクタ・セットの場合には以下のようにします：

</P>

<OL>
<LI>

<TT>`strings/ctype-MYSET.c'</TT> ファイルを <STRONG>MySQL</STRONG> のソースディレクトリ以下
に作成します。
  
<LI>

MYSET を <TT>`sql/share/charsets/Index'</TT> ファイルの最後に追加。
一意な番号を与えます。

<LI>

必要な定義されるものを調べるために、既存の <TT>`ctype-*.c'</TT> ファイルの一つを見てく
ださい。このファイル中で使用する配列の名前は、
<CODE>ctype_MYSET</CODE>, <CODE>to_lower_MYSET</CODE> のようにしなければいけないことに注意し
てください。
This corresponds to the arrays
in the simple character set.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_arrays">4.6.4  The character definition arrays</A>」節参照.  For a complex
character set

<LI>

<TT>`ctype-*.c'</TT> ファイルの先頭付近に、以下のようなコメントを書きます：


<PRE>
/*
 * This comment is parsed by configure to create ctype.c,
 * so don't change it unless you know what you are doing.
 *
 * .configure. number_MYSET=MYNUMBER
 * .configure. strxfrm_multiply_MYSET=N
 * .configure. mbmaxlen_MYSET=N
 */
</PRE>

<CODE>configure</CODE> プログラムは、 <STRONG>MySQL</STRONG> ライブラリに自動的に
キャラクタセットを含めるために、このコメントを使用します。

The strxfrm_multiply and mbmaxlen lines will be explained in
the following sections.  Only include them if you the string
collating functions or the multi-byte character set functions,
respectively.

<LI>

以下の関数を作成しなくてはなりません：


<UL>
<LI><CODE>my_strncoll_MYSET()</CODE>

<LI><CODE>my_strcoll_MYSET()</CODE>

<LI><CODE>my_strxfrm_MYSET()</CODE>

<LI><CODE>my_like_range_MYSET()</CODE>

</UL>

 「<A HREF="manual.ja_MySQL_Database_Administration.html#String_collating">4.6.5  String Collating Support</A>」節参照.

<LI>

キャラクタ・セット名を、<CODE>configure.in</CODE> 中の <CODE>CHARSETS_AVAILABLE</CODE> と
<CODE>COMPILED_CHARSETS</CODE> に追加します。

<LI>

Reconfigure, recompile, and test.
</OL>

<P>
The file <TT>`sql/share/charsets/README'</TT> includes some more instructions.

</P>
<P>
If you want to have the character set included in the MySQL
distribution, mail a patch to <a HREF="mailto:internals@lists.mysql.com">internals@lists.mysql.com</a>.

</P>



<H3><A NAME="Character_arrays" HREF="manual.ja_toc.html#Character_arrays">4.6.4  The character definition arrays</A></H3>

<P>
<CODE>to_lower[]</CODE> と <CODE>to_upper[]</CODE> は、それぞれのキャラクターセットに於ける
大文字、小文字の対応を定義した、単純な配列です。
例えば：

</P>

<PRE>
to_lower['A'] should contain 'a'
to_upper['a'] should contain 'A'
</PRE>

<P>
<CODE>sort_order[]</CODE> は文字がどのようにソートされるべきかのマップです。多くのセッ
トでは、これは <CODE>to_upper[]</CODE> と同じです (ケース非依存ソート)。
<STRONG>MySQL</STRONG> は <CODE>sort_order[character]</CODE> の値を元に文字をソートします。
 For more complicated sorting rules, see
the discussion of string collating below.  「<A HREF="manual.ja_MySQL_Database_Administration.html#String_collating">4.6.5  String Collating Support</A>」節参照.

</P>
<P>
<CODE>ctype[]</CODE> は各文字を説明するビットの配列で、1かたまりのビット列が1文字を定
義します。
( <CODE>to_lower[]</CODE>, <CODE>to_upper[]</CODE>,<CODE>sort_order[]</CODE>は、文字の値でインデッ
クスされますが、
<CODE>ctype[]</CODE>は文字の値+1 でインデックスされます。

</P>
<P>
これは EOF を操作するためにずいぶん前から使われているので、この方法を使用してい
ます。)
<TT>`m_ctype.h'</TT> に次のビットマスクの定義を見ることができます:

</P>

<PRE>
#define _U      01      /* Uppercase */
#define _L      02      /* Lowercase */
#define _N      04      /* Numeral (digit) */
#define _S      010     /* Spacing character */
#define _P      020     /* Punctuation */
#define _C      040     /* Control character */
#define _B      0100    /* Blank */
#define _X      0200    /* heXadecimal digit */
</PRE>

<P>
それぞれの文字に対する <CODE>ctype[]</CODE> は、文字を確定するために
ビット列と組になっていなければなりません。
たとえば、<CODE>'A'</CODE> は大文字定義 (<CODE>_U</CODE>) と 16進定義 (<CODE>_X</CODE>) 両方ともに
属するので、<CODE>ctype['A'+1]</CODE> は以下の値を含まなくてはなりません:

</P>

<PRE>
_U + _X = 01 + 0200 = 0201
</PRE>



<H3><A NAME="String_collating" HREF="manual.ja_toc.html#String_collating">4.6.5  String Collating Support</A></H3>

<P>
<A NAME="IDX611"></A>
<A NAME="IDX612"></A>

</P>
<P>
If the sorting rules for your language are too complex to be handled
with the simple <CODE>sort_order[]</CODE> table, you need to use the string
collating functions.

</P>
<P>
Right now the best documentation on this is the character sets that are
already implemented.  Look at the big5, czech, gbk, sjis, and tis160
character sets for examples.

</P>
<P>
You must specify the <CODE>strxfrm_multiply_MYSET=N</CODE> value in the
special comment at the top of the file.  <CODE>N</CODE> should be set to
the maximum ratio the strings may grow during <CODE>my_strxfrm_MYSET</CODE> (it
must be a positive integer).

</P>



<H3><A NAME="Multi-byte_characters" HREF="manual.ja_toc.html#Multi-byte_characters">4.6.6  マルチバイト文字のサポート</A></H3>

<P>
<A NAME="IDX613"></A>
<A NAME="IDX614"></A>

</P>
<P>
If your want to add support for a new character set that includes
multi-byte characters, you need to use the multi-byte character
functions.

</P>
<P>
Right now the best documentation on this is the character sets that are
already implemented.  Look at the euc_kr, gb2312, gbk, sjis and ujis
character sets for examples. These are implemented in the
<CODE>ctype-'charset'.c</CODE> files in the <TT>`strings'</TT> directory.

</P>
<P>
You must specify the <CODE>mbmaxlen_MYSET=N</CODE> value in the special
comment at the top of the source file.  <CODE>N</CODE> should be set to the
size in bytes of the largest character in the set.

</P>



<H2><A NAME="Server-Side_Scripts" HREF="manual.ja_toc.html#Server-Side_Scripts">4.7  MySQL Server-Side Scripts and Utilities</A></H2>



<H3><A NAME="Server-Side_Overview" HREF="manual.ja_toc.html#Server-Side_Overview">4.7.1  Overview of the Server-Side Scripts and Utilities</A></H3>

<P>
<A NAME="IDX615"></A>
<A NAME="IDX616"></A>

</P>
<P>
All MySQL clients that communicate with the server using the
<CODE>mysqlclient</CODE> library use the following environment variables:

</P>
<P>
<A NAME="IDX617"></A>
<A NAME="IDX618"></A>
<A NAME="IDX619"></A>
<A NAME="IDX620"></A>
<A NAME="IDX621"></A>
<A NAME="IDX622"></A>
<A NAME="IDX623"></A>
<A NAME="IDX624"></A>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Name</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>MYSQL_UNIX_PORT</CODE> </TD><TD> The default socket; used for connections to <CODE>localhost</CODE>
</TR NOSAVE>
<TR><TD><CODE>MYSQL_TCP_PORT</CODE> </TD><TD> The default TCP/IP port
</TR NOSAVE>
<TR><TD><CODE>MYSQL_PWD</CODE> </TD><TD> The default password
</TR NOSAVE>
<TR><TD><CODE>MYSQL_DEBUG</CODE> </TD><TD> Debug-trace options when debugging
</TR NOSAVE>
<TR><TD><CODE>TMPDIR</CODE> </TD><TD> The directory where temporary tables/files are created
</TR>
</TABLE>

</P>
<P>
Use of <CODE>MYSQL_PWD</CODE> is insecure.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Connecting">4.2.7  MySQL サーバーに接続</A>」節参照.

</P>
<P>
<A NAME="IDX625"></A>
<A NAME="IDX626"></A>
<A NAME="IDX627"></A>
<A NAME="IDX628"></A>
<A NAME="IDX629"></A>
<A NAME="IDX630"></A>
<A NAME="IDX631"></A>
The <TT>`mysql'</TT> client uses the file named in the <CODE>MYSQL_HISTFILE</CODE>
environment variable to save the command-line history. The default value for
the history file is <TT>`$HOME/.mysql_history'</TT>, where <CODE>$HOME</CODE> is the
value of the <CODE>HOME</CODE> environment variable.  「<A HREF="manual.ja_Environment_variables.html#Environment_variables">H  Environment Variables</A>」節参照.

</P>
<P>
All MySQL programs take many different options. However, every
MySQL program provides a <CODE>--help</CODE> option that you can use
to get a full description of the program's different options. For example, try
<CODE>mysql --help</CODE>.

</P>
<P>
You can override default options for all standard client programs with an
option file.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節.

</P>
<P>
The list below briefly describes the MySQL programs:

</P>
<DL COMPACT>

<DT><CODE>myisamchk</CODE>
<DD>
<A NAME="IDX632"></A>
 
Utility to describe, check, optimize, and repair MySQL tables.
Because <CODE>myisamchk</CODE> has many functions, it is described in its own
chapter.  「<A HREF="manual.ja_MySQL_Database_Administration.html#MySQL_Database_Administration">4  MySQL Database Administration</A>」節参照.

<A NAME="IDX633"></A>
<DT><CODE>make_binary_distribution</CODE>
<DD>
Makes a binary release of a compiled MySQL. This could be sent
by FTP to <TT>`/pub/mysql/Incoming'</TT> on <CODE>support.mysql.com</CODE> for the
convenience of other MySQL users.

<A NAME="IDX634"></A>
<DT><CODE>msql2mysql</CODE>
<DD>
A shell script that converts <CODE>mSQL</CODE> programs to MySQL. It doesn't
handle all cases, but it gives a good start when converting.

<A NAME="IDX635"></A>
<DT><CODE>mysqlaccess</CODE>
<DD>
A script that checks the access privileges for a host, user, and database
combination.

<A NAME="IDX636"></A>
<DT><CODE>mysqladmin</CODE>
<DD>
Utility for performing administrative operations, such as creating or
dropping databases, reloading the grant tables, flushing tables to disk, and
reopening log files.  <CODE>mysqladmin</CODE> can also be used to retrieve version,
process, and status information from the server.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqladmin">4.8.3  mysqladmin, MySQL サーバーの管理</A>」節参照.

<A NAME="IDX637"></A>
<DT><CODE>mysqlbug</CODE>
<DD>
The MySQL bug report script.  This script should always be used when
filing a bug report to the MySQL list.

<A NAME="IDX638"></A>
<DT><CODE>mysqld</CODE>
<DD>
The SQL daemon. This should always be running.

<A NAME="IDX639"></A>
<DT><CODE>mysqldump</CODE>
<DD>
Dumps a MySQL database into a file as SQL statements or
as tab-separated text files. Enhanced freeware originally by Igor Romanenko.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqldump">4.8.5  mysqldump, データベースとテーブルから、構造とデータをダンプ</A>」節参照.

<A NAME="IDX640"></A>
<DT><CODE>mysqlimport</CODE>
<DD>
Imports text files into their respective tables using <CODE>LOAD DATA
INFILE</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqlimport">4.8.7  mysqlimport, テキストファイルからデータを取り込む</A>」節参照.

<A NAME="IDX641"></A>
<DT><CODE>mysqlshow</CODE>
<DD>
Displays information about databases, tables, columns, and indexes.

<A NAME="IDX642"></A>
<DT><CODE>mysql_install_db</CODE>
<DD>
Creates the MySQL grant tables with default privileges. This is
usually executed only once, when first installing MySQL
on a system.

<A NAME="IDX643"></A>
<DT><CODE>replace</CODE>
<DD>
A utility program that is used by <CODE>msql2mysql</CODE>, but that has more
general applicability as well.  <CODE>replace</CODE> changes strings in place in
files or on the standard input. Uses a finite state machine to match longer
strings first. Can be used to swap strings. For example, this command
swaps <CODE>a</CODE> and <CODE>b</CODE> in the given files:


<PRE>
shell&#62; replace a b b a -- file1 file2 ...
</PRE>

</DL>



<H3><A NAME="safe_mysqld" HREF="manual.ja_toc.html#safe_mysqld">4.7.2  safe_mysqld, the wrapper around mysqld</A></H3>

<P>
<A NAME="IDX644"></A>
<A NAME="IDX645"></A>
<A NAME="IDX646"></A>

</P>
<P>
<CODE>safe_mysqld</CODE> is the recommended way to start a <CODE>mysqld</CODE>
daemon on Unix.  <CODE>safe_mysqld</CODE> adds some safety features such as
restarting the server when an error occurs and logging run-time
information to a log file.

</P>
<P>
If you don't use <CODE>--mysqld=#</CODE> or <CODE>--mysqld-version=#</CODE>
<CODE>safe_mysqld</CODE> will use an executable named <CODE>mysqld-max</CODE> if it
exists. If not, <CODE>safe_mysqld</CODE> will start <CODE>mysqld</CODE>.
This makes it very easy to test to use <CODE>mysqld-max</CODE> instead of
<CODE>mysqld</CODE>;  Just copy <CODE>mysqld-max</CODE> to where you have
<CODE>mysqld</CODE> and it will be used.

</P>
<P>
Normally one should never edit the <CODE>safe_mysqld</CODE> script, but
instead put the options to <CODE>safe_mysqld</CODE> in the
<CODE>[safe_mysqld]</CODE> section in the <CODE>my.cnf</CODE>
file. <CODE>safe_mysqld</CODE> will read all options from the <CODE>[mysqld]</CODE>,
<CODE>[server]</CODE> and <CODE>[safe_mysqld]</CODE> sections from the option files.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.

</P>
<P>
Note that all options on the command line to <CODE>safe_mysqld</CODE> are passed
to <CODE>mysqld</CODE>.  If you wants to use any options in <CODE>safe_mysqld</CODE> that
<CODE>mysqld</CODE> doesn't support, you must specify these in the option file.

</P>
<P>
Most of the options to <CODE>safe_mysqld</CODE> are the same as the options to
<CODE>mysqld</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Command-line_options">4.1.1  mysqld コマンド行オプション</A>」節参照.

</P>
<P>
<CODE>safe_mysqld</CODE> supports the following options:

</P>
<DL COMPACT>

<DT><CODE>--basedir=path</CODE>
<DD>
<DT><CODE>--core-file-size=#</CODE>
<DD>
Size of the core file <CODE>mysqld</CODE> should be able to create. Passed to <CODE>ulimit -c</CODE>.
<DT><CODE>--datadir=path</CODE>
<DD>
<DT><CODE>--defaults-extra-file=path</CODE>
<DD>
<DT><CODE>--defaults-file=path</CODE>
<DD>
<DT><CODE>--err-log=path</CODE>
<DD>
<DT><CODE>--ledir=path</CODE>
<DD>
Path to <CODE>mysqld</CODE>
<DT><CODE>--log=path</CODE>
<DD>
<DT><CODE>--mysqld=mysqld-version</CODE>
<DD>
Name of the <CODE>mysqld</CODE> version in the <CODE>ledir</CODE> directory you want to start.
<DT><CODE>--mysqld-version=version</CODE>
<DD>
Similar to <CODE>--mysqld=</CODE> but here you only give the suffix for <CODE>mysqld</CODE>.
For example if you use <CODE>--mysqld-version=max</CODE>, <CODE>safe_mysqld</CODE> will
start the <CODE>ledir/mysqld-max</CODE> version.  If the argument to
<CODE>--mysqld-version</CODE> is empty, <CODE>ledir/mysqld</CODE> will be used.
<DT><CODE>--no-defaults</CODE>
<DD>
<DT><CODE>--open-files-limit=#</CODE>
<DD>
Number of files <CODE>mysqld</CODE> should be able to open. Passed to <CODE>ulimit -n</CODE>. Note that you need to start <CODE>safe_mysqld</CODE> as root for this to work properly!
<DT><CODE>--pid-file=path</CODE>
<DD>
<DT><CODE>--port=#</CODE>
<DD>
<DT><CODE>--socket=path</CODE>
<DD>
<DT><CODE>--timezone=#</CODE>
<DD>
Set the timezone (the <CODE>TZ</CODE>) variable to the value of this parameter.
<DT><CODE>--user=#</CODE>
<DD>
</DL>

<P>
The <CODE>safe_mysqld</CODE> script is written so that it normally is able to start
a server that was installed from either a source or a binary version of
MySQL, even if these install the server in slightly different
locations.  <CODE>safe_mysqld</CODE> expects one of these conditions to be true:

</P>

<UL>
<LI>

The server and databases can be found relative to the directory from which
<CODE>safe_mysqld</CODE> is invoked.  <CODE>safe_mysqld</CODE> looks under its working
directory for <TT>`bin'</TT> and <TT>`data'</TT> directories (for binary
distributions) or for <TT>`libexec'</TT> and <TT>`var'</TT> directories (for source
distributions).  This condition should be met if you execute
<CODE>safe_mysqld</CODE> from your MySQL installation directory (for
example, <TT>`/usr/local/mysql'</TT> for a binary distribution).

<LI>

If the server and databases cannot be found relative to the working directory,
<CODE>safe_mysqld</CODE> attempts to locate them by absolute pathnames.  Typical
locations are <TT>`/usr/local/libexec'</TT> and <TT>`/usr/local/var'</TT>.
The actual locations are determined when the distribution was built from which
<CODE>safe_mysqld</CODE> comes.  They should be correct if
MySQL was installed in a standard location.
</UL>

<P>
Because <CODE>safe_mysqld</CODE> will try to find the server and databases relative
to its own working directory, you can install a binary distribution of
MySQL anywhere, as long as you start <CODE>safe_mysqld</CODE> from the
MySQL installation directory:

</P>

<PRE>
shell&#62; cd mysql_installation_directory
shell&#62; bin/safe_mysqld &#38;
</PRE>

<P>
If <CODE>safe_mysqld</CODE> fails, even when invoked from the MySQL
installation directory, you can modify it to use the path to <CODE>mysqld</CODE>
and the pathname options that are correct for your system.  Note that if you
upgrade MySQL in the future, your modified version of
<CODE>safe_mysqld</CODE> will be overwritten, so you should make a copy of your
edited version that you can reinstall.

</P>



<H3><A NAME="mysqld_multi" HREF="manual.ja_toc.html#mysqld_multi">4.7.3  mysqld_multi, program for managing multiple MySQL servers</A></H3>

<P>
<A NAME="IDX647"></A>
<A NAME="IDX648"></A>
<A NAME="IDX649"></A>
<A NAME="IDX650"></A>

</P>
<P>
<CODE>mysqld_multi</CODE> is meant for managing several <CODE>mysqld</CODE>
processes running in different UNIX sockets and TCP/IP ports.

</P>
<P>
The program will search for group(s) named [mysqld#] from my.cnf (or the
given --config-file=...), where # can be any positive number starting
from 1. These groups should be the same as the usual <CODE>[mysqld]</CODE>
group (e.g. options to mysqld, see MySQL manual for detailed
information about this group), but with those port, socket etc. options
that are wanted for each separate <CODE>mysqld</CODE> processes. The number in
the group name has another function; it can be used for starting,
stopping, or reporting some specific <CODE>mysqld</CODE> servers with this
program. See the usage and options below for more information.

</P>

<PRE>
Usage: mysqld_multi [OPTIONS] {start|stop|report} [GNR,GNR,GNR...]
or     mysqld_multi [OPTIONS] {start|stop|report} [GNR-GNR,GNR,GNR-GNR,...]
</PRE>

<P>
The GNR above means the group number. You can start, stop or report
any GNR, or several of them at the same time. (See --example) The GNRs
list can be comma separated, or a dash combined, of which the latter
means that all the GNRs between GNR1-GNR2 will be affected. Without
GNR argument all the found groups will be either started, stopped, or
reported. Note that you must not have any white spaces in the GNR
list. Anything after a white space is ignored.

</P>
<P>
<CODE>mysqld_multi</CODE> supports the following options:

</P>
<DL COMPACT>

<DT><CODE>--config-file=...</CODE>
<DD>
<A NAME="IDX651"></A>
 
Alternative config file. NOTE: This will not affect this program's own
options (group <CODE>[mysqld_multi]</CODE>), but only groups
[mysqld#]. Without this option everything will be searched from the
ordinary my.cnf file.
<A NAME="IDX652"></A>
<DT><CODE>--example</CODE>
<DD>
Give an example of a config file.
<A NAME="IDX653"></A>
<DT><CODE>--help</CODE>
<DD>
Print this help and exit.
<A NAME="IDX654"></A>
<DT><CODE>--log=...</CODE>
<DD>
Log file. Full path to and the name for the log file. NOTE: If the file
exists, everything will be appended.
<A NAME="IDX655"></A>
<DT><CODE>--mysqladmin=...</CODE>
<DD>
<CODE>mysqladmin</CODE> binary to be used for a server shutdown.
<A NAME="IDX656"></A>
<DT><CODE>--mysqld=...</CODE>
<DD>
<CODE>mysqld</CODE> binary to be used. Note that you can give
<CODE>safe_mysqld</CODE> to this option also. The options are passed to
<CODE>mysqld</CODE>. Just make sure you have <CODE>mysqld</CODE> in your environment
variable <CODE>PATH</CODE> or fix <CODE>safe_mysqld</CODE>.
<A NAME="IDX657"></A>
<DT><CODE>--no-log</CODE>
<DD>
Print to stdout instead of the log file. By default the log file is
turned on.
<A NAME="IDX658"></A>
<DT><CODE>--password=...</CODE>
<DD>
Password for user for <CODE>mysqladmin</CODE>.
<A NAME="IDX659"></A>
<DT><CODE>--tcp-ip</CODE>
<DD>
Connect to the MySQL server(s) via the TCP/IP port instead of
the UNIX socket. This affects stopping and reporting.  If a socket file
is missing, the server may still be running, but can be accessed only
via the TCP/IP port.  By default connecting is done via the UNIX socket.
<A NAME="IDX660"></A>
<DT><CODE>--user=...</CODE>
<DD>
MySQL user for <CODE>mysqladmin</CODE>.
<A NAME="IDX661"></A>
<DT><CODE>--version</CODE>
<DD>
Print the version number and exit.
</DL>

<P>
Some notes about <CODE>mysqld_multi</CODE>:

</P>

<UL>
<LI>

Make sure that the MySQL user, who is stopping the
<CODE>mysqld</CODE> services (e.g using the <CODE>mysqladmin</CODE>) have the same
password and username for all the data directories accessed (to the
'mysql' database) And make sure that the user has the 'Shutdown_priv'
privilege! If you have many data- directories and many different 'mysql'
databases with different passwords for the MySQL 'root' user,
you may want to create a common 'multi_admin' user for each using the
same password (see below). Example how to do it:

<PRE>
shell&#62; mysql -u root -S /tmp/mysql.sock -proot_password -e
"GRANT SHUTDOWN ON *.* TO multi_admin@localhost IDENTIFIED BY 'multipass'"
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Privileges">4.2.5  特権システムはどのように動くか？</A>」節参照.
</PRE>

You will have to do the above for each <CODE>mysqld</CODE> running in each
data directory, that you have (just change the socket, -S=...)
<LI>

<CODE>pid-file</CODE> is very important, if you are using <CODE>safe_mysqld</CODE>
to start <CODE>mysqld</CODE> (e.g. --mysqld=safe_mysqld) Every <CODE>mysqld</CODE>
should have its own <CODE>pid-file</CODE>. The advantage using
<CODE>safe_mysqld</CODE> instead of <CODE>mysqld</CODE> directly here is, that
<CODE>safe_mysqld</CODE> 'guards' every <CODE>mysqld</CODE> process and will restart
it, if a <CODE>mysqld</CODE> process fails due to signal kill -9, or
similar. (Like segmentation fault, which MySQL should never do,
of course ;) Please note that <CODE>safe_mysqld</CODE> script may require that
you start it from a certain place. This means that you may have to CD to
a certain directory, before you start the <CODE>mysqld_multi</CODE>. If
you have problems starting, please see the <CODE>safe_mysqld</CODE>
script. Check especially the lines:

<PRE>
--------------------------------------------------------------------------
MY_PWD=`pwd` Check if we are starting this relative (for the binary
release) if test -d /data/mysql -a -f ./share/mysql/english/errmsg.sys
-a -x ./bin/mysqld
--------------------------------------------------------------------------
 「<A HREF="manual.ja_MySQL_Database_Administration.html#safe_mysqld">4.7.2  safe_mysqld, the wrapper around mysqld</A>」節参照.
</PRE>

The above test should be successful, or you may encounter problems.
<LI>

Beware of the dangers starting multiple <CODE>mysqlds</CODE> in the same data
directory.  Use separate data directories, unless you <STRONG>KNOW</STRONG> what
you are doing!
<LI>

The socket file and the TCP/IP port must be different for every <CODE>mysqld</CODE>.
<LI>

The first and fifth <CODE>mysqld</CODE> group were intentionally left out from
the example.  You may have 'gaps' in the config file. This gives you
more flexibility.  The order in which the <CODE>mysqlds</CODE> are started or
stopped depends on the order in which they appear in the config file.
<LI>

When you want to refer to a certain group using GNR with this program,
just use the number in the end of the group name ( [mysqld# &#60;== ).
<LI>

You may want to use option '--user' for <CODE>mysqld</CODE>, but in order to
do this you need to be root when you start the <CODE>mysqld_multi</CODE>
script. Having the option in the config file doesn't matter; you will
just get a warning, if you are not the superuser and the <CODE>mysqlds</CODE>
are started under <STRONG>YOUR</STRONG> UNIX account. <STRONG>IMPORTANT</STRONG>: Make
sure that the <CODE>pid-file</CODE> and the data directory are
read+write(+execute for the latter one) accessible for <STRONG>THAT</STRONG>
UNIX user, who the specific <CODE>mysqld</CODE> process is started
as. <STRONG>DON'T</STRONG> use the UNIX root account for this, unless you
<STRONG>KNOW</STRONG> what you are doing!
<LI>

<STRONG>MOST IMPORTANT</STRONG>: Make sure that you understand the meanings of
the options that are passed to the <CODE>mysqlds</CODE> and why <STRONG>WOULD
YOU WANT</STRONG> to have separate <CODE>mysqld</CODE> processes. Starting multiple
<CODE>mysqlds</CODE> in one data directory <STRONG>WILL NOT</STRONG> give you extra
performance in a threaded system!
</UL>

<P>
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Multiple_servers">4.1.4  同一マシン上に複数の MySQL サーバーを走らせる</A>」節参照.

</P>
<P>
This is an example of the config file on behalf of <CODE>mysqld_multi</CODE>.

</P>

<PRE>
# This file should probably be in your home dir (~/.my.cnf) or /etc/my.cnf
# Version 2.1 by Jani Tolonen

[mysqld_multi]
mysqld     = /usr/local/bin/safe_mysqld
mysqladmin = /usr/local/bin/mysqladmin
user       = multi_admin
password   = multipass

[mysqld2]
socket     = /tmp/mysql.sock2
port       = 3307
pid-file   = /usr/local/mysql/var2/hostname.pid2
datadir    = /usr/local/mysql/var2
language   = /usr/local/share/mysql/english
user       = john

[mysqld3]
socket     = /tmp/mysql.sock3
port       = 3308
pid-file   = /usr/local/mysql/var3/hostname.pid3
datadir    = /usr/local/mysql/var3
language   = /usr/local/share/mysql/swedish
user       = monty

[mysqld4]
socket     = /tmp/mysql.sock4
port       = 3309
pid-file   = /usr/local/mysql/var4/hostname.pid4
datadir    = /usr/local/mysql/var4
language   = /usr/local/share/mysql/estonia
user       = tonu

[mysqld6]
socket     = /tmp/mysql.sock6
port       = 3311
pid-file   = /usr/local/mysql/var6/hostname.pid6
datadir    = /usr/local/mysql/var6
language   = /usr/local/share/mysql/japanese
user       = jani
</PRE>

<P>
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節参照.

</P>



<H3><A NAME="myisampack" HREF="manual.ja_toc.html#myisampack">4.7.4  myisampack, MySQL の圧縮された読み込み専用テーブルジェネレータ</A></H3>

<P>
<A NAME="IDX662"></A>
<A NAME="IDX663"></A>
<A NAME="IDX664"></A>
<A NAME="IDX665"></A>
<A NAME="IDX666"></A>

</P>
<P>
<CODE>myisampack</CODE> is used to compress MyISAM tables, and <CODE>pack_isam</CODE>
is used to compress ISAM tables. Because ISAM tables are deprecated, we
will only discuss <CODE>myisampack</CODE> here, but everything said about
<CODE>myisampack</CODE> should also be true for <CODE>pack_isam</CODE>.

</P>
<P>
<CODE>myisampack</CODE> はテーブル内の各項目を別々に圧縮するように働きます。展開のため
の情報は、テーブルがオープンされた時にメモリに読まれます。これは、正確に1レコー
ドだけを展開する必要があるような、個々のレコードへのアクセス時にとても良
い性能を与えます。MSDOS 上の Stacker 使用時のように、ディスクブロックは
そんなに大きくありません。
通常、<CODE>myisampack</CODE> はデータファイルを 40～70% にパックします。

</P>
<P>
a much larger disk block as when using Stacker on MS-DOS.
Usually, <CODE>myisampack</CODE> packs the data file 40%-70%.

</P>
<P>
MySQL は圧縮されたテーブルでメモリマップ (<CODE>mmap()</CODE>) を使用します。
<CODE>mmap()</CODE> が働かない場合は、通常のファイルの読み書きを使用します。

</P>
<P>
There are currently two limitations with <CODE>myisampack</CODE>:

<UL>
<LI>

パック後、テーブルは読み込み専用になります。
<LI>

<CODE>myisampack</CODE> can also pack <CODE>BLOB</CODE> or <CODE>TEXT</CODE> columns. The
older <CODE>pack_isam</CODE> could not do this.
</UL>

<P>
これらの制限の修正は TODO にありますが、優先度は低いです。

</P>
<P>
<CODE>myisampack</CODE> は以下のようにして起動します:

</P>

<PRE>
shell&#62; myisampack [options] filename ...
</PRE>

<P>
それぞれのファイル名はインデックスファイル(<TT>`.MYI'</TT>)の名前です。
もしデータディレクトリにカレントディレクトリを移動していないなら、
ファイルのパスを指定しなくてはなりません。<TT>`.MYI'</TT> 拡張子は
省略することが可能です。

</P>
<P>
<CODE>myisampack</CODE> は以下のオプションをサポートします:

</P>
<DL COMPACT>

<DT><CODE>-b, --backup</CODE>
<DD>
<CODE>tbl_name.OLD</CODE> としてバックアップを作成します.

<DT><CODE>-#, --debug=debug_options</CODE>
<DD>
デバック出力。<CODE>debug_options</CODE> は <CODE>'d:t:o,filename'</CODE>.

<DT><CODE>-f, --force</CODE>
<DD>
一時ファイルが存在していようが、サイズが大きくなろうが、強制的にテーブルを
パックします。
<CODE>myisampack</CODE> はテーブルを圧縮している間、
一時ファイルを <TT>`tbl_name.TMD'</TT> という名前で作成します。
もし <CODE>myisampack</CODE> を途中で kill した場合、 <TT>`.TMD'</TT> ファイルが消されて
いない事があります。通常、<CODE>myisampack</CODE> は <TT>`tbl_name.TMD'</TT> ファイルが
既に存在する場合はエラーで終了します。 <CODE>--force</CODE> を使用すると、
<CODE>myisampack</CODE> はそのような場合でもテーブルをパックします。

<DT><CODE>-?, --help</CODE>
<DD>
ヘルプメッセージを出力して終了。

<DT><CODE>-j big_tbl_name, --join=big_tbl_name</CODE>
<DD>
全てのテーブルをコマンドラインで指定した <CODE>big_tbl_name</CODE> 一つに
まとめます。結合される全てのテーブル定義は同じでなければなりません
(同じ項目名、同じ項目型、同じインデックス、等)

<DT><CODE>-p #, --packlength=#</CODE>
<DD>
Specify the record length storage size, in bytes.  The value should be 1, 2,
or 3.  (<CODE>myisampack</CODE> stores all rows with length pointers of 1, 2, or 3
bytes.  In most normal cases, <CODE>myisampack</CODE> can determine the right length
value before it begins packing the file, but it may notice during the packing
process that it could have used a shorter length. In this case,
<CODE>myisampack</CODE> will print a note that the next time you pack the same file,
you could use a shorter record length.)

<DT><CODE>-s, --silent</CODE>
<DD>
Silent mode.  Write output only when errors occur.

<DT><CODE>-t, --test</CODE>
<DD>
Don't actually pack table, just test packing it.

<DT><CODE>-T dir_name, --tmp_dir=dir_name</CODE>
<DD>
Use the named directory as the location in which to write the temporary table.

<DT><CODE>-v, --verbose</CODE>
<DD>
Verbose mode.  Write information about progress and packing result.

<DT><CODE>-V, --version</CODE>
<DD>
Display version information and exit.

<DT><CODE>-w, --wait</CODE>
<DD>
Wait and retry if table is in use.  If the <CODE>mysqld</CODE> server was
invoked with the <CODE>--skip-locking</CODE> option, it is not a good idea to
invoke <CODE>myisampack</CODE> if the table might be updated during the
packing process.
</DL>

<P>
<A NAME="IDX667"></A>
The sequence of commands shown below illustrates a typical table compression
session:

</P>

<PRE>
shell&#62; ls -l station.*
-rw-rw-r--   1 monty    my         994128 Apr 17 19:00 station.MYD
-rw-rw-r--   1 monty    my          53248 Apr 17 19:00 station.MYI
-rw-rw-r--   1 monty    my           5767 Apr 17 19:00 station.frm

shell&#62; myisamchk -dvv station

MyISAM file:     station
Isam-version:  2
Creation time: 1996-03-13 10:08:58
Recover time:  1997-02-02  3:06:43
Data records:              1192  Deleted blocks:              0
Datafile: Parts:           1192  Deleted data:                0
Datafile pointer (bytes):     2  Keyfile pointer (bytes):     2
Max datafile length:   54657023  Max keyfile length:   33554431
Recordlength:               834
Record format: Fixed length

table description:
Key Start Len Index   Type                       Root  Blocksize    Rec/key
1   2     4   unique  unsigned long              1024       1024          1
2   32    30  multip. text                      10240       1024          1

Field Start Length Type
1     1     1
2     2     4
3     6     4
4     10    1
5     11    20
6     31    1
7     32    30
8     62    35
9     97    35
10    132   35
11    167   4
12    171   16
13    187   35
14    222   4
15    226   16
16    242   20
17    262   20
18    282   20
19    302   30
20    332   4
21    336   4
22    340   1
23    341   8
24    349   8
25    357   8
26    365   2
27    367   2
28    369   4
29    373   4
30    377   1
31    378   2
32    380   8
33    388   4
34    392   4
35    396   4
36    400   4
37    404   1
38    405   4
39    409   4
40    413   4
41    417   4
42    421   4
43    425   4
44    429   20
45    449   30
46    479   1
47    480   1
48    481   79
49    560   79
50    639   79
51    718   79
52    797   8
53    805   1
54    806   1
55    807   20
56    827   4
57    831   4

shell&#62; myisampack station.MYI
Compressing station.MYI: (1192 records)
- Calculating statistics

normal:     20  empty-space:      16  empty-zero:        12  empty-fill:  11
pre-space:   0  end-space:        12  table-lookups:      5  zero:         7
Original trees:  57  After join: 17
- Compressing file
87.14%

shell&#62; ls -l station.*
-rw-rw-r--   1 monty    my         127874 Apr 17 19:00 station.MYD
-rw-rw-r--   1 monty    my          55296 Apr 17 19:04 station.MYI
-rw-rw-r--   1 monty    my           5767 Apr 17 19:00 station.frm

shell&#62; myisamchk -dvv station

MyISAM file:     station
Isam-version:  2
Creation time: 1996-03-13 10:08:58
Recover time:  1997-04-17 19:04:26
Data records:              1192  Deleted blocks:              0
Datafile: Parts:           1192  Deleted data:                0
Datafilepointer (bytes):      3  Keyfile pointer (bytes):     1
Max datafile length:   16777215  Max keyfile length:     131071
Recordlength:               834
Record format: Compressed

table description:
Key Start Len Index   Type                       Root  Blocksize    Rec/key
1   2     4   unique  unsigned long             10240       1024          1
2   32    30  multip. text                      54272       1024          1

Field Start Length Type                         Huff tree  Bits
1     1     1      constant                             1     0
2     2     4      zerofill(1)                          2     9
3     6     4      no zeros, zerofill(1)                2     9
4     10    1                                           3     9
5     11    20     table-lookup                         4     0
6     31    1                                           3     9
7     32    30     no endspace, not_always              5     9
8     62    35     no endspace, not_always, no empty    6     9
9     97    35     no empty                             7     9
10    132   35     no endspace, not_always, no empty    6     9
11    167   4      zerofill(1)                          2     9
12    171   16     no endspace, not_always, no empty    5     9
13    187   35     no endspace, not_always, no empty    6     9
14    222   4      zerofill(1)                          2     9
15    226   16     no endspace, not_always, no empty    5     9
16    242   20     no endspace, not_always              8     9
17    262   20     no endspace, no empty                8     9
18    282   20     no endspace, no empty                5     9
19    302   30     no endspace, no empty                6     9
20    332   4      always zero                          2     9
21    336   4      always zero                          2     9
22    340   1                                           3     9
23    341   8      table-lookup                         9     0
24    349   8      table-lookup                        10     0
25    357   8      always zero                          2     9
26    365   2                                           2     9
27    367   2      no zeros, zerofill(1)                2     9
28    369   4      no zeros, zerofill(1)                2     9
29    373   4      table-lookup                        11     0
30    377   1                                           3     9
31    378   2      no zeros, zerofill(1)                2     9
32    380   8      no zeros                             2     9
33    388   4      always zero                          2     9
34    392   4      table-lookup                        12     0
35    396   4      no zeros, zerofill(1)               13     9
36    400   4      no zeros, zerofill(1)                2     9
37    404   1                                           2     9
38    405   4      no zeros                             2     9
39    409   4      always zero                          2     9
40    413   4      no zeros                             2     9
41    417   4      always zero                          2     9
42    421   4      no zeros                             2     9
43    425   4      always zero                          2     9
44    429   20     no empty                             3     9
45    449   30     no empty                             3     9
46    479   1                                          14     4
47    480   1                                          14     4
48    481   79     no endspace, no empty               15     9
49    560   79     no empty                             2     9
50    639   79     no empty                             2     9
51    718   79     no endspace                         16     9
52    797   8      no empty                             2     9
53    805   1                                          17     1
54    806   1                                           3     9
55    807   20     no empty                             3     9
56    827   4      no zeros, zerofill(2)                2     9
57    831   4      no zeros, zerofill(1)                2     9
</PRE>

<P>
The information printed by <CODE>myisampack</CODE> is described below:

</P>
<DL COMPACT>

<DT><CODE>normal</CODE>
<DD>
The number of columns for which no extra packing is used.

<DT><CODE>empty-space</CODE>
<DD>
The number of columns containing
values that are only spaces; these will occupy 1 bit.

<DT><CODE>empty-zero</CODE>
<DD>
The number of columns containing
values that are only binary 0's; these will occupy 1 bit.

<DT><CODE>empty-fill</CODE>
<DD>
The number of integer columns that don't occupy the full byte range of their
type; these are changed to a smaller type (for example, an <CODE>INTEGER</CODE>
column may be changed to <CODE>MEDIUMINT</CODE>).

<DT><CODE>pre-space</CODE>
<DD>
The number of decimal columns that are stored with leading spaces. In this
case, each value will contain a count for the number of leading spaces.

<DT><CODE>end-space</CODE>
<DD>
The number of columns that have a lot of trailing spaces.  In this case, each
value will contain a count for the number of trailing spaces.

<DT><CODE>table-lookup</CODE>
<DD>
The column had only a small number of different values, which were
converted to an <CODE>ENUM</CODE> before Huffman compression.

<DT><CODE>zero</CODE>
<DD>
The number of columns for which all values are zero.

<DT><CODE>Original trees</CODE>
<DD>
The initial number of Huffman trees.

<DT><CODE>After join</CODE>
<DD>
The number of distinct Huffman trees left after joining
trees to save some header space.
</DL>

<P>
After a table has been compressed, <CODE>myisamchk -dvv</CODE> prints additional
information about each field:

</P>
<DL COMPACT>

<DT><CODE>Type</CODE>
<DD>
The field type may contain the following descriptors:

<DL COMPACT>

<DT><CODE>constant</CODE>
<DD>
All rows have the same value.

<DT><CODE>no endspace</CODE>
<DD>
Don't store endspace.

<DT><CODE>no endspace, not_always</CODE>
<DD>
Don't store endspace and don't do end space compression for all values.

<DT><CODE>no endspace, no empty</CODE>
<DD>
Don't store endspace. Don't store empty values.

<DT><CODE>table-lookup</CODE>
<DD>
The column was converted to an <CODE>ENUM</CODE>.

<DT><CODE>zerofill(n)</CODE>
<DD>
The most significant <CODE>n</CODE> bytes in the value are always 0 and are not
stored.

<DT><CODE>no zeros</CODE>
<DD>
Don't store zeros.

<DT><CODE>always zero</CODE>
<DD>
0 values are stored in 1 bit.
</DL>

<DT><CODE>Huff tree</CODE>
<DD>
The Huffman tree associated with the field.

<DT><CODE>Bits</CODE>
<DD>
The number of bits used in the Huffman tree.
</DL>

<P>
After you have run <CODE>pack_isam</CODE>/<CODE>myisampack</CODE> you must run
<CODE>isamchk</CODE>/<CODE>myisamchk</CODE> to re-create the index.  At this time you
can also sort the index blocks and create statistics needed for
the MySQL optimizer to work more efficiently:

</P>

<PRE>
myisamchk -rq --analyze --sort-index table_name.MYI
isamchk   -rq --analyze --sort-index table_name.ISM
</PRE>

<P>
After you have installed the packed table into the MySQL database
directory you should do <CODE>mysqladmin flush-tables</CODE> to force <CODE>mysqld</CODE>
to start using the new table.

</P>
<P>
If you want to unpack a packed table, you can do this with the
<CODE>--unpack</CODE> option to <CODE>isamchk</CODE> or <CODE>myisamchk</CODE>.

</P>



<H3><A NAME="mysqld-max" HREF="manual.ja_toc.html#mysqld-max">4.7.5  mysqld-max, An extended mysqld server</A></H3>

<P>
<A NAME="IDX668"></A>

</P>
<P>
<CODE>mysqld-max</CODE> is the MySQL server (<CODE>mysqld</CODE>) configured with
the following configure options:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Option</STRONG> </TD><TD> <STRONG>Comment</STRONG>
</TR NOSAVE>
<TR><TD>--with-server-suffix=-max </TD><TD> Add a suffix to the <CODE>mysqld</CODE> version string.
</TR NOSAVE>
<TR><TD>--with-bdb </TD><TD> Support for Berkeley DB (BDB) tables
</TR NOSAVE>
<TR><TD>--with-innodb </TD><TD> Support for InnoDB tables.
</TR NOSAVE>
<TR><TD>CFLAGS=-DUSE_SYMDIR </TD><TD> Symbolic links support for Windows.
</TR>
</TABLE>

<P>
You can find the MySQL-max binaries at
<a HREF="http://www.mysql.com/downloads/mysql-max-3.23.html">http://www.mysql.com/downloads/mysql-max-3.23.html</a>.

</P>
<P>
The Windows MySQL 3.23 binary distribution includes both the
standard <CODE>mysqld.exe</CODE> binary and the <CODE>mysqld-max.exe</CODE> binary.
<a HREF="http://www.mysql.com/downloads/mysql-3.23.html">http://www.mysql.com/downloads/mysql-3.23.html</a>.
 「<A HREF="manual.ja_Installing.html#Windows_installation">2.1.2  Windows への <STRONG>MySQL</STRONG> のインストール</A>」節参照.

</P>
<P>
Note that as Berkeley DB and InnoDB are not available for all platforms,
some of the <CODE>Max</CODE> binaries may not have support for both of these.
You can check which table types are supported by doing the following
query:

</P>

<PRE>
mysql&#62; show variables like "have_%";
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| have_bdb      | YES   |
| have_innodb   | NO    |
| have_isam     | YES   |
| have_raid     | NO    |
| have_ssl      | NO    |
+---------------+-------+
</PRE>

<P>
The meaning of the values are:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Value</STRONG> </TD><TD> <STRONG>Meaning</STRONG>.
</TR NOSAVE>
<TR><TD>YES </TD><TD> The option is activated and usable.
</TR NOSAVE>
<TR><TD>NO </TD><TD> MySQL is not compiled with support for this option.
</TR NOSAVE>
<TR><TD>DISABLED </TD><TD> The xxxx option is disabled because one started <CODE>mysqld</CODE> with <CODE>--skip-xxxx</CODE> or because one didn't start <CODE>mysqld</CODE> with all needed options to enable the option.  In this case the <CODE>hostname.err</CODE> file should contain a reason for why the option is disabled.
</TR>
</TABLE>

<P>
<STRONG>NOTE</STRONG>:  To be able to create InnoDB tables you <STRONG>MUST</STRONG> edit
your startup options to include at least the <CODE>innodb_data_file_path</CODE>
option.  「<A HREF="manual.ja_Table_types.html#InnoDB_start">7.6.2  InnoDB 起動オプション</A>」節参照.

</P>
<P>
To get better performance for BDB tables, you should add some configuration
options for these too.  「<A HREF="manual.ja_Table_types.html#BDB_start">7.5.3  BDB startup options</A>」節参照.

</P>
<P>
<CODE>safe_mysqld</CODE> will automatically try to start any <CODE>mysqld</CODE> binary
with the <CODE>-max</CODE> prefix. This makes it very easy to test out a
another <CODE>mysqld</CODE> binary in an existing installation.  Just
run <CODE>configure</CODE> with the options you want and then install the
new <CODE>mysqld</CODE> binary as <CODE>mysqld-max</CODE> in the same directory
where your old <CODE>mysqld</CODE> binary is.  「<A HREF="manual.ja_MySQL_Database_Administration.html#safe_mysqld">4.7.2  safe_mysqld, the wrapper around mysqld</A>」節参照.

</P>
<P>
The <CODE>mysqld-max</CODE> RPM uses the above mentioned <CODE>safe_mysqld</CODE>
feature. It just installs the <CODE>mysqld-max</CODE> executable and
<CODE>safe_mysqld</CODE> will automatically use this executable when
<CODE>safe_mysqld</CODE> is restarted.

</P>
<P>
The following table shows which table types our standard <STRONG>MySQL-Max</STRONG>
binaries includes:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>System</STRONG> </TD><TD> <STRONG>BDB</STRONG> </TD><TD> <STRONG>InnoDB</STRONG>
</TR NOSAVE>
<TR><TD>AIX 4.3 </TD><TD> N </TD><TD> Y
</TR NOSAVE>
<TR><TD>HP-UX 11.0 </TD><TD> N </TD><TD> Y
</TR NOSAVE>
<TR><TD>Linux-Alpha </TD><TD> N </TD><TD> Y
</TR NOSAVE>
<TR><TD>Linux-Intel </TD><TD> Y </TD><TD> Y
</TR NOSAVE>
<TR><TD>Linux-Ia64 </TD><TD> N </TD><TD> Y
</TR NOSAVE>
<TR><TD>Solaris-intel </TD><TD> N </TD><TD> Y
</TR NOSAVE>
<TR><TD>Solaris-sparc </TD><TD> Y </TD><TD> Y
</TR NOSAVE>
<TR><TD>SCO OSR5 </TD><TD> Y </TD><TD> Y
</TR NOSAVE>
<TR><TD>UnixWare </TD><TD> Y </TD><TD> Y
</TR NOSAVE>
<TR><TD>Windows/NT </TD><TD> Y </TD><TD> Y
</TR>
</TABLE>



<H2><A NAME="Client-Side_Scripts" HREF="manual.ja_toc.html#Client-Side_Scripts">4.8  MySQL Client-Side Scripts and Utilities</A></H2>



<H3><A NAME="Client-Side_Overview" HREF="manual.ja_toc.html#Client-Side_Overview">4.8.1  Overview of the Client-Side Scripts and Utilities</A></H3>

<P>
<A NAME="IDX669"></A>
<A NAME="IDX670"></A>

</P>
<P>
All MySQL clients that communicate with the server using the
<CODE>mysqlclient</CODE> library use the following environment variables:

</P>
<P>
<A NAME="IDX671"></A>
<A NAME="IDX672"></A>
<A NAME="IDX673"></A>
<A NAME="IDX674"></A>
<A NAME="IDX675"></A>
<A NAME="IDX676"></A>
<A NAME="IDX677"></A>
<A NAME="IDX678"></A>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Name</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>MYSQL_UNIX_PORT</CODE> </TD><TD> The default socket; used for connections to <CODE>localhost</CODE>
</TR NOSAVE>
<TR><TD><CODE>MYSQL_TCP_PORT</CODE> </TD><TD> The default TCP/IP port
</TR NOSAVE>
<TR><TD><CODE>MYSQL_PWD</CODE> </TD><TD> The default password
</TR NOSAVE>
<TR><TD><CODE>MYSQL_DEBUG</CODE> </TD><TD> Debug-trace options when debugging
</TR NOSAVE>
<TR><TD><CODE>TMPDIR</CODE> </TD><TD> The directory where temporary tables/files are created
</TR>
</TABLE>

</P>
<P>
Use of <CODE>MYSQL_PWD</CODE> is insecure.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Connecting">4.2.7  MySQL サーバーに接続</A>」節参照.

</P>
<P>
<A NAME="IDX679"></A>
<A NAME="IDX680"></A>
<A NAME="IDX681"></A>
<A NAME="IDX682"></A>
<A NAME="IDX683"></A>
<A NAME="IDX684"></A>
<A NAME="IDX685"></A>
The <TT>`mysql'</TT> client uses the file named in the <CODE>MYSQL_HISTFILE</CODE>
environment variable to save the command-line history. The default value for
the history file is <TT>`$HOME/.mysql_history'</TT>, where <CODE>$HOME</CODE> is the
value of the <CODE>HOME</CODE> environment variable.  「<A HREF="manual.ja_Environment_variables.html#Environment_variables">H  Environment Variables</A>」節参照.

</P>
<P>
All MySQL programs take many different options. However, every
MySQL program provides a <CODE>--help</CODE> option that you can use
to get a full description of the program's different options. For example, try
<CODE>mysql --help</CODE>.

</P>
<P>
You can override default options for all standard client programs with an
option file.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Option_files">4.1.2  my.cnf オプションファイル</A>」節.

</P>
<P>
The list below briefly describes the MySQL programs:

</P>
<DL COMPACT>

<DT><CODE>myisamchk</CODE>
<DD>
<A NAME="IDX686"></A>
 
Utility to describe, check, optimize, and repair MySQL tables.
Because <CODE>myisamchk</CODE> has many functions, it is described in its own
chapter.  「<A HREF="manual.ja_MySQL_Database_Administration.html#MySQL_Database_Administration">4  MySQL Database Administration</A>」節参照.

<A NAME="IDX687"></A>
<DT><CODE>make_binary_distribution</CODE>
<DD>
Makes a binary release of a compiled MySQL. This could be sent
by FTP to <TT>`/pub/mysql/Incoming'</TT> on <CODE>support.mysql.com</CODE> for the
convenience of other MySQL users.

<A NAME="IDX688"></A>
<DT><CODE>msql2mysql</CODE>
<DD>
A shell script that converts <CODE>mSQL</CODE> programs to MySQL. It doesn't
handle all cases, but it gives a good start when converting.

<A NAME="IDX689"></A>
<DT><CODE>mysqlaccess</CODE>
<DD>
A script that checks the access privileges for a host, user, and database
combination.

<A NAME="IDX690"></A>
<DT><CODE>mysqladmin</CODE>
<DD>
Utility for performing administrative operations, such as creating or
dropping databases, reloading the grant tables, flushing tables to disk, and
reopening log files.  <CODE>mysqladmin</CODE> can also be used to retrieve version,
process, and status information from the server.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqladmin">4.8.3  mysqladmin, MySQL サーバーの管理</A>」節参照.

<A NAME="IDX691"></A>
<DT><CODE>mysqlbug</CODE>
<DD>
The MySQL bug report script.  This script should always be used when
filing a bug report to the MySQL list.

<A NAME="IDX692"></A>
<DT><CODE>mysqld</CODE>
<DD>
The SQL daemon. This should always be running.

<A NAME="IDX693"></A>
<DT><CODE>mysqldump</CODE>
<DD>
Dumps a MySQL database into a file as SQL statements or
as tab-separated text files. Enhanced freeware originally by Igor Romanenko.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqldump">4.8.5  mysqldump, データベースとテーブルから、構造とデータをダンプ</A>」節参照.

<A NAME="IDX694"></A>
<DT><CODE>mysqlimport</CODE>
<DD>
Imports text files into their respective tables using <CODE>LOAD DATA
INFILE</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqlimport">4.8.7  mysqlimport, テキストファイルからデータを取り込む</A>」節参照.

<A NAME="IDX695"></A>
<DT><CODE>mysqlshow</CODE>
<DD>
Displays information about databases, tables, columns, and indexes.

<A NAME="IDX696"></A>
<DT><CODE>mysql_install_db</CODE>
<DD>
Creates the MySQL grant tables with default privileges. This is
usually executed only once, when first installing MySQL
on a system.

<A NAME="IDX697"></A>
<DT><CODE>replace</CODE>
<DD>
A utility program that is used by <CODE>msql2mysql</CODE>, but that has more
general applicability as well.  <CODE>replace</CODE> changes strings in place in
files or on the standard input. Uses a finite state machine to match longer
strings first. Can be used to swap strings. For example, this command
swaps <CODE>a</CODE> and <CODE>b</CODE> in the given files:


<PRE>
shell&#62; replace a b b a -- file1 file2 ...
</PRE>

</DL>



<H3><A NAME="mysql" HREF="manual.ja_toc.html#mysql">4.8.2  コマンドラインツール　（ <CODE>mysql</CODE> ）</A></H3>

<P>
<A NAME="IDX698"></A>
<A NAME="IDX699"></A>
<A NAME="IDX700"></A>
<A NAME="IDX701"></A>

</P>
<P>
<CODE>mysql</CODE> はシンプルな SQL shell です(GNU <CODE>readline</CODE> を持っています).
これは対話モードと、非対話モードを持っています。 対話モードで使用された場合、
クエリの結果は ASCII テーブルのフォーマットで与えられます。
非対話モードで使用された場合(例えばフィルターとして)、結果はタブ区切りの
フォーマットで返ります。
(出力フォーマットはコマンドラインのオプションで変更できます)
以下のようにしてスクリプトを実行できます：

</P>

<PRE>
shell&#62; mysql database &#60; script.sql &#62; output.tab
</PRE>

<P>
もしクライアントでメモリー不足の問題が出た場合、<CODE>--quick</CODE> オプションを
使用します！ これは <CODE>mysql</CODE> に、結果セットを取得する際に、
<CODE>mysql_store_result()</CODE> ではなく <CODE>mysql_use_result()</CODE> を
使用させます。

</P>
<P>
<CODE>mysql</CODE> の使用はとても簡単です：
<CODE>mysql database</CODE> や <CODE>mysql --user=user_name --password=your_password d
atabase</CODE> のようにしてはじめます。
SQL 文を入力し、一文を <SAMP>`;'</SAMP>, <SAMP>`\g'</SAMP> or <SAMP>`\G'</SAMP> で終え、
RETURN/ENTER を押します。

</P>
<P>
<A NAME="IDX702"></A>
<A NAME="IDX703"></A>
<A NAME="IDX704"></A>
<A NAME="IDX705"></A>
<CODE>mysql</CODE> は以下のオプションをサポートします：

</P>
<DL COMPACT>

<DT><CODE>-?, --help</CODE>
<DD>
<A NAME="IDX706"></A>
 
help を表示して終了

<A NAME="IDX707"></A>
<DT><CODE>-A, --no-auto-rehash</CODE>
<DD>
自動リハッシュをしない。 テーブルとフィールドの取得には 'rehash' を
使用しなくてはなりません。 これは <CODE>mysql</CODE> の起動を速くします。

<A NAME="IDX708"></A>
<DT><CODE>-B, --batch</CODE>
<DD>
結果をタブ区切り、１レコードは１行で出力します。 history ファイルは使用しません。

<A NAME="IDX709"></A>
<DT><CODE>--character-sets-dir=...</CODE>
<DD>
Directory where character sets are located.

<A NAME="IDX710"></A>
<DT><CODE>-C, --compress</CODE>
<DD>
サーバー・クライアント間の通信を圧縮します

<A NAME="IDX711"></A>
<DT><CODE>-#, --debug[=...]</CODE>
<DD>
デバッグログ。 デフォルトは 'd:t:o,/tmp/mysql.trace'

<A NAME="IDX712"></A>
<DT><CODE>-D, --database=...</CODE>
<DD>
使用するデータベース。 これは <CODE>my.cnf</CODE> ファイルが便利です

<A NAME="IDX713"></A>
<DT><CODE>--default-character-set=...</CODE>
<DD>
Set the default character set.

<A NAME="IDX714"></A>
<DT><CODE>-e, --execute=...</CODE>
<DD>
コマンドを実行して終了。 (Output like with --batch)

<A NAME="IDX715"></A>
<DT><CODE>-E, --vertical</CODE>
<DD>
垂直にレコードを出力します。 このオプションを指定していなくても、
SQL 文を <CODE>\G</CODE> で終了した場合、同じように垂直に出力します。

<A NAME="IDX716"></A>
<DT><CODE>-f, --force</CODE>
<DD>
SQL エラーがおきたとしても、処理を続けます

<A NAME="IDX717"></A>
<DT><CODE>-g, --no-named-commands</CODE>
<DD>
Named commands are disabled. Use \* form only, or use named commands
only in the beginning of a line ending with a semicolon (;). Since
Version 10.9, the client now starts with this option ENABLED by default!
With the -g option, long format commands will still work from the first
line, however.

<A NAME="IDX718"></A>
<DT><CODE>-G, --enable-named-commands</CODE>
<DD>
Named commands are <STRONG>enabled</STRONG>.  Long format commands are allowed as
well as shortened \* commands.

<A NAME="IDX719"></A>
<DT><CODE>-i, --ignore-space</CODE>
<DD>
関数名の後ろについたスペースを無視します

<A NAME="IDX720"></A>
<DT><CODE>-h, --host=...</CODE>
<DD>
指定したホストに接続します

<A NAME="IDX721"></A>
<DT><CODE>-H, --html</CODE>
<DD>
結果を HTML フォーマットで返します

<A NAME="IDX722"></A>
<DT><CODE>-L, --skip-line-numbers</CODE>
<DD>
エラーの起きた行の番号を書きません。 これはエラーメッセージを含んだ結果を
比較する場合に便利です。

<A NAME="IDX723"></A>
<DT><CODE>--no-pager</CODE>
<DD>
Disable pager and print to stdout. See interactive help (\h) also.

<A NAME="IDX724"></A>
<DT><CODE>--no-tee</CODE>
<DD>
Disable outfile. See interactive help (\h) also.

<A NAME="IDX725"></A>
<DT><CODE>-n, --unbuffered</CODE>
<DD>
それぞれのクエリ毎にバッファをフラッシュします

<A NAME="IDX726"></A>
<DT><CODE>-N, --skip-column-names</CODE>
<DD>
結果に、フィールド名を書き出しません。

<A NAME="IDX727"></A>
<DT><CODE>-O, --set-variable var=option</CODE>
<DD>
変数に値をセットします。 <CODE>--help</CODE> lists variables.

<A NAME="IDX728"></A>
<DT><CODE>-o, --one-database</CODE>
<DD>
デフォルトのデータベースのみ更新します。 これは update ログファイルを
使用して更新する場合、他のデータベースの更新を避けたい時に便利です。

<A NAME="IDX729"></A>
<DT><CODE><CODE>--pager[=...]</CODE></CODE>
<DD>
Output type. Default is your <CODE>ENV</CODE> variable <CODE>PAGER</CODE>. Valid
pagers are less, more, cat [&#62; filename], etc.  See interactive help (\h)
also. This option does not work in batch mode. Pager works only in UNIX.

<A NAME="IDX730"></A>
<DT><CODE>-p[password], --password[=...]</CODE>
<DD>
サーバーに接続する際のパスワード。 もしパスワードがコマンドラインに
指定されていなかった場合、tty 上でパスワードが問い合わされます。
<CODE>-p</CODE> を使用する場合、このオプションとパスワードの間には
スペースが不要だということに注意してください。

<A NAME="IDX731"></A>
<DT><CODE>-P  --port=...</CODE>
<DD>
接続に使用する TCP/IP ポート番号

<A NAME="IDX732"></A>
<DT><CODE>-q, --quick</CODE>
<DD>
結果をキャッシュせず、一レコードづつ出力します。
これはもし出力を中止した場合、サーバーを遅くします。
ヒストリファイルは使用しません。

<A NAME="IDX733"></A>
<DT><CODE>-r, --raw</CODE>
<DD>
エスケープ処理をしないで値を書き出します。 <CODE>--batch</CODE> とともに使用されます

<A NAME="IDX734"></A>
<DT><CODE>-s, --silent</CODE>
<DD>
静粛モード

<A NAME="IDX735"></A>
<DT><CODE>-S  --socket=...</CODE>
<DD>
接続に使用する ソケットファイル

<A NAME="IDX736"></A>
<DT><CODE>-t  --table</CODE>
<DD>
表の形式で出力します。 これは batch モード以外でのデフォルトです。

<A NAME="IDX737"></A>
<DT><CODE>-T, --debug-info</CODE>
<DD>
Print some debug information at exit.

<A NAME="IDX738"></A>
<DT><CODE>--tee=...</CODE>
<DD>
Append everything into outfile. See interactive help (\h) also. Does not
work in batch mode.

<A NAME="IDX739"></A>
<DT><CODE>-u, --user=#</CODE>
<DD>
ログインユーザー名

<A NAME="IDX740"></A>
<DT><CODE>-U, --safe-updates[=#], --i-am-a-dummy[=#]</CODE>
<DD>
キーを使用する <CODE>UPDATE</CODE> and <CODE>DELETE</CODE> のみを行います。
これは後述します。 このオプションをもし <CODE>my.cnf</CODE> に書いている場合は、
<CODE>--safe-updates=0</CODE> でこのオプションをリセットできます。

<A NAME="IDX741"></A>
<DT><CODE>-v, --verbose</CODE>
<DD>
冗長出力。 (-v -v -v は表形式の出力を与える)

<A NAME="IDX742"></A>
<DT><CODE>-V, --version</CODE>
<DD>
バージョンを表示して終了

<A NAME="IDX743"></A>
<DT><CODE>-w, --wait</CODE>
<DD>
もし接続が落ちた場合、中断しないで、待って、再試行します。
</DL>

<P>
You can also set the following variables with <CODE>-O</CODE> or
<CODE>--set-variable</CODE>:

</P>
<P>
<A NAME="IDX744"></A>
<A NAME="IDX745"></A>
<A NAME="IDX746"></A>
<A NAME="IDX747"></A>
<A NAME="IDX748"></A>
<A NAME="IDX749"></A>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>Variable Name </TD><TD> Default </TD><TD> Description
</TR NOSAVE>
<TR><TD>connect_timeout </TD><TD> 0 </TD><TD> Number of seconds before timeout connection.
</TR NOSAVE>
<TR><TD>max_allowed_packet </TD><TD> 16777216 </TD><TD> Max packetlength to send/receive from to server
</TR NOSAVE>
<TR><TD>net_buffer_length </TD><TD> 16384 </TD><TD> Buffer for TCP/IP and socket communication
</TR NOSAVE>
<TR><TD>select_limit </TD><TD> 1000 </TD><TD> Automatic limit for SELECT when using --i-am-a-dummy
</TR NOSAVE>
<TR><TD>max_join_size </TD><TD> 1000000 </TD><TD> Automatic limit for rows in a join when using --i-am-a-dummy.
</TR>
</TABLE>

</P>
<P>
もしコマンドラインで 'help' と打った場合、<CODE>mysql</CODE> はサポートする
コマンドを表示します：

</P>
<P>
<A NAME="IDX750"></A>

<PRE>
mysql&#62; help

MySQL commands:
help    (\h)    Display this text.
?       (\h)    Synonym for `help'.
clear   (\c)    Clear command.
connect (\r)    Reconnect to the server. Optional arguments are db and host.
edit    (\e)    Edit command with $EDITOR.
ego     (\G)    Send command to mysql server, display result vertically.
exit    (\q)    Exit mysql. Same as quit.
go      (\g)    Send command to mysql server.
nopager (\n)    Disable pager, print to stdout.
notee   (\t)    Don't write into outfile.
pager   (\P)    Set PAGER [to_pager]. Print the query results via PAGER.
print   (\p)    Print current command.
quit    (\q)    Quit mysql.
rehash  (\#)    Rebuild completion hash.
source  (\.)    Execute a SQL script file. Takes a file name as an argument.
status  (\s)    Get status information from the server.
tee     (\T)    Set outfile [to_outfile]. Append everything into given outfile.
use     (\u)    Use another database. Takes database name as argument.
</PRE>

<P>
From the above, pager only works in UNIX.

</P>
<P>
<A NAME="IDX751"></A>
<CODE>status</CODE> コマンドは、今使用している
接続とサーバーについての情報をいくつか表示します。
もし <CODE>--safe-updates</CODE> モードで使用している場合、 <CODE>status</CODE> は
あなたのクエリに影響する <CODE>mysql</CODE> 変数の値を表示します。

</P>
<P>
<A NAME="IDX752"></A>
初心者に便利な起動オプション(MySQL バージョン 3.23.11 で導入されました)は、
<CODE>--safe-updates</CODE> あるいは <CODE>--i-am-a-dummy</CODE> です。
( これは <CODE>DELETE FROM table_name</CODE> を <CODE>WHERE</CODE> 節を忘れて
実行しようとした場合のためにあります。)
このオプションが使用されると、 <CODE>mysql</CODE> は接続時に <STRONG>MySQL</STRONG> サーバーに
以下のようなコマンドを送ります：

</P>

<PRE>
SET SQL_SAFE_UPDATES=1,SQL_SELECT_LIMIT=#select_limit#,
    SQL_MAX_JOIN_SIZE=#max_join_size#"
</PRE>

<P>
ここで <CODE>#select_limit#</CODE> と <CODE>#max_join_size#</CODE> は変数で
これらは <CODE>mysql</CODE> コマンドからセット可能です。
 「<A HREF="manual.ja_MySQL_Optimization.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節参照.

</P>
<P>
この効果は：

</P>

<UL>
<LI>

もし <CODE>WHERE</CODE> 節でキーを使用していなければ、<CODE>UPDATE</CODE> や <CODE>DELETE</CODE>
は許可されません。 しかし、 <CODE>LIMIT</CODE> を使用すれば <CODE>UPDATE/DELETE</CODE> を
強制実行できます：

<PRE>
UPDATE table_name SET not_key_column=# WHERE not_key_column=# LIMIT 1;
</PRE>

<LI>

全ての多きな結果は自動的に <CODE>#select_limit#</CODE> レコードまでに抑えられます。
<LI>

評価に <CODE>#max_join_size</CODE> 以上の行を必要とするであろう <CODE>SELECT</CODE> は
中断されます。
</UL>

<P>
Some useful hints about the <CODE>mysql</CODE> client:

</P>
<P>
Some data is much more readable when displayed vertically, instead of
the usual horizontal box type output. For example longer text, which
includes new lines, is often much easier to be read with vertical
output.

</P>

<PRE>
mysql&#62; select * from mails where length(txt) &#60; 300 limit 300,1\G
*************************** 1. row ***************************
  msg_nro: 3068
     date: 2000-03-01 23:29:50
time_zone: +0200
mail_from: Monty
    reply: monty@no.spam.com
  mail_to: "Thimble Smith" &#60;tim@no.spam.com&#62;
      sbj: UTF-8
      txt: &#62;&#62;&#62;&#62;&#62; "Thimble" == Thimble Smith writes:

Thimble&#62; Hi.  I think this is a good idea.  Is anyone familiar with UTF-8
Thimble&#62; or Unicode?  Otherwise I'll put this on my TODO list and see what
Thimble&#62; happens.

Yes, please do that.

Regards,
Monty
     file: inbox-jani-1
     hash: 190402944
1 row in set (0.09 sec)
</PRE>


<UL>
<LI>

For logging, you can use the <CODE>tee</CODE> option. The <CODE>tee</CODE> can be
started with option <CODE>--tee=...</CODE>, or from the command line
interactively with command <CODE>tee</CODE>. All the data displayed on the
screen will also be appended into a given file. This can be very useful
for debugging purposes also. The <CODE>tee</CODE> can be disabled from the
command line with command <CODE>notee</CODE>. Executing <CODE>tee</CODE> again
starts logging again. Without a parameter the previous file will be
used. Note that <CODE>tee</CODE> will flush the results into the file after
each command, just before the command line appears again waiting for the
next command.

<LI>

Browsing, or searching the results in the interactive mode in UNIX less,
more, or any other similar program, is now possible with option
<CODE>--pager[=...]</CODE>. Without argument, <CODE>mysql</CODE> client will look
for environment variable PAGER and set <CODE>pager</CODE> to that.
<CODE>pager</CODE> can be started from the interactive command line with
command <CODE>pager</CODE> and disabled with command <CODE>nopager</CODE>.  The
command takes an argument optionally and the <CODE>pager</CODE> will be set to
that. Command <CODE>pager</CODE> can be called without an argument, but this
requires that the option <CODE>--pager</CODE> was used, or the <CODE>pager</CODE>
will default to stdout. <CODE>pager</CODE> works only in UNIX, since it uses
the popen() function, which doesn't exist in Windows. In Windows, the
<CODE>tee</CODE> option can be used instead, although it may not be as handy
as <CODE>pager</CODE> can be in some situations.

<LI>

A few tips about <CODE>pager</CODE>: You can use it to write to a file:

<PRE>
mysql&#62; pager cat &#62; /tmp/log.txt
</PRE>

and the results will only go to a file. You can also pass any options
for the programs that you want to use with the <CODE>pager</CODE>:

<PRE>
mysql&#62; pager less -n -i -S
</PRE>

From the above do note the option '-S'. You may find it very useful when
browsing the results; try the option with horizontal output (end
commands with '\g', or ';') and with vertical output (end commands with
'\G'). Sometimes a very wide result set is hard to be read from the screen,
with option -S to less you can browse the results within the interactive
less from left to right, preventing lines longer than your screen from
being continued to the next line. This can make the result set much more
readable. You can swith the mode between on and off within the interactive
less with '-S'. See the 'h' for more help about less.

<LI>

Last (unless you already understood this from the above examples ;) you
can combine very complex ways to handle the results, for example the
following would send the results to two files in two different
directories, on two different hard-disks mounted on /dr1 and /dr2, yet
let the results still be seen on the screen via less:

<PRE>
mysql&#62; pager cat | tee /dr1/tmp/res.txt | tee /dr2/tmp/res2.txt | less -n -i -S
</PRE>

<LI>

You can also combine the two functions above; have the <CODE>tee</CODE>
enabled, <CODE>pager</CODE> set to 'less' and you will be able to browse the
results in unix 'less' and still have everything appended into a file
the same time. The difference between <CODE>UNIX tee</CODE> used with the
<CODE>pager</CODE> and the <CODE>mysql</CODE> client in-built <CODE>tee</CODE>, is that
the in-built <CODE>tee</CODE> works even if you don't have the <CODE>UNIX tee</CODE>
available. The in-built <CODE>tee</CODE> also logs everything that is printed
on the screen, where the <CODE>UNIX tee</CODE> used with <CODE>pager</CODE> doesn't
log quite that much. Last, but not least, the interactive <CODE>tee</CODE> is
more handy to switch on and off, when you want to log something into a
file, but want to be able to turn the feature off sometimes.
</UL>



<H3><A NAME="mysqladmin" HREF="manual.ja_toc.html#mysqladmin">4.8.3  mysqladmin, MySQL サーバーの管理</A></H3>

<P>
<A NAME="IDX753"></A>
<A NAME="IDX754"></A>
<A NAME="IDX755"></A>

</P>
<P>
管理オペレーションを実行するためのユーティリティ。シンタックスは: 

</P>

<PRE>
shell&#62; mysqladmin [OPTIONS] command [command-option] command ...
</PRE>

<P>
<CODE>mysqladmin --help</CODE> によって、オプションの一覧を手にいれることができます。

</P>
<P>
現在の <CODE>mysqladmin</CODE> は以下のコマンドをサポートします：

</P>
<DL COMPACT>

<DT><CODE>create databasename</CODE>
<DD>
データベースの作成

<DT><CODE>drop databasename</CODE>
<DD>
データベースとテーブルの全削除。

<DT><CODE>extended-status</CODE>
<DD>
サーバーから拡張ステータスを取得。

<DT><CODE>flush-hosts</CODE>
<DD>
キャッシュされている全ホストをフラッシュ。

<DT><CODE>flush-logs</CODE>
<DD>
全てのログをフラッシュ

<DT><CODE>flush-tables</CODE>
<DD>
全てのテーブルをフラッシュ

<DT><CODE>flush-privileges</CODE>
<DD>
許可テーブルの再読み込み (reload と同じ)

<DT><CODE>kill id,id,...</CODE>
<DD>
mysql スレッドの kill.

<DT><CODE>password</CODE>
<DD>
古いパスワードを New-password に変更

<DT><CODE>ping</CODE>
<DD>
<CODE>mysqld</CODE> が生きているかチェック

<DT><CODE>processlist</CODE>
<DD>
現在活動中の mysql スレッドを表示

<DT><CODE>reload</CODE>
<DD>
許可テーブルの再読み込み

<DT><CODE>refresh</CODE>
<DD>
全テーブルをフラッシュし、ログファイルを一度閉じて開きます。

<DT><CODE>shutdown</CODE>
<DD>
サーバーをダウンさせます。

<DT><CODE>slave-start</CODE>
<DD>
Start slave replication thread.

<DT><CODE>slave-stop</CODE>
<DD>
Stop slave replication thread.

<DT><CODE>status</CODE>
<DD>
サーバーから短いステータスを得ます。

<DT><CODE>variables</CODE>
<DD>
変数の表示

<DT><CODE>version</CODE>
<DD>
サーバーからバージョンを得ます。
</DL>

<P>
全てのコマンドは、ユニークなプレフィックスで省略可能です。
例えば：

</P>

<PRE>
shell&#62; mysqladmin proc stat
+----+-------+-----------+----+-------------+------+-------+------+
| Id | User  | Host      | db | Command     | Time | State | Info |
+----+-------+-----------+----+-------------+------+-------+------+
| 6  | monty | localhost |    | Processlist | 0    |       |      |
+----+-------+-----------+----+-------------+------+-------+------+
Uptime: 10077  Threads: 1  Questions: 9  Slow queries: 0  Opens: 6  Flush tables: 1  Open tables: 2  Memory in use: 1092K  Max memory used: 1116K
</PRE>

<P>
<A NAME="IDX756"></A>
The <CODE>mysqladmin status</CODE> command result has the following columns:

</P>
<P>
<A NAME="IDX757"></A>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>Uptime </TD><TD> MySQL サーバーの起動秒数
</TR NOSAVE>
<TR><TD>Threads </TD><TD> 稼働中のスレッド数 (clients).
<A NAME="IDX758"></A>
 
</TR NOSAVE>
<TR><TD>Questions </TD><TD> <CODE>mysqld</CODE> が開始してからのクライアントからのクエリ数
<A NAME="IDX759"></A>
 
</TR NOSAVE>
<TR><TD>Slow queries </TD><TD> <CODE>long_query_time</CODE> 秒より時間のかかったクエリの数  「<A HREF="manual.ja_MySQL_Database_Administration.html#Slow_query_log">4.9.5  The Slow Query Log</A>」節参照.
<A NAME="IDX760"></A>
 
</TR NOSAVE>
<TR><TD>Opens </TD><TD> <CODE>mysqld</CODE> が開いたテーブル数
<A NAME="IDX761"></A>
 
</TR NOSAVE>
<TR><TD>Flush tables </TD><TD> Number of <CODE>flush ...</CODE>, <CODE>refresh</CODE>, and <CODE>reload</CODE> commands.
<A NAME="IDX762"></A>
 <A NAME="IDX763"></A>
 
</TR NOSAVE>
<TR><TD>Open tables </TD><TD> 現在開かれているテーブルの数
<A NAME="IDX764"></A>
 
</TR NOSAVE>
<TR><TD>Memory in use </TD><TD> <CODE>mysqld</CODE> のコードによって直接割り当てられたメモリ (only available when MySQL is compiled with --with-debug=full).
<A NAME="IDX765"></A>
 
</TR NOSAVE>
<TR><TD>Max memory used </TD><TD> <CODE>mysqld</CODE> のコードによって直接割り当てられる最大メモリー量 (only available when MySQL is compiled with --with-debug=full).
<A NAME="IDX766"></A>
 
</TR>
</TABLE>

</P>
<P>
If you do <CODE>myslqadmin shutdown</CODE> on a socket (in other words, on a
the computer where <CODE>mysqld</CODE> is running), <CODE>mysqladmin</CODE> will
wait until the MySQL <CODE>pid-file</CODE> is removed to ensure that
the <CODE>mysqld</CODE> server has stopped properly.

</P>



<H3><A NAME="Using_mysqlcheck" HREF="manual.ja_toc.html#Using_mysqlcheck">4.8.4  Using <CODE>mysqlcheck</CODE> for Table Maintenance and Crash Recovery</A></H3>

<P>
Since MySQL version 3.23.38 you will be able to use a new
checking and repairing tool for <CODE>MyISAM</CODE> tables. The difference to
<CODE>myisamchk</CODE> is that <CODE>mysqlcheck</CODE> should be used when the
<CODE>mysqld</CODE> server is running, where as <CODE>myisamchk</CODE> should be used
when it is not. The benefit is that you no longer have to take the
server down for checking or repairing your tables.

</P>
<P>
<CODE>mysqlcheck</CODE> uses MySQL server commands <CODE>CHECK</CODE>,
<CODE>REPAIR</CODE>, <CODE>ANALYZE</CODE> and <CODE>OPTIMIZE</CODE> in a convenient way
for the user.

</P>
<P>
There are three alternative ways to invoke <CODE>mysqlcheck</CODE>:

</P>

<PRE>
shell&#62; mysqlcheck [OPTIONS] database [tables]
shell&#62; mysqlcheck [OPTIONS] --databases DB1 [DB2 DB3...]
shell&#62; mysqlcheck [OPTIONS] --all-databases
</PRE>

<P>
So it can be used in a similar way as <CODE>mysqldump</CODE> when it
comes to what databases and tables you want to choose.

</P>
<P>
<CODE>mysqlcheck</CODE> does have a special feature compared to the other
clients; the default behavior, checking tables (-c), can be changed by
renaming the binary. So if you want to have a tool that repairs tables
by default, you should just copy <CODE>mysqlcheck</CODE> to your harddrive
with a new name, <CODE>mysqlrepair</CODE>, or alternatively make a symbolic
link to <CODE>mysqlrepair</CODE> and name the symbolic link as
<CODE>mysqlrepair</CODE>. If you invoke <CODE>mysqlrepair</CODE> now, it will repair
tables by default.

</P>
<P>
The names that you can use to change <CODE>mysqlcheck</CODE> default behavior
are here:

</P>

<PRE>
mysqlrepair:   The default option will be -r
mysqlanalyze:  The default option will be -a
mysqloptimize: The default option will be -o
</PRE>

<P>
The options available for <CODE>mysqlcheck</CODE> are listed here, please
check what your version supports with <CODE>mysqlcheck --help</CODE>.

</P>
<DL COMPACT>

<DT><CODE>-A, --all-databases</CODE>
<DD>
Check all the databases. This will be same as --databases with all
databases selected
<DT><CODE>-1, --all-in-1</CODE>
<DD>
Instead of making one query for each table, execute all queries in 1
query separately for each database. Table names will be in a comma
separated list.
<DT><CODE>-a, --analyze</CODE>
<DD>
Analyze given tables.
<DT><CODE>--auto-repair</CODE>
<DD>
If a checked table is corrupted, automatically fix it. Repairing will be
done after all tables have been checked, if corrupted ones were found.
<DT><CODE>-#, --debug=...</CODE>
<DD>
Output debug log. Often this is 'd:t:o,filename'
<DT><CODE>--character-sets-dir=...</CODE>
<DD>
Directory where character sets are
<DT><CODE>-c, --check</CODE>
<DD>
Check table for errors
<DT><CODE>-C, --check-only-changed</CODE>
<DD>
Check only tables that have changed since last check or haven't been
closed properly.
<DT><CODE>--compress</CODE>
<DD>
Use compression in server/client protocol.
<DT><CODE>-?, --help</CODE>
<DD>
Display this help message and exit.
<DT><CODE>-B, --databases</CODE>
<DD>
To check several databases. Note the difference in usage; In this case
no tables are given. All name arguments are regarded as database names.
<DT><CODE>--default-character-set=...</CODE>
<DD>
Set the default character set
<DT><CODE>-F, --fast</CODE>
<DD>
Check only tables that hasn't been closed properly
<DT><CODE>-f, --force</CODE>
<DD>
Continue even if we get an sql-error.
<DT><CODE>-e, --extended</CODE>
<DD>
If you are using this option with CHECK TABLE, it will ensure that the
table is 100 percent consistent, but will take a long time.

If you are using this option with REPAIR TABLE, it will run an extended
repair on the table, which may not only take a long time to execute, but
may produce a lot of garbage rows also!
<DT><CODE>-h, --host=...</CODE>
<DD>
Connect to host.
<DT><CODE>-m, --medium-check</CODE>
<DD>
Faster than extended-check, but only finds 99.99 percent of all
errors. Should be good enough for most cases.
<DT><CODE>-o, --optimize</CODE>
<DD>
Optimize table
<DT><CODE>-p, --password[=...]</CODE>
<DD>
Password to use when connecting to server. If password is not given
it's solicited on the tty.
<DT><CODE>-P, --port=...</CODE>
<DD>
Port number to use for connection.
<DT><CODE>-q, --quick</CODE>
<DD>
If you are using this option with CHECK TABLE, it prevents the check
from scanning the rows to check for wrong links. This is the fastest
check.

If you are using this option with REPAIR TABLE, it will try to repair
only the index tree. This is the fastest repair method for a table.
<DT><CODE>-r, --repair</CODE>
<DD>
Can fix almost anything except unique keys that aren't unique.
<DT><CODE>-s, --silent</CODE>
<DD>
Print only error messages.
<DT><CODE>-S, --socket=...</CODE>
<DD>
Socket file to use for connection.
<DT><CODE>--tables</CODE>
<DD>
Overrides option --databases (-B).
<DT><CODE>-u, --user=#</CODE>
<DD>
User for login if not current user.
<DT><CODE>-v, --verbose</CODE>
<DD>
Print info about the various stages.
<DT><CODE>-V, --version</CODE>
<DD>
Output version information and exit.
</DL>



<H3><A NAME="mysqldump" HREF="manual.ja_toc.html#mysqldump">4.8.5  mysqldump, データベースとテーブルから、構造とデータをダンプ</A></H3>

<P>
<A NAME="IDX767"></A>
<A NAME="IDX768"></A>
<A NAME="IDX769"></A>
<A NAME="IDX770"></A>

</P>
<P>
<A NAME="IDX771"></A>
データベース、あるいは、バックアップ、他のSQLサーバー(<STRONG>MySQL</STRONG> サーバであ
る必要はない)へのデータを移動を目的としたデータのまとまり、これらをダンプする
ためのユーティリティ。ダンプは、テーブルの作成のための SQL 文を含みます。

</P>
<P>
サーバでバックアップを行なう場合、<CODE>mysqlhotcopy</CODE> を代わりに使用するこ
とを考慮すべきです。  「<A HREF="manual.ja_MySQL_Database_Administration.html#mysqlhotcopy">4.8.6  mysqlhotcopy, Copying MySQL Databases and Tables</A>」節参照.

</P>

<PRE>
shell&#62; mysqldump [OPTIONS] database [tables]
OR     mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]
OR     mysqldump [OPTIONS] --all-databases [OPTIONS]
</PRE>

<P>
もしテーブルを指定せず、<CODE>--databases</CODE> や <CODE>--all-databases</CODE> を
使用しなかったなら、データベースの全てのテーブルがダンプされます。

</P>
<P>
<CODE>mysqldump --help</CODE> によって、オプションの一覧を手にいれることができます。

</P>
<P>
もし <CODE>mysqldump</CODE> を <CODE>--quick</CODE> や <CODE>--opt</CODE> なしで実行するならば、
<CODE>mysqldump</CODE> は結果を表示する前に、結果をメモリに全てロードすることに
注意してください。
これは大きなデータベースをダンプする際に問題になるでしょう。

</P>
<P>
Note that if you are using a new copy of the <CODE>mysqldump</CODE> program
and you are going to do a dump that will be read into a very old MySQL
server, you should not use the <CODE>--opt</CODE> or <CODE>-e</CODE> options.

</P>
<P>
<CODE>mysqldump</CODE> は以下のオプションをサポートします：

</P>
<DL COMPACT>

<DT><CODE>--add-locks</CODE>
<DD>
Add <CODE>LOCK TABLES</CODE> before and <CODE>UNLOCK TABLE</CODE> after each table dump.
(To get faster inserts into MySQL.)
<DT><CODE>--add-drop-table</CODE>
<DD>
Add a <CODE>drop table</CODE> before each create statement.
<DT><CODE>-A, --all-databases</CODE>
<DD>
Dump all the databases. This will be same as <CODE>--databases</CODE> with all
databases selected.
<DT><CODE>-a, --all</CODE>
<DD>
Include all MySQL-specific create options.
<DT><CODE>--allow-keywords</CODE>
<DD>
Allow creation of column names that are keywords.  This works by
prefixing each column name with the table name.
<DT><CODE>-c, --complete-insert</CODE>
<DD>
Use complete insert statements (with column names).
<DT><CODE>-C, --compress</CODE>
<DD>
Compress all information between the client and the server if both support
compression.
<DT><CODE>-B, --databases</CODE>
<DD>
To dump several databases. Note the difference in usage. In this case
no tables are given. All name arguments are regarded as database names.
<CODE>USE db_name;</CODE> will be included in the output before each new database.
<DT><CODE>--delayed</CODE>
<DD>
Insert rows with the <CODE>INSERT DELAYED</CODE> command.
<DT><CODE>-e, --extended-insert</CODE>
<DD>
Use the new multiline <CODE>INSERT</CODE> syntax. (Gives more compact and
faster inserts statements.)
<DT><CODE>-#, --debug[=option_string]</CODE>
<DD>
Trace usage of the program (for debugging).
<DT><CODE>--help</CODE>
<DD>
Display a help message and exit.
<DT><CODE>--fields-terminated-by=...</CODE>
<DD>
<DT><CODE>--fields-enclosed-by=...</CODE>
<DD>
<DT><CODE>--fields-optionally-enclosed-by=...</CODE>
<DD>
<DT><CODE>--fields-escaped-by=...</CODE>
<DD>
<DT><CODE>--lines-terminated-by=...</CODE>
<DD>
These options are used with the <CODE>-T</CODE> option and have the same
meaning as the corresponding clauses for <CODE>LOAD DATA INFILE</CODE>.
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.8  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.
<DT><CODE>-F, --flush-logs</CODE>
<DD>
Flush log file in the MySQL server before starting the dump.
<DT><CODE>-f, --force,</CODE>
<DD>
Continue even if we get a SQL error during a table dump.
<DT><CODE>-h, --host=..</CODE>
<DD>
Dump data from the MySQL server on the named host. The default host
is <CODE>localhost</CODE>.
<DT><CODE>-l, --lock-tables.</CODE>
<DD>
Lock all tables before starting the dump.  The tables are locked with
<CODE>READ LOCAL</CODE> to allow concurrent inserts in the case of <CODE>MyISAM</CODE>
tables.
<DT><CODE>-n, --no-create-db</CODE>
<DD>
'CREATE DATABASE /*!32312 IF NOT EXISTS*/ db_name;' will not be put in the
output. The above line will be added otherwise, if --databases or
--all-databases option was given.
<DT><CODE>-t, --no-create-info</CODE>
<DD>
Don't write table creation information (The <CODE>CREATE TABLE</CODE> statement.)
<DT><CODE>-d, --no-data</CODE>
<DD>
Don't write any row information for the table.  This is very useful if you
just want to get a dump of the structure for a table!
<DT><CODE>--opt</CODE>
<DD>
Same as <CODE>--quick --add-drop-table --add-locks --extended-insert
--lock-tables</CODE>.  Should give you the fastest possible dump for reading
into a MySQL server.
<DT><CODE>-pyour_pass, --password[=your_pass]</CODE>
<DD>
The password to use when connecting to the server. If you specify
no <SAMP>`=your_pass'</SAMP> part,
<CODE>mysqldump</CODE> you will be prompted for a password.
<DT><CODE>-P port_num, --port=port_num</CODE>
<DD>
The TCP/IP port number to use for connecting to a host.  (This is used for
connections to hosts other than <CODE>localhost</CODE>, for which Unix sockets are
used.)
<DT><CODE>-q, --quick</CODE>
<DD>
Don't buffer query, dump directly to stdout. Uses <CODE>mysql_use_result()</CODE>
to do this.
<DT><CODE>-r, --result-file=...</CODE>
<DD>
Direct output to a given file. This option should be used in MSDOS,
because it prevents new line '\n' from being converted to '\n\r' (new
line + carriage return).
<DT><CODE>-S /path/to/socket, --socket=/path/to/socket</CODE>
<DD>
The socket file to use when connecting to <CODE>localhost</CODE> (which is the
default host).
<DT><CODE>--tables</CODE>
<DD>
Overrides option --databases (-B).
<DT><CODE>-T, --tab=path-to-some-directory</CODE>
<DD>
Creates a <CODE>table_name.sql</CODE> file, that contains the SQL CREATE commands,
and a <CODE>table_name.txt</CODE> file, that contains the data, for each give table.
<STRONG>NOTE</STRONG>: This only works if <CODE>mysqldump</CODE> is run on the same
machine as the <CODE>mysqld</CODE> daemon.  The format of the <CODE>.txt</CODE> file
is made according to the <CODE>--fields-xxx</CODE> and <CODE>--lines--xxx</CODE> options.
<DT><CODE>-u user_name, --user=user_name</CODE>
<DD>
The MySQL user name to use when connecting to the server. The
default value is your Unix login name.
<DT><CODE>-O var=option, --set-variable var=option</CODE>
<DD>
Set the value of a variable.  The possible variables are listed below.
<DT><CODE>-v, --verbose</CODE>
<DD>
Verbose mode.  Print out more information on what the program does.
<DT><CODE>-V, --version</CODE>
<DD>
Print version information and exit.
<DT><CODE>-w, --where='where-condition'</CODE>
<DD>
Dump only selected records. Note that QUOTES are mandatory:


<PRE>
"--where=user='jimf'" "-wuserid&#62;1" "-wuserid&#60;1"
</PRE>

<DT><CODE>-O net_buffer_length=#, where # &#60; 16M</CODE>
<DD>
When creating multi-row-insert statements (as with option
<CODE>--extended-insert</CODE> or <CODE>--opt</CODE>), <CODE>mysqldump</CODE> will create
rows up to <CODE>net_buffer_length</CODE> length. If you increase this
variable, you should also ensure that the <CODE>max_allowed_packet</CODE>
variable in the MySQL server is bigger than the
<CODE>net_buffer_length</CODE>.
</DL>

<P>
The most normal use of <CODE>mysqldump</CODE> is probably for making a backup of
whole databases.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Backup">4.4.1  データベースのバックアップ</A>」節参照.

</P>

<PRE>
mysqldump --opt database &#62; backup-file.sql
</PRE>

<P>
You can read this back into MySQL with:

</P>

<PRE>
mysql database &#60; backup-file.sql
</PRE>

<P>
or

</P>

<PRE>
mysql -e "source /patch-to-backup/backup-file.sql" database
</PRE>

<P>
However, it's also very useful to populate another MySQL server with
information from a database:

</P>

<PRE>
mysqldump --opt database | mysql --host=remote-host -C database
</PRE>

<P>
It is possible to dump several databases with one command:

</P>

<PRE>
mysqldump --databases database1 [database2 database3...] &#62; my_databases.sql
</PRE>

<P>
If all the databases are wanted, one can use:

</P>

<PRE>
mysqldump --all-databases &#62; all_databases.sql
</PRE>



<H3><A NAME="mysqlhotcopy" HREF="manual.ja_toc.html#mysqlhotcopy">4.8.6  mysqlhotcopy, Copying MySQL Databases and Tables</A></H3>

<P>
<A NAME="IDX772"></A>
<A NAME="IDX773"></A>
<A NAME="IDX774"></A>
<A NAME="IDX775"></A>

</P>
<P>
<CODE>mysqlhotcopy</CODE> is a perl script that uses <CODE>LOCK TABLES</CODE>,
<CODE>FLUSH TABLES</CODE> and <CODE>cp</CODE> or <CODE>scp</CODE> to quickly make a backup
of a database.  It's the fastest way to make a backup of the database,
of single tables but it can only be run on the same machine where the
database directories are.

</P>

<PRE>
mysqlhotcopy db_name [/path/to/new_directory]

mysqlhotcopy db_name_1 ... db_name_n /path/to/new_directory

mysqlhotcopy db_name./regex/
</PRE>

<P>
<CODE>mysqlhotcopy</CODE> supports the following options:

</P>
<DL COMPACT>

<DT><CODE>-?, --help</CODE>
<DD>
Display a help screen and exit
<DT><CODE>-u, --user=#</CODE>
<DD>
User for database login
<DT><CODE>-p, --password=#</CODE>
<DD>
Password to use when connecting to server
<DT><CODE>-P, --port=#</CODE>
<DD>
Port to use when connecting to local server
<DT><CODE>-S, --socket=#</CODE>
<DD>
Socket to use when connecting to local server
<DT><CODE>--allowold</CODE>
<DD>
Don't abort if target already exists (rename it _old)
<DT><CODE>--keepold</CODE>
<DD>
Don't delete previous (now renamed) target when done
<DT><CODE>--noindices</CODE>
<DD>
Don't include full index files in copy to make the backup smaller and faster
The indexes can later be reconstructed with <CODE>myisamchk -rq.</CODE>.
<DT><CODE>--method=#</CODE>
<DD>
Method for copy (<CODE>cp</CODE> or <CODE>scp</CODE>).
<DT><CODE>-q, --quiet</CODE>
<DD>
Be silent except for errors
<DT><CODE>--debug</CODE>
<DD>
Enable debug
<DT><CODE>-n, --dryrun</CODE>
<DD>
Report actions without doing them
<DT><CODE>--regexp=#</CODE>
<DD>
Copy all databases with names matching regexp
<DT><CODE>--suffix=#</CODE>
<DD>
Suffix for names of copied databases
<DT><CODE>--checkpoint=#</CODE>
<DD>
Insert checkpoint entry into specified db.table
<DT><CODE>--flushlog</CODE>
<DD>
Flush logs once all tables are locked.
<DT><CODE>--tmpdir=#</CODE>
<DD>
Temporary directory (instead of /tmp).
</DL>

<P>
You can use <CODE>perldoc mysqlhotcopy</CODE> to get a more complete
documentation for <CODE>mysqlhotcopy</CODE>.

</P>
<P>
<CODE>mysqlhotcopy</CODE> reads the groups <CODE>[client]</CODE> and  <CODE>[mysqlhotcopy]</CODE>
from the option files.

</P>
<P>
To be able to execute <CODE>mysqlhotcopy</CODE> you need write access to the
backup directory, <CODE>SELECT</CODE> privilege to the tables you are about to
copy and the MySQL <CODE>Reload</CODE> privilege (to be able to
execute <CODE>FLUSH TABLES</CODE>).

</P>



<H3><A NAME="mysqlimport" HREF="manual.ja_toc.html#mysqlimport">4.8.7  mysqlimport, テキストファイルからデータを取り込む</A></H3>

<P>
<A NAME="IDX776"></A>
<A NAME="IDX777"></A>
<A NAME="IDX778"></A>
<A NAME="IDX779"></A>
<A NAME="IDX780"></A>

</P>
<P>
<CODE>mysqlimport</CODE> は、<CODE>LOAD DATA INFILE</CODE> SQL 構文を、
コマンドラインインターフェースで提供します。
<CODE>mysqlimport</CODE> のオプションのほとんどが、
 <CODE>LOAD DATA INFILE</CODE> への同じオプションに対応します。
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.8  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>mysqlimport</CODE> の実行は以下のようにします:

</P>

<PRE>
shell&#62; mysqlimport [options] database textfile1 [textfile2....]
</PRE>

<P>
<CODE>mysqlimport</CODE> は、コマンドラインの引数に与えられたファイル名の拡張子を取り、
拡張子を取った後の名前を、ファイルの内容を取り込むテーブルの名前とします。
例えば、<TT>`patient.txt'</TT>, <TT>`patient.text'</TT>, <TT>`patient'</TT> という
ファイルは全て、<CODE>patient</CODE> とという名前のテーブルに取り込まれます。

</P>
<P>
<CODE>mysqlimport</CODE> は以下のオプションをサポートします:

</P>
<DL COMPACT>

<DT><CODE>-c, --columns=...</CODE>
<DD>
This option takes a comma-separated list of field names as an argument.
The field list is used to create a proper <CODE>LOAD DATA INFILE</CODE> command,
which is then passed to MySQL.  「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.8  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.

<DT><CODE>-C, --compress</CODE>
<DD>
クライアントとサーバーの両方が圧縮をサポートしているなら、
クライアント・サーバー間でやり取りされる全ての情報を圧縮します。

<DT><CODE>-#, --debug[=option_string]</CODE>
<DD>
プログラムのトレース(デバッグ)

<DT><CODE>-d, --delete</CODE>
<DD>
テキストファイルを取り込む前にテーブルを空にします。

<DT><CODE>--fields-terminated-by=...</CODE>
<DD>
<DT><CODE>--fields-enclosed-by=...</CODE>
<DD>
<DT><CODE>--fields-optionally-enclosed-by=...</CODE>
<DD>
<DT><CODE>--fields-escaped-by=...</CODE>
<DD>
<DT><CODE>--lines-terminated-by=...</CODE>
<DD>
これらのオプションは、<CODE>LOAD DATA INFILE</CODE> の対応する文節と同じ意味になります
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.8  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.

<DT><CODE>-f, --force</CODE>
<DD>
エラーを無視します。例えば、テキストファイルを取り込むテーブルがない場合、
残りのファイルの処理に移ります。 <CODE>--force</CODE> がなければ、
テーブルがなければ <CODE>mysqlimport</CODE> は終了します。

<DT><CODE>--help</CODE>
<DD>
ヘルプを表示して終了。

<DT><CODE>-h host_name, --host=host_name</CODE>
<DD>
名前を指定された <STRONG>MySQL</STRONG> サーバーにデータを取り入れます。
デフォルトでは <CODE>localhost</CODE>.

<DT><CODE>-i, --ignore</CODE>
<DD>
<CODE>--replace</CODE> オプションの説明を見てください。

<DT><CODE>-l, --lock-tables</CODE>
<DD>
それぞれのテキストファイルを処理する前に、書き込まれる
<STRONG>全ての</STRONG>テーブルをロックします。
これは確実に、すべてのテーブルをサーバ上で同期させます。

<DT><CODE>-L, --local</CODE>
<DD>
クライアントからの入力ファイルを読みます。
デフォルトでは、<CODE>localhost</CODE> に接続した場合、テキストファイルは
サーバー上にあると仮定されます。(<CODE>localhost</CODE> はデフォルト値)

<DT><CODE>-pyour_pass, --password[=your_pass]</CODE>
<DD>
サーバーに接続するときに使用するパスワード。
もし <SAMP>`=your_pass'</SAMP> のところにパスワードを書かなければ、
<CODE>mysqlimport</CODE> はパスワードのためのプロンプトをだします。

<DT><CODE>-P port_num, --port=port_num</CODE>
<DD>
ホストに接続するための TCP/IP ポート番号。
(これは <CODE>localhost</CODE> を除くホストへの接続に使用します。
<CODE>localhost</CODE> へは、UNIX ソケットを使用します。)

<DT><CODE>-r, --replace</CODE>
<DD>
<CODE>--replace</CODE> と <CODE>--ignore</CODE> オプションは、
入力されているレコードのユニークキーの値が、
既に存在しているレコードのユニークキーの値と同じ場合、
その入力されているデータの取り扱いを決定します。
もし <CODE>--replace</CODE> が指定されているなら、
既にあるレコードは新しく読まれたレコードに置き換えられます。
もし <CODE>--ignore</CODE> が指定されているなら、
入力された物は無視されます。
どちらのオプションも指定していない場合、
キーの値が重なっているとエラーを発し、
テキストファイルの残りの部分は無視されます。

<DT><CODE>-s, --silent</CODE>
<DD>
静粛モード。エラーだけ出力します。

<DT><CODE>-S /path/to/socket, --socket=/path/to/socket</CODE>
<DD>
<CODE>localhost</CODE> への接続時に使用するソケットファイルを指定します。

<DT><CODE>-u user_name, --user=user_name</CODE>
<DD>
サーバーの接続に使用する <STRONG>MySQL</STRONG> ユーザー名の指定。
デフォルトは、Unix のログイン名。

<DT><CODE>-v, --verbose</CODE>
<DD>
冗長モード。プログラムがしている事について多く出力します。

<DT><CODE>-V, --version</CODE>
<DD>
バージョンを表示して終了。
</DL>

<P>
Here is a sample run using <CODE>mysqlimport</CODE>:

</P>

<PRE>
$ mysql --version
mysql  Ver 9.33 Distrib 3.22.25, for pc-linux-gnu (i686)
$ uname -a
Linux xxx.com 2.2.5-15 #1 Mon Apr 19 22:21:09 EDT 1999 i586 unknown
$ mysql -e 'CREATE TABLE imptest(id INT, n VARCHAR(30))' test
$ ed
a
100     Max Sydow
101     Count Dracula
.
w imptest.txt
32
q
$ od -c imptest.txt
0000000   1   0   0  \t   M   a   x       S   y   d   o   w  \n   1   0
0000020   1  \t   C   o   u   n   t       D   r   a   c   u   l   a  \n
0000040
$ mysqlimport --local test imptest.txt
test.imptest: Records: 2  Deleted: 0  Skipped: 0  Warnings: 0
$ mysql -e 'SELECT * FROM imptest' test
+------+---------------+
| id   | n             |
+------+---------------+
|  100 | Max Sydow     |
|  101 | Count Dracula |
+------+---------------+
</PRE>



<H3><A NAME="mysqlshow" HREF="manual.ja_toc.html#mysqlshow">4.8.8  Showing Databases, Tables, and Columns</A></H3>

<P>
<A NAME="IDX781"></A>
<A NAME="IDX782"></A>
<A NAME="IDX783"></A>
<A NAME="IDX784"></A>
<A NAME="IDX785"></A>

</P>
<P>
<CODE>mysqlshow</CODE> can be used to quickly look at which databases exist,
their tables, and the table's columns.

</P>
<P>
With the <CODE>mysql</CODE> program you can get the same information with the
<CODE>SHOW</CODE> commands.   「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW">4.5.5  <CODE>SHOW</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>mysqlshow</CODE> is invoked like this:

</P>

<PRE>
shell&#62; mysqlshow [OPTIONS] [database [table [column]]]
</PRE>


<UL>
<LI>

If no database is given, all matching databases are shown.
<LI>

If no table is given, all matching tables in the database are shown.
<LI>

If no column is given, all matching columns and column types in the table
are shown.
</UL>

<P>
Note that in newer MySQL versions, you only see those
database/tables/columns for which you have some privileges.

</P>
<P>
If the last argument contains a shell or SQL wild-card (<CODE>*</CODE>, <CODE>?</CODE>,
<CODE>%</CODE> or <CODE>_</CODE>) then only what's matched by the wild card is shown.
This may cause some confusion when you try to display the columns for a
table with a <CODE>_</CODE> as in this case <CODE>mysqlshow</CODE> only shows you
the table names that match the pattern.  This is easily fixed by
adding an extra <CODE>%</CODE> last on the command line (as a separate
argument).

</P>



<H3><A NAME="perror" HREF="manual.ja_toc.html#perror">4.8.9  perror, Explaining Error Codes</A></H3>

<P>
<A NAME="IDX786"></A>
<A NAME="IDX787"></A>

</P>
<P>
<CODE>perror</CODE> can be used to print error message(s). <CODE>perror</CODE> can
be invoked like this:

</P>

<PRE>
shell&#62; perror [OPTIONS] [ERRORCODE [ERRORCODE...]]

For example:

shell&#62; perror 64 79
Error code  64:  Machine is not on the network
Error code  79:  Can not access a needed shared library
</PRE>

<P>
<CODE>perror</CODE> can be used to display a description for a system error
code, or an MyISAM/ISAM table handler error code. The error messages
are mostly system dependent.

</P>



<H3><A NAME="Batch_Commands" HREF="manual.ja_toc.html#Batch_Commands">4.8.10  How to Run SQL Commands from a Text File</A></H3>

<P>
The <CODE>mysql</CODE> client typically is used interactively, like this:

</P>

<PRE>
shell&#62; mysql database
</PRE>

<P>
However, it's also possible to put your SQL commands in a file and tell
<CODE>mysql</CODE> to read its input from that file.  To do so, create a text
file <TT>`text_file'</TT> that contains the commands you wish to execute.
Then invoke <CODE>mysql</CODE> as shown below:

</P>

<PRE>
shell&#62; mysql database &#60; text_file
</PRE>

<P>
You can also start your text file with a <CODE>USE db_name</CODE> statement.  In
this case, it is unnecessary to specify the database name on the command
line:

</P>

<PRE>
shell&#62; mysql &#60; text_file
</PRE>

<P>
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  MySQL Client-Side Scripts and Utilities</A>」節参照.

</P>



<H2><A NAME="Log_Files" HREF="manual.ja_toc.html#Log_Files">4.9  The MySQL Log Files</A></H2>

<P>
<A NAME="IDX788"></A>

</P>
<P>
MySQL has several different log files that can help you find
out what's going on inside <CODE>mysqld</CODE>:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>The error log </TD><TD> Problems encountering starting, running or stopping <CODE>mysqld</CODE>.
</TR NOSAVE>
<TR><TD>The isam log </TD><TD> Logs all changes to the ISAM tables. Used only for debugging the isam code.
</TR NOSAVE>
<TR><TD>The query log </TD><TD> Established connections and executed queries.
</TR NOSAVE>
<TR><TD>The update log </TD><TD> Deprecated: Stores all statements that changes data
</TR NOSAVE>
<TR><TD>The binary log </TD><TD> Stores all statements that changes something. Used also for replication
</TR NOSAVE>
<TR><TD>The slow log </TD><TD> Stores all queries that took more than <CODE>long_query_time</CODE> to execute or didn't use indexes.
</TR>
</TABLE>

<P>
All logs can be found in the <CODE>mysqld</CODE> data directory.  You can
force <CODE>mysqld</CODE> to reopen the log files (or in some cases
switch to a new log) by executing <CODE>FLUSH LOGS</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#FLUSH">4.5.3  <CODE>FLUSH</CODE> 構文</A>」節参照.

</P>



<H3><A NAME="Error_log" HREF="manual.ja_toc.html#Error_log">4.9.1  The Error Log</A></H3>

<P>
<CODE>mysqld</CODE> writes all errors to the stderr, which the
<CODE>safe_mysqld</CODE> script redirects to a file called
<CODE>'hostname'.err</CODE>.  (On Windows, <CODE>mysqld</CODE> writes this directly
to <TT>`\mysql\data\mysql.err'</TT>).

</P>
<P>
This contains information indicating when <CODE>mysqld</CODE> was started and
stopped and also any critical errors found when running.  If <CODE>mysqld</CODE>
dies unexpectedly and <CODE>safe_mysqld</CODE> needs to restart <CODE>mysqld</CODE>,
<CODE>safe_mysqld</CODE> will write a <CODE>restarted mysqld</CODE> row in this
file.  This log also holds a warning if <CODE>mysqld</CODE> notices a table
that needs to be automatically checked or repaired.

</P>
<P>
On some operating systems, the error log will contain a stack trace
for where <CODE>mysqld</CODE> died. This can be used to find out where
<CODE>mysqld</CODE> died.   「<A HREF="manual.ja_Porting.html#Using_stack_trace">G.1.4  Using a stack trace</A>」節参照.

</P>



<H3><A NAME="Query_log" HREF="manual.ja_toc.html#Query_log">4.9.2  The General Query Log</A></H3>

<P>
<A NAME="IDX789"></A>
<A NAME="IDX790"></A>

</P>
<P>
If you want to know what happens within <CODE>mysqld</CODE>, you should start
it with <CODE>--log[=file]</CODE>.  This will log all connections and queries
to the log file (by default named <TT>`'hostname'.log'</TT>).  This log can
be very useful when you suspect an error in a client and want to know
exactly what <CODE>mysqld</CODE> thought the client sent to it.

</P>
<P>
By default, the <CODE>mysql.server</CODE> script starts the MySQL
server with the <CODE>-l</CODE> option.  If you need better performance when
you start using MySQL in a production environment, you can
remove the <CODE>-l</CODE> option from <CODE>mysql.server</CODE> or change it to
<CODE>--log-bin</CODE>.

</P>
<P>
The entries in this log are written as <CODE>mysqld</CODE> receives the questions.
This may be different than the order in which the statements are executed.
This is in contrast to the update log and the binary log which are written
after the query is executed, but before any locks are released.

</P>



<H3><A NAME="Update_log" HREF="manual.ja_toc.html#Update_log">4.9.3  更新ログ</A></H3>

<P>
<A NAME="IDX791"></A>
<A NAME="IDX792"></A>

</P>
<P>
<STRONG>NOTE</STRONG>: The update log is replaced by the binary
log.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Binary_log">4.9.4  The Binary Update Log</A>」節参照.  With this you can do anything that you can do
with the update log.

</P>
<P>
<CODE>--log-update=file_name</CODE>オプションを使用して<CODE>mysqld</CODE>を起動すると、
データを更新した全てのSQLコマンドをログファイルに書きます。
もし file_name が与えられなかった場合は、ホスト名がデフォルトで使用されます。
もし file_name にディレクトリパスが含まれなかった場合は、
このファイルはデータディレクトリに書かれます。
もし file_name が拡張を持たなかったなら、<CODE>mysqld</CODE> は
<CODE>file_name.###</CODE> という形でログファイルを作成します。
このログファイルはデータディレクトリにかかれ、
その名前は <CODE>file_name.###</CODE> という形式の名前になっています。

</P>
<P>
<CODE>###</CODE> は <CODE>mysqladmin refresh</CODE> か <CODE>mysqladmin flush-logs</CODE> を実行す
る度に、
あるいは <CODE>FLUSH LOGS</CODE> 構文を実行したり、サーバーをリスタートする度に
自動的に増える数字です。

</P>
<P>
<STRONG>NOTE:</STRONG> For the above scheme to work, you should NOT create
your own files with the same filename as the update log + some extensions
that may be regarded as a number, in the directory used by the update log!

</P>
<P>
もし <CODE>--log</CODE> か <CODE>-l</CODE> オプションを使用した場合、ログファイルの名前は
<CODE>mysqld</CODE> は全部のログを <TT>`hostname.log'</TT> に書き出します。
この場合、リスタートやりフレッシュを行っても新しくログファイルを作りません。
(一度クローズして再度オープンします。)

</P>

<PRE>
mv hostname.log hostname-old.log
mysqladmin flush-logs
cp hostname-old.log to-backup-directory
rm hostname-old.log
</PRE>

<P>
更新ログは、実際に更新されたデータのステートメントだけを書くため、きびきびと動作
します。
<CODE>WHERE</CODE> を使用した <CODE>UPDATE</CODE> か <CODE>DELETE</CODE> で結果が得られなかった場合、
ログは書き出されません。
すでにセットされている値に、もう一度項目を更新するような <CODE>UPDATE</CODE> もスキッ
プされます。

</P>
<P>
The update logging is done immediately after a query completes but before
any locks are released or any commit is done. This ensures that the log
will be logged in the execution order.

</P>
<P>
ログファイルの更新に従ってデータベースを更新したい場合は、次を行います
(更新ログファイル名を <TT>`file_name.###'</TT> と仮定します):

</P>

<PRE>
shell&#62; ls -1 -t -r file_name.[0-9]* | xargs cat | mysql
</PRE>

<P>
<CODE>ls</CODE> は全てのログファイルを正しく並べるために使用しています。

</P>
<P>
これは、クラッシュ後にバックアップした状態まで戻りたい、あるいは、
バックアップした後からクラッシュするまでの間のデータの更新を行いたい、
そんな場合に使えます。

</P>



<H3><A NAME="Binary_log" HREF="manual.ja_toc.html#Binary_log">4.9.4  The Binary Update Log</A></H3>

<P>
<A NAME="IDX793"></A>
<A NAME="IDX794"></A>

</P>
<P>
The intention is that the binary log should replace the update log, so
we recommend you to switch to this log format as soon as possible!

</P>
<P>
The binary log contains all information that is available in the update
log in a more efficient format. It also contains information about how long
every query that updated the database took.

</P>
<P>
The binary log is also used when you are replicating a slave from a master.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Replication">4.10  MySQL のレプリケーション</A>」節参照.

</P>
<P>
When started with the <CODE>--log-bin[=file_name]</CODE> option, <CODE>mysqld</CODE>
writes a log file containing all SQL commands that update data. If no
file name is given, it defaults to the name of the host machine followed
by <CODE>-bin</CODE>. If file name is given, but it doesn't contain a path, the
file is written in the data directory.

</P>
<P>
If you supply an extension to <CODE>--log-bin=filename.extension</CODE>, the
extension will be silenty removed.

</P>
<P>
To the binary log filename <CODE>mysqld</CODE> will append an extension that is a
number that is incremented each time you execute <CODE>mysqladmin
refresh</CODE>, execute <CODE>mysqladmin flush-logs</CODE>, execute the <CODE>FLUSH LOGS</CODE>
statement or restart the server. 

</P>
<P>
You can use the following options to <CODE>mysqld</CODE> to affect what is logged
to the binary log:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>binlog-do-db=database_name</CODE> </TD><TD>
Tells the master it should log updates for the specified database, and
exclude all others not explicitly mentioned.
(Example: <CODE>binlog-do-db=some_database</CODE>)

</TR NOSAVE>
<TR><TD><CODE>binlog-ignore-db=database_name</CODE> </TD><TD>
Tells the master that updates to the given database should not be logged
to the binary log (Example: <CODE>binlog-ignore-db=some_database</CODE>)
</TR>
</TABLE>

<P>
To be able to know which different binary log files have been used,
<CODE>mysqld</CODE> will also create a binary log index file that
contains the name of all used binary log files. By default this has the
same name as the binary log file, with the extension <CODE>'.index'</CODE>.
You can change the name of the binary log index file with the
<CODE>--log-bin-index=[filename]</CODE> option.

</P>
<P>
If you are using replication, you should not delete old binary log
files until you are sure that no slave will ever need to use them.
One way to do this is to do <CODE>mysqladmin flush-logs</CODE> once a day and then
remove any logs that are more than 3 days old.

</P>
<P>
You can examine the binary log file with the <CODE>mysqlbinlog</CODE> command.
For example, you can update a MySQL server from the binary log
as follows:

</P>

<PRE>
mysqlbinlog log-file | mysql -h server_name
</PRE>

<P>
You can also use the <CODE>mysqlbinlog</CODE> program to read the binary log
directly from a remote MySQL server!

</P>
<P>
<CODE>mysqlbinlog --help</CODE> will give you more information of how to use
this program!

</P>
<P>
If you are using <CODE>BEGIN [WORK]</CODE> or <CODE>SET AUTOCOMMIT=0</CODE>, you must
use the MySQL binary log for backups instead of the old update log.

</P>
<P>
The binary logging is done immediately after a query completes but before
any locks are released or any commit is done. This ensures that the log
will be logged in the execution order.

</P>
<P>
All updates (<CODE>UPDATE</CODE>, <CODE>DELETE</CODE> or <CODE>INSERT</CODE>) that change
a transactional table (like BDB tables) are cached until a <CODE>COMMIT</CODE>.
Any updates to a non-transactional table are stored in the binary log at
once.  Every thread will, on start, allocate a buffer of
<CODE>binlog_cache_size</CODE> to buffer queries.  If a query is bigger than
this, the thread will open a temporary file to handle the bigger cache.
The temporary file will be deleted when the thread ends.

</P>
<P>
The <CODE>max_binlog_cache_size</CODE> can be used to restrict the total size used
to cache a multi-transaction query.

</P>
<P>
If you are using the update or binary log, concurrent inserts will
not work together with <CODE>CREATE ... INSERT</CODE> and <CODE>INSERT ... SELECT</CODE>.
This is to ensure that you can recreate an exact copy of your tables by
applying the log on a backup.

</P>



<H3><A NAME="Slow_query_log" HREF="manual.ja_toc.html#Slow_query_log">4.9.5  The Slow Query Log</A></H3>

<P>
<A NAME="IDX795"></A>
<A NAME="IDX796"></A>

</P>
<P>
When started with the <CODE>--log-slow-queries[=file_name]</CODE> option,
<CODE>mysqld</CODE> writes a log file containing all SQL commands that took
more than <CODE>long_query_time</CODE> to execute. The time to get the initial
table locks are not counted as execution time.

</P>
<P>
The slow query log is logged after the query is executed and after all
locks has been released. This may be different than the order in which
the statements are executed.

</P>
<P>
If no file name is given, it defaults to the name of the host machine
suffixed with <CODE>-slow.log</CODE>. If a filename is given, but doesn't
contain a path, the file is written in the data directory.

</P>
<P>
The slow query log can be used to find queries that take a long time to
execute and are thus candidates for optimization. With a large log, that
can become a difficult task. You can pipe the slow query log through the
<CODE>mysqldumpslow</CODE> command to get a summary of the queries which
appear in the log.

</P>
<P>
You are using <CODE>--log-long-format</CODE> then also queries that are not
using indexes are printed.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Command-line_options">4.1.1  mysqld コマンド行オプション</A>」節参照.

</P>



<H3><A NAME="Log_file_maintenance" HREF="manual.ja_toc.html#Log_file_maintenance">4.9.6  Log File Maintenance</A></H3>

<P>
<A NAME="IDX797"></A>
<A NAME="IDX798"></A>
<A NAME="IDX799"></A>

</P>
<P>
MySQL has a lot of log files which make it easy to see what is
going.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Log_Files">4.9  The MySQL Log Files</A>」節参照. One must however from time to time clean up
after <CODE>MysQL</CODE> to ensure that the logs don't take up too much disk
space.

</P>
<P>
<STRONG>MySQL</STRONG> をログファイルとともに使用する場合、
あなたは、時々古いログファイルを リムーブ/バックアップ し、
 <STRONG>MySQL</STRONG> に新しいファイルにログを取るように指示したいと思うことでしょう。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Backup">4.4.1  データベースのバックアップ</A>」節参照.

</P>
<P>
<CODE>Redhat</CODE> Linux においては、<CODE>mysql-log-rotate</CODE> スクリプトを
これに使用できます。 もし RPM ディストリビューションの <STRONG>MySQL</STRONG> を
インストールしたなら、このスクリプトは自動でインストールされているはずです。
Note that you should be careful with this if you are using
the log for replication!

</P>
<P>
他のシステムでは、自分自身で短いスクリプトをインストールします。
<CODE>cron</CODE> でログファイルを扱うようにします。

</P>
<P>
<CODE>mysqladmin flush-logs</CODE> コマンドか <CODE>FLUSH LOGS</CODE> SQL文で、
<STRONG>MySQL</STRONG> に新しいログファイルを使用させることが出来ます。
もしあなたが <STRONG>MySQL</STRONG> Version 3.21 を使用しているなら、
 <CODE>mysqladmin refresh</CODE> を使用しなくてはなりません。

</P>
<P>
上記のコマンドは、以下のように動作します：

</P>

<UL>
<LI>

If standard logging (<CODE>--log</CODE>) or slow query logging
(<CODE>--log-slow-queries</CODE>) is used, closes and reopens the log file.
(<TT>`mysql.log'</TT> and <TT>``hostname`-slow.log'</TT> as default).
<LI>

もし更新ログ (<CODE>--log-update</CODE>) を使用しているなら、
更新ログを閉じ、新しいログファイルを開きます。そのさい、
ログファイルについている番号は増えます。
</UL>

<P>
もし更新ログだけを使用しているなら、あなたは、ログを flush するだけでよくて、
その時、バックアップのため古い更新ログファイルを移動します。
 もし普通のログを使っていれば、あなたは以下のようにすることができます: 

</P>

<PRE>
shell&#62; cd mysql-data-directory
shell&#62; mv mysql.log mysql.old
shell&#62; mysqladmin flush-logs
</PRE>

<P>
こうしておいて、<TT>`mysql.old'</TT> をバックアップし削除します。

</P>



<H2><A NAME="Replication" HREF="manual.ja_toc.html#Replication">4.10  MySQL のレプリケーション</A></H2>

<P>
<A NAME="IDX800"></A>
<A NAME="IDX801"></A>
<A NAME="IDX802"></A>
<A NAME="IDX803"></A>

</P>

<P>
この章は MySQL の様々なレプリケーション機能を説明します。レプリケーション
で有効なオプションのリファレンスとしても役立ちます。レプリケーションの紹介
と、その実装方法を学べます。終りの方には、いくつかの FAQ と問題の説明とそ
の解決方法もあります。

</P>



<H3><A NAME="Replication_Intro" HREF="manual.ja_toc.html#Replication_Intro">4.10.1  紹介</A></H3>

<P>
一方通行レプリケーションは、堅牢さと速度の両方を増加させるために使用できま
す。堅牢さについて、２つのシステムを持つことができ、マスターで問題が発生し
た場合にバックアップに切り替えられます。速度の増加は、更新でないクエリの一
部をレプリカサーバに送ることで、成立します。もちろん、これは更新でないクエ
リが多い時にだけ働くのですが、通常はそうなります。

</P>
<P>
バージョン 3.23.15 から、<STRONG>MySQL</STRONG> はワンウェイ・レプリケーションを
サポートしました。 
1つのサーバーがマスターの役をつとめ，もう一方は、スレーブの役をつとめます。
1つのサーバーはマスターとして動くことも、他に対するスレーブとして動作することも
可能です。
マスターサーバーは update のバイナリログを保持しています( 「<A HREF="manual.ja_MySQL_Database_Administration.html#Binary_log">4.9.4  The Binary Update Log</A>」節参照.)。
また、インデックスファイルは、バイナリログのローテーションの切り出し記録を残すた
めに保持されます。
The slave, upon connecting, informs the master where it
left off since the last successfully propagated update, catches up on
the updates, and then blocks and waits for the master to notify it of
the new updates.

</P>
<P>
もしデータベースの複製を行なうなら、このデータベースに対する全ての更新は
マスター上で行なわなくてはならないことに注意！

</P>
<P>
レプリケーションを使用することのもう一つの恩恵は、マスターの代わりに、スレー
ブでバックアップを行なうことで、システムのライブバックアップを取ることがで
きるということです。 「<A HREF="manual.ja_MySQL_Database_Administration.html#Backup">4.4.1  データベースのバックアップ</A>」節参照。

</P>



<H3><A NAME="Replication_Implementation" HREF="manual.ja_toc.html#Replication_Implementation">4.10.2  レプリケーション実装概要</A></H3>

<P>
<A NAME="IDX804"></A>

</P>
<P>
MySQL レプリケーションは、サーバがデータベースへのすべての変更のトラックを
バイナリログ ( 「<A HREF="manual.ja_MySQL_Database_Administration.html#Binary_log">4.9.4  The Binary Update Log</A>」節参照) に保持し、スレーブサーバがデータのコピー
上で同じクエリを実行できるように、マスターサーバのバイナリログから保存され
たクエリを読み込むということを基本にします。

</P>
<P>
バイナリログは単に固定点(バイナリロギングを有効にした瞬間)からの記録である
ことを理解することが<STRONG>とても重要</STRONG>です。セットアップするすべてのスレー
ブで、マスターからすべてのデータのコピーが必要です。マスター上でバイナリロ
ギングを有効にした瞬間に存在していたように。
スレーブのデータがマスターに存在するデータと違う状態でスレーブを起動したならば、
<STRONG>バイナリログが開始されたときに</STRONG>、スレーブは失敗するでしょう。

</P>
<P>
<STRONG>MySQL</STRONG> の将来のバージョン(4.0)では、新しいスレーブサーバーのために、
(できる限り、)データのスナップショットを不要にするつもりでいます。
ロックをしなくても live backup を通してスレーブをセットアップできるように。
しかし現時点では、スナップショットを取る間は、マスターを
read lock を使って全ての書き込みから保護したり、
シャットダウンしたりする必要があります。

</P>
<P>
一旦スレーブが適切に構成され、実行していれば、スレーブは単にマスターに接続して、
更新が処理されるのを待つでしょう。
もしマスターがなくなったり、または、スレーブがマスターとの接続性を失えば、
スレーブは再接続できるまで <CODE>master-connect-retry</CODE> 秒毎に接続を試み、
そして、更新の監視を再開します。

</P>
<P>
各スレーブはそれが止まった場所のトラックを保持します。マスターサーバはいく
つのスレーブが存在し、どれがいつ更新を行なったかについての知識はありません。

</P>
<P>
次の節はマスター／スレーブ設定過程を詳細に説明します。

</P>



<H3><A NAME="Replication_HOWTO" HREF="manual.ja_toc.html#Replication_HOWTO">4.10.3  レプリケーションの設定方法</A></H3>

<P>
以下は、現在の MySQL サーバ上に完全なレプリケーションを設定する方法の簡単
な記述です。あなたがすべてのデータベースのレプリケーションを行ないたくて、
事前にレプリケーションを設定していないと仮定します。以下に示すステップを完
了するためには、マスターサーバを少しシャットダウンすることが必要になります。

</P>

<OL>
<LI>

マスターとスレーブに、最新の <STRONG>MySQL</STRONG> (同じバージョン) をインストールしま
す。

バージョン 3.23.29 以上を使用すること。
これより前のバージョンでは、バイナリログのフォーマットが違い、また、新しい
バージョンで直っているバグも含まれます。
最新のバージョンで確かめるまでは、バグレポートを送らないでください。

<LI>

マスター上に、レプリケーション用の特別なユーザーを登録します。
このユーザーには <CODE>FILE</CODE> 権限が必要です。全てのスレーブからこのユーザーで
接続できるようにします。
もしユーザーがレプリケーションのみ(推奨)を行なうなら、
他の権限は与える必要は有りません。

例えば、<CODE>repl</CODE> という名前のユーザー(マスターにアクセス可能なユーザー)を
作成するには、次のようにします：


<PRE>
GRANT FILE ON *.* TO repl@"%" IDENTIFIED BY '&#60;password&#62;';
</PRE>

<LI>

マスター上の <STRONG>MySQL</STRONG> を停止。


<PRE>
mysqladmin -u root -p&#60;password&#62; shutdown
</PRE>

<LI>

マスターサーバーにある全てのデータのスナップショットを取る。

(Unixでは) もっとも簡単な方法は <STRONG>tar</STRONG> を使用してデータディレクトリの
アーカーブを作成することです。
正確なデータディレクトリの場所はインストール方法に依存します。


<PRE>
tar -cvf /tmp/mysql-snapshot.tar /path/to/data-dir
</PRE>

Windows ユーザは WinZip か似たソフトウェアを使用してデータディレクトリのアー
カイブを作成することができます。

<LI>

マスターの <CODE>my.cnf</CODE> ファイル中の <CODE>[mysqld]</CODE> セクションに、
<CODE>log-bin</CODE> と <CODE>server-id=unique number</CODE> を加えます。
ここで指定するマスターの id 番号とスレーブの id 番号は違うものでなくてはなりませ
ん。

<CODE>server-id</CODE> は IPアドレスのような何かを考慮してください - これはレプ
リケーションパートナーのコミュニティ内で、サーバの実体を一意に識別します。


<PRE>
[mysqld]
log-bin
server-id=1
</PRE>

<LI>

マスター上の MySQL を再起動します。

<LI>

スレーブの <CODE>my.cnf</CODE> ファイルに、次を追加します：


<PRE>
master-host=&#60;hostname of the master&#62;
master-user=&#60;replication user name&#62;
master-password=&#60;replication user password&#62;
master-port=&#60;TCP/IP port for master&#62;
server-id=&#60;some unique number between 2 and 2^32-1&#62;
</PRE>

システムに関連したものは &#60;&#62; 内の値で置き換えてあります。

<CODE>server-id</CODE> には、サーバーそれぞれで違う番号にしなくてはなりません。
(同じ複製のグループ内で)。
もし server-id を指定しなければ、 <CODE>master-host</CODE> が無い場合には 1 に
なり、それ以外の場合には 2 に自動的になります。
マスターで <CODE>server-id</CODE> の記入漏れがあった場合、
マスターはスレーブからの接続を拒否します。
スレーブ上での記入漏れの場合には、スレーブはマスターへの接続を拒否します。
従って、<CODE>server-id</CODE> の省略はバイナリログのバックアップのためにだけ良
いことです。

<LI>

スレーブのデータディレクトリにデータのスナップショットをコピーします。
ファイルとディレクトリのユーザーとパーミッションは確実に正しいものに
してください。 これらのファイルに対して、 <STRONG>MySQL</STRONG> を実行している
アカウントで、読み書きできるようにする必要があります。

<LI>スレーブの再起動。

</OL>

<P>
上記を行なった後、スレーブはマスターに接続し、スナップショット以後の
更新をキャッチするはずです。

</P>
<P>
もしスレーブに <CODE>server-id</CODE> をセットし忘れた場合、エラーログファイルに
次のようなエラーが出るでしょう：

</P>

<PRE>
Warning: one should set server_id to a non-0 value if master_host is set.
The server will not act as a slave.
</PRE>

<P>
もしマスターにセットし忘れたなら、スレーブはマスターに接続できません。

</P>
<P>
もし何かの理由でスレーブが複製できなかったなら、スレーブ上のエラーログ
ファイルに、エラーメッセージが出るでしょう。

</P>
<P>
一度スレーブがレプリケーションを始めたなら、
エラーログファイルと同じディレクトリに
<CODE>master.info</CODE> ファイルを見ることができます。
<CODE>master.info</CODE> ファイルはスレーブに使用され、
これは、マスターのバイナリログのいくつまで処理したかを保持しています。
このファイルを消したり編集したりしては <STRONG>いけません</STRONG>。
(あなたがやろうとしていることが確実に分かるまでは)。
そういうやむを得ない場合には、
<CODE>CHANGE MASTER TO</CODE> コマンドの使用の方が良いです。

</P>



<H3><A NAME="Replication_Features" HREF="manual.ja_toc.html#Replication_Features">4.10.4  レプリケーション機能と既知の問題</A></H3>

<P>
<A NAME="IDX805"></A>
<A NAME="IDX806"></A>
<A NAME="IDX807"></A>

</P>
<P>
以下はサポートされていることとサポートされていないことの説明です:

</P>

<UL>
<LI>

レプリケーションは <CODE>AUTO_INCREMENT</CODE>,
<CODE>LAST_INSERT_ID</CODE>, <CODE>TIMESTAMP</CODE> 値を正しく扱います。

<LI>

更新中の <CODE>RAND()</CODE> はうまく複製できません。
<CODE>RAND()</CODE> での更新を複製する場合は、<CODE>RAND(some_non_rand_expr)</CODE> を
使用してください。
例えば、<CODE>UNIX_TIMESTAMP()</CODE> を <CODE>RAND()</CODE> の引数に使用するとか。

<LI>

マスターとスレーブは同じキャラクタ・セット (<CODE>--default-character-set</CODE>) を使
用しなくてはなりません。
もし違った場合、スレーブ上で  duplicate key errors が出るかもしれません。
これは、マスター上で一意のキーであったとしても、
違う キャラクタ・セット ではそうとはみなされない事があるからです。

<LI>

<CODE>LOAD DATA INFLIE</CODE> は更新の伝達時にマスターサーバ上にまだ存在していれ
ば、ただしく処理されます。<CODE>LOAD LOCAL DATA INFILE</CODE> はスキップされます。
<LI>

ユーザー変数を使用したクエリは、(まだ) replication-safe ではありません。

<LI>

<CODE>FLUSH</CODE> コマンドはバイナリログに記録されません。
もちろん、スレーブに複製されません。
これは <CODE>FLUSH</CODE> が通常は何もデータを変更しないからです。
しかし、仮に <CODE>MySQL</CODE> の権限データベースを複製していて、
<CODE>GRANT</CODE> 文ではなくて直接 <CODE>MySQL</CODE> 権限テーブルを変更した場合には、
権限を反映させるために、スレーブ上で <CODE>FLUSH PRIVILEGES</CODE> を行なわなくては
なりません。

<LI>

3.23.29 以降の一時テーブルは正しく複製されます。ただし、スレーブサーバ(ス
レーブスレッドではない)をシャットダウンした時に、いくつかの一時テーブルが
オープンされていて、続く更新で使用される場合を除きます。この問題を扱うため
に、スレーブをシャットダウンするには、<CODE>SLAVE STOP</CODE> を行ない、それから 
<CODE>Slave_open_temp_tables</CODE> 変数が 0 かどうかをチェックし、そして、
<CODE>mysqladmin shutdown</CODE> を発行してください。数値が 0 でない場合は、スレー
ブスレッドを <CODE>SLAVE START</CODE> で再起動して、次回に幸運かどうかを見てくだ
さい。cleaner solution は、バージョン 4.0 まで待つ必要があります。それ以前
のバージョンの一時テーブルは正しく複製されません - アップグレードするか 一
時テーブルでのすべてのクエリの前にクライアント上で <CODE>SET
SQL_LOG_BIN=0</CODE> の実行をお勧めします。
<LI>

<STRONG>MySQL</STRONG> は 1 つのマスターと複数のスレーブの構成のみをサポートします。
4.x では、何かが現在のマスターを故障させた場合に、自動的にマスターを変更す
る voting アルゴリズムを追加するでしょう。また、異なるスレーブに select ク
エリを送ることで、負荷分散を行なうための手助けとなるような 'エージェント
' プロセスも導入するでしょう。
<LI>

バージョン 3.23.26 から、<CODE>log-slave-updates</CODE> を有効にすることで、
マスターとスレーブの関係を輪っか状にすることが可能です。

しかし、多くのクエリは、この種のセットアップでは正しく動作しません。
違うシーケンス、違うサーバーで行なわれる更新によって引き起こる
潜在的な問題に対応するように、クライアントコードを注意して書かない限りは。

これは以下のようなセットアップを意味します：


<PRE>
A -&#62; B -&#62; C -&#62; A
</PRE>

このセットアップはテーブル間での更新に何も衝突が無い場合にのみ、動作します。
仮に A と C でデータを insert するとき、C にinsertするレコードのキーと
競合するようなレコードを A に insert してはいけません。
同じレコードを、２つのサーバーで更新すべきではありません。
もしそこで更新が適用される順番が重要なら。

ログのフォーマットは バージョン 3.23.36 で変更になりました。
3.23.36 以前のスレーブは、3.23.36 以上のログファイルを読むことができません。

<LI>

もしスレーブ上でクエリがエラーになると、スレーブのスレッドは停止され、
 <CODE>.err</CODE> ファイルにメッセージが現われます。
この場合、スレーブを手動で接続し、エラーの原因を修正し(例えば、テーブルが無いと
か)、
その後、 <CODE>SLAVE START</CODE> SQLコマンドを実行します
(このコマンドはバージョン 3.23.16 以上から)。
バージョン 3.23.15 までは、サーバーを再起動しなくてはなりません。

<LI>

もしマスターへの接続が失われた場合、スレーブは直ちにリトライし、
それでも失敗した場合は、 <CODE>master-connect-retry</CODE> 秒毎（デフォルトでは 60秒）に
リトライを繰り返します。
このため、マスターをシャットダウンして、しばらくあとに再起動することは安全
です。スレーブはネットワーク接続性の停止も処理できます。

<LI>

スレーブのシャットダウンも安全にできます。レプリケーションを止めた位置を
保存するようにしているからです。
きれいでないシャットダウンは問題を引き起こすでしょう。システムが落ちる前に
もしディスクキャッシュがシンクされない場合には特に。
もしあなたが良い UPS を持っているならば、安全性を高めることができるでしょう。

<LI>

もしマスターが非標準のポートを使用している場合、
<CODE>my.cnf</CODE> ファイルに <CODE>master-port</CODE> パラメターを書くことにより、
ポート番号を指定できます。

<LI>

バージョン 3.23.15 では、すべてのテーブルとデータベースが複製されます。バー
ジョン 3.23.16 からは <CODE>my.cnf</CODE> 内の <CODE>replicate-do-db</CODE> 命令でデー
タベースのセットに、または <CODE>replicate-ignore-db</CODE> でデータベースのセッ
トを除外して、複製を制限できます。注意: バージョン 3.23.23 になるまでは、
複製から除外されたデータベースで <CODE>LOAD DATA INFILE</CODE> を行なうと、正し
く扱えないというバグがありました。
<LI>

バージョン 3.23.16 から、マスター上で、<CODE>SET SQL_LOG_BIN = 0</CODE> でレプリケーシ
ョン(バイナリ) ログを止めることができます。
<CODE>SET SQL_LOG_BIN = 1</CODE> で再びログを採取することができます。
これを行なう場合には、process 権限が必要です。

<LI>

バージョン 3.23.19 から、何かがおかしくなって、残っている複製をクリーンナップし
て、まったくの最初から開始したいときのために、
 <CODE>FLUSH MASTER</CODE> と <CODE>FLUSH SLAVE</CODE> コマンドが用意されました。
バージョン 3.23.26 から、これらの名前を
<CODE>RESET MASTER</CODE> と <CODE>RESET SLAVE</CODE> に変更しました。
互換性のために、古い <CODE>FLUSH</CODE> もまだ動作します。
（訳注： このコマンドは、bin log を 001 からに強制してしまうため、
場合によっては複製をおかしくすることも有る。使用には注意。）

<LI>

バージョン 3.23.21 から、 <CODE>LOAD TABLE FROM MASTER</CODE> をネットワーク越しの
バックアップと、レプリケーションのイニシャライズに使用できるようになりました。
ただし、我々は
これに関して調査しているという、いくつかのバグ報告を受けているので、
これが安定するまでは、この機能はあくまでもテストとして使用することを
勧めます。

<LI>

バージョン 3.23.23 から、 <CODE>CHANGE MASTER TO</CODE> を使用して、
マスターを変更したりポジションを変更したりできるようになりました。

<LI>

バージョン 3.23.23 から、 <CODE>binlog-ignore-db</CODE> を使用して、
バイナリログを取らないデータベースを指定できるようになりました。

<LI>

バージョン 3.23.26 から、 <CODE>replicate-rewrite-db</CODE> を使用して、
マスター上のデータベースの名前を、スレーブ上では違う名前にするように、
スレーブに指示することができるようになりました。

<LI>

バージョン 3.23.28 から、
スレーブが実行している最中に、
古いログを取り去るために、 <CODE>PURGE MASTER LOGS TO 'log-name'</CODE> が使用できます。
</UL>



<H3><A NAME="Replication_Options" HREF="manual.ja_toc.html#Replication_Options">4.10.5  my.cnf 内のレプリケーションオプション</A></H3>

<P>
レプリケーションを使用する場合は、我々は  <STRONG>MySQL</STRONG> Version 3.23.30 以降を
推奨します。
これより古いバージョンでも動きますが、古い物はバグがあったり機能が無かったりしま
す。

</P>
<P>
マスターとスレーブの両方に、 <CODE>server-id</CODE> オプションが必要です。
これは一意のレプリケーションid をセットします。
マスター、スレーブそれぞれのために、一意な値を、1 から 2^32-1 までの間から
選ばねばなりません。
例: <CODE>server-id=3</CODE>

</P>
<P>
以下の表は、<STRONG>MASTER</STRONG> で使用できるオプションを示したものです:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >

<TR><TD><STRONG>オプション</STRONG> </TD><TD> <STRONG>説明</STRONG>
</TR NOSAVE>
<TR><TD><CODE>log-bin=filename</CODE> </TD><TD>
バイナリ update log のファイル名を指定します。
もしこれに拡張子を指定した場合には
(例えば <CODE>log-bin=/mysql/logs/replication.log</CODE> )、
バージョン 3.23.34 までの MySQL では、<CODE>FLUSH LOGS</CODE> を行なった場合に正しく
レプリケーションを行ないません。
この問題は バージョン 3.23.35 で修正されています。
もしこのような log 名を使用するならば、binlog においては <CODE>FLUSH LOGS</CODE> は無
視されます。
（訳注： これは、バージョン3.23.34までの話です。3.23.36 以上では動作します。）
log を clear するには、<CODE>FLUSH MASTER</CODE> の実行をします。
<CODE>FLUSH SLAVE</CODE> を全てのスレーブ上で実行することも忘れてはいけません。
バージョン 3.23.36 以上では、<CODE>RESET MASTER</CODE> と <CODE>RESET SLAVE</CODE> を使用す
べきです。
（訳注： <CODE>RESET</CODE> はログを本当に全部消してしまうので、注意が必要。）

</TR NOSAVE>
<TR><TD><CODE>log-bin-index=filename</CODE> </TD><TD>
<CODE>FLUSH LOGS</CODE> コマンドの実行のためには、どのログが現在使用されているもので、
どれがローテートされたもので、どの順番なのか、ということを知る必要があります。
この情報はバイナリログindexファイルに記述されます。
デフォルトでは `hostname`.index というファイルになります。
違う名前にしたい場合に、このオプションを使用します。

Example: <CODE>log-bin-index=db.index</CODE>.

</TR NOSAVE>
<TR><TD><CODE>sql-bin-update-same</CODE> </TD><TD>
設定されると、<CODE>SQL_LOG_BIN</CODE> に値を設定すると自動的に 
<CODE>SQL_LOG_UPDATE</CODE> を同じ値に設定します。逆も同様です。

</TR NOSAVE>
<TR><TD><CODE>binlog-do-db=database_name</CODE> </TD><TD>
現在のデータベースが 'database_name' の場合、バイナリログに更新をログすべ
きことをマスターに伝えます。他のすべてのデータベースは無視されます。注意
: これを使用する場合は、現在のデータベースでだけ更新を行なうことを確実にす
べきです。

Example: <CODE>binlog-do-db=some_database</CODE>.

</TR NOSAVE>
<TR><TD><CODE>binlog-ignore-db=database_name</CODE> </TD><TD>
現在のデータベースが 'database_name' である更新をバイナリログに格納すべき
でないと、マスターに伝えます。注意: これを使用する場合は、現在のデータベー
スでだけ更新を行なうことを確実にすべきです。

Example: <CODE>binlog-ignore-db=some_database</CODE>
</TR>
</TABLE>

<P>
次のテーブルは <STRONG>SLAVE</STRONG> に使用できるオプションです:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >

<TR><TD><STRONG>Option</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>master-host=host</CODE> </TD><TD>
マスタのホスト名か IP アドレス。
もし設定されていないと、スレーブはスタートしません。

Example: <CODE>master-host=db-master.mycompany.com</CODE>.

</TR NOSAVE>
<TR><TD><CODE>master-user=username</CODE> </TD><TD>
スレーブスレッドがマスターに接続する時に自分を認証するためのユーザ。ユーザ
は <CODE>FILE</CODE> 権限を持つ必要があります。マスターユーザが設定されない場合
は、<CODE>test</CODE> が適用されます。

Example: <CODE>master-user=scott</CODE>.

</TR NOSAVE>
<TR><TD><CODE>master-password=password</CODE> </TD><TD>
スレーブスレッドがマスターサーバに接続する時に認証するパスワード。設定され
ない場合は、空のパスワードが適用されます。

Example: <CODE>master-password=tiger</CODE>.

</TR NOSAVE>
<TR><TD><CODE>master-port=portnumber</CODE> </TD><TD>
マスターが listen しているポート。設定されない場合は、<CODE>MYSQL_PORT</CODE> の
コンパイル時の設定が適用されます。<CODE>configure</CODE> オプションで何もしてな
ければ、これは 3306 です。

Example: <CODE>master-port=3306</CODE>.

</TR NOSAVE>
<TR><TD><CODE>master-connect-retry=seconds</CODE> </TD><TD>
マスターが落ちたり接続が失われた場合に、スレーブスレッドがマスターへの接続
を再試行するまでに休眠する秒数。デフォルトは 60。

Example: <CODE>master-connect-retry=60</CODE>.

</TR NOSAVE>
<TR><TD><CODE>master-info-file=filename</CODE> </TD><TD>
複製処理がマスターのどこまで行なったかを覚えておくファイルの場所。デフォル
トはデータディレクトリの master.info です。Sasha: The only reason I see
for ever changing the default is the desire to be rebelious.

Example: <CODE>master-info-file=master.info</CODE>.

</TR NOSAVE>
<TR><TD><CODE>replicate-do-table=db_name.table_name</CODE> </TD><TD>
指定されたテーブルに複製を制限することをスレーブスレッドに伝えます。一つ以
上のテーブルを指定するには、この命令を複数回(各テーブルに１回ずつ)使用しま
す。This will work for cross-database updates, in contrast to
<CODE>replicate-do-db</CODE>.

Example: <CODE>replicate-do-table=some_db.some_table</CODE>.

</TR NOSAVE>
<TR><TD><CODE>replicate-ignore-table=db_name.table_name</CODE> </TD><TD>
指定されたテーブルを複製しないことをスレーブスレッドに伝えます。一つ以上の
テーブルを無視するように指定するには、この命令を複数回(各テーブルに１回ず
つ)使用します。This will work for cross-datbase updates, in contrast to
<CODE>replicate-ignore-db</CODE>.

Example: <CODE>replicate-ignore-table=db_name.some_table</CODE>.

</TR NOSAVE>
<TR><TD><CODE>replicate-wild-do-table=db_name.table_name</CODE> </TD><TD>
指定されたワイルドカードパターンに適合するテーブルに複製を制限することをス
レーブスレッドに伝えます。一つ以上のテーブルを指定するには、この命令を複数
回(各テーブルに１回ずつ)使用します。This will work for cross-database
updates.

Example: <CODE>replicate-wild-do-table=foo%.bar%</CODE> は foo で始まるすべての
データベースの bar で始まるテーブルだけに更新を複製します。

</TR NOSAVE>
<TR><TD><CODE>replicate-wild-ignore-table=db_name.table_name</CODE> </TD><TD>
与えられたワイルドカードパターンに適合するテーブルを複製しないことをスレー
ブスレッドに伝えます。一つ以上のテーブルを無視するように指定するには、この
命令を複数回(各テーブルに１回ずつ)使用します。This will work for
cross-database updates.

Example: <CODE>replicate-wild-ignore-table=foo%.bar%</CODE> は foo で始まるデー
タベースの bar で始まるテーブルを更新しません。

</TR NOSAVE>
<TR><TD><CODE>replicate-ignore-db=database_name</CODE> </TD><TD>
指定されたデータベースを複製しないことをスレーブスレッドに伝えます。一つ以
上のデータベースを無視するように指定するには、この命令を複数回(各データベー
スに１回ずつ)使用します。This option will not work if you use cross
database updates. If you need cross database updates to work, make sure
you have 3.23.28 or later, and use
<CODE>replicate-wild-ignore-table=db_name.%</CODE>

Example: <CODE>replicate-ignore-db=some_db</CODE>.

</TR NOSAVE>
<TR><TD><CODE>replicate-do-db=database_name</CODE> </TD><TD>

指定されたデータベースに複製を制限することをスレーブスレッドに伝えます。一
つ以上のデータベースを指定するには、この命令を複数回(各データベースに１回
ずつ)使用します。
Note that this will only work if you do
not use cross-database queries such as <CODE>UPDATE some_db.some_table
SET foo='bar'</CODE> while having selected a different or no database. If you
need cross database updates to work, make sure you have 3.23.28 or
later, and use <CODE>replicate-wild-do-table=db_name.%</CODE>

Example: <CODE>replicate-do-db=some_db</CODE>.

</TR NOSAVE>
<TR><TD><CODE>log-slave-updates</CODE> </TD><TD>
スレーブスレッドからの更新をバイナリログに記録するように、スレーブに告げます。
デフォルトは Off です。
もしスレーブのデイジーチェーン(daisy-chain)を考えているならば、
これを on にする必要があります。

</TR NOSAVE>
<TR><TD><CODE>replicate-rewrite-db=from_name-&#62;to_name</CODE> </TD><TD>
オリジナルと異なる名前のデータベースを更新します。

Example: <CODE>replicate-rewrite-db=master_db_name-&#62;slave_db_name</CODE>.

</TR NOSAVE>
<TR><TD><CODE>slave-skip-errors=err_code1,err_code2,..</CODE> </TD><TD>
Available only in 3.23.47 and later. Tells the slave thread to continue
replication when a query returns an error from the provided
list. Normally, replication will discontinue when an error is
encountered giving the user a chance to resolve the inconsistency in the
data manually. Do not use this option unless you fully understand why
you are getting the errors.  If there are no bugs in your 
replication setup and client programs, and no bugs in MySQL itself, you
should never get an abort with error.Indiscriminate use of this option
will result in slaves being hopelessly out of sync with the master and
you having no idea how the problem happened.

For error codes, you should use the numbers provided by the error message in
your slave error log and in the output of <CODE>SHOW SLAVE STATUS</CODE>. Full list
of error messages can be found in the source distribution in
<CODE>Docs/mysqld_error.txt</CODE>.

You can ( but should not) also use a very non-recommended value of <CODE>all</CODE>
which will ignore all error messages and keep barging along regardless.
Needless to say, if you use it, we make no promises regarding your data
integrity. Please do not complain if your data on the slave is not anywhere
close to what it is on the master in this case - you have been warned.

Example:

<CODE>slave-skip-errors=1062,1053</CODE> or <CODE>slave-skip-errors=all</CODE>

</TR NOSAVE>
<TR><TD><CODE>skip-slave-start</CODE> </TD><TD>
起動時にスレーブを開始しないようにスレーブサーバに伝えます。ユーザは後で 
<CODE>SLAVE START</CODE> で開始できます。

</TR NOSAVE>
<TR><TD><CODE>slave_read_timeout=#</CODE> </TD><TD>
読み込みがアボートする前にマスターからデータを待つ秒数。
</TR>
</TABLE>



<H3><A NAME="Replication_SQL" HREF="manual.ja_toc.html#Replication_SQL">4.10.6  レプリケーションに関連する SQL コマンド</A></H3>

<P>
<A NAME="IDX808"></A>
<A NAME="IDX809"></A>
<A NAME="IDX810"></A>

</P>
<P>
レプリケーションは SQL インタフェースを通じて制御できます。以下はコマンド
のサマリです:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Command</STRONG> </TD><TD> <STRONG>Description</STRONG>

</TR NOSAVE>
<TR><TD><CODE>SLAVE START</CODE>
 </TD><TD> スレーブスレッドを開始します。(スレーブ)

</TR NOSAVE>
<TR><TD><CODE>SLAVE STOP</CODE>
 </TD><TD> スレーブスレッドを停止します。(スレーブ)

</TR NOSAVE>
<TR><TD><CODE>SET SQL_LOG_BIN=0</CODE>
 </TD><TD> ユーザが process 権限を持っている場合に更新ログを無効にします。そう
でなければ無視されます。(マスター)

</TR NOSAVE>
<TR><TD><CODE>SET SQL_LOG_BIN=1</CODE>
 </TD><TD> ユーザが process 権限を持っている場合更新ロギングを再度有効にします。
そうでなければ無視されます。(マスター)

</TR NOSAVE>
<TR><TD><CODE>SET SQL_SLAVE_SKIP_COUNTER=n</CODE>
 </TD><TD> マスターからの次の <CODE>n</CODE> イベントをスキップします。スレーブスレッ
ドが実行していない場合にだけ正当です。そうでなければエラーになります。レプ
リケーションの不調からの復旧に有用です。

</TR NOSAVE>
<TR><TD><CODE>RESET MASTER</CODE>
 </TD><TD> インデックスファイルにリストされたすべてのバイナリログを削除し、
binlog インデックスファイルを空にリセットします。3.23.26 バージョンより前
では、<CODE>FLUSH MASTER</CODE> (Master)

</TR NOSAVE>
<TR><TD><CODE>RESET SLAVE</CODE>
 </TD><TD> スレーブにマスターログのレプリケーション位置を忘れさせます。
3.23.26 バージョンより前ではこのコマンドは <CODE>FLUSH SLAVE</CODE> と呼ばれてい
ました(Slave)

</TR NOSAVE>
<TR><TD><CODE>LOAD TABLE tblname FROM MASTER</CODE>
 </TD><TD> マスターからスレーブにテーブルのコピーをダウンロードします。
(Slave)

</TR NOSAVE>
<TR><TD><CODE>CHANGE MASTER TO master_def_list</CODE>
 </TD><TD> マスターパラメータを <CODE>master_def_list</CODE> に指定された値に変更し、
スレーブスレッドを再起動します。<CODE>master_def_list</CODE> はコンマで区切られ
た <CODE>master_def</CODE> のリストです。<CODE>master_def</CODE> は次のうちの一つです
: <CODE>MASTER_HOST</CODE>, <CODE>MASTER_USER</CODE>, <CODE>MASTER_PASSWORD</CODE>,
<CODE>MASTER_PORT</CODE>, <CODE>MASTER_CONNECT_RETRY</CODE>, <CODE>MASTER_LOG_FILE</CODE>,
<CODE>MASTER_LOG_POS</CODE>。Example:


<PRE>

CHANGE MASTER TO
  MASTER_HOST='master2.mycompany.com',
  MASTER_USER='replication',
  MASTER_PASSWORD='bigs3cret',
  MASTER_PORT=3306,
  MASTER_LOG_FILE='master2-bin.001',
  MASTER_LOG_POS=4;

</PRE>

変更する必要のある値だけを指定する必要があります。省略した値は同じ値を維持
します。ホストまたはポートを変更した時を除きます。この場合、スレーブは異な
るホストまたは異なるポートに接続しているのでマスターが異なっているとみなし
ます。従って、古いログと位置の値はどこにも該当しません。そして、自動的に空
文字列と 0 にそれぞれリセットされます (開始値)。注意: スレーブを再起動する
場合、最後のマスターを覚えています。これが望ましくない場合、
<TT>`master.info'</TT> ファイルを再起動前に削除すべきです。すると、スレーブは 
<CODE>my.cnf</CODE> またはコマンドラインからそのマスターを読み込みます。
(Slave)

</TR NOSAVE>
<TR><TD><CODE>SHOW MASTER STATUS</CODE> </TD><TD> マスターの binlog のステータス情報を提供します。(Master)

</TR NOSAVE>
<TR><TD><CODE>SHOW SLAVE STATUS</CODE> </TD><TD> スレーブスレッドの基本的なパラメータのステータス情報を提供します。(Slave)
</TR NOSAVE>
<TR><TD><CODE>SHOW MASTER LOGS</CODE> </TD><TD> バージョン 3.23.28 以降だけで有効です。マスター上のバイナリログをリストします。どれくらい行くべきかを見つけるためには、このコマンドを <CODE>PURGE MASTER LOGS TO</CODE> よりも先に使用すべきです。

</TR NOSAVE>
<TR><TD><CODE>PURGE MASTER LOGS TO 'logname'</CODE>
 </TD><TD> バージョン 3.23.28 からの機能。
index ファイルに書かれているログファイルのうち、
指定されたログよりも前のログファイルを全て消します。
index ファイルのリストからもエントリを消します。
そして、指定されたログを一番最初の物とします。
例えば：


<PRE>
PURGE MASTER LOGS TO 'mysql-bin.010'
</PRE>

（訳注： このコマンドの場合、mysql-bin.001 ～ mysql-bin.009 までの
ファイルは消され、mysql.index ファイルの中身は、mysql-bin.010 のみ、
記述される状態になるということ。）

削除しようとしているログの一つを現在読み込み中の実行中スレーブがある場合、
このコマンドは何も行なわず、エラーで失敗します。しかし、休眠中のスレーブが
あり、それが読もうとしているログの一つをパージしてしまうと、スレーブは複製
できなくなります。このコマンドはスレーブが複製中には安全に実行できます - 
それらを停止する必要はありません。

最初に <CODE>SHOW SLAVE STATUS</CODE> で、どのログが on になっているか、すべての
スレーブをチェックする必要があります。それからマスターで <CODE>SHOW
MASTER LOGS</CODE> でログのリストを行ない、すべてのスレーブに共通の最も古いログ
を見つけ(すべてのスレーブが最新の場合、リストの最後のログになります)、削除
しようとするすべてのログをバックアップし、目的のログをパージします。

</TR>
</TABLE>



<H3><A NAME="Replication_FAQ" HREF="manual.ja_toc.html#Replication_FAQ">4.10.7  Replication FAQ</A></H3>

<P>
<A NAME="IDX811"></A>
<STRONG>Q</STRONG>: Why do I sometimes see more than one <CODE>Binlog_Dump</CODE> thread on
the master after I have restarted the slave?

</P>
<P>
<STRONG>A</STRONG>: <CODE>Binlog_Dump</CODE> is a continuous process that is handled by the
server in the following way:

</P>

<UL>
<LI>

Catch up on the updates.
<LI>

Once there are no more updates left, go into <CODE>pthread_cond_wait()</CODE>,
from which we can be awakened either by an update or a kill.
<LI>

On wake up, check the reason. If we are not supposed to die, continue
the <CODE>Binlog_dump</CODE> loop.
<LI>

If there is some fatal error, such as detecting a dead client,
terminate the loop.
</UL>

<P>
So if the slave thread stops on the slave, the corresponding
<CODE>Binlog_Dump</CODE> thread on the master will not notice it until after
at least one update to the master (or a kill), which is needed to wake
it up from <CODE>pthread_cond_wait()</CODE>.  In the meantime, the slave
could have opened another connection, which resulted in another
<CODE>Binlog_Dump</CODE> thread.

</P>
<P>
The above problem should not be present in Version 3.23.26 and later
versions.  In Version 3.23.26 we added <CODE>server-id</CODE> to each
replication server, and now all the old zombie threads are killed on the
master when a new replication thread connects from the same slave

</P>
<P>
<STRONG>Q</STRONG>: replication log をどうやってローテートするの?

</P>
<P>
<STRONG>A</STRONG>: バージョン 3.23.28 からでは、<CODE>PURGE MASTER LOGS TO</CODE> コマンド
を使用するべきです。 実行前には、どのログが消せれるか確認し、場合によっては
バックアップを取っておきます。
In earlier versions the process is much more
painful, and cannot be safely done without stopping all the slaves in
the case that you plan to re-use log names. You will need to stop the
slave threads, edit the binary log index file, delete all the old logs,
restart the master, start slave threads, and then remove the old log files.

</P>

<P>
<STRONG>Q</STRONG>: How do I upgrade on a hot replication setup?

</P>
<P>
<STRONG>A</STRONG>: If you are upgrading  pre-3.23.26 versions, you should just
lock the master tables, let the slave catch up, then run <CODE>FLUSH
MASTER</CODE> on the master, and <CODE>FLUSH SLAVE</CODE> on the slave to reset the
logs, then restart new versions of the master and the slave. Note that
the slave can stay down for some time - since the master is logging
all the updates, the slave will be able to catch up once it is up and
can connect.

</P>
<P>
After 3.23.26, we have locked the replication protocol for modifications, so
you can upgrade masters and slave on the fly to a newer 3.23 version and you
can have different versions of MySQL running on the slave and the
master, as long as they are both newer than 3.23.26. 

</P>
<P>
<A NAME="IDX812"></A>
<STRONG>Q</STRONG>: What issues should I be aware of when setting up two-way
replication?

</P>
<P>
<STRONG>A</STRONG>: MySQL replication currently does not support any
locking protocol between master and slave to guarantee the atomicity of
a distributed (cross-server) update. In in other words, it is possible
for client A to make an update to  co-master 1, and in the meantime,
before it propagates to co-master 2, client B could make an update to
co-master 2 that will make the update of client A work differently than
it did on co-master 1. Thus when the update of client A will make it
to co-master 2, it will produce  tables that will be different than
what you have on co-master 1, even after all the updates from co-master
2 have also propagated. So you should not co-chain two servers in a
two-way replication relationship, unless you are sure that you updates
can safely happen in any order, or unless you take care of mis-ordered
updates somehow in the client code.

</P>

<P>
You must also realize that two-way replication actually does not improve
performance very much, if at all, as far as updates are concerned. Both
servers need to do the same amount of updates each, as you would have
one server do. The only difference is that there will be a little less
lock contention, because the updates originating on another server will
be serialized in one slave thread. This benefit, though, might be
offset by network delays.

</P>
<P>
<A NAME="IDX813"></A>
<A NAME="IDX814"></A>
<STRONG>Q</STRONG>: How can I use replication to improve performance of my system?

</P>
<P>
<STRONG>A</STRONG>: You should set up one server as the master, and direct all
writes to it, and configure as many slaves as you have the money and
rackspace for, distributing the reads among the master and the slaves.
You can also start the slaves with <CODE>--skip-bdb</CODE>,
<CODE>--low-priority-updates</CODE> and <CODE>--delay-key-write-for-all-tables</CODE>
to get speed improvements for the slave.  In this case the slave will
use non-transactional <CODE>MyISAM</CODE> tables instead of <CODE>BDB</CODE> tables
to get more speed.

</P>
<P>
<STRONG>Q</STRONG>: What should I do to prepare my client code to use
performance-enhancing replication?

</P>
<P>
<STRONG>A</STRONG>:
If the part of your code that is responsible for database access has
been properly abstracted/modularized, converting it to run with the
replicated setup should be very smooth and easy - just change the
implementation of your database access to read from some slave or the
master, and to always write to the master. If your code does not have
this level of abstraction,
setting up a replicated system will give you an opportunity/motivation
to it clean up.
 You should start by creating a wrapper library
/module with the following functions:

</P>

<UL>
<LI>

<CODE>safe_writer_connect()</CODE>
<LI>

<CODE>safe_reader_connect()</CODE>
<LI>

<CODE>safe_reader_query()</CODE>
<LI>

<CODE>safe_writer_query()</CODE>
</UL>

<P>
<CODE>safe_</CODE> means that the function will take care of handling all
the error conditions.

</P>
<P>
You should then convert your client code to use the wrapper library.
It may be a painful and scary process at first, but it will pay off in
the long run. All applications that follow the above pattern will be
able to take advantage of one-master/many slaves solution.  The
code will be a lot easier to maintain, and adding troubleshooting
options will be trivial. You will just need to modify one or two
functions, for example, to log how long each query took, or which
query, among your many thousands, gave you an error. If you have written a lot of code already,
you may want to automate the conversion task by using Monty's
<CODE>replace</CODE> utility, which comes with the standard distribution of
MySQL, or just write your own Perl script. Hopefully, your
code follows some recognizable pattern. If not, then you are probably
better off re-writing it anyway, or at least going through and manually
beating it into a pattern.

</P>
<P>
Note that, of course, you can use different names for the
functions. What is important is having unified interface for connecting
for reads, connecting for writes, doing a read, and doing a write.

</P>

<P>
<STRONG>Q</STRONG>: When and how much can MySQL replication improve the performance
of my system?

</P>
<P>
<STRONG>A</STRONG>: MySQL replication is most beneficial for a system
with frequent reads and not so frequent writes. In theory, by using a
one master/many slaves setup you can scale by adding more slaves until
you either run out of network bandwidth, or your update
load grows to the point
that the master cannot handle it.

</P>
<P>
In order to determine how many slaves you can get before the added
benefits begin to level out, and how much you can improve performance
of your site, you need to know your query patterns, and empirically
 (by benchmarking) determine the relationship between the throughput
on reads (reads per second, or <CODE>max_reads</CODE>) and on writes
<CODE>max_writes</CODE>) on a typical master and a typical slave. The
example below will show you a rather simplified calculation of what you
can get with replication for our imagined system.

</P>
<P>
Let's say our system load consists of 10% writes and 90% reads, and we
have determined that <CODE>max_reads</CODE> = 1200 - 2 * <CODE>max_writes</CODE>,
or in other words, our system can do 1200 reads per second with no
writes, our average write is twice as slow as average read,
and the relationship is
linear. Let us suppose that our master and slave are of the same
capacity, and we have N slaves and 1 master. Then we have for each
server (master or slave):

</P>
<P>
<CODE>reads = 1200 - 2 * writes</CODE> (from bencmarks)

</P>
<P>
<CODE>reads = 9* writes / (N + 1) </CODE> (reads split, but writes go
to all servers)

</P>
<P>
<CODE>9*writes/(N+1) + 2 * writes = 1200</CODE>

</P>
<P>
<CODE>writes = 1200/(2 + 9/(N+1)</CODE>

</P>
<P>
So if N = 0, which means we have no replication, our system can handle
1200/11, about 109 writes per second (which means we will have 9 times
as many reads due to the nature of our application).

</P>
<P>
If N = 1, we can get up to 184 writes per second.

</P>
<P>
If N = 8, we get up to 400.

</P>
<P>
If N = 17, 480 writes.

</P>
<P>
Eventually as N approaches infinity (and our budget negative infinity),
we can get very close to 600 writes per second, increasing system
throughput about 5.5 times. However, with only 8 servers, we increased
it almost 4 times already.

</P>
<P>
Note that our computations assumed infinite network bandwidth, and
neglected several other factors that could turn out to be significant on
your system. In many cases, you may not be able to make a computation
similar to the one above that will accurately predict what will happen
on your system if you add N replication slaves. However, answering the
following questions should help you decided whether and how much, if at
all, the replication will improve the performance of your system:

</P>

<UL>
<LI>

What is the read/write ratio on your system?
<LI>

How much more write load can one server handle if you reduce the reads?
<LI>

How many slaves do you have bandwidth for on your network?
</UL>

<P>
<STRONG>Q</STRONG>: 冗長性/高可用性を提供するようにレプリケーションを使用するには？

</P>
<P>
<STRONG>A</STRONG>: 現在有効な機能で、マスターとスレーブ(またはいくつかのスレーブ
達)をセットアップする必要があります。マスターが生きているかどうかを監視し、
アプリケーションとマスターのスレーブに失敗時に変更を指示するスクリプトを書
きます。以下はいくつかの提案です:

</P>

<UL>
<LI>

<CODE>CHANGE MASTER TO</CODE> コマンドを使用して、スレーブにマスターを変更するよ
うに通知します。
<LI>

マスターの場所が通知されるアプリケーションを保持する良い方法は、マスターの
エントリをダイナミック DNS によって持つことです。<STRONG>bind</STRONG> では 
<CODE>nsupdate</CODE> を使って DNS を動的に更新できます。
<LI>

スレーブを <CODE>log-bin</CODE> オプション付きで <CODE>log-slave-updates</CODE> 無しで
実行すべきです。この方法で、<CODE>STOP SLAVE</CODE>; <CODE>RESET MASTER</CODE>、他のス
レーブ上で <CODE>CHANGE MASTER TO</CODE> を実行すると、すぐにスレーブがマスター
になるように準備ができます。
It will also help you catch
spurious updates that may happen because of misconfiguration of the
slave (ideally, you want to configure access rights so that no client
can update the slave, except for the slave thread) combined with the
bugs in your client programs (they should never update the slave
directly).

</UL>

<P>
我々は現在自動マスター選択システムを MySQL に統合するように働いていますが、
準備ができるまでは、あなた自身のモニタリングツールを作成する必要があります。

</P>



<H3><A NAME="Replication_Problems" HREF="manual.ja_toc.html#Replication_Problems">4.10.8  Troubleshooting Replication</A></H3>

<P>
If you have followed the instructions, and your replication setup is not
working, first eliminate the user error factor by checking the following:

</P>

<UL>
<LI>

Is the master logging to the binary log? Check with <CODE>SHOW MASTER STATUS</CODE>.
If it is, <CODE>Position</CODE> will be non-zero. If not, verify that you have
given the master <CODE>log-bin</CODE> option and have set <CODE>server-id</CODE>.
<LI>

Is the slave running? Check with <CODE>SHOW SLAVE STATUS</CODE>. The answer is found
in <CODE>Slave_running</CODE> column. If not, verify slave options and check the
error log for messages.
<LI>

If the slave is running, did it establish connection with the master? Do
<CODE>SHOW PROCESSLIST</CODE>, find the thread with <CODE>system user</CODE> value in
<CODE>User</CODE> column and <CODE>none</CODE> in the <CODE>Host</CODE> column, and check the
<CODE>State</CODE> column. If it says <CODE>connecting to master</CODE>, verify the
privileges for the replication user on the master, master host name, your
DNS setup, whether the master is actually running, whether it is reachable
from the slave, and if all that seems ok, read the error logs.
<LI>

If the slave was running, but then stopped, look at SHOW SLAVE STATUS
output and check the error logs. It usually
happens when some query that succeeded on the master fails on the slave. This
should never happen if you have taken a proper snapshot of the master, and
never modify the data on the slave outside of the slave thread. If it does,
it is a bug, read below on how to report it.
<LI>

If a query on that succeeded on the master refuses to run on the slave, and
a full database resync ( the proper thing to do ) does not seem feasible,
try the following:

<UL>
<LI>

First see if there is some stray record in the way. Understand how it got
there, then delete it and run <CODE>SLAVE START</CODE>
<LI>

If the above does not work or does not apply, try to understand if it would
be safe to make the update manually ( if needed) and then ignore the next
query from the master.
<LI>

If you have decided you can skip the next query, do
<CODE>SET SQL_SLAVE_SKIP_COUNTER=1; SLAVE START;</CODE> to skip a query that
does not use auto_increment, or last_insert_id  or
<CODE>SET SQL_SLAVE_SKIP_COUNTER=2; SLAVE START;</CODE> otherwise. The reason
auto_increment/last_insert_id queries are different is that they take
two events in the binary log of the master.

<LI>

If you are sure the slave started out perfectly in sync with the master,
and no one has updated  the tables involved outside of slave thread,
report the bug, so
you will not have to do the above tricks again.
</UL>

<LI>

Make sure you are not running into an old bug by upgrading to the most recent
version.
<LI>

If all else fails, read the error logs. If they are big,
<CODE>grep -i slave /path/to/your-log.err</CODE> on the slave. There is no
generic pattern to search for on the master, as the only errors it logs
are general system errors - if it can, it will send the error to the slave
when things go wrong.
</UL>

<P>
When you have determined that there is no user error involved, and replication
still either does not work at all or is unstable, it is time to start working
on a bug report. We need to get as much info as possible from you to be able
to track down the bug. Please do spend some time and effort preparing a good
bug report. Ideally, we would like to have a test case in the format found in
<CODE>mysql-test/t/rpl*</CODE> directory of the source tree. If you submit a test
case like that, you can expect a patch within a day or two in most cases,
although, of course, you mileage may vary depending on a number of factors.

</P>
<P>
Second best option is a just program with easily configurable connection
arguments for the master and the slave that will demonstrate the problem on our
systems. You can write one in Perl or in C, depending on which language you
know better.

</P>
<P>
If you have one of the above ways to demonstrate the bug, use
<CODE>mysqlbug</CODE> to prepare a bug report and send it to
<a HREF="mailto:bugs@lists.mysql.com">bugs@lists.mysql.com</a>. If you have a phantom - a problem that
does occur but you cannot duplicate "at will":

</P>

<UL>
<LI>

Verify that there is no user error involved. For example, if you update the
slave outside of the slave thread, the data will be out of sync, and you can
have unique key violations on updates, in which case the slave thread will
stop and wait for you to clean up the tables manually to bring them in sync.
<LI>

Run slave with <CODE>log-slave-updates</CODE> and <CODE>log-bin</CODE> - this will keep
a log of all updates on the slave.
<LI>

Save all evidence before resetting the replication. If we have no or only
sketchy information, it would take us a while to track down the problem. The
evidence you should collect is:

<UL>
<LI>

All binary logs on the master
<LI>

All binary log on the slave
<LI>

The output of <CODE>SHOW MASTER STATUS</CODE> on the master at the time
you have discovered the problem
<LI>

The output of <CODE>SHOW SLAVE STATUS</CODE> on the master at the time
you have discovered the problem
<LI>

Error logs on the master and on the slave
</UL>

<LI>

Use <CODE>mysqlbinlog</CODE> to examine the binary logs. The following should
be helpful
to find the trouble query, for example:

<PRE>
mysqlbinlog -j pos_from_slave_status /path/to/log_from_slave_status | head
</PRE>

</UL>

<P>
Once you have collected the evidence on the phantom problem, try hard to
isolate it into a separate test case first. Then report the problem to
<a HREF="mailto:bugs@lists.mysql.com">bugs@lists.mysql.com</a> with as much info as possible.

</P>

<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Tutorial.html">previous</A>, <A HREF="manual.ja_MySQL_Optimization.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
