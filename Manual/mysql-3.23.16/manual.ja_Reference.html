<html><head>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 22 May 2000 -->

  <title>MySQL Reference Manual for version 3.23.16-alpha. - 7  MySQL 言語リファレンス</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  </head>
  <body bgcolor="#FFFFFF" text="#000000" link="#101090" vlink="#7030B0">
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_Privilege_system.html">previous</a>, <a href="manual.ja_Table_types.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
<p></p><hr><p>


</p><h1><a name="Reference" href="manual.ja_toc.html#Reference">7  <strong>MySQL</strong> 言語リファレンス</a></h1>

<p>
<a name="IDX149"></a>
<a name="IDX150"></a>


</p><h2><a name="Literals" href="manual.ja_toc.html#Literals">7.1  リテラル:文字列と数値をどのように書くか？</a></h2>



<h3><a name="String_syntax" href="manual.ja_toc.html#String_syntax">7.1.1  文字列</a></h3>

<p>
文字列は文字の並びです。引用符(<samp>`''</samp>)または二重引用符(<samp>`"'</samp>)で括ら
れます(後者は ANSI モードで実行していない場合のみ)。 例：

</p>

<pre>'a string'
"another string"
</pre>

<p>
文字列中では、いくつかのシーケンスは特別な意味を持ちます。これらのシーケ
ンスのそれぞれは<em>エスケープ文字</em>として知られるバックスラッシュ
(<samp>`\'</samp>)で始まります。<strong>MySQL</strong> は次のエスケープシーケンスを認識
します。

</p>
<dl compact="">

<dt><code>\0</code>
</dt><dd>
<a name="IDX151"></a>
 <a name="IDX152"></a>
 
ASCII 0 (<code>NUL</code>) 文字。

<a name="IDX153"></a>
<a name="IDX154"></a>
</dd><dt><code>\n</code>
</dt><dd>
改行文字。

<a name="IDX155"></a>
<a name="IDX156"></a>
</dd><dt><code>\t</code>
</dt><dd>
タブ文字。

<a name="IDX157"></a>
<a name="IDX158"></a>
<a name="IDX159"></a>
</dd><dt><code>\r</code>
</dt><dd>
リターン文字。

<a name="IDX160"></a>
<a name="IDX161"></a>
</dd><dt><code>\b</code>
</dt><dd>
バックスペース文字。

<a name="IDX162"></a>
<a name="IDX163"></a>
</dd><dt><code>\'</code>
</dt><dd>
引用符(<samp>`''</samp>)。

<a name="IDX164"></a>
<a name="IDX165"></a>
</dd><dt><code>\"</code>
</dt><dd>
二重引用符(<samp>`"'</samp>)。

<a name="IDX166"></a>
<a name="IDX167"></a>
</dd><dt><code>\\</code>
</dt><dd>
バックスラッシュ(<samp>`\'</samp>)文字。

<a name="IDX168"></a>
<a name="IDX169"></a>
</dd><dt><code>\%</code>
</dt><dd>
<samp>`%'</samp> 文字。これは <samp>`%'</samp> がワイルドカード文字として解釈される文脈
で、<samp>`%'</samp> そのものを検索するために使用されます。

<a name="IDX170"></a>
<a name="IDX171"></a>
</dd><dt><code>\_</code>
</dt><dd>
<code>_</code> 文字。これは <samp>`_'</samp> がワイルドカード文字として解釈される文脈
で、<code>_</code> そのものを検索するために使用されます。
</dd></dl>

<p>
いくつかの文字列文脈で <samp>`\%'</samp> または <samp>`\_'</samp> を使用すると、これらは文
字列 <samp>`%'</samp> と <samp>`_'</samp> ではなく、<samp>`\%'</samp> と <samp>`\_'</samp> を返します。

</p>
<p>
文字列中に引用符を含める方法はいくつかあります:

</p>

<ul>
<li>

<samp>`''</samp> で括られる文字列中の <samp>`''</samp> は <samp>`'''</samp> として書くことができ
ます。

</li><li>

<samp>`"'</samp> で括られる文字列中の <samp>`"'</samp> は <samp>`""'</samp> として書くことができ
ます。

</li><li>

引用符の前にエスケープ文字 (<samp>`\'</samp>) を置くことができます。

</li><li>

<samp>`"'</samp> で括られた文字列中の <samp>`''</samp> は特別扱いの必要はなく、二重にし
たり、エスケープする必要はありません。同じように、<samp>`''</samp> で括られた文
字列中の <samp>`"'</samp> は特別扱いの必要はありません。
</li></ul>

<p>
次の <code>SELECT</code> ステートメントは、クォートとエスケープがどのように働
くかを示します:

</p>

<pre>mysql&gt; SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+

mysql&gt; SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+

mysql&gt; SELECT "This\nIs\nFour\nlines";
+--------------------+
| This
Is
Four
lines |
+--------------------+
</pre>

<p>
<a name="IDX172"></a>

</p>
<p>
バイナリデータを <code>BLOB</code> フィールドに挿入したい場合、次の文字をエスケープ
シーケンスで表す必要があります:
</p><dl compact="">

<dt><code>NUL</code>
</dt><dd>
ASCII 0。<samp>`\0'</samp> (バックスラッシュと ASCII <samp>`0'</samp> 文字) に置き換える
べきです。
</dd><dt><code>\</code>
</dt><dd>
ASCII 92, バックスラッシュ。<samp>`\\'</samp> と表記してください。
</dd><dt><code>'</code>
</dt><dd>
ASCII 39, 引用符。<samp>`\''</samp> と表記してください。
</dd><dt><code>"</code>
</dt><dd>
ASCII 34, 二重引用符。<samp>`\"'</samp> と表記してください。
</dd></dl>

<p>
<a name="IDX173"></a>
<a name="IDX174"></a>
<a name="IDX175"></a>
<a name="IDX176"></a>
C コードを書く場合、<code>INSERT</code> 節で文字をエスケープするために、C API 
関数 <code>mysql_escape_string()</code> を使用できます。 「<a href="manual.ja_Clients.html#C_API_function_overview">22.3  C API 関数概要</a>」節参照.  Perl では、<code>DBI</code> パッケージの <code>quote</code> メソッドを使
用して、特殊文字を適当なエスケープシーケンスに変換できます。 「<a href="manual.ja_Clients.html#Perl_DBI_Class">22.5.1.1  The <code>DBI</code> interface</a>」節参照.

</p>
<p>
上記の特殊文字のどれかを含む可能性のある全ての文字列について、エスケープ
関数を使用すべきです！

</p>


<h3><a name="Number_syntax" href="manual.ja_toc.html#Number_syntax">7.1.2  数値</a></h3>

<p>
整数は数字の並びで表現されます。
浮動小数点は <samp>`.'</samp> で小数を分割します。
どちらの型も負数を表すために <samp>`-'</samp> を前につけます。

</p>
<p>
正当な数値の例:

</p>

<pre>1221
0
-32
</pre>

<p>
有効な浮動小数点の例：

</p>

<pre>294.42
-32032.6809e+10
148.00
</pre>

<p>
整数が浮動小数点の文脈で使用されるかもしれません； この場合、浮動小数点に
変換されます。

</p>
<p>
<a name="IDX177"></a>


</p><h3><a name="Hexadecimal_values" href="manual.ja_toc.html#Hexadecimal_values">7.1.3  16進法の値</a></h3>

<p>
<strong>MySQL</strong> は16進法の値をサポートします。
数値の文脈では、これらは整数(64ビット精度)のように振る舞います。
文字列の文脈では、hexの桁のそれぞれのペアが文字に変換された
バイナリー文字のように振る舞います。

</p>

<pre>mysql&gt; SELECT 0xa+0
       -&gt; 10
mysql&gt; select 0x5061756c;
       -&gt; Paul
</pre>

<p>
16進数表記は、ODBC において BLOB の値を与えるためにしばしば使用されます。

</p>
<p>
<a name="IDX178"></a>


</p><h3><a name="NULL_values" href="manual.ja_toc.html#NULL_values">7.1.4  <code>NULL</code> 値</a></h3>

<p>
<code>NULL</code> は ``no data'' を意味し、数値型の <code>0</code> や文字列型の空文
字列とは異なることに注意してください。
 「<a href="manual.ja_Problems.html#Problems_with_NULL">20.15  <code>NULL</code> 値での問題</a>」節参照.

</p>
<p>
テキストファイルの読み込みや書き出し時に、<code>NULL</code> は <code>\N</code> で
表現されます。 (<code>LOAD DATA INFILE</code>, <code>SELECT ... INTO OUTFILE</code>).
 「<a href="manual.ja_Reference.html#LOAD_DATA">7.18  <code>LOAD DATA INFILE</code>構文</a>」節参照.


</p><h3><a name="Legal_names" href="manual.ja_toc.html#Legal_names">7.1.5  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</a></h3>

<p>
データベース名、テーブル名、インデックス名、フィールド名、エイリアス名は
<strong>MySQL</strong> では全て同じ規則に基づきます:

</p>
<p>
<a name="IDX179"></a>
<a name="IDX180"></a>
<a name="IDX181"></a>
注意: 規則は <strong>MySQL</strong> 3.23.6 で変更されました。それは識別子(データベー
ス名、テーブル名、フィールド名)の <code>`</code> でのクォートを導入した時です
(ANSI モードで実行する場合は、<code>"</code> も識別子をクォートするために働きま
す)。

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>識別子</strong> </td><td> <strong>最大長</strong> </td><td> <strong>許される文字</strong>
</td></tr>
<tr><td>データベース </td><td> 64 </td><td> ディレクトリ名として許されるすべての文字。<code>/</code> を除く。
</td></tr>
<tr><td>テーブル </td><td> 64 </td><td> ファイル名として許されるすべての文字。<code>/</code> と <code>.</code> を除く。
</td></tr>
<tr><td>フィールド </td><td> 64 </td><td> すべての文字
</td></tr>
<tr><td>エイリアス </td><td> 255 </td><td> すべての文字
</td></tr>
</tbody></table>

<p>
注意: 上記に加え、識別子内には ASCII(0) と ASCII(255) を持てません。

</p>
<p>
注意: 識別子が制限された単語であったり特殊文字を含む場合は、それを使用する
時には常に <code>`</code> でクォートする必要があります:

</p>

<pre>SELECT * from `select` where `select`.id &gt; 100;
</pre>

<p>
<strong>MySQL</strong> の前のバージョンでは、名前の規則は次に従います:

</p>

<ul>
<li>

名前は、現在の文字セットのアルファベットと数字文字から成り、<samp>`_'</samp> と 
<samp>`$'</samp> も含みます。デフォルト文字セットは ISO-8859-1 Latin1 ですが、
これは <code>mysqld</code> に <code>--default-character-set</code> オプションを
与えることで変更できます. (3.23.14 以上の場合のみ。
それ以前のバージョンでは <strong>MySQL</strong> 再コンパイルが必要)
 「<a href="manual.ja_Server.html#Character_sets">10.1.1  データとソートに使用されるキャラクターセット</a>」節参照.

</li><li>

名前は、名前として正しい任意の文字で始めることができます。特に、名前は数
字で始めることができます(これは他の多くのシステムと異なります！)。しかし、
数字<em>だけ</em>の名前にする事はできません。

</li><li>

名前の中に <samp>`.'</samp> 文字を使用することはできません。フィールドを参照できるよう
に形式を拡張するために使用されるためです(後述)。
</li></ul>

<p>
<code>1e</code> のような名前は使用しないことを勧めます。<code>1e+1</code> のような式が
あいまいだからです。これは、式 <code>1e + 1</code> として、または数値 
<code>1e+1</code> として解釈されます。

</p>
<p>
<strong>MySQL</strong> では次の形式のいずれかを使用してフィールドを参照できます:

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フィールドの参照方法</strong> </td><td> <strong>意味</strong>
</td></tr>
<tr><td><code>col_name</code> </td><td> クエリ中で使用されるテーブル内に存在している <code>col_name</code> という名前のフィールド
</td></tr>
<tr><td><code>tbl_name.col_name</code> </td><td> 現在のデータベースのテーブル <code>tbl_name</code> 内のフィールド <code>col_name</code>
</td></tr>
<tr><td><code>db_name.tbl_name.col_name</code> </td><td> データベース <code>db_name</code>
のテーブル <code>tbl_name</code> 内のフィールド <code>col_name</code>。この形式は 3.22 以降
で有効です。
</td></tr>
<tr><td>
<code>`column_name`</code> </td><td> キーワードであったり特殊文字を含むフィールド。
</td></tr>
</tbody></table>

<p>
参照が曖昧でないならば、ステートメント中のフィールド参照の前に <code>tbl_name</code> 
または <code>db_name.tbl_name</code> を記述する必要はありません。例えば、テー
ブル <code>t1</code> と <code>t2</code> がそれぞれフィールド <code>c</code> を含み、<code>t1</code> と 
<code>t2</code> の両方を使用する <code>SELECT</code> ステートメントで <code>c</code> を取
り出すとします。この場合、<code>c</code> はステートメントで使用されるテーブル
間で唯一でないので曖昧です。そのため、<code>t1.c</code> または <code>t2.c</code> と
記述するこよによりどちらのテーブルを意味するかを示す必要があります。同様
に、データベース <code>db1</code> のテーブル <code>t</code> とデータベース 
<code>db2</code> のテーブル <code>t</code> から取り出す場合、これらのテーブル中の項
目は、<code>db1.t.col_name</code> と <code>db2.t.col_name</code> として参照する必要
があります。

</p>
<p>
<a name="IDX182"></a>
<a name="IDX183"></a>
構文 <code>.tbl_name</code> は現在のデータベース内のテーブル <code>tbl_name</code> 
を意味します。この構文はいくつかの ODBC が <samp>`.'</samp> 文字をテーブル名の前
に置くために許されています。

</p>


<h4><a name="Name_case_sensitivity" href="manual.ja_toc.html#Name_case_sensitivity">7.1.5.1  名前のケース依存性</a></h4>
<p>
<a name="IDX184"></a>
<a name="IDX185"></a>
<a name="IDX186"></a>
<a name="IDX187"></a>
<a name="IDX188"></a>
<a name="IDX189"></a>
<a name="IDX190"></a>
<a name="IDX191"></a>

</p>
<p>
<strong>MySQL</strong> では、データベースとテーブルは、ディレクトリと
そのディレクトリ中のファイルに対応します。そのため、下で動作するオペレー
ティングシステムのケース依存性は、データベースとテーブル名のケース依存性を決定します。
データベース名とテーブル名は Unix ではケース依存で、Win32 ではケース非依
存です。

</p>
<p>
<strong>注意:</strong> Win32 ではデータベース名とファイル名はケース非依存ですが、
同じクエリ内で、データベースやテーブルを異なるケースを使用して参照すべき
ではありません。
以下のクエリは動きません。なぜなら <code>my_table</code> と <code>MY_TABLE</code> の両方を
参照しているからです：

</p>

<pre>mysql&gt; SELECT * FROM my_table WHERE MY_TABLE.col=1;
</pre>

<p>
フィールド名は全ての場合でケース非依存です。

</p>
<p>
テーブルの別名はケース依存です。
以下のクエリは動きません。なぜなら <code>a</code> と <code>A</code> のエイリアスを両方
参照しているからです：

</p>

<pre>mysql&gt; SELECT col_name FROM tbl_name AS a
           WHERE a.col_name = 1 OR A.col_name = 2;
</pre>

<p>
フィールドのエイリアス名はケース非依存です。

</p>



<h2><a name="Variables" href="manual.ja_toc.html#Variables">7.2  ユーザー変数</a></h2>

<p>
<strong>MySQL</strong> は、<code>@variablename</code> 構文でスレッド固有の変数をサポー
トします。変数名は現在の文字セットのアルファベットと数字、それに 
<samp>`_'</samp>、<samp>`$'</samp>、<samp>`.'</samp> 文字からなります。デフォルト文字セットは 
ISO-8859-1 Latin1 です。
これは <code>mysqld</code> に <code>--default-character-set</code> オプションを
与えることで変更できます. (3.23.14 以上の場合のみ。
それ以前のバージョンでは <strong>MySQL</strong> 再コンパイルが必要)
 「<a href="manual.ja_Server.html#Character_sets">10.1.1  データとソートに使用されるキャラクターセット</a>」節参照。

</p>
<p>
変数は初期化する必要はありません。デフォルトでは <code>NULL</code> であり、整数
値、実数値、文字列値を格納できます。すべてのスレッド変数は、スレッドが終了
すると自動的に解放されます。

</p>
<p>
<code>SET</code> 構文で変数を設定できます:

</p>

<pre>SET @variable= { integer expression | real expression | string expression }
[,@variable= ...].
</pre>

<p>
<code>@variable:=expr</code> 構文で、式中で変数を設定することも可能です:

</p>

<pre>select @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;
+----------------------+------+------+------+
| @t1:=(@t2:=1)+@t3:=4 | @t1  | @t2  | @t3  |
+----------------------+------+------+------+
|                    5 |    5 |    1 |    4 |
+----------------------+------+------+------+
</pre>

<p>
(我々は <code>:=</code> 構文を使用する必要がありました。<code>=</code> は比較のために
予約されていたからです。)

</p>
<p>
ユーザー変数は式が許される場所で使用できます。注意: これは現在、
<code>SELECT</code> ステートメントの <code>LIMIT</code> 節、<code>LOAD DATA</code> ステート
メントの <code>IGNORE number LINES</code> 節のように、数値が明示的に要求される文
脈での使用を含みません。

</p>
<p>
<strong>注意:</strong> <code>SELECT</code> ステートメントでは、それぞれの式はクライアン
トに送られた時にだけ評価されます。これは、<code>SELECT</code> 部で設定された変数
を必要とする式を参照する <code>HAVING</code>, <code>GROUP BY</code>, <code>ORDER BY</code> 
節ができないことを意味します。例えば、次のステートメントは期待通りには動作
しません:

</p>

<pre>SELECT (@aa:=id) AS a, (@aa+3) AS b FROM table_name HAVING b=5;
</pre>

<p>
この理由は、<code>@aa</code> が現在のレコードの値ではなく、前に受け取ったレコー
ドの <code>id</code> の値になるからです。

</p>


<h2><a name="Column_types" href="manual.ja_toc.html#Column_types">7.3  フィールド型</a></h2>

<p>
<strong>MySQL</strong>は多くのフィールド型をサポートしており、それらは３つのカテゴリにグループ化されます: 数値型、日付及び時間型、そして文字列(文字)型。
この章ではまず、利用できる型の概要から始まり、それから各カテゴリの各フィールド型の所要記憶容量の要約と、型の属性についてのより詳細な情報を提供します。
概要は意図的に簡潔にまとめています。値として指定できる書式のようなフィールド型固有の付加情報は、詳細の説明部にて調べて下さい。

</p>
<p>
<strong>MySQL</strong>でサポートされるフィールド型は以下に示す通りです。後に続く文字の意味は説明のために使われます:

</p>
<dl compact="">

<dt><code>M</code>
</dt><dd>
最大表示サイズを意味します。最大の表示桁数は 255.

</dd><dt><code>D</code>
</dt><dd>
浮動小数点数型に適用され、小数点以下の桁数を表します。
最大の値は 30 ですが、これは <code>M</code>-2 より大きくなってはいけません。
</dd></dl>

<p>
中カッコ(<samp>`['</samp>及び<samp>`]'</samp>)は型定義の一部であり、それがオプションであることを表します。

</p>
<p>
<a name="IDX192"></a>

</p>

<p>
もしあるフィールドに <code>ZEROFILL</code> を指定した場合、
 <strong>MySQL</strong> は自動で <code>UNSIGNED</code> 属性をそのフィールドに
追加します。

</p>
<dl compact="">

<dt><code>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</code>
</dt><dd>
<a name="IDX193"></a>
 

とても小さい整数。符号つきの範囲は <code>-128</code>～<code>127</code>。符号なしの範囲は <code>0</code>～<code>255</code>。

<a name="IDX194"></a>
</dd><dt><code>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</code>
</dt><dd>
小さい整数。符号つきの範囲は <code>-32768</code>～<code>32767</code>。符号なしの範囲は <code>0</code>～<code>65535</code>。

<a name="IDX195"></a>
</dd><dt><code>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</code>
</dt><dd>
中間の整数。符号ありの範囲は <code>-8388608</code>～<code>8388607</code>。符号なしの範囲は <code>0</code>～<code>16777215</code>

<a name="IDX196"></a>
</dd><dt><code>INT[(M)] [UNSIGNED] [ZEROFILL]</code>
</dt><dd>
通常の整数。符号ありの範囲は <code>-2147483648</code>～<code>2147483647</code>。符号なしの範囲は <code>0</code>～<code>4294967295</code>

<a name="IDX197"></a>
</dd><dt><code>INTEGER[(M)] [UNSIGNED] [ZEROFILL]</code>
</dt><dd>
これは、<code>INT</code>の同義語です。

<a name="IDX198"></a>
</dd><dt><code>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</code>
</dt><dd>
大きい整数。符号ありの範囲は <code>-9223372036854775808</code>～<code>9223372036854775807</code>。
符号なしの範囲は <code>0</code>～<code>18446744073709551615</code>。
全ての演算は符合付き <code>BIGINT</code> または <code>DOUBLE</code> で行われるため、
符合無しの <code>9223372036854775807</code> (63 bits) よりも大きな整数を
ビット関数以外で使用すべきではありません！
<code>-</code>、<code>+</code>及び<code>*</code>は、両方の引数が<code>INTEGER</code>値の時、<code>BIGINT</code>演算を使うことに注意して下さい！これは、２つの大きな整数のかけ算を行なう(又は整数を返す関数の結果が大きな整数である)時、結果が<code>9223372036854775807</code>よりも大きい場合に予期しない結果を受け取ることがあるということを意味しています。

<a name="IDX199"></a>
</dd><dt><code>FLOAT(precision) [ZEROFILL]</code>
</dt><dd>
浮動小数点数。符号なしにはできません。単精度浮動小数点数では 
<code>precision</code> が <code>&lt;=24</code> で、倍精度浮動小数点数では 25～53 の間です。
これらの型は次で述べる<code>FLOAT</code>や<code>DOUBLE</code>型に似ています。
<code>FLOAT(X)</code>は、<code>FLOAT</code>及び<code>DOUBLE</code>型に一致する同じ範囲を持っていますが、
表示サイズや小数点以下桁数が定義されません。

<strong>MySQL</strong> 3.23 では、これは正しい浮動小数点です。前の 
<strong>MySQL</strong> バージョンでは, <code>FLOAT(precision)</code> は常に小数部は2桁で
した。

<a name="IDX200"></a>
<a name="IDX201"></a>
この構文は ODBC 互換です。

<a name="IDX202"></a>
<a name="IDX203"></a>
</dd><dt><code>FLOAT[(M,D)] [ZEROFILL]</code>
</dt><dd>
小さい浮動小数点数。符号なしにはできません。
範囲は <code>-3.402823466E+38</code>～<code>-1.175494351E-38</code>、 <code>0</code>、
<code>1.175494351E-38</code>～<code>3.402823466E+38</code>です。
M は表示幅で D は小数部桁数です。引数が無いか引数が24以下の <code>FLOAT</code> 
は単精度浮動小数点数を意味します。

<a name="IDX204"></a>
<a name="IDX205"></a>
</dd><dt><code>DOUBLE[(M,D)] [ZEROFILL]</code>
</dt><dd>
通常の浮動小数点数。符号なしにはできません。
範囲は <code>-1.7976931348623157E+308</code>～<code>-2.2250738585072014E-308</code>、 <code>0</code>、<code>2.2250738585072014E-308</code>～<code>1.7976931348623157E+308</code>です。
M は表示幅で D は小数部桁数です。引数が無いか <code>DOUBLE</code> か、25 &lt;= X
&lt;= 53 である <code>FLOAT(X)</code> は倍精度浮動小数点数を意味します。

<a name="IDX206"></a>
<a name="IDX207"></a>
</dd><dt><code>DOUBLE PRECISION[(M,D)] [ZEROFILL]</code>
</dt><dd>
</dd><dt><code>REAL[(M,D)] [ZEROFILL]</code>
</dt><dd>
これらは<code>DOUBLE</code>の同義語です。

<a name="IDX208"></a>
</dd><dt><code>DECIMAL[(M[,D])] [ZEROFILL]</code>
</dt><dd>
パック無し浮動小数点数。符号なしにはできません。<code>CHAR</code>フィールドのように振舞います。`パック無し'は、数値が文字列として格納されることを意味し、数値のそれぞれの桁、小数点、及び負数での<samp>`-'</samp>符号に１文字使用します。
<code>D</code>が0の時、値は小数点や小数部を持ちません。<code>DECIMAL</code>値の最大範囲は<code>DOUBLE</code>と同じですが、実際の範囲は<code>DECIMAL</code>フィールドに与えられた<code>M</code>及び<code>D</code>の選択に強制されます。

<code>D</code> を省略した場合は 0 に設定されいます。<code>M</code> を省略した場合は 
10 に設定されます。

<strong>MySQL</strong> 3.22 では、 <code>M</code> 引数は符号や小数点を含みます。 

<a name="IDX209"></a>
</dd><dt><code>NUMERIC(M,D) [ZEROFILL]</code>
</dt><dd>
<code>DECIMAL</code>と同じ。

<a name="IDX210"></a>
</dd><dt><code>DATE</code>
</dt><dd>
日付。サポートされる範囲は<code>'1000-01-01'</code>から<code>'9999-12-31'</code>まで。
<strong>MySQL</strong>は<code>'YYYY-MM-DD'</code>の書式で<code>DATE</code>値を表示しますが、<code>DATE</code>フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。

<a name="IDX211"></a>
</dd><dt><code>DATETIME</code>
</dt><dd>
日付と時刻の組み合わせ。サポートされる範囲は<code>'1000-01-01 00:00:00'</code>～<code>'9999-12-31 23:59:59'</code>です。<strong>MySQL</strong>は<code>DATETIME</code>値を<code>'YYYY-MM-DD HH:MM:SS'</code>という書式で表示しますが、<code>DATETIME</code>フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。

<a name="IDX212"></a>
</dd><dt><code>TIMESTAMP[(M)]</code>
</dt><dd>
タイムスタンプ。範囲は<code>'1970-01-01 00:00:00'</code>～<code>2106</code>年末までです。<strong>MySQL</strong>は<code>TIMESTAMP</code>値を<code>YYYYMMDDHHMMSS</code>、<code>YYMMDDHHMMSS</code>、<code>YYYYMMDD</code>又は<code>YYMMDD</code>という書式で表示し、それは<code>M</code>に<code>14</code>(もしくは誤ってそれ以上の値を指定した時)、<code>12</code>、<code>8</code>又は<code>6</code>のいずれが指定されたかに依存します。しかしながら<code>TIMESTAMP</code>フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。
<code>TIMESTAMP</code>フィールドは、最後に操作された時刻を自動的に設定するので、<code>INSERT</code>や<code>UPDATE</code>操作の時刻を記録するのに役立ちます。
<code>NULL</code>値を与えることによっても、現在時刻を設定できます。
 「<a href="manual.ja_Reference.html#Date_and_time_types">7.3.6  日付と時間の型</a>」節参照。

<a name="IDX213"></a>
</dd><dt><code>TIME</code>
</dt><dd>
時間。範囲は<code>'-838:59:59'</code>～<code>'838:59:59'</code>です。
<strong>MySQL</strong>は<code>TIME</code>値を<code>'HH:MM:SS'</code>という書式で表示しますが、<code>TIME</code>フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。

<a name="IDX214"></a>
</dd><dt><code>YEAR[(2|4)]</code>
</dt><dd>
年。2桁または4桁形式(デフォルトは4桁)。許される値は、4桁形式では 
<code>1901</code>～<code>2155</code>, <code>0000</code> で、2桁形式(70～69)では 1970～2069 
です。<strong>MySQL</strong> は <code>YEAR</code> 値を <code>YYYY</code> 形式で表示しますが、
<code>YEAR</code> フィールドへの値の割り当ては文字列と数字のどちらでも使用できま
す。(<code>YEAR</code> は <strong>MySQL</strong> 3.22 での新しい型です。)

<a name="IDX215"></a>
<a name="IDX216"></a>
<a name="IDX217"></a>
<a name="IDX218"></a>
</dd><dt><code>[NATIONAL] CHAR(M) [BINARY]</code>
</dt><dd>
固定長文字列で、格納時には必ず指定された長さまで右側に空白を埋めます。
<code>M</code>の範囲は 1 から 255 文字です。後続の空白は値の取り出し時に削除され
ます。<code>BINARY</code> キーワードが与えられない場合、<code>CHAR</code> 値のソートと
比較は、デフォルト文字セットに従ってケース非依存の方法で行なわれます。

<code>NATIONAL CHAR</code> (短い形式は <code>NCHAR</code>) は、ANSI SQL で、CHAR フィー
ルドがデフォルト文字セットを使用することを定義する方法です。これは 
<code>MySQL</code> ではデフォルトです。

<code>CHAR</code> は <code>CHARACTER</code> の略記です。

<strong>MySQL</strong> は <code>CHAR(0)</code> 型のフィールドの生成を許します。これは主
に、実際にはもう値が使われていないフィールドが存在することに依存しているよ
うないくつかの古いアプリケーションに対応する必要がある時に便利です。２つの
値だけを取ることができるフィールドを必要とする時にもとても良いことです:
<code>NOT NULL</code> として定義されていない <code>CHAR(0)</code> は1ビットだけを占有
し、２つの値だけを取ることができます: <code>NULL</code> または <code>""</code>。

<a name="IDX219"></a>
<a name="IDX220"></a>
<a name="IDX221"></a>
</dd><dt><code>[NATIONAL] VARCHAR(M) [BINARY]</code>
</dt><dd>
可変長文字列。  注意:
後続の空白は格納時に削除されます(これは ANSI SQL 仕様と異なります)。
<code>M</code>の範囲は 1 から 255 文字です。
<code>BINARY</code> キーワードが与えられない場合、ソートと比較はケースに依存しません。
 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

<code>VARCHAR</code> は <code>CHARACTER VARYING</code> の略記です。

<a name="IDX222"></a>
<a name="IDX223"></a>
</dd><dt><code>TINYBLOB</code>
</dt><dd>
</dd><dt><code>TINYTEXT</code>
</dt><dd>
最大長 255 (2^8 - 1) 文字の <code>TEXT</code>/<code>BLOB</code>。 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

<a name="IDX224"></a>
<a name="IDX225"></a>
</dd><dt><code>BLOB</code>
</dt><dd>
</dd><dt><code>TEXT</code>
</dt><dd>
最大長 65535 (2^16 - 1) 文字の <code>TEXT</code>/<code>BLOB</code>。 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

<a name="IDX226"></a>
<a name="IDX227"></a>
</dd><dt><code>MEDIUMBLOB</code>
</dt><dd>
</dd><dt><code>MEDIUMTEXT</code>
</dt><dd>
最大長 16777215 (2^24 - 1) 文字の <code>TEXT</code>/<code>BLOB</code>。 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

<a name="IDX228"></a>
<a name="IDX229"></a>
</dd><dt><code>LONGBLOB</code>
</dt><dd>
</dd><dt><code>LONGTEXT</code>
</dt><dd>
最大長 4294967295 (2^32 - 1) 文字の <code>TEXT</code>/<code>BLOB</code>。 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

<a name="IDX230"></a>
</dd><dt><code>ENUM('value1','value2',...)</code>
</dt><dd>
列挙。
対象となる文字列は、値を一つだけ持ち、値リスト<code>'value1', 'value2',...</code>(又は<code>NULL</code>)から選ばれます。<code>ENUM</code>は最大65535個の固有値を持つことができます。

<a name="IDX231"></a>
</dd><dt><code>SET('value1','value2',...)</code>
</dt><dd>
組。
対象となる文字列は0以上の値を持ち、それぞれ値リスト<code>'value1', 'value2',...</code>から選ばれなければなりません。
<code>SET</code>は、最大 64個の要素を持つことができます。
</dd></dl>

<p>
<a name="IDX232"></a>


</p><h3><a name="Storage_requirements" href="manual.ja_toc.html#Storage_requirements">7.3.1  フィールドタイプの所要容量</a></h3>

<p>
<strong>MySQL</strong>がサポートする各フィールドタイプ毎の所要容量を、カテゴリ別に以下に記述します。

</p>

<h3>7.3.2  数値タイプ</h3>

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フィールドタイプ</strong> </td><td> <strong>所要容量</strong>
</td></tr>
<tr><td><code>TINYINT</code> </td><td> 1 byte
</td></tr>
<tr><td><code>SMALLINT</code> </td><td> 2 bytes
</td></tr>
<tr><td><code>MEDIUMINT</code> </td><td> 3 bytes
</td></tr>
<tr><td><code>INT</code> </td><td> 4 bytes
</td></tr>
<tr><td><code>INTEGER</code> </td><td> 4 bytes
</td></tr>
<tr><td><code>BIGINT</code> </td><td> 8 bytes
</td></tr>
<tr><td><code>FLOAT(X)</code> </td><td> X &lt;= 24 の場合 4、25 &lt;= X &lt;= 53 の場合 8
</td></tr>
<tr><td><code>FLOAT</code> </td><td> 4 bytes
</td></tr>
<tr><td><code>DOUBLE</code> </td><td> 8 bytes
</td></tr>
<tr><td><code>DOUBLE PRECISION</code> </td><td> 8 bytes
</td></tr>
<tr><td><code>REAL</code> </td><td> 8 bytes
</td></tr>
<tr><td><code>DECIMAL(M,D)</code> </td><td> <code>M</code> bytes (<code>M &lt; D</code> の場合 <code>D</code>+2)
</td></tr>
<tr><td><code>NUMERIC(M,D)</code> </td><td> <code>M</code> bytes (<code>M &lt; D</code> の場合 <code>D</code>+2)
</td></tr>
</tbody></table>


<h3>7.3.3  日付と時間タイプ</h3>

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フィールドタイプ</strong> </td><td> <strong>所要容量</strong>
</td></tr>
<tr><td><code>DATE</code> </td><td> 3 bytes
</td></tr>
<tr><td><code>DATETIME</code> </td><td> 8 bytes
</td></tr>
<tr><td><code>TIMESTAMP</code> </td><td> 4 bytes
</td></tr>
<tr><td><code>TIME</code> </td><td> 3 bytes
</td></tr>
<tr><td><code>YEAR</code> </td><td> 1 byte
</td></tr>
</tbody></table>


<h3>7.3.4  文字列タイプ</h3>

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フィールドタイプ</strong> </td><td> <strong>所要容量</strong>
</td></tr>
<tr><td><code>CHAR(M)</code> </td><td> <code>M</code> bytes, <code>1 &lt;= M &lt;= 255</code>
</td></tr>
<tr><td><code>VARCHAR(M)</code> </td><td> <code>L</code>+1 bytes, where <code>L &lt;= M</code> and
<code>1 &lt;= M &lt;= 255</code>
</td></tr>
<tr><td><code>TINYBLOB</code>, <code>TINYTEXT</code> </td><td> <code>L</code>+1 bytes,
where <code>L</code> &lt; 2^8
</td></tr>
<tr><td><code>BLOB</code>, <code>TEXT</code> </td><td> <code>L</code>+2 bytes,
where <code>L</code> &lt; 2^16
</td></tr>
<tr><td><code>MEDIUMBLOB</code>, <code>MEDIUMTEXT</code> </td><td> <code>L</code>+3 bytes,
where <code>L</code> &lt; 2^24
</td></tr>
<tr><td><code>LONGBLOB</code>, <code>LONGTEXT</code> </td><td> <code>L</code>+4 bytes,
where <code>L</code> &lt; 2^32
</td></tr>
<tr><td><code>ENUM('value1','value2',...)</code> </td><td> 1 or 2 bytes, 列挙値の数に依存 (最大値は 65535 )
</td></tr>
<tr><td><code>SET('value1','value2',...)</code> </td><td> 1, 2, 3, 4 or 8 bytes, 要素の数に依存 (最大要素 64 )
</td></tr>
</tbody></table>

<p>
<code>VARCHAR</code>、<code>BLOB</code>、及び<code>TEXT</code>型は可変長型であり、所要容量は、フィールドのとり得る最大サイズというよりはむしろフィールド値の実際の長さに依存します(前の表で<code>L</code>と表しました)。
例えば、<code>VARCHAR(10)</code>フィールドは、最大10文字分の長さの文字列を保持することが出来ます。実際の所要容量は、文字列の長さ(<code>L</code>)と、その長さを記録するための１バイトを加えます。文字列<code>'abcd'</code>においては、<code>L</code>は４で、所要容量は５バイトです。

</p>
<p>
<code>BLOB</code>と<code>TEXT</code>型は、フィールド値の長さを記録するのに、１、２、３、又は４バイト必要とし、型のとり得る最大の長さに依存します。

</p>
<p>
テーブルが可変長フィールド型を含む場合、そのレコードフォーマットもまた可変長となるでしょう。
テーブルが作成された時、<strong>MySQL</strong>は確かな条件の下、フィールドを可変長タイプから固定長タイプへ変更し、副作用を起こすことに注意して下さい。

</p>
<p>
<code>ENUM</code>オブジェクトのサイズは、異なる列挙値の数によって決められます。
列挙する数が255以内では、１バイトが使用されます。
列挙する数が65535以内では、２バイトが使用されます。

</p>
<p>
<code>SET</code>オブジェクトのサイズは、異なる要素の数によって決められます。
組のサイズを<code>N</code>とすると、オブジェクトは<code>(N+7)/8</code>バイトを占有し、１、２、３、４又は８バイトに切上げられます。
１つの<code>SET</code>は、最大６４要素を持つことができます。

</p>


<h3><a name="Numeric_types" href="manual.ja_toc.html#Numeric_types">7.3.5  数値型</a></h3>

<p>
<strong>MySQL</strong> は ANSI/ISO SQL92 数値型をすべてサポートします。これらの型
は正確な数値データ型(<code>NUMERIC</code>, <code>DECIMAL</code>, <code>INTEGER</code>,
<code>SMALLINT</code>)、近似数値型(<code>FLOAT</code>, <code>REAL</code>, <code>DOUBLE
PRECISION</code>)を含みます。キーワード <code>INT</code> は <code>INTEGER</code> の同義語で、
<code>DEC</code>は <code>DECIMAL</code> の同義語です。

</p>
<p>
<strong>MySQL</strong> では <code>NUMERIC</code> と <code>DECIMAL</code> 型は、SQL92 標準で許
されているように同じ型として実装されています。これらは正確な精度を維持する
ことが重要な値(例えば金銭データ)に使用されます。これらの型の一つのフィール
ドを宣言する時、精度と大きさが指定できます(通常はそうします); 例えば:

</p>

<pre>    salary DECIMAL(9,2)
</pre>

<p>
この例では、<code>9</code> (<code>precisoin</code>) は値を格納する重要な数値の桁数を表
します。そして <code>2</code> (<code>scale</code>) は小数点に続いて格納される桁数を表
します。従って、この場合 <code>salary</code> フィールドに格納することができる値
の範囲は、<code>-9999999.99</code> から <code>9999999.99</code> です。ANSI/ISO SQL92 
では、構文 <code>DECIMAL(p)</code> は <code>DECIMAL(p,0)</code> と等しいです。同様に、
構文 <code>DECIMAL</code> は <code>DECIMAL(p,0)</code> と等しいです。ここで <code>p</code> 
の値の決定は実装に許されてます。<code>DECIMAL</code>/<code>NUMERIC</code> データ型のこ
れらの異なる形式は、<strong>MySQL</strong> は現在サポートしていません。この型の主
な利益は精度と大きさの両方を明示的に制御する機能から引き出されるので、これ
は通常深刻な問題ではありません。

</p>
<p>
<code>DECIMAL</code> と <code>NUMERIC</code> 値は、値の小数の精度を維持するため、バイ
ナリ浮動小数点数としてではなく、文字列として格納されます。1文字は値のそれ
ぞれの桁(<code>scale</code> &gt; 0 の場合)と <samp>`-'</samp> 記号(負数の場合)に使用されま
す。<code>scale</code> が 0 の場合、<code>DECIMAL</code> と <code>NUMERIC</code> 値は小数点
と小数部を含みません。

</p>
<p>
<code>DECIMAL</code> と <code>NUMERIC</code> 値の最大範囲は <code>DOUBLE</code> と同じです。
しかし <code>DECIMAL</code> や <code>NUMERIC</code> フィールドに与えられる実際の範囲は
フィールドに与えられた <code>precision</code> と <code>scale</code> によって強制されま
す。このフィールドに、指定された <code>scale</code> で許されるよりも多い桁の小数
部を持つ数値が割り当てられた場合、値はその <code>scale</code> に丸められます。
<code>DECIMAL</code> や <code>NUMERIC</code> フィールドに、指定された(またはデフォルト
の) <code>precision</code> と <code>scale</code> で示された範囲を超えた大きさの値を割
り当てた時、<strong>MySQL</strong> はその範囲の対応する最大値を表す値を格納します。

</p>
<p>
ANSI/ISO SQL92 標準に対する拡張として、上の表にリストしたように、
<strong>MySQL</strong> は整数型 <code>TINYINT</code>, <code>MEDIUMINT</code>, <code>BIGINT</code> も
サポートします。<strong>MySQL</strong> によってサポートされる他の拡張として、オプ
ションで、型の基本キーワードに続けて括弧内に指定する整数値の表示幅(例えば 
<code>INT(4)</code>)があります。このオプションの幅指定は、フィールドに指定された
幅よりも少ない幅の値の表示の左側を埋めるために使用されます。しかしフィール
ドに格納することができる値の範囲や、フィールドに指定された幅を超える幅の値
について表示される桁数は制約されません。オプションの拡張属性 
<code>ZEROFILL</code> を指定して使用された場合、デフォルトの埋められる空白は 0 
で置き換えられます。例えば、<code>INT(5) ZEROFILL</code> として宣言されたフィー
ルドでは、値 <code>4</code> は <code>0004</code> として取り出されます。注意: 整数フィー
ルド内に表示幅よりも大きい値を格納する場合、<strong>MySQL</strong> が複雑な join 
のために一時テーブルを生成する時に、問題を体験するでしょう。この場合 
<strong>MySQL</strong> はデータがオリジナルのフィールド幅に合っていることを信用す
るためです。

</p>
<p>
すべての整数型はオプションの(非標準)属性 <code>UNSIGNED</code> を持つことができ
ます。符合無しの値はフィールド内に正の数だけを許可したくて、フィールドに対
して少し大きい数値の範囲が必要な時に使用できます。

</p>
<p>
<code>FLOAT</code> 型は近似数データ型を表すために使用されます。ANSI/ISO SQL92 標
準は、<code>FLOAT</code> キーワードに続く括弧中にオプションの精度(指数の範囲では
ない)の指定を許しています。<strong>MySQL</strong> 実装はこのオプションの精度指定も
サポートしています。キーワード <code>FLOAT</code> が精度の指定無しでフィールド型
として使用された時は、<strong>MySQL</strong> は値を格納するために4バイトを使用しま
す。<code>FLOAT</code> キーワードに続く括弧中に2つの数値を与える構文もサポートさ
れます。このオプションでの、最初の数値は値に必要な容量をバイトで表します。
2番目の数値は、格納、表示される小数部の桁数を指定します(<code>DECIMAL</code> と 
<code>NUMERIC</code> と同様)。<strong>MySQL</strong> がフィールドに指定されたよりも大き
い小数部の桁数を持つ数値をこのフィールドに格納する時、値の格納時に余計な桁
を取り除くように値が丸められます。

</p>
<p>
<code>REAL</code> と <code>DOUBLE PRECISION</code> 型は精度指定を許しません。
ANSI/ISO SQL92 標準に対する拡張として、<strong>MySQL</strong> は <code>DOUBLE</code> を 
<code>DOUBLE PRECISION</code> 型の同義語として認識します。<code>REAL</code> の精度は 
<code>DOUBLE PRECISION</code> の指定よりも小さいことを要求する標準と異なり、
<strong>MySQL</strong> はどちらも8バイトの倍精度小数点の値として実装しています
("ANSI モード"で実行していない場合)。移植性を最大にするためには、近似数値
データ値の格納を要求するコードは、精度や小数部桁数の指定無しの 
<code>FLOAT</code> か <code>DOUBLE PRECISION</code> を使用すべきです。

</p>
<p>
フィールドの型の値の許容範囲を超えた数値を代入しようとすると、<strong>MySQL</strong> は
その値を許容範囲いっぱいに切り詰め、その結果を代わりに代入します。

</p>
<p>
例えば、 <code>INT</code> フィールドの範囲は <code>-2147483648</code> から <code>2147483647</code> です。
もし <code>-9999999999</code> を <code>INT</code> フィールドに挿入しようとすると、値は範囲の最低値に
修正され、 <code>-2147483648</code> が代わりに代入されます。同様に、<code>9999999999</code> の場合、
 <code>2147483647</code> が代わりに代入されます。

</p>
<p>
そして、<code>INT</code> フィールドが符号無しの場合、フィールドの範囲の大きさは
同じですが、限界値は <code>0</code> と<code>4294967296</code> になります。
もし <code>-9999999999</code> と <code>9999999999</code> を代入しようとすると、
値は <code>0</code> と <code>4294967296</code> として代入されます。

</p>
<p>
<code>ALTER TABLE</code>, <code>LOAD DATA INFILE</code>, <code>UPDATE</code> または
 multi-row <code>INSERT</code> 時、これらの変換は `警告' として得られます。

</p>

<p>
<a name="IDX233"></a>
<a name="IDX234"></a>


</p><h3><a name="Date_and_time_types" href="manual.ja_toc.html#Date_and_time_types">7.3.6  日付と時間の型</a></h3>

<p>
日付と時間の型は <code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code>,
<code>TIME</code>, <code>YEAR</code> です.  これらはそれぞれ値に適正な範囲があり、
``zero'' はあなたが間違った値を指定した場合に用いられます。注意: <strong>MySQL</strong> は
確実に '厳密でない' 正しい日付の値、例えば <code>1999-11-31</code> を格納するこ
とができます。この理由は、日付をチェックする処理の責任はアプリケーションに
あり、SQL サーバにはないと考えているからです。日付を'速く'チェックするため
に、<strong>MySQL</strong> は月が 0～12 の範囲であるかと日が 0～31 の範囲であるか
だけをチェックします。上述の範囲は、<strong>MySQL</strong> が <code>DATE</code> または 
<code>DATETIME</code> フィールドに、日または月日が 0 である日付を格納できるため
に定義されています。これは、正確な日付を知らない誕生日を登録する必要がある
アプリケーションに非常に有用です。この場合、<code>1999-00-00</code> や 
<code>1999-01-00</code> のような日付を単純に登録できます(もちろん、このような日
付を <code>DATE_SUB()</code> や <code>DATE_ADD</code> のような関数で使用して、正しい値
が返ることは期待できません)。

</p>
<p>
これは、日付と時間型で作業する場合に、一般的に考慮しなければならないことです:

</p>

<ul>
<li>

<strong>MySQL</strong>は、標準形式で与えられた日付や時間から値を抽出しますが、与えられた多様な形式の値(例えば、指定された値を日付や時間型に割り当てたり、比較したり)を解釈しようと試みます。
それでも、次節で述べる形式だけがサポートされます。
それは、正当な値が与えられることを期待し、他の形式の値を使用されるような事態が起こると、どのような結果となるか予想できません。

</li><li>

<strong>MySQL</strong> はいくつかの形式に値を変えてくれますが、
常に年の部分と日にちの部分は左から与えられていると期待しています。
日付は 年-月-日 の順(例えば、<code>'98-09-04'</code>)でなくてはなりません。
月-日-年 や 日-月-年 の様などこでも使われているような形であってはなりません。
(例えば、<code>'09-04-98'</code>や<code>'04-09-98'</code>).

</li><li>

<strong>MySQL</strong> は、もし数値の文脈で日付と時間の型が使用されると、
自動的に日付と時間を数値に直します。逆も行います。

</li><li>

<strong>MySQL</strong> が範囲外の誤った値を日付と時間型として受け取った場合
(このセクションの最初をみてください)、その値は ``ゼロ'' に変換されます。
(例外は、範囲外の<code>TIME</code>値が適切な<code>TIME</code>の範囲の限界値に切り詰められることです。)
以下に、それぞれの型の `ゼロ' の形式を示します：

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フィールドタイプ</strong> </td><td> <strong>`ゼロ'値</strong>
</td></tr>
<tr><td><code>DATETIME</code> </td><td> <code>'0000-00-00 00:00:00'</code>
</td></tr>
<tr><td><code>DATE</code> </td><td> <code>'0000-00-00'</code>
</td></tr>
<tr><td><code>TIMESTAMP</code> </td><td> <code>00000000000000</code> (length depends on display size)
</td></tr>
<tr><td><code>TIME</code> </td><td> <code>'00:00:00'</code>
</td></tr>
<tr><td><code>YEAR</code> </td><td> <code>0000</code>
</td></tr>
</tbody></table>

</li><li>

`ゼロ'値は特別ですが、表に示された値を明示的に使用して、格納したり参照したりできます。
この値は、 <code>'0'</code> 又は <code>0</code> を使用することにより、より簡潔に書くこともできます。

</li><li>

<strong>MyODBC</strong> 内で使用されている `ゼロ' の日付と時間は、
<strong>MyODBC</strong> 2.50.12 以上では自動的に <code>NULL</code> に変換されます。
これは ODBC がこれらの値を扱えないからです。
</li></ul>

<p>
<a name="IDX235"></a>


</p><h4><a name="Y2K_issues" href="manual.ja_toc.html#Y2K_issues">7.3.6.1  西暦２０００年問題とデータ型</a></h4>

<p>
<strong>MySQL</strong> 自体は2000年問題に対して安全です( 「<a href="manual.ja_Introduction.html#Year_2000_compliance">1.7  2000 年対応</a>」節参照)が、
 <strong>MySQL</strong> に提示される入力値に関してはそうではありません。2桁の
年の入力は何世紀なのかわからないので全て曖昧です。このような値は <strong>MySQL</strong>
が内部で年に4桁を使っていることから4桁の形式に変換されてしまいます。

</p>
<p>
 <strong>MySQL</strong> は曖昧な日付を <code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code> 
および <code>YEAR</code> 型に関して、以下の
ルールに従って解釈します。

</p>

<ul>
<li>

<code>00-69</code> の範囲の年は <code>2000-2069</code> に変換。

</li><li>

<code>70-99</code> の範囲の年は <code>1970-1999</code> に変換。
</li></ul>

<p>
これらのルールはデータが何を意味しているかに対して妥当な推定を与えるに
過ぎないことに注意してください。この <strong>MySQL</strong> 発見的手法が正しい値を生成し
ない場合は曖昧でない4桁の年を含む入力を与えるべきです。

</p>
<p>
<code>ORDER BY</code> は2桁の <code>YEAR/DATE/DATETIME</code> 型を正しくソートされます。

</p>
<p>
注意: <code>MIN()</code> と <code>MAX()</code> のようないくつかの関数は <code>TIMESTAMP/DATE</code> を数値
に変換します。これは年が2桁のタイムスタンプはこれらの関数で正しく動作しな
いことを意味します。この場合の修復は、<code>TIMESTAMP/DATE</code> を4桁の年の形
式に変換するか、<code>MIN(DATE_ADD(timestamp,INTERVAL 0 DAYS))</code> のような何
かを使用することです。

</p>
<p>
<a name="IDX236"></a>
<a name="IDX237"></a>
<a name="IDX238"></a>


</p><h4><a name="DATETIME" href="manual.ja_toc.html#DATETIME">7.3.6.2  <code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code> 型</a></h4>

<p>
<code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code>型はお互いに関連しています。このセクションで
はそれらの特徴と、それぞれがどう同じでどう違うかを示します。

</p>
<p>
<code>DATETIME</code> 型は日付と時刻の情報を含む値が必要な場合に使います。<strong>MySQL</strong> は
 <code>DATETIME</code> 値を <code>'YYYY-MM-DD HH:MM:SS'</code> のフォーマットで取り出し、表示します。
サポートされる範囲は <code>'1000-01-01 00:00:00'</code> から <code>'9999-12-31 23:59:59'</code> です。
(「サポートされる」とはさらに過去の値でも動くかも知れませんが保証の限りではないという意味です)

</p>
<p>
<code>DATE</code> 型は時刻の部分なしで日付の値のみが必要な場合に使います。<strong>MySQL</strong> は
 <code>DATE</code> 値を<code>'YYYY-MM-DD'</code> のフォーマットで取り出し、表示します。サポートされ
る範囲は <code>'1000-01-01'</code> から <code>'9999-12-31'</code> です。

</p>
<p>
<code>TIMESTAMP</code> タイプは <code>INSERT</code> や <code>UPDATE</code> 操作に自動的に
現在の日付と時刻をマークする場合に提供される型です。
もし複数の <code>TIMESTAMP</code> フィールドがある場合には最初
の一つだけが自動的に更新されます。

</p>
<p>
最初の <code>TIMESTAMP</code> フィールドの自動更新は以下のいずれかの条件で起こります：

</p>

<ul>
<li>

そのフィールドが明示的に <code>INSERT</code> または <code>LOAD DATA INFILE</code> 文で指定されていないとき。
</li><li>

そのフィールドが明示的に <code>UPDATE</code> 文で指定されず、かつ、他のフィールドの値が変わった場合。
(もともとフィールドに入っていた値と同じ値に更新しようとする <code>UPDATE</code> 文は <code>TIMESTAMP</code>
フィールドを更新しないことに注意。なぜならあるフィールドを現在と同じ値に変えようとしても
<strong>MySQL</strong> は効率のためにそれを無視するからです。)
</li><li>

明示的に <code>TIMESTAMP</code> フィールドを <code>NULL</code> にした場合。
</li></ul>

<p>
最初以外の <code>TIMESTAMP</code> フィールドも現在の日付と時刻にすることができます。それらのフィールドを
<code>NULL</code> または <code>NOW()</code> にすることです。

</p>
<p>
どの <code>TIMESTAMP</code> フィールドも明示的に望む値をセットすることで現在の日時でない値に
することができます。それは最初の <code>TIMESTAMP</code> フィールドについても同じです。この特
性は例えば <code>TIMESTAMP</code> フィールドをあるレコードが生成されたときの日時にし、その後その行
が更新されても変化しないようにしたいというようなときに使えます。

</p>

<ul>
<li>

<strong>MySQL</strong> にレコードが生成されたときにそのフィールドをセットさせる。これで現在日時に初
期化される。

</li><li>

以降の他のフィールドに対する更新時に <code>TIMESTAMP</code> フィールドをそれ自体が今持っている値に
明示的に更新する。
</li></ul>

<p>
一方、この手法は <code>DATATIME</code> フィールドを行生成時に <code>NOW()</code> で初期化し、以降の更新時に
それをほうっておくのと同じように簡単であるとわかるでしょう。

</p>
<p>
<code>TIMESTAMP</code> の値は <code>1970</code> 年の最初から <code>2037</code> 年のどこかの時点までの範囲で有効で、
1秒の時間分解能を持ちます。値は数値として表示されます。

</p>
<p>
<strong>MySQL</strong> が <code>TIMESTAMP</code> 値を取り出したり表示するのに使うフォーマットは以下の表
に示すようにその表示サイズに依存します。「目一杯の」 <code>TIMESTAMP</code> フォーマッ
トは14桁ですが、 <code>TIMESTAMP</code> フィールドはより短い表示サイズで生成することもできます：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フィールド型</strong> </td><td> <strong>表示フォーマット</strong>
</td></tr>
<tr><td><code>TIMESTAMP(14)</code> </td><td> <code>YYYYMMDDHHMMSS</code>
</td></tr>
<tr><td><code>TIMESTAMP(12)</code> </td><td> <code>YYMMDDHHMMSS</code>
</td></tr>
<tr><td><code>TIMESTAMP(10)</code> </td><td> <code>YYMMDDHHMM</code>
</td></tr>
<tr><td><code>TIMESTAMP(8)</code> </td><td> <code>YYYYMMDD</code>
</td></tr>
<tr><td><code>TIMESTAMP(6)</code> </td><td> <code>YYMMDD</code>
</td></tr>
<tr><td><code>TIMESTAMP(4)</code> </td><td> <code>YYMM</code>
</td></tr>
<tr><td><code>TIMESTAMP(2)</code> </td><td> <code>YY</code>
</td></tr>
</tbody></table>

<p>
全ての <code>TIMESTAMP</code> フィールドは表示サイズに関係なく同じ格納サイズを持ちます。もっ
とも一般的な表示サイズは 6 , 8 , 12 および 14 です。表示サイズはテーブル生成時
に任意の値に指定できますが、 0 および 14 以上の値は強制的に 14 になります。1
から 13 までの奇数のサイズは強制的に一つ大きい偶数になります。

</p>
<p>
<code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code> 値は以下の共通フォーマットセットのいずれかを
使って指定できます：

</p>

<ul>
<li>

文字列で <code>'YYYY-MM-DD HH:MM:SS'</code> か <code>'YY-MM-DD HH:MM:SS'</code> の形式。
"柔軟な"書き方を許しています -- 日付や時刻の区切り文字として、いかなる句読記号
も使用できます。例えば、<code>'98-12-31 11:30:45'</code>, <code>'98.12.31 11+30+45'</code>,
<code>'98/12/31 11*30*45'</code>, <code>'98@12@31 11^30^45'</code> は等価です。

</li><li>

文字列で <code>'YYYY-MM-DD'</code> か <code>'YY-MM-DD'</code> の形式。
これも"柔軟な"書き方ができます。
例えば, <code>'98-12-31'</code>,<code>'98.12.31'</code>, <code>'98/12/31'</code>, <code>'98@12@31'</code> は
等価です。

</li><li>

文字列 <code>'YYYYMMDDHHMMSS'</code> または <code>'YYMMDDHHMMSS'</code> フォーマット。
「緩やかな」文法が認められていて、句読記号は日付、時刻部分の区切り
として使えます。例えば <code>'98-12-31 11:30:45'</code>,  <code>'98.12.31 11+30+45'</code>,
 <code>'98/12/31 11*:30*:45'</code>,  <code>'98@12@31 11^30^45'</code> は全て等価です。

</li><li>

文字列 <code>'YYYY-MM-DD'</code> または <code>'YY-MM-DD'</code> フォーマット。これも「緩やかな」文法
が認められています。例えば <code>'98-12-31'</code>,  <code>'98.12.31'</code>,  <code>'98/12/31'</code>, <code>'98@12@31'</code>
は全て等価です。

</li><li>

区切り文字なしの文字列 <code>'YYYYMMDDHHMMSS'</code> または <code>'YYMMDDHHMMSS'</code> フォーマッ
トで日時として意味のあるもの。例えば <code>'19970523091528'</code> および <code>'970523091528'</code> 
は <code>'1997-05-23 09:15:28'</code> と解釈されます。しかし <code>'971122129015'</code> は無効で
(時と分の部分がおかしい)、 <code>'0000-00-00 00:00:00'</code> になります。

</li><li>

区切り文字なしの文字列 <code>'YYYYMMDD'</code> または <code>'YYMMDD'</code> フォーマットで、日付と
して意味のあるもの。例えば <code>'19970523'</code> および <code>'970523'</code> は <code>'1997-05-23'</code> と解釈
されます。しかし <code>'971332'</code> は無効で(月と日の部分がおかしい)、 <code>'0000-00-00'</code> 
になります。

</li><li>

 <code>YYYYMMDDHHMMSS</code> または <code>YYMMDDHHMMSS</code> のフォーマットの数値で、日時として意
味のあるもの。例えば <code>19830905132800</code> および <code>830905132800</code> は
 <code>'1983-09-05 13:28:00'</code> と解釈されます。

</li><li>

 <code>YYYYMMDD</code> または <code>YYMDD</code> のフォーマットの数値で日付として意味のあるもの。
例えば <code>19830905</code> および <code>830905</code> は <code>'1983-09-05'</code> として解釈されます。

</li><li>

 <code>NOW()</code> や <code>CURRENT_DATE</code> のように
 <code>DATETIME</code> , <code>DATE</code> , <code>TIMESTAMP</code> のコンテキストで
アクセス可能な値を返す関数の結果。
</li></ul>

<p>
無効な <code>DATETIME</code> , <code>DATE</code> , <code>TIMESTAMP</code> の値は適切な「ゼロ」値に変換されます(
 <code>'0000-00-00 00:00:00'</code> , <code>'0000-00-00'</code> または <code>00000000000000</code> )。

</p>
<p>
日時の部分に区切りを持つ文字列で指定される値で、月、日の値が10未満の場
合は2桁で指定しなくてもかまいません。 <code>'1979-6-9'</code> は <code>'1979-06-09'</code> と等価で
す。同様に時刻の部分に区切りを持つ文字列で指定される値で、時、分、秒が
 <code>10</code> 未満の場合は2桁で指定しなくてもかまいません。 <code>'1979-10-30 1:2:3'</code> は
 <code>'1979-10-30 01:02:03'</code> と等価です。

</p>
<p>
数値でしていされる値は 6, 8, 12 または 14 桁である必要があります。もしその数
値が 8 または 14 桁の長さの時はそれぞれ <code>YYYYMMDD</code> および <code>YYYYMMDDHHMMSS</code> フォー
マットで、最初の 4 桁で年が与えられるものと仮定されます。もしその数値が 6
または12桁の長さの時は <code>YYMMDD</code> および <code>YYMMDDHHMMSS</code> フォーマットで最初の2桁で
年が与えられるものと仮定されます。これら以外の長さの数値はあとに <code>0</code> が追加
されてこれらのうちのもっとも近い長さのものと解釈されます。

</p>
<p>
区切りなしの文字列で与えられる値はそれ自身の長さを使って解釈されます。
もし文字列が8または14文字ならば年は最初の4文字で与えられると仮定されま
す。そうでなければ最初の2文字で与えられると仮定されます。文字列は左か
ら右に年、月、日、時、分、秒と文字列中に表現されている分だけ順に解釈さ
れます。つまり6文字以下の文字列は使ってはいけないということです。例え
ば1999年3月を指定するつもりで <code>'9903'</code> を指定した場合、 <strong>MySQL</strong> は「ゼロ」日付
をテーブルに挿入します。これは年と月の部分は <code>99</code> と <code>03</code> ですが日の部分が欠け
ている(ゼロ)ために値が有効な日付でないために起こります。

</p>
<p>
<code>TIMESTAMP</code> フィールドは有効な値を、表示サイズに関係なく指定された値を最高精度の
時間分解能で格納します。このことはいくつかの意味合いを持ちます。

</p>
<p>
年の値が二桁で指定された場合、世紀の部分がないので曖昧な値となります。
<strong>MySQL</strong> は二桁の年の値を以下に示す規則にそって変換します：

</p>

<ul>
<li>

列の型がTIMESTAMP(4)であってもTIMESTAMP(2)であっても常に年月日を指定
すること。そうでなければ値は無効で0が格納されます。

</li><li>

もし短い形式の <code>TIMESTAMP</code> を <code>ALTER TABLE</code> を使って拡張しようとした場合、拡
張前には「隠れていた」情報が現れます。

</li><li>

同様に <code>TIMESTAMP</code> フィールドを縮めた場合も、値が表示された時により少ない情報し
か現れないという点を除いて、情報は失われません。

</li><li>

 <code>TIMESTAMP</code> 値は最高精度の時間分解能で格納されますが、内部的に格納され
た値を直接操作できる関数は <code>UNIX_TIMESTAMP()</code> のみです。他の関数はフォーマッ
トされて取り出された値について操作します。つまり、 <code>HOUR()</code> や <code>SECOND()</code> など
の関数は <code>TIMESTAMP</code> 値の対応する部分がフォーマットされた値で含まれないと
使うことができません。例えば <code>TIMESTAMP</code> 列の <code>HH</code> の部分は表示サイズが少なく
とも10以上ないと表示されないので、それより短い <code>TIMESTAMP</code> 値に <code>HOUR()</code> の操
作を行っても無意味な値しか得られません。
</li></ul>

<p>
ある日付型を他の日付型のオブジェクトに拡張して指定することができます。
しかしそれは値の変化や情報の欠落を起こす可能性があります。

</p>

<ul>
<li>

<code>DATE</code> の値を <code>DATETIME</code> か <code>TIMESTAMP</code> の物に与えた場合、
時刻の部分は <code>'00:00:00'</code> になります。これは <code>DATE</code> 値が
時刻の情報を持っていないからです。

</li><li>

<code>DATETIME</code> か <code>TIMESTAMP</code> の値を <code>DATE</code> の物に与えた場合、
時刻の部分は削られます。これは <code>DATE</code> 値が
時刻の情報を持っていないからです。

</li><li>

 <code>DATETIME</code>, <code>DATE</code>, <code>TIMESTAMP</code> 値は同じフォーマットのセットを使って表現で
きますが、どの型も同じ値の範囲を持っているわけではないことを覚えておい
てください。例えば <code>TIMESTAMP</code> 値は <code>1970</code> 年より前や <code>2037</code> 年より後の値にはでき
ません。つまり <code>'1968-01-01'</code> という値は <code>DATETIME</code> や <code>DATE</code> の値としては有効です
が <code>TIMESTAMP</code> の値としては無効で、そのようなオブジェクトを指定した場合は
 <code>0</code> に変換されます。
</li></ul>

<p>
日付の値を指定するときの落とし穴に注意してください:

</p>

<ul>
<li>

文字列として指定される値の柔軟なフォーマットに騙されないよう。例え
ば <code>'10:11:12'</code> は <samp>`':''</samp> を区切り文字とする時刻のように見えますが、日付のコン
テキストで使われるとこれは <code>'2010-11-12'</code> と解釈されます。<code>'10:45:15'</code> は <code>'45'</code> 
が有効な月ではないので <code>'0000-00-00'</code> に変換されます。

</li><li>

2桁で表される年は世紀の部分が不明なので曖昧です。 <strong>MySQL</strong> は以下のルール
で2桁の年を解釈します。


<ul>
<li>

<code>00-69</code> の範囲にある年の値は <code>2000-2069</code> 年とする。

</li><li>

<code>70-99</code> の範囲にある年の値は <code>1970-1999</code> 年とする。
</li></ul>

</li></ul>

<p>
<a name="IDX239"></a>


</p><h4><a name="TIME" href="manual.ja_toc.html#TIME">7.3.6.3  <code>TIME</code> 型</a></h4>

<p>
<strong>MySQL</strong> は <code>TIME</code> の値を <code>'HH:MM:SS'</code>
 (時の部分が大きい場合は <code>'HHH:MM:SS'</code>)
というフォーマットで扱い、また表示します。
(時の部分が大きい場合は <code>'HHH:MM:SS'</code>)。
<code>TIME</code> 値の範囲は <code>'-838:59:59'</code> から <code>'838:59:59'</code> の範囲です。
時の部分がこんなに大きいのは、<code>TIME</code> 型は一日すなわち24時間以内
の時刻を表現するのに用いられるだけではなく経過時間や二つの事象の間隔
(どちらも２４時間を越えたり、負の数になる場合もあります)を表現すること
もあるからです。

</p>
<p>
<code>TIME</code> 値は様々なフォーマットで指定可能です：

</p>

<ul>
<li>

文字列で <code>'D HH:MM:SS.fraction'</code> というフォーマット。
(<strong>MySQL</strong>はまだこの fraction を time フィールドに保存できません)。
以下の ``柔軟な'' 文法が使用できます：

<code>HH:MM:SS.fraction</code>, <code>HH:MM:SS</code>, <code>HH:MM</code>, <code>D HH:MM:SS</code>,
<code>D HH:MM</code>, <code>D HH</code> or <code>SS</code>.  Here <code>D</code> is days between 0-33.

</li><li>

文字列で <code>'HHMMSS'</code> というように区切りのないフォーマットで時刻として有効
なもの。例えば <code>'101112'</code> は <code>'10:11:12'</code> と解釈されますが <code>'109712'</code> は無効で(分
の部分が無意味) <code>'00:00:00'</code> になります。

</li><li>

数値で <code>HHMMSS</code> のフォーマットで時刻として有効なもの。
例えば <code>101112</code> は <code>'10:11:12'</code> と解釈されます。
次の別の形式も解釈できます: <code>SS</code>, <code>MMSS</code>,<code>HHMMSS</code>,
<code>HHMMSS.fraction</code>。注意: <strong>MySQL</strong> はまだ fraction 部を保存でき
ません。

</li><li>

例えば <code>CURRENT_TIME</code> のように <code>TIME</code> のコンテキストで受け付けられる値を返す
関数の結果。
</li></ul>

<p>
文字列で時刻の各部の区切りを含む <code>TIME</code> の値については、時、分、秒が <code>10</code> 以下
の場合、２桁の数字を指定する必要はありません。<code>'8:3:2'</code> は <code>'08:03:02'</code> と同
じです。

</p>
<p>
「短い」 <code>TIME</code> 値を <code>TIME</code> フィールドとして指定する場合は要注意です。
<strong>MySQL</strong> はその値をもっとも右端の桁は秒を表すと仮定して解釈します
(<strong>MySQL</strong> は <code>TIME</code> の値を一日の
うちの時刻としてより経過時間として解釈します)。例えば <code>'11:12'</code>,<code>'1112'</code>,
 <code>1112</code> が <code>'00:11:12'</code> (11時12分)を表しているつもりでいても、
<strong>MySQL</strong> はこれらを <code>'00:00:12'</code> (11分12秒)として解釈します。
同様に <code>'12'</code> および <code>12</code> は <code>'00:00:12'</code> と解釈します。

</p>
<p>
<code>TIME</code> の範囲外にある値で値以外は正しいものは範囲の端の値の適当な方にクリッ
プされます。例えば <code>'-850:00:00'</code> および <code>'850:00:00'</code> は
それぞれ <code>'-838:59:59'</code> および <code>'838:59:59'</code> になります。

</p>
<p>
無効な <code>TIME</code> 値は <code>'00:00:00'</code> に変換されます。
ここで <code>'00:00:00'</code> 自体は有効な <code>TIME</code> 値なので、
テーブル内に保存された'00:00:00'という値からそれがもとも
と <code>'00:00:00'</code> と指定された値なのか無効なために変換された結果なのかを区
別する方法はないことに注意してください。

</p>

<p>
<a name="IDX240"></a>


</p><h4><a name="YEAR" href="manual.ja_toc.html#YEAR">7.3.6.4  <code>YEAR</code> 型</a></h4>

<p>
<code>YEAR</code> 型は年を表現するのに使われる1バイトの値です。

</p>
<p>
<strong>MySQL</strong> は <code>YEAR</code> の値を <code>YYYY</code> というフォーマットで扱い、
また表示します。範囲は <code>1901</code> から <code>2155</code> です。

</p>
<p>
<code>YEAR</code> 型は様々なフォーマットで指定可能です：

</p>

<ul>
<li>

<code>'1901'</code> から <code>'2155'</code> の範囲にある4桁の文字列

</li><li>

<code>1901</code> から <code>2155</code> の範囲にある4桁の数値。

</li><li>

<code>'00'</code> から <code>'99'</code> の範囲にある2桁の文字列。
<code>'00'</code> から <code>'69'</code> までおよび <code>'70'</code> から
<code>'99'</code> までの範囲はそれぞれ <code>2000</code> から <code>2069</code> まで
および <code>1970</code> から <code>1999</code> までの範囲の
YEAR型に変換されます。

</li><li>

<code>1</code> から <code>99</code> の範囲にある2桁の数値。<code>1</code> から <code>69</code> まで
および <code>70</code> から <code>99</code> までの範囲は
それぞれ <code>2001</code> から <code>2069</code> までおよび <code>1970</code> から <code>1999</code> まで
の範囲の <code>YEAR</code> 型に変換されます。
2桁の数値の場合は2桁の文字列の場合と若干異なっている点に注意して
ください。なぜなら0を数値として指定し、それを2000年として解釈させるこ
とができないからです。その場合は文字列で <code>'0'</code> または <code>'00'</code> を<em>指定しなければ
なりません</em>。そうでなければ数値0は無効なYEAR値を示す <code>0000</code> に変換されます。

</li><li>

例えば <code>NOW()</code> のように <code>YEAR</code> コンテキストで受け入れられる値を返す関数の結
果。
</li></ul>

<p>
無効な <code>YEAR</code> 値は <code>0000</code> に変換されます。

</p>



<h3><a name="String_types" href="manual.ja_toc.html#String_types">7.3.7  文字列型</a></h3>

<p>
文字列型は  <code>CHAR</code>, <code>VARCHAR</code>, <code>BLOB</code>, <code>TEXT</code>,
<code>ENUM</code> および <code>SET</code> です。

</p>
<p>
<a name="IDX241"></a>
<a name="IDX242"></a>

</p>


<h4><a name="CHAR" href="manual.ja_toc.html#CHAR">7.3.7.1  <code>CHAR</code> 型と <code>VARCHAR</code> 型</a></h4>

<p>
<code>CHAR</code> 型と <code>VARCHAR</code> 型はよく似ていますが格納、取り出しの手順に違いがあります。

</p>
<p>
<code>CHAR</code> フィールドの長さはテーブルを生成するときに宣言した長さに固定されます。長さ
は 1 から 255 までの値を取ります。<code>CHAR</code> が格納されるときには指定された長さに
なるように右側に空白が詰められます。<code>CHAR</code> の値が取り出された場合には右側
(後続)の空白は取り除かれます。

</p>
<p>
<code>VARCHAR</code> フィールドの値は可変長文字列です。
<code>VARCHAR</code> フィールドは <code>CHAR</code> フィールド
と同じく 1 から 255 までの長さに宣言できます。
(<strong>MySQL</strong> 3.23 では, <code>CHAR</code> の長さは 0 から 255 まで許されています.)
しかし <code>CHAR</code> 型と異なり <code>VARCHAR</code> 型の値は必要な文字数の分に
長さを記録する1 バイトを足した領域に格納されます。値には桁合わせのための空白はつけられ
ません。後続の空白は値の格納時に取り除かれます。(この空白の除去は ANSI
SQL仕様とは違っています。)

</p>
<p>
もし <code>CHAR</code> または <code>VARCHAR</code> フィールドに、フィールドの最大長を
越える長さの値を与えた場合は、適合するように切り詰められます。

</p>
<p>
以下の表はこれらの二つのフィールド型の違いを、<code>CHAR(4)</code> および <code>VARCHAR(4)</code> に様々
な文字列値を格納した結果を示すことで表しています。

</p>

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>値</strong> </td><td> <code>CHAR(4)</code> </td><td> <strong>必要な格納域</strong> </td><td> <code>VARCHAR(4)</code> </td><td> <strong>必要な格納域</strong>
</td></tr>
<tr><td><code>''</code> </td><td> <code>'    '</code> </td><td> 4 バイト </td><td> <code>''</code> </td><td> 1 バイト
</td></tr>
<tr><td><code>'ab'</code> </td><td> <code>'ab  '</code> </td><td> 4 バイト </td><td> <code>'ab'</code> </td><td> 3 バイト
</td></tr>
<tr><td><code>'abcd'</code> </td><td> <code>'abcd'</code> </td><td> 4 バイト </td><td> <code>'abcd'</code> </td><td> 5 バイト
</td></tr>
<tr><td><code>'abcdefgh'</code> </td><td> <code>'abcd'</code> </td><td> 4 バイト </td><td> <code>'abcd'</code> </td><td> 5 バイト
</td></tr>
</tbody></table>

<p>
<code>CHAR(4)</code> フィールドの後続の空白は取り出し時にとりのぞかれるので、CHAR(4)および
<code>VARCHAR(4)</code> から取り出される値はどの場合でも同じです。

</p>
<p>
<code>CHAR</code> および <code>VARCHAR</code> フィールドの値はテーブルの生成時に <code>BINARY</code> 属性が
つけられない限り、大文字と小文字を区別しないでソート・比較されます。<code>BINARY</code> 属性はその
列の値が大文字、小文字を区別して、MySQLサーバを実行しているマシンの
ASCII順にソート・比較されることを意味します。

</p>
<p>
<code>BINARY</code> 属性は「固定的」です。つまり、もし <code>BINARY</code> であると指定された
フィールドが式の中にあると式全体が <code>BINARY</code> の値として比較されるのです。

</p>
<p>
<strong>MySQL</strong> はテーブル生成時に何も断らずに<code>CHAR</code> または <code>VARCHAR</code> 型の
フィールドを変更する事があります。
 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

</p>
<p>
<a name="IDX243"></a>
<a name="IDX244"></a>


</p><h4><a name="BLOB" href="manual.ja_toc.html#BLOB">7.3.7.2  <code>BLOB</code> と <code>TEXT</code> 型</a></h4>

<p>
<code>BLOB</code> は大きなバイナリ型のオブジェクトで、可変長のデータを保持できます。
4 つの <code>BLOB</code> 型、すなわち <code>TINYBLOB</code>, <code>BLOB</code>,
<code>MEDIUMBLOB</code> と <code>LONGBLOB</code> は保持できるデータの最大長が違うだけです。
 「<a href="manual.ja_Reference.html#Storage_requirements">7.3.1  フィールドタイプの所要容量</a>」節参照.

</p>
<p>
4 つの <code>TEXT</code> 型、すなわち <code>TINYTEXT</code>, <code>TEXT</code>, <code>MEDIUMTEXT</code>
と <code>LONGTEXT</code> は 4 つの <code>BLOB</code> 型に対応し、同じ最大長と
格納条件を持っています。 <code>TEXT</code> と <code>BLOB</code> の違いは、
<code>TEXT</code> はケースに依存しないでソートと比較され、
<code>BLOB</code> はケースに依存して(文字コードで)比較されることだけです。
いうならば、<code>TEXT</code> は、ケースに依存しない <code>BLOB</code> です。

</p>
<p>
もし <code>BLOB</code> や <code>TEXT</code> フィールドにそれらの最大長以上の値が与えられた場合、
その値はきっちり収まるように切り落とされます。

</p>
<p>
ほとんどの点で、<code>TEXT</code> フィールドを <code>VARCHAR</code> の大きい物と見なすことが出来ます。
同様に、<code>BLOB</code> フィールドは <code>VARCHAR BINARY</code> フィールドの大きくなった物です。
違いは、

</p>

<ul>
<li>

<strong>MySQL</strong> 3.23.2 以上では、<code>BLOB</code> と <code>TEXT</code> 項に
インデックスを持つことが出来ます。それ以前のバージョンでは
インデックスをもつことが出来ません。

</li><li>

<code>VARCHAR</code> フィールドで行っているようには、<code>BLOB</code> と <code>TEXT</code> フィールドの
値の後ろについている連続した空白文字は切り落とされません。

</li><li>

<a name="IDX245"></a>
<a name="IDX246"></a>
<a name="IDX247"></a>
<code>BLOB</code> と <code>TEXT</code> 項は <code>DEFAULT</code> 値を持つことが出来ません。
</li></ul>

<p>
<code>MyODBC</code> は <code>BLOB</code> を <code>LONGVARBINARY</code> として、 
<code>TEXT</code> を <code>LONGVARCHAR</code> として定義します。

</p>
<p>
<code>BLOB</code> と <code>TEXT</code> フィールドは極端に長いので、それらを使用する際には、
いくつかの困った事にでくわすかもしれません：

</p>

<ul>
<li>

もし <code>GROUP BY</code> か <code>ORDER BY</code> を <code>BLOB</code> フィールドや <code>TEXT</code> フィールド
で使用したいなら、フィールドの値を固定長のものに変換しなくてはなりません。
標準的な方法は、 <code>SUBSTRING</code> 関数を使用することです。
たとえば：


<pre>mysql&gt; select comment from tbl_name,substring(comment,20) as substr
       ORDER BY substr;
</pre>

もしこれをしない場合、フィールドの最初の <code>max_sort_length</code> バイトが
ソート時に使用されます。 <code>max_sort_length</code> のデフォルト値は 1024; 
この値は <code>mysqld</code> サーバー起動時に <code>-O</code> オプションを使用することで
変更できます。
フィールドの位置を指定することによってか、エイリアスを使用することによって、
 <code>BLOB</code> や <code>TEXT</code> の値で group 化できます。


<pre>mysql&gt; select id,substring(blob_col,1,100) from tbl_name
           GROUP BY 2;
mysql&gt; select id,substring(blob_col,1,100) as b from tbl_name
           GROUP BY b;
</pre>

</li><li>

<code>BLOB</code> または <code>TEXT</code> オブジェクトの最大長はその型により決定されますが、
あなたがクライアントとサーバの間で実際に送ることができるは最大長は、
利用可能なメモリ量とコミュニケーションバッファのサイズによって決定されます。
メッセージバッファサイズを変えることができますが、その場合、サーバーとクライアント、
両方共に変更しなければなりません。 「<a href="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</a>」節参照.
</li></ul>

<p>
それぞれの <code>BLOB</code>, <code>TEXT</code> フィールドは、一意のアロケートされたオブジェクトによって、
内部では表されることに注意してください.。
これはテーブルが開かれるときに一度だけアロケートされる他のフィールドとは対照的です。

</p>
<p>
<a name="IDX248"></a>


</p><h4><a name="ENUM" href="manual.ja_toc.html#ENUM">7.3.7.3  <code>ENUM</code> 型</a></h4>

<p>
<code>ENUM</code> はストリングオブジェクトで、
その値は、通常、テーブル作成時のフィールド定義で列挙された値の中から選ばれます。

</p>
<p>
値はある状況下では 空文字 (<code>""</code>) か <code>NULL</code> を取ることがあります：

</p>

<ul>
<li>

もし <code>ENUM</code> に無効な値 (列挙されている値の中に含まれない文字) を
代入した場合、 そのエラーになる文字の代わりに空文字が挿入されます。

</li><li>

もし <code>ENUM</code> が <code>NULL</code> と定義された場合, <code>NULL</code> はそのフィールドで
許可される値となり、デフォルト値が <code>NULL</code> になります。
 もし <code>ENUM</code> が <code>NOT NULL</code> と定義されたならば、 デフォルト値は、
列挙リストの最初の値になります。
</li></ul>

<p>
列挙されたそれぞれの値はインデックスを持ちます：

</p>

<ul>
<li>

列挙リストの要素は 1 から付番されます。

</li><li>

空文字エラーのインデックス値は 0 。
 これは不正な <code>ENUM</code> 値が与えられているレコードを見つけるために
以下のような <code>SELECT</code> 構文が使用できることを意味します：


<pre>mysql&gt; SELECT * FROM tbl_name WHERE enum_col=0;
</pre>

</li><li>

<code>NULL</code> のインデックス値は <code>NULL</code>.
</li></ul>

<p>
たとえば、フィールドが <code>ENUM("one", "two", "three")</code> と定義されたなら、
以下に示す値をとります。 それぞれのインデックス値も示します。

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>値</strong> </td><td> <strong>インデックス</strong>
</td></tr>
<tr><td><code>NULL</code> </td><td> <code>NULL</code>
</td></tr>
<tr><td><code>""</code> </td><td> 0
</td></tr>
<tr><td><code>"one"</code> </td><td> 1
</td></tr>
<tr><td><code>"two"</code> </td><td> 2
</td></tr>
<tr><td><code>"three"</code> </td><td> 3
</td></tr>
</tbody></table>

<p>
列挙は最大 65535 個の要素まで可能です。

</p>
<p>
<code>ENUM</code> フィールドに値を与える場合は大文字小文字は無関係です。
しかし、後でフィールドから検索される値は、大文字小文字をもちます。
これはテーブル作成時に与えられたリストの値です。

</p>
<p>
もし <code>ENUM</code> を数値の文脈で検索した場合、そのメンバーを前から数えた
時の順番が数値で返ってきます。
もし <code>ENUM</code> に数値を代入しようとした場合、その数値の位置にある
メンバーが代入されます。
(しかし、これは <code>LOAD DATA</code> では働きません。これはすべての入力を文字
列として扱います。)

</p>
<p>
<code>ENUM</code> 値は列挙メンバがフィールド指定にリストされた順に従ってソートさ
れます。
(つまり、<code>ENUM</code> 値はインデックス値に従ってソートされます。)
例えば、<code>ENUM("a", "b")</code> ならば <code>"a"</code> が <code>"b"</code> の前にソートされ、
<code>ENUM("b", "a")</code> ならば <code>"b"</code> が <code>"a"</code> の前にソートされます。
空文字列は空ではない文字の前にソートされ、
<code>NULL</code> は他の列挙の前に並びます。

</p>
<p>
<code>ENUM</code> フィールドで指定可能な値のリストを全て取りたいならば、
次のようにします：
<code>SHOW COLUMNS FROM table_name LIKE enum_column_name</code>
そして二番目のフィールドの <code>ENUM</code> 定義を分析します。

</p>
<p>
<a name="IDX249"></a>


</p><h4><a name="SET" href="manual.ja_toc.html#SET">7.3.7.4  <code>SET</code> 型</a></h4>

<p>
<code>SET</code> は文字型オブジェクトでゼロかそれ以上を値持ちます。
テーブル作成時には、それぞれの値はリストから選ばれるべきです。
<code>SET</code> 型のフィールドの値は、コンマ(<samp>`,'</samp>)
区切りで並べられた複数のメンバーで構成されています。 
これは、 <code>SET</code> メンバーの値中にコンマを含むことが出来ない、
ということです。

</p>
<p>
例えば、
<code>SET("one", "two") NOT NULL</code> と指定されたフィールドは以下の値をとります：

</p>

<pre>""
"one"
"two"
"one,two"
</pre>

<p>
<code>SET</code> は最大 64 個の異なったメンバーがもてます。

</p>
<p>
<strong>MySQL</strong> は <code>SET</code> の値を数値として代入します。代入された
値の最下位のビットが最初のメンバーに対応します。もし <code>SET</code> 値を
数値の文脈で検索した場合、検索される値はフィールドの値に対応します。
もしメンバーが <code>SET</code> フィールドに代入された場合、
二進数で表される数値が、メンバーの数値として決定されます。
<code>SET("a","b","c","d")</code> とフィールドが定義されたとします。
メンバーは以下の２進数の値を持ちます：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><code>SET</code> <strong>member</strong> </td><td> <strong>10進数</strong> </td><td> <strong>２進数値</strong>
</td></tr>
<tr><td><code>a</code> </td><td> <code>1</code> </td><td> <code>0001</code>
</td></tr>
<tr><td><code>b</code> </td><td> <code>2</code> </td><td> <code>0010</code>
</td></tr>
<tr><td><code>c</code> </td><td> <code>4</code> </td><td> <code>0100</code>
</td></tr>
<tr><td><code>d</code> </td><td> <code>8</code> </td><td> <code>1000</code>
</td></tr>
</tbody></table>

<p>
もしこのフィールドに <code>9</code> を与えた場合、これは２進数で <code>1001</code> ですから、
1 番目と 4 番目の <code>SET</code> メンバーである <code>"a"</code> と <code>"d"</code> が
選択され、結果、 <code>"a,d"</code> となります。

</p>
<p>
1つ以上の <code>SET</code> 要素を含む値においては,あなたが値を挿入するとき,要素がどんな
順序で記載されているのかは重要ではありません. また,何回要素が与えられたのかは
重要ではありません. 後で値が検索されるとき, 値の中のそれぞれの要素は
ただ一回だけ表れます。そのとき、テーブル作成時に与えられた順に要素は並びます。
例えば、フィールドが <code>SET("a","b","c","d")</code> と設定されていたなら、
<code>"a,d"</code>, <code>"d,a"</code>, <code>"d,a,a,d,d"</code> は検索されると <code>"a,d"</code> と
なります。

</p>
<p>
<code>SET</code> 値は数値として代入されます。
<code>NULL</code> 値は非 <code>NULL</code> <code>SET</code> 値の前にソートされます。

</p>
<p>
通常、<code>LIKE</code> か <code>FIND_IN_SET()</code> を使用して <code>SET</code> フィールド
の <code>SELECT</code> を行います：

</p>

<pre>mysql&gt; SELECT * FROM tbl_name WHERE set_col LIKE '%value%';
mysql&gt; SELECT * FROM tbl_name WHERE FIND_IN_SET('value',set_col)&gt;0;
</pre>

<p>
しかし、以下も動作します：

</p>

<pre>mysql&gt; SELECT * FROM tbl_name WHERE set_col = 'val1,val2';
mysql&gt; SELECT * FROM tbl_name WHERE set_col &amp; 1;
</pre>

<p>
最初の文は完全一致するものを探します。
二つ目は第一番目のメンバーを含む値を探します。

</p>
<p>
もし <code>SET</code> フィールドで設定可能なすべてのメンバーを知りたい場合：
 <code>SHOW COLUMNS FROM table_name LIKE set_column_name</code> とし、
２番目にあらわされる <code>SET</code> 定義を分析します。

</p>
<p>
<a name="IDX250"></a>
<a name="IDX251"></a>


</p><h3><a name="Choosing_types" href="manual.ja_toc.html#Choosing_types">7.3.8  正しいフィールド型の選択</a></h3>

<p>
もっとも効率よく格納するには、全てにおいて一番正確な型を使用することです。
例えば、<code>1</code>-<code>99999</code> の整数
には、<code>MEDIUMINT UNSIGNED</code> が最良の型です。

</p>
<p>
良くある問題は、貨幣の値の正確な表現です。<strong>MySQL</strong> では 
<code>DECIMAL</code> 型を使用すべきです。これは文字列として格納し、正確さのロ
スは発生しません。正確さが重要でない場合は <code>DOUBLE</code> 型でも十分良い
です。

</p>
<p>
高精度のため、常に <code>BITINT</code> に格納される固定小数点型に変換できます。
これは、全ての計算を整数で行なうようにし、結果だけを浮動小数点に変換して
戻します。

</p>
<p>
<a name="IDX252"></a>
<a name="IDX253"></a>


</p><h3><a name="Indexes" href="manual.ja_toc.html#Indexes">7.3.9  フィールドインデックス</a></h3>

<p>
<strong>MySQL</strong> の全てのフィールドはインデックスを持つことができます。
適切なフィールドでのインデックスの使用は、<code>SELECT</code> の
性能を向上する最良の方法です。

</p>
<p>
一つのテーブルには最大16個のインデックスが許されます。
インデックスの最大長は256バイトで、
これは <strong>MySQL</strong> コンパイル時に変更できます。

</p>
<p>
<code>CHAR</code> と <code>VARCHAR</code> フィールドには接頭部にインデックスを持つことができます。
フィールド全体をインデックス化するより、
これははるかに早く、少ないディスク容量でできます。

</p>
<p>
<code>CREATE TABLE</code> 構文でフィールドにインデックスを作るには、
以下のようにします：

</p>

<pre>KEY index_name (col_name(length))
</pre>

<p>
以下の例は <code>name</code> フィールドの最初の10文字にインデックスを創り出します:

</p>

<pre>mysql&gt; CREATE TABLE test (
          name CHAR(200) NOT NULL,
          KEY index_name (name(10)));
</pre>

<p>
 <code>BLOB</code> と <code>TEXT</code> フィールドでは、そのフィールドの頭の部分に
インデックスを張らなくてはなりません。 フィールドの全体にインデックスは張れません。

</p>



<h3><a name="Multiple-column_indexes" href="manual.ja_toc.html#Multiple-column_indexes">7.3.10  複数フィールドインデックス</a></h3>

<p>
<strong>MySQL</strong> は異なるフィールドのセットに一つのインデックスを持つことができます。
インデックスは最大15個のコラムまで許されます。
(<code>CHAR</code> と <code>VARCHAR</code> フィールドの接頭部をインデックスとして使用できます)

</p>
<p>
複数フィールドインデックスは、
ソートされた配列(インデックス化されたフィールドの値が結合されている配列)
　を扱うことができます。

</p>
<p>
インデックス化されたコラムに対して、既知の値を <code>WHERE</code> 節で指定した時、
たとえ他のフィールドの値を指定しなくとも、
<strong>MySQL</strong> は複数フィールドインデックスを使用します。

</p>
<p>
以下のテーブルがあると仮定してください：

</p>

<pre>mysql&gt; CREATE TABLE test (
           id INT NOT NULL,
           last_name CHAR(30) NOT NULL,
           first_name CHAR(30) NOT NULL,
           PRIMARY KEY (id),
           INDEX name (last_name,first_name));
</pre>

<p>
<code>name</code> インデックスは、<code>last_name</code> と <code>first_name</code> にまたがるインデックスです。
このインデックスは、<code>last_name</code> に対するクエリや、
<code>name</code> インデックスは以下のクエリで使われます：

</p>

<pre>mysql&gt; SELECT * FROM test WHERE last_name="Widenius";

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
                          AND first_name="Michael";

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
                          AND (first_name="Michael" OR first_name="Monty");

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
                          AND first_name &gt;="M" AND first_name &lt; "N";
</pre>

<p>
しかし <code>name</code> インデックスは以下のクエリでは使用されません:

</p>

<pre>mysql&gt; SELECT * FROM test WHERE first_name="Michael";

mysql&gt; SELECT * FROM test WHERE last_name="Widenius"
　　　　　　　　　　　　OR first_name="Michael";
</pre>

<p>
<strong>MySQL</strong> がクエリの性能を上げるためにどうインデックスを使用しているか、
より詳しい情報はこちら：  「<a href="manual.ja_Performance.html#MySQL_indexes">12.4  MySQL はどのようにインデックスを使用するか？</a>」節.

</p>

<p>
<a name="IDX254"></a>


</p><h3><a name="Other-vendor_column_types" href="manual.ja_toc.html#Other-vendor_column_types">7.3.11  他のデータベースエンジンのフィールド型の使用</a></h3>

<p>
ほかのベンダーからSQLを簡単に書けれるように、 <strong>MySQL</strong> は以下の表に
しめすフィールド型をサポートします。これらは、テーブルの定義を、
他のデータベースエンジンから <strong>MySQL</strong> に簡単に移行させてくれます：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Other vendor type</strong> </td><td> <strong>MySQL type</strong>
</td></tr>
<tr><td><code>BINARY(NUM)</code> </td><td> <code>CHAR(NUM) BINARY</code>
</td></tr>
<tr><td><code>CHAR VARYING(NUM)</code> </td><td> <code>VARCHAR(NUM)</code>
</td></tr>
<tr><td><code>FLOAT4</code> </td><td> <code>FLOAT</code>
</td></tr>
<tr><td><code>FLOAT8</code> </td><td> <code>DOUBLE</code>
</td></tr>
<tr><td><code>INT1</code> </td><td> <code>TINYINT</code>
</td></tr>
<tr><td><code>INT2</code> </td><td> <code>SMALLINT</code>
</td></tr>
<tr><td><code>INT3</code> </td><td> <code>MEDIUMINT</code>
</td></tr>
<tr><td><code>INT4</code> </td><td> <code>INT</code>
</td></tr>
<tr><td><code>INT8</code> </td><td> <code>BIGINT</code>
</td></tr>
<tr><td><code>LONG VARBINARY</code> </td><td> <code>MEDIUMBLOB</code>
</td></tr>
<tr><td><code>LONG VARCHAR</code> </td><td> <code>MEDIUMTEXT</code>
</td></tr>
<tr><td><code>MIDDLEINT</code> </td><td> <code>MEDIUMINT</code>
</td></tr>
<tr><td><code>VARBINARY(NUM)</code> </td><td> <code>VARCHAR(NUM) BINARY</code>
</td></tr>
</tbody></table>

<p>
もし他のベンダーの型を使用してテーブルを作ろうとすると、
テーブル作成時のフィールドの型のマッピングが発生し、
<code>DESCRIBE tbl_name</code> 構文を発行します。
そして <strong>MySQL</strong> は、使用された型と等価な <strong>MySQL</strong> の型を用いて
テーブルを構成したことを告げます。

</p>
<p>
<a name="IDX255"></a>


</p><h2><a name="Functions" href="manual.ja_toc.html#Functions">7.4  <code>SELECT</code> と <code>WHERE</code> 節で使用する関数</a></h2>

<p>
SQL ステートメント中の <code>select_expression</code> または 
<code>where_definition</code> は後述の関数を使用した任意の式からなります。

</p>
<p>
演算と関数を式の中で呼ぶ時、本ドキュメントに示しているもの以外の、
<code>NULL</code> を含む式は常に <code>NULL</code> 値を生成します

</p>
<p>
<strong>注意:</strong> 関数名とそれに続く語句の間には、空白はありません。
これは関数の呼び出しと、関数と同名のテーブル(かフィールド)の参照を、
 <strong>MySQL</strong> パーサが区別するのを助けます。

</p>
<p>
次の例では、<code>mysql</code> プログラムの出力は短くなっています。つまり:

</p>

<pre>mysql&gt; select MOD(29,9);
1 rows in set (0.00 sec)

+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+
</pre>

<p>
これは次に変換されています:

</p>

<pre>mysql&gt; select MOD(29,9);
        -&gt; 2
</pre>



<h3><a name="Grouping_functions" href="manual.ja_toc.html#Grouping_functions">7.4.1  グループ化関数</a></h3>
<p>
<a name="IDX256"></a>
</p><dl compact="">

<dt><code>( ... )</code>
</dt><dd>
<a name="IDX257"></a>
 <a name="IDX258"></a>
 
丸かっこ。 式の評価の優先度を強制するために使用します。

<pre>mysql&gt; select 1+2*3;
        -&gt; 7
mysql&gt; select (1+2)*3;
        -&gt; 9
</pre>

</dd></dl>



<h3><a name="Arithmetic_functions" href="manual.ja_toc.html#Arithmetic_functions">7.4.2  通常の算術演算</a></h3>

<p>
普通の算術演算が有効です。
<code>-</code>, <code>+</code>, <code>*</code> は、二つの引数が正数ならば
 <code>BIGINT</code> (64bit精度) で計算されることに注意してください！

</p>
<p>
<a name="IDX259"></a>
</p><dl compact="">

<dt><code>+</code>
</dt><dd>
<a name="IDX260"></a>
 <a name="IDX261"></a>
 
足し算

<pre>mysql&gt; select 3+5;
        -&gt; 8
</pre>

<a name="IDX262"></a>
<a name="IDX263"></a>
</dd><dt><code>-</code>
</dt><dd>
引き算

<pre>mysql&gt; select 3-5;
        -&gt; -2
</pre>

<a name="IDX264"></a>
<a name="IDX265"></a>
</dd><dt><code>*</code>
</dt><dd>
掛け算

<pre>mysql&gt; select 3*5;
        -&gt; 15
mysql&gt; select 18014398509481984*18014398509481984.0;
        -&gt; 324518553658426726783156020576256.0
mysql&gt; select 18014398509481984*18014398509481984;
        -&gt; 0
</pre>

最後の式の結果は不当です。なぜなら結果は 64 ビットを超えた整数だからです。

<a name="IDX266"></a>
<a name="IDX267"></a>
</dd><dt><code>/</code>
</dt><dd>
割り算。

<pre>mysql&gt; select 3/5;
        -&gt; 0.60
</pre>

0 で割った場合、<code>NULL</code> になります。


<pre>mysql&gt; select 102/(1-1);
        -&gt; NULL
</pre>

演算結果が整数になる場合にだけ、 <code>BIGINT</code> を用いて割り算は計算されます。
</dd></dl>

<p>
<a name="IDX268"></a>
<a name="IDX269"></a>
<a name="IDX270"></a>
<a name="IDX271"></a>


</p><h3><a name="Bit_functions" href="manual.ja_toc.html#Bit_functions">7.4.3  ビット関数</a></h3>

<p>
これらは最大 64 ビットの範囲を持ちます。<strong>MySQL</strong> は <code>BIGINT</code> (64-bit) 演算を使用するためです。

</p>
<dl compact="">

<dt><code>|</code>
</dt><dd>
<a name="IDX272"></a>
 <a name="IDX273"></a>
 
ビット演算 OR

<pre>mysql&gt; select 29 | 15;
        -&gt; 31
</pre>

<a name="IDX274"></a>
<a name="IDX275"></a>
</dd><dt><code>&amp;</code>
</dt><dd>
ビット演算 AND

<pre>mysql&gt; select 29 &amp; 15;
        -&gt; 13
</pre>

<a name="IDX276"></a>
</dd><dt><code>&lt;&lt;</code>
</dt><dd>
左に longlong (<code>BIGINT</code>) number 分、ビットをシフトします

<pre>mysql&gt; select 1 &lt;&lt; 2
        -&gt; 4
</pre>

<a name="IDX277"></a>
</dd><dt><code>&gt;&gt;</code>
</dt><dd>
右に longlong (<code>BIGINT</code>) number 分、ビットをシフトします

<pre>mysql&gt; select 4 &gt;&gt; 2
        -&gt; 1
</pre>

<a name="IDX278"></a>
</dd><dt><code>~</code>
</dt><dd>
Invert all bits.

<pre>mysql&gt; select 5 &amp; ~1
        -&gt; 4
</pre>

<a name="IDX279"></a>
</dd><dt><code>BIT_COUNT(N)</code>
</dt><dd>
引数 <code>N</code> がいくつビットを持っているか(２進数表記したときの１の数)

<pre>mysql&gt; select BIT_COUNT(29);
        -&gt; 4
</pre>

</dd></dl>

<p>
<a name="IDX280"></a>


</p><h3><a name="Logical_functions" href="manual.ja_toc.html#Logical_functions">7.4.4  論理演算</a></h3>

<p>
全ての論理関数は <code>1</code> (TRUE) or <code>0</code> (FALSE) を返します。

</p>
<dl compact="">

<dt><code>NOT</code>
</dt><dd>
<a name="IDX281"></a>
 <a name="IDX282"></a>
 
</dd><dt><code>!</code>
</dt><dd>
論理否定。引数が <code>0</code> なら <code>1</code> を返し、そうでなければ <code>0</code> を返します。
例外: <code>NOT NULL</code> は <code>NULL</code> を返します.

<pre>mysql&gt; select NOT 1;
        -&gt; 0
mysql&gt; select NOT NULL;
        -&gt; NULL
mysql&gt; select ! (1+1);
        -&gt; 0
mysql&gt; select ! 1+1;
        -&gt; 1
</pre>

最後の例は <code>1</code> を返します。なぜなら、式の評価が
 <code>(!1)+1</code> と同じだからです。

<a name="IDX283"></a>
<a name="IDX284"></a>
</dd><dt><code>OR</code>
</dt><dd>
</dd><dt><code>||</code>
</dt><dd>
論理和。引数のどれかが <code>0</code> または <code>NULL</code> でなければ <code>1</code> を返します。

<pre>mysql&gt; select 1 || 0;
        -&gt; 1
mysql&gt; select 0 || 0;
        -&gt; 0
mysql&gt; select 1 || NULL;
        -&gt; 1

</pre>

<a name="IDX285"></a>
<a name="IDX286"></a>
</dd><dt><code>AND</code>
</dt><dd>
</dd><dt><code>&amp;&amp;</code>
</dt><dd>
論理積。全ての引数が <code>0</code> または <code>NULL</code> でなければ <code>1</code> を返します。

<pre>mysql&gt; select 1 &amp;&amp; NULL;
        -&gt; 0
mysql&gt; select 1 &amp;&amp; 0;
        -&gt; 0
</pre>

</dd></dl>

<p>
<a name="IDX287"></a>
<a name="IDX288"></a>
<a name="IDX289"></a>


</p><h3><a name="Comparison_functions" href="manual.ja_toc.html#Comparison_functions">7.4.5  比較演算子</a></h3>

<p>
<code>1</code> (TRUE), <code>0</code> (FALSE) または <code>NULL</code> を返します。
これらの関数は数値と文字列の両方で働きます。
必要ならば、文字は自動的に数字に変換され、数字は文字に変換されます。
(Perlがおこなっているみたいに)

</p>
<p>
<strong>MySQL</strong> は以下の規則で比較を行います：

</p>

<ul>
<li>

どちらかまたは両方の引数が <code>NULL</code> の場合は、比較結果は <code>NULL</code> 
です。<code>&lt;=&gt;</code> 演算子を除きます。

</li><li>

比較操作の両方の引数が文字列の場合、文字列として比較されます。

</li><li>

両方の引数が整数の場合、整数として比較されます。

</li><li>

16進数の値は、もし数値と比較されないのであれば、文字列として扱われます。

</li><li>

<a name="IDX290"></a>
<a name="IDX291"></a>
引数の一方が <code>TIMESTAMP</code> または <code>DATETIME</code> フィールドで、他の引数が
定数の場合は、定数は比較前に timestamp に変換されます。これはより ODBC 
フレンドリにするためです。

</li><li>

他の場合は全て浮動小数点(real)として比較されます。
</li></ul>

<p>
文字列の比較は、ケースに依存せず、標準のキャラクターセットに従って
行われます。(ISO-8859-1 Latin1 がデフォルトです。これは English です)

</p>
<p>
以下は、比較のために文字が数値へ変換されている例です：

</p>

<pre>mysql&gt; SELECT 1 &gt; '6x';
         -&gt; 0
mysql&gt; SELECT 7 &gt; '6x';
         -&gt; 1
mysql&gt; SELECT 0 &gt; 'x6';
         -&gt; 0
mysql&gt; SELECT 0 = 'x6';
         -&gt; 1
</pre>

<dl compact="">

<dt><code>=</code>
</dt><dd>
<a name="IDX292"></a>
 <a name="IDX293"></a>
 
等しい

<pre>mysql&gt; select 1 = 0;
        -&gt; 0
mysql&gt; select '0' = 0;
        -&gt; 1
mysql&gt; select '0.0' = 0;
        -&gt; 1
mysql&gt; select '0.01' = 0;
        -&gt; 0
mysql&gt; select '.01' = 0.01;
        -&gt; 1
</pre>

<a name="IDX294"></a>
<a name="IDX295"></a>
<a name="IDX296"></a>
<a name="IDX297"></a>
</dd><dt><code>&lt;&gt;</code>
</dt><dd>
</dd><dt><code>!=</code>
</dt><dd>
等しくない

<pre>mysql&gt; select '.01' &lt;&gt; '0.01';
        -&gt; 1
mysql&gt; select .01 &lt;&gt; '0.01';
        -&gt; 0
mysql&gt; select 'zapp' &lt;&gt; 'zappp';
        -&gt; 1
</pre>

<a name="IDX298"></a>
<a name="IDX299"></a>
</dd><dt><code>&lt;=</code>
</dt><dd>
より小さいか等しい

<pre>mysql&gt; select 0.1 &lt;= 2;
        -&gt; 1
</pre>

<a name="IDX300"></a>
<a name="IDX301"></a>
</dd><dt><code>&lt;</code>
</dt><dd>
より小さい

<pre>mysql&gt; select 2 &lt;= 2;
        -&gt; 1
</pre>

<a name="IDX302"></a>
<a name="IDX303"></a>
</dd><dt><code>&gt;=</code>
</dt><dd>
より大きいか等しい

<pre>mysql&gt; select 2 &gt;= 2;
        -&gt; 1
</pre>

<a name="IDX304"></a>
<a name="IDX305"></a>
</dd><dt><code>&gt;</code>
</dt><dd>
より大きい

<pre>mysql&gt; select 2 &gt; 2;
        -&gt; 0
</pre>

<a name="IDX306"></a>
</dd><dt><code>&lt;=&gt;</code>
</dt><dd>
等しい(NULL 安全)

<pre>mysql&gt; select 1 &lt;=&gt; 1, NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULL;
        -&gt; 1 1 0
</pre>

<a name="IDX307"></a>
<a name="IDX308"></a>
</dd><dt><code>IS NULL</code>
</dt><dd>
</dd><dt><code>IS NOT NULL</code>
</dt><dd>
値が <code>NULL</code> とであるかどうかのテスト

<pre>mysql&gt; select 1 IS NULL, 0 IS NULL, NULL IS NULL:
        -&gt; 0 0 1
mysql&gt; select 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL;
        -&gt; 1 1 0
</pre>

<a name="IDX309"></a>
</dd><dt><code>expr BETWEEN min AND max</code>
</dt><dd>
もし <code>expr</code> が <code>min</code> 以上、 <code>max</code> 以下なら <code>1</code>を返します。
そうでないなら <code>0</code> を返します。
これは 全ての引数が同じ型ならば、<code>(min &lt;= expr AND expr &lt;= max)</code> と同じです。
 最初の引数 (<code>expr</code>) はいかのように比較方法を決定します。


<ul>
<li>

もし <code>exor</code> が <code>TIMESTAMP</code>, <code>DATE</code>, <code>DATETIME</code> フィー
ルドなら、最小と最大はそれらが定数の場合と同じフォーマットになります。
</li><li>

もし <code>expr</code> が文字式なら、ケース非依存で比較が行われます。
</li><li>

もし <code>expr</code> がバイナリ文字なら、ケース依存で比較が行われます。
</li><li>

もし <code>expr</code> が整数なら、整数で比較が行われます。
</li><li>

その他は浮動小数点(実数)で比較されます。
</li></ul>


<pre>mysql&gt; select 1 BETWEEN 2 AND 3;
        -&gt; 0
mysql&gt; select 'b' BETWEEN 'a' AND 'c';
        -&gt; 1
mysql&gt; select 2 BETWEEN 2 AND '3';
        -&gt; 1
mysql&gt; select 2 BETWEEN 2 AND 'x-3';
        -&gt; 0
</pre>

<a name="IDX310"></a>
</dd><dt><code>expr IN (value,...)</code>
</dt><dd>
もし <code>expr</code> が <code>IN</code> リストにある値のどれかならば、<code>1</code> を返します。
そうでなければ <code>0</code> を返します。
もし全ての値が定数なら、すべての値が <code>expr</code> の型に従って評価され、
ソートされます。この検索にはバイナリサーチが使用されます。
これは <code>IN</code> リストに定数を与えた場合、<code>IN</code> が速くなることを意味します。
もし <code>expr</code> がケース依存の文字式なら、ケース依存のやり方で比較されます。

<pre>mysql&gt; select 2 IN (0,3,5,'wefwf');
        -&gt; 0
mysql&gt; select 'wefwf' IN (0,3,5,'wefwf');
        -&gt; 1
</pre>

<a name="IDX311"></a>
</dd><dt><code>expr NOT IN (value,...)</code>
</dt><dd>
<code>NOT (expr IN (value,...))</code> と同じ。

<a name="IDX312"></a>
</dd><dt><code>ISNULL(expr)</code>
</dt><dd>
<code>expr</code> が <code>NULL</code> なら <code>1</code> を、そうでなければ <code>0</code> を返します。

<pre>mysql&gt; select ISNULL(1+1);
        -&gt; 0
mysql&gt; select ISNULL(1/0);
        -&gt; 1
</pre>

<code>NULL</code> の値を <code>=</code> を使用して比較した場合は常に偽(false) となることに
注意してください！

<a name="IDX313"></a>
</dd><dt><code>COALESCE(list)</code>
</dt><dd>
list 中の、最初に現れた 非-<code>NULL</code> 要素を返します。


<pre>mysql&gt; select COALESCE(NULL,1);
        -&gt; 1
mysql&gt; select COALESCE(NULL,NULL,NULL);
        -&gt; NULL
</pre>

<a name="IDX314"></a>
</dd><dt><code>INTERVAL(N,N1,N2,N3,...)</code>
</dt><dd>
もし <code>N</code> &lt; <code>N1</code> なら <code>0</code> を返します。
もし <code>N</code> &lt; <code>N2</code> なら <code>1</code> を返します。
全ての引数は整数として扱われます。
これは <code>N1</code> &lt; <code>N2</code> &lt; <code>N3</code> &lt; <code>...</code> &lt; <code>Nn</code>を正しく動作させるために
必要なことです。これはバイナリ検索が使用されます(速いです)


<pre>mysql&gt; select INTERVAL(23, 1, 15, 17, 30, 44, 200);
        -&gt; 3
mysql&gt; select INTERVAL(10, 1, 10, 100, 1000);
        -&gt; 2
mysql&gt; select INTERVAL(22, 23, 30, 44, 200);
        -&gt; 0
</pre>

</dd></dl>

<p>
<a name="IDX315"></a>
<a name="IDX316"></a>


</p><h3><a name="String_comparison_functions" href="manual.ja_toc.html#String_comparison_functions">7.4.6  文字列比較関数</a></h3>

<p>
<a name="IDX317"></a>
<a name="IDX318"></a>
通常、比較される表現がケース依存でない場合、比較はケース非依存で行われます。

</p>
<dl compact="">

<dt><code>expr LIKE pat [ESCAPE 'escape-char']</code>
</dt><dd>
<a name="IDX319"></a>
 
SQL の簡単な正規表現比較です。<code>1</code> (TRUE) または <code>0</code> (FALSE) を返します。
<code>LIKE</code> には2つのワイルドカードがあります:

<table border="" width="100%" nosave="">
<tbody><tr><td><code>%</code> </td><td> 任意の数の文字(0文字も含む)に適合します。
</td></tr>
<tr><td><code>_</code> </td><td> 厳密に1つの文字に適合します。
</td></tr>
</tbody></table>


<pre>mysql&gt; select 'David!' LIKE 'David_';
        -&gt; 1
mysql&gt; select 'David!' LIKE '%D%v%';
        -&gt; 1
</pre>

ワイルドカード文字のテストをするためには、エスケープ文字より先行しておこなって
ください。
<code>ESCAPE</code> を指定しない場合は、文字 <code>'\'</code> が使われます:

<table border="" width="100%" nosave="">
<tbody><tr><td><code>\%</code> </td><td> 1つの <code>%</code> に適合します。
</td></tr>
<tr><td><code>\_</code> </td><td> 1つの <code>_</code> に適合します。
</td></tr>
</tbody></table>


<pre>mysql&gt; select 'David!' LIKE 'David\_';
        -&gt; 0
mysql&gt; select 'David_' LIKE 'David\_';
        -&gt; 1
</pre>

違うエスケープ文字を指定するには、 <code>ESCAPE</code> 節を使用します:


<pre>mysql&gt; select 'David_' LIKE 'David|_' ESCAPE '|';
        -&gt; 1
</pre>

<code>LIKE</code> は数値表現でも許されます！
(これは <strong>MySQL</strong> の、ANSI SQL <code>LIKE</code> に対する拡張です)

注意： <strong>MySQL</strong> は文字列中に C のエスケープ文字を使用しているので(e.g.,
<samp>`\n'</samp>),  <code>LIKE</code> の指定文字列として使用するには <samp>`\'</samp> を
二倍しなくてはなりません。 例えば、 <samp>`\n'</samp> を探すには、<samp>`\\n'</samp> と
記述します。 <samp>`\'</samp> を探すには、  <samp>`\\\\'</samp> (バックスラッシュは、
一つはパーサーに取り除かれ、パターンマッチが行われる際にもうひとつ
取り除かれ、一致を探すために残った一つのバックスラッシュが使用されます)

<a name="IDX320"></a>
</dd><dt><code>expr NOT LIKE pat [ESCAPE 'escape-char']</code>
</dt><dd>
<code>NOT (expr LIKE pat [ESCAPE 'escape-char'])</code> と同じ


<pre>mysql&gt; select 10 LIKE '1%';
        -&gt; 1
</pre>

<a name="IDX321"></a>
<a name="IDX322"></a>
<a name="IDX323"></a>
<a name="IDX324"></a>
</dd><dt><code>expr REGEXP pat</code>
</dt><dd>
</dd><dt><code>expr RLIKE pat</code>
</dt><dd>
パターン <code>pat</code> に対し、文字式 <code>expr</code> のパターンマッチを行います。
パターン <code>pat</code> は正規表現の拡張が使用できます。 「<a href="manual.ja_Regexp.html#Regexp">I  MySQL の正規表現の文法について</a>」節参照.
もし <code>expr</code> が <code>pat</code> にマッチするなら <code>1</code> を返し、
でなければ <code>0</code> を返します。
<code>RLIKE</code> は <code>REGEXP</code> と同義で、<code>mSQL</code> 互換を提供します。
注意: <strong>MySQL</strong> は C エスケープ構文を文字中に使用しており(<code>\n</code>)、
 <code>REGEXP</code> 中で使用される <code>'\'</code> 文字はすべて、二重に書かなければ
なりません。
<code>MySQL</code> 3.23.4 <code>REGEXP</code> は、普通の文字 (not binary) はケース非依存です。


<pre>mysql&gt; select 'Monty!' REGEXP 'm%y%%';
        -&gt; 0
mysql&gt; select 'Monty!' REGEXP '.*';
        -&gt; 1
mysql&gt; select 'new*\n*line' REGEXP 'new\\*.\\*line';
        -&gt; 1
mysql&gt; select "a" REGEXP "A", "a" REGEXP BINARY "A";
        -&gt; 1  0
</pre>

</dd><dt><code></code>
</dt><dd>
<code>REGEXP</code> and <code>RLIKE</code> は、文字の型を決定する場合、
カレントのキャラクターセットを使用します。
(ISO-8859-1 Latin1 がデフォルト)

<a name="IDX325"></a>
</dd><dt><code>expr NOT REGEXP pat</code>
</dt><dd>
</dd><dt><code>expr NOT RLIKE pat</code>
</dt><dd>
<code>NOT (expr REGEXP pat)</code> と同じ.

<a name="IDX326"></a>
</dd><dt><code>STRCMP(expr1,expr2)</code>
</dt><dd>
文字列が同じなら <code>0</code> を返します。そうでなければ、最初の引数がソート順で小
さければ <code>-1</code> を返します。そうでなければ <code>1</code> を返します。


<pre>mysql&gt; select STRCMP('text', 'text2');
        -&gt; -1
mysql&gt; select STRCMP('text2', 'text');
        -&gt; 1
mysql&gt; select STRCMP('text', 'text');
        -&gt; 0
</pre>

</dd></dl>

<p>
<a name="IDX327"></a>


</p><h3><a name="Casts" href="manual.ja_toc.html#Casts">7.4.7  Cast operators</a></h3>

<dl compact="">

<dt><code><code>BINARY</code></code>
</dt><dd>
<a name="IDX328"></a>
 
<code>BINARY</code> 演算子は、これ以降に続く文字をバイナリにキャストします。
これはたとえフィールドが <code>BINARY</code> や <code>BLOB</code> 定義でなくても、
ケース依存でフィールドを比較することが出来る簡単な方法です。

<pre>mysql&gt; select "a" = "A";
        -&gt; 1
mysql&gt; select BINARY "a" = "A";
        -&gt; 0
</pre>

<code>BINARY</code> は <strong>MySQL</strong> 3.23.0 で登場しました。
</dd></dl>

<p>
<a name="IDX329"></a>
<a name="IDX330"></a>


</p><h3><a name="Control_flow_functions" href="manual.ja_toc.html#Control_flow_functions">7.4.8  フロー制御関数</a></h3>

<dl compact="">

<dt><code>IFNULL(expr1,expr2)</code>
</dt><dd>
<a name="IDX331"></a>
 
<code>expr1</code> が <code>NULL</code> でない場合は <code>expr1</code> を、そうでなければ 
<code>expr2</code> を返します。
<code>IFNULL()</code> はどの文脈で使用されたかにより数値か文字を返します。

<pre>mysql&gt; select IFNULL(1,0);
        -&gt; 1
mysql&gt; select IFNULL(0,10);
        -&gt; 0
mysql&gt; select IFNULL(1/0,10);
        -&gt; 10
mysql&gt; select IFNULL(1/0,'yes');
        -&gt; 'yes'
</pre>

<a name="IDX332"></a>
</dd><dt><code>NULLIF(expr1,expr2)</code>
</dt><dd>
<code>expr1 = expr2</code> が真なら、<code>expr1</code> を返し、そうでなければ 
<code>NULL</code> を返します。

<pre>mysql&gt; select NULLIF(1,1);
        -&gt; 1
mysql&gt; select NULLIF(1,2);
        -&gt; NULL
</pre>

注意: 引数が等しい場合、<code>expr1</code> は <strong>MySQL</strong> では2回評価されます。

<a name="IDX333"></a>
</dd><dt><code>IF(expr1,expr2,expr3)</code>
</dt><dd>
<code>expr1</code> が真 (<code>expr1 &lt;&gt; 0</code> and <code>expr1 &lt;&gt; NULL</code>) の場合
 <code>expr2</code> を返し、そうでなければ <code>expr3</code> を返します。
<code>IF()</code> はどの文脈で使用されたかにより数値か文字を返します。


<pre>mysql&gt; select IF(1&gt;2,2,3);
        -&gt; 3
mysql&gt; select IF(1&lt;2,'yes','no');
        -&gt; 'yes'
mysql&gt; select IF(strcmp('test','test1'),'no','yes');
        -&gt; 'no'
</pre>

<code>expr1</code> は <code>INTEGER</code> として評価されます。これは浮動小数点を使用する場合、
比較演算も使用すべきであることを意味します。


<pre>mysql&gt; select IF(0.1,1,0);
        -&gt; 0
mysql&gt; select IF(0.1&lt;&gt;0,1,0);
        -&gt; 1
</pre>

上の最初の例では、 <code>IF(0.1)</code> は <code>0</code> を返します。なぜなら <code>0.1</code> は
整数値として変換され <code>IF(0)</code> になり、それをもとにしたテスト結果が
返るからです。 これはあなたの期待に添わないかもしれません。
 二番目の場合、 比較は、元の浮動小数点値が非ゼロかどうかテストします。
比較結果は整数として使用されます。

<code>IF()</code> のデフォルトの戻り値型(一時テーブルに格納される時に問題となり
ます)は <strong>MySQL</strong> 3.23 では次のように計算されます:

<table border="" width="100%" nosave="">
<tbody><tr><td>expr2 または expr3 が文字列を返す </td><td> 文字列
</td></tr>
<tr><td>expr2 または expr3 が浮動小数点値を返す </td><td> 浮動小数点
</td></tr>
<tr><td>expr2 または expr3 が整数を返す </td><td> 整数
</td></tr>
</tbody></table>

<a name="IDX334"></a>
</dd><dt><code>CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END</code>
</dt><dd>
</dd><dt><code>CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END</code>
</dt><dd>
最初の式は <code>value=compare-value</code> ならば <code>result</code> を返します。
二つ目の式では、最初の条件[condition] が真ならば、 <code>result</code> を返します。
もしマッチする result の値がなければ、 <code>ELSE</code> 以下の result が返ります。
もし <code>ELSE</code> 部分がなければ、 <code>NULL</code> が返ります。


<pre>mysql&gt; SELECT CASE 1 WHEN 1 THEN "one" WHEN 2 THEN "two" ELSE "more" END;
       -&gt; "one"
mysql&gt; SELECT CASE WHEN 1&gt;0 THEN "true" ELSE "false" END;
       -&gt; "true"
mysql&gt; SELECT CASE BINARY "B" when "a" then 1 when "b" then 2 END;
       -&gt; NULL
</pre>

</dd></dl>

<p>
<a name="IDX335"></a>
<a name="IDX336"></a>


</p><h3><a name="Mathematical_functions" href="manual.ja_toc.html#Mathematical_functions">7.4.9  数学関数</a></h3>
<p>
すべての数学関数はエラーの場合 <code>NULL</code> を返します。

</p>
<dl compact="">

<dt><code>-</code>
</dt><dd>
<a name="IDX337"></a>
 <a name="IDX338"></a>
 <a name="IDX339"></a>
 
符号。引数の符号を変更します。

<pre>mysql&gt; select - 2;
        -&gt; -2
</pre>

このオペレーターが <code>BIGINT</code> とともに使用された場合、
返り値は <code>BIGINT</code> であることに注意してください!  これは <code>-2^63</code> の値を
持つかもしれない整数を、 <code>-</code> で使用してはならないことを意味します！

<a name="IDX340"></a>
</dd><dt><code>ABS(X)</code>
</dt><dd>
Returns the absolute value of <code>X</code>.

<pre>mysql&gt; select ABS(2);
        -&gt; 2
mysql&gt; select ABS(-32);
        -&gt; 32
</pre>

この関数は <code>BIGINT</code> 値とともに使用されると安全です。

<a name="IDX341"></a>
</dd><dt><code>SIGN(X)</code>
</dt><dd>
<code>X</code> が負数、ゼロ、整数によって、 <code>-1</code>, <code>0</code> or <code>1</code> を
返します。

<pre>mysql&gt; select SIGN(-32);
        -&gt; -1
mysql&gt; select SIGN(0);
        -&gt; 0
mysql&gt; select SIGN(234);
        -&gt; 1
</pre>

<a name="IDX342"></a>
<a name="IDX343"></a>
<a name="IDX344"></a>
</dd><dt><code>MOD(N,M)</code>
</dt><dd>
</dd><dt><code>%</code>
</dt><dd>
剰余 ( C の <code>%</code> 演算子のような ).
<code>N</code> を <code>M</code> で割ったときの余りが返ります。

<pre>mysql&gt; select MOD(234, 10);
        -&gt; 4
mysql&gt; select 253 % 7;
        -&gt; 1
mysql&gt; select MOD(29,9);
        -&gt; 2
</pre>

この関数は <code>BIGINT</code> 値でも安全に使用できます。

<a name="IDX345"></a>
</dd><dt><code>FLOOR(X)</code>
</dt><dd>
<code>X</code> より大きくならない整数のうち、最大の整数値を返します.

<pre>mysql&gt; select FLOOR(1.23);
        -&gt; 1
mysql&gt; select FLOOR(-1.23);
        -&gt; -2
</pre>

返り値は <code>BIGINT</code> に変換されていることに注意!

<a name="IDX346"></a>
</dd><dt><code>CEILING(X)</code>
</dt><dd>
<code>X</code> より小さくならない整数のうち、最小の整数値を返します.

<pre>mysql&gt; select CEILING(1.23);
        -&gt; 2
mysql&gt; select CEILING(-1.23);
        -&gt; -1
</pre>

返り値は <code>BIGINT</code> に変換されていることに注意!

<a name="IDX347"></a>
</dd><dt><code>ROUND(X)</code>
</dt><dd>
<code>X</code> を整数に丸めた値(四捨五入)を返します。

<pre>mysql&gt; select ROUND(-1.23);
        -&gt; -1
mysql&gt; select ROUND(-1.58);
        -&gt; -2
mysql&gt; select ROUND(1.58);
        -&gt; 2
</pre>

返り値は <code>BIGINT</code> に変換されていることに注意!

<a name="IDX348"></a>
</dd><dt><code>ROUND(X,D)</code>
</dt><dd>
<code>X</code> を <code>D</code> で指定した少数桁に丸めた値(四捨五入)を返します。
もし <code>D</code> が <code>0</code> なら, 結果は小数点無しになるか
少数部分になるでしょう。

<pre>mysql&gt; select ROUND(1.298, 0);
        -&gt; 1
</pre>

<a name="IDX349"></a>
</dd><dt><code>EXP(X)</code>
</dt><dd>
指数関数 : <code>e</code> (自然対数の底) の <code>X</code> 乗。

<pre>mysql&gt; select EXP(2);
        -&gt; 7.389056
mysql&gt; select EXP(-2);
        -&gt; 0.135335
</pre>

<a name="IDX350"></a>
</dd><dt><code>LOG(X)</code>
</dt><dd>
自然対数 <code>X</code>

<pre>mysql&gt; select LOG(2);
        -&gt; 0.693147
mysql&gt; select LOG(-2);
        -&gt; NULL
</pre>

If you want the log of a number <code>X</code> to some arbitary base <code>B</code>, use
the formula <code>LOG(X)/LOG(B)</code>.

<a name="IDX351"></a>
</dd><dt><code>LOG10(X)</code>
</dt><dd>
常用対数(10を底とした対数) <code>X</code>

<pre>mysql&gt; select LOG10(2);
        -&gt; 0.301030
mysql&gt; select LOG10(100);
        -&gt; 2.000000
mysql&gt; select LOG10(-100);
        -&gt; NULL
</pre>

<a name="IDX352"></a>
<a name="IDX353"></a>
</dd><dt><code>POW(X,Y)</code>
</dt><dd>
</dd><dt><code>POWER(X,Y)</code>
</dt><dd>
<code>X</code> の <code>Y</code> 乗。

<pre>mysql&gt; select POW(2,2);
        -&gt; 4.000000
mysql&gt; select POW(2,-2);
        -&gt; 0.250000
</pre>

<a name="IDX354"></a>
</dd><dt><code>SQRT(X)</code>
</dt><dd>
<code>X</code> の非負の平方根を返します。

<pre>mysql&gt; select SQRT(4);
        -&gt; 2.000000
mysql&gt; select SQRT(20);
        -&gt; 4.472136
</pre>

<a name="IDX355"></a>
</dd><dt><code>PI()</code>
</dt><dd>
π

<pre>mysql&gt; select PI();
        -&gt; 3.141593
</pre>

<a name="IDX356"></a>
</dd><dt><code>COS(X)</code>
</dt><dd>
コサイン <code>X</code>。<code>X</code> はラジアン。

<pre>mysql&gt; select COS(PI());
        -&gt; -1.000000
</pre>

<a name="IDX357"></a>
</dd><dt><code>SIN(X)</code>
</dt><dd>
サイン <code>X</code>。<code>X</code> はラジアン。

<pre>mysql&gt; select SIN(PI());
        -&gt; 0.000000
</pre>

<a name="IDX358"></a>
</dd><dt><code>TAN(X)</code>
</dt><dd>
タンジェント <code>X</code>。<code>X</code> はラジアン。

<pre>mysql&gt; select TAN(PI()+1);
        -&gt; 1.557408
</pre>

<a name="IDX359"></a>
</dd><dt><code>ACOS(X)</code>
</dt><dd>
<code>X</code> のアークコサインを返します。これはコサインが <code>X</code> である値で
す。<code>X</code> が <code>-1</code> から <code>1</code> の範囲にない場合は <code>NULL</code> を
返します。

<pre>mysql&gt; select ACOS(1);
        -&gt; 0.000000
mysql&gt; select ACOS(1.0001);
        -&gt; NULL
mysql&gt; select ACOS(0);
        -&gt; 1.570796
</pre>

<a name="IDX360"></a>
</dd><dt><code>ASIN(X)</code>
</dt><dd>
<code>X</code> のアークサインを返します。これはサインが <code>X</code> である値です。
<code>X</code> が <code>-1</code> から <code>1</code> の範囲にない場合は <code>NULL</code> を返し
ます。

<pre>mysql&gt; select ASIN(0.2);
        -&gt; 0.201358
mysql&gt; select ASIN('foo');
        -&gt; 0.000000
</pre>

<a name="IDX361"></a>
</dd><dt><code>ATAN(X)</code>
</dt><dd>
<code>X</code> のアークタンジェントを返します。これはタンジェントが <code>X</code> で
ある値です。

<pre>mysql&gt; select ATAN(2);
        -&gt; 1.107149
mysql&gt; select ATAN(-2);
        -&gt; -1.107149
</pre>

<a name="IDX362"></a>
</dd><dt><code>ATAN2(X,Y)</code>
</dt><dd>
２つの変数 <code>X</code> と <code>Y</code> のアークタンジェントを返します。両方の引数
の符号が結果の象限を決定するために使用されることを除いて、<code>Y / X</code> の
アークタンジェントの計算と同様です。

<pre>mysql&gt; select ATAN(-2,2);
        -&gt; -0.785398
mysql&gt; select ATAN(PI(),0);
        -&gt; 1.570796
</pre>

<a name="IDX363"></a>
</dd><dt><code>COT(X)</code>
</dt><dd>
<code>X</code> のコタンジェントを返します。

<pre>mysql&gt; select COT(12);
        -&gt; -1.57267341
mysql&gt; select COT(0);
        -&gt; NULL
</pre>

<a name="IDX364"></a>
</dd><dt><code>RAND()</code>
</dt><dd>
</dd><dt><code>RAND(N)</code>
</dt><dd>
<code>0</code> から <code>1.0</code> 間のランダムな浮動小数点数値を返します。
もし <code>N</code> に整数を与えた場合、シードとしてこの値が使用されます。

<pre>mysql&gt; select RAND();
        -&gt; 0.5925
mysql&gt; select RAND(20);
        -&gt; 0.1811
mysql&gt; select RAND(20);
        -&gt; 0.1811
mysql&gt; select RAND();
        -&gt; 0.2079
mysql&gt; select RAND();
        -&gt; 0.7888
</pre>

<code>RAND()</code> 値を持つフィールドは <code>ORDER BY</code> 節で使用できません。
<code>ORDER BY</code> はフィールドを複数回評価するためです。

しかし <strong>MySQL</strong> 3.23 では, 次が可能です:
<code>SELECT * FROM table_name ORDER BY RAND()</code>

これは <code>SELECT * FROM table1,table2 WHERE a=b AND c&lt;d ORDER BY
RAND() LIMIT 1000</code> のセットからランダムなサンプルを得るのに便利です。

注意: <code>WHERE</code> 節の <code>RAND()</code> は <code>WHERE</code> が実行する度に再評価
されます。

<a name="IDX365"></a>
</dd><dt><code>LEAST(X,Y,...)</code>
</dt><dd>
二つ以上の引数を取り、引数中、最小の値を返します。
引数は以下の規則に従って比較されます：


<ul>
<li>

値が <code>INTEGER</code> を使用しているなら、あるいは、全ての引数が
整数値ならば、整数として比較します。

</li><li>

値が <code>REAL</code> として使用されているか、全ての引数が実数ならば、
実数として比較します。

</li><li>

いかなる引数もケース依存の文字ならば、引数はケース依存文字として比較されます。

</li><li>

そのほかの場合、引数はケース非依存文字として比較されます。
</li></ul>


<pre>mysql&gt; select LEAST(2,0);
        -&gt; 0
mysql&gt; select LEAST(34.0,3.0,5.0,767.0);
        -&gt; 3.0
mysql&gt; select LEAST("B","A","C");
        -&gt; "A"
</pre>

3.22.5 以前の <strong>MySQL</strong> では、<code>MIN()</code> を <code>LEAST</code> の代わりに使用できます。

<a name="IDX366"></a>
</dd><dt><code>GREATEST(X,Y,...)</code>
</dt><dd>
二つ以上の引数を取り、引数中、最大の値を返します。
引数は <code>LEAST</code> の時と同じように比較されます。


<pre>mysql&gt; select GREATEST(2,0);
        -&gt; 2
mysql&gt; select GREATEST(34.0,3.0,5.0,767.0);
        -&gt; 767.0
mysql&gt; select GREATEST("B","A","C");
        -&gt; "C"
</pre>

3.22.5 以前の <strong>MySQL</strong> では、<code>MAX()</code> を <code>GREATEST</code> の代わりに使用できます。

<a name="IDX367"></a>
</dd><dt><code>DEGREES(X)</code>
</dt><dd>
引数 <code>X</code> をラジアンから度に変換して返します。

<pre>mysql&gt; select DEGREES(PI());
        -&gt; 180.000000
</pre>

<a name="IDX368"></a>
</dd><dt><code>RADIANS(X)</code>
</dt><dd>
引数 <code>X</code> を度からラジアンに変換して返します。

<pre>mysql&gt; select RADIANS(90);
        -&gt; 1.570796
</pre>

<a name="IDX369"></a>
</dd><dt><code>TRUNCATE(X,D)</code>
</dt><dd>
少数点以下 <code>D</code> 桁で <code>X</code> を切り捨てた値を返します。
<code>D</code> が <code>0</code> の場合、結果は小数部や微小部を持ちません。

<pre>mysql&gt; select TRUNCATE(1.223,1);
        -&gt; 1.2
mysql&gt; select TRUNCATE(1.999,1);
        -&gt; 1.9
mysql&gt; select TRUNCATE(1.999,0);
        -&gt; 1
</pre>

</dd></dl>

<p>
<a name="IDX370"></a>
<a name="IDX371"></a>


</p><h3><a name="String_functions" href="manual.ja_toc.html#String_functions">7.4.10  文字列関数</a></h3>

<p>
サーバー側のパラメター <code>max_allowed_packet</code> よりも結果の長さが大きい場合、
文字列関数は <code>NULL</code> を返します。  「<a href="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</a>」節参照.

</p>
<p>
文字の位置を扱う関数においては、一番最初の位置は数字の 1 です。

</p>
<dl compact="">

<dt><code>ASCII(str)</code>
</dt><dd>
<a name="IDX372"></a>
 
<code>str</code> の左端の文字の ASCII コード値を返します。
<code>str</code> が空文字の場合は <code>0</code> を返します。
<code>str</code> が <code>NULL</code> の場合は <code>NULL</code> を返します。


<pre>mysql&gt; select ASCII('2');
        -&gt; 50
mysql&gt; select ASCII(2);
        -&gt; 50
mysql&gt; select ASCII('dx');
        -&gt; 100
</pre>

See also the <code>ORD()</code> function.

<a name="IDX373"></a>
</dd><dt><code>ORD(str)</code>
</dt><dd>
文字列 str の左端の文字がマルチバイト文字の場合、文字のASCII コード値を次
の形式で返すことにより、マルチバイト文字のコードを返します:
<code>((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...]</code>.
左端の文字がマルチバイト文字でない場合は、<code>ASCII()</code> 関数と同じ値を返
します。


<pre>mysql&gt; select ORD('2');
        -&gt; 50
</pre>

<a name="IDX374"></a>
</dd><dt><code>CONV(N,from_base, to_base)</code>
</dt><dd>
数字を、進数の違う数字に変換します。
数 <code>N</code> を <code>from_base</code> 進数から <code>to_base</code> 進数に
変換した場合の、文字表現を返します。
もし引数が <code>NULL</code> なら <code>NULL</code> を返します。
引数 <code>N</code> は整数として解釈されますが、整数か文字列で指定します。
最小の進数は <code>2</code> で、最大は <code>36</code> です。
<code>to_base</code> が負数なら、<code>N</code> は符号付きの数になります。
<code>CONV</code> は 64-bit 精度で動作します。


<pre>mysql&gt; select CONV("a",16,2);
        -&gt; '1010'
mysql&gt; select CONV("6E",18,8);
        -&gt; '172'
mysql&gt; select CONV(-17,10,-18);
        -&gt; '-H'
mysql&gt; select CONV(10+"10"+'10'+0xa,10,10);
        -&gt; '40'
</pre>

<a name="IDX375"></a>
</dd><dt><code>BIN(N)</code>
</dt><dd>
<code>N</code> を二進数にした値を返します。<code>N</code> は longlong 数値です。
これは <code>CONV(N,10,2)</code> と同じです。
<code>N</code> が <code>NULL</code> なら <code>NULL</code> を返します.


<pre>mysql&gt; select BIN(12);
        -&gt; '1100'
</pre>

<a name="IDX376"></a>
</dd><dt><code>OCT(N)</code>
</dt><dd>
<code>N</code> の8進数値を表す文字列を返します。<code>N</code> は longlong 数値です。
これは <code>CONV(N,10,8)</code> と同じです。<code>N</code> が <code>NULL</code> の場合は 
<code>NULL</code> を返します。


<pre>mysql&gt; select OCT(12);
        -&gt; '14'
</pre>

<a name="IDX377"></a>
</dd><dt><code>HEX(N)</code>
</dt><dd>
<code>N</code> の16進数値を表す文字列を返します。<code>N</code> は 
longlong(<code>BIGINT</code>) 数値です。これは <code>CONV(N,10,16)</code> と同じです。
<code>N</code> が <code>NULL</code> の場合は <code>NULL</code> を返します。


<pre>mysql&gt; select HEX(255);
        -&gt; 'FF'
</pre>

<a name="IDX378"></a>
</dd><dt><code>CHAR(N,...)</code>
</dt><dd>
引数の ASCII コード値によって与えられた文字からなる文字列を返します。
<code>NULL</code> は飛ばされます。


<pre>mysql&gt; select CHAR(77,121,83,81,'76');
        -&gt; 'MySQL'
mysql&gt; select CHAR(77,77.3,'77.3');
        -&gt; 'MMM'
</pre>

<a name="IDX379"></a>
</dd><dt><code>CONCAT(str1,str2,...)</code>
</dt><dd>
引数を結合した結果を返します。引数が <code>NULL</code> なら <code>NULL</code> を返します.
2個以上の引数を必要とします。
数値の引数は等価の文字列形式に変換されます。

<pre>mysql&gt; select CONCAT('My', 'S', 'QL');
        -&gt; 'MySQL'
mysql&gt; select CONCAT('My', NULL, 'QL');
        -&gt; NULL
mysql&gt; select CONCAT(14.3);
        -&gt; '14.3'
</pre>

<a name="IDX380"></a>
</dd><dt><code>CONCAT_WS(separator, str1, str2,...)</code>
</dt><dd>
<code>CONCAT_WS()</code> は区切り文字つき CONCAT (CONCAT With Separator) を意味
し、<code>CONCAT()</code> の特殊な形式です。最初の引数は、残りの引数の区切り文字
です。区切り文字は残りの引数と同じような文字列です。区切り文字が 
<code>NULL</code> の場合、結果は <code>NULL</code> になります。関数は区切り文字より後
の <code>NULL</code> と空文字列を飛ばします。区切り文字は結合される文字列の間に
追加されます。

<pre>mysql&gt; select CONCAT_WS(",","First name","Second name","Last Name");
       -&gt; 'First name,Second name,Last Name'
mysql&gt; select CONCAT_WS(",","First name",NULL,"Last Name");
       -&gt; 'First name,Last Name'
</pre>

<a name="IDX381"></a>
<a name="IDX382"></a>
<a name="IDX383"></a>
<a name="IDX384"></a>
</dd><dt><code>LENGTH(str)</code>
</dt><dd>
</dd><dt><code>OCTET_LENGTH(str)</code>
</dt><dd>
</dd><dt><code>CHAR_LENGTH(str)</code>
</dt><dd>
</dd><dt><code>CHARACTER_LENGTH(str)</code>
</dt><dd>
文字列 <code>str</code> の長さ。

<pre>mysql&gt; select LENGTH('text');
        -&gt; 4
mysql&gt; select OCTET_LENGTH('text');
        -&gt; 4
</pre>

注意: <code>CHAR_LENGTH()</code> については、マルチバイト文字は一度だけしかカウ
ントされません。

<a name="IDX385"></a>
<a name="IDX386"></a>
</dd><dt><code>LOCATE(substr,str)</code>
</dt><dd>
</dd><dt><code>POSITION(substr IN str)</code>
</dt><dd>
<code>str</code> 内にある <code>substr</code> 文字列の位置を返します。最初の位置は 1 です。
<code>str</code> 内に <code>substr</code> がない時は <code>0</code> を返します。

<pre>mysql&gt; select LOCATE('bar', 'foobarbar');
        -&gt; 4
mysql&gt; select LOCATE('xbar', 'foobar');
        -&gt; 0
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX387"></a>
</dd><dt><code>LOCATE(substr,str,pos)</code>
</dt><dd>
文字列 <code>str</code> 中に最初に顕れた <code>substr</code> 文字の位置を返します。
<code>pos</code> は検索を開始する位置です。
<code>str</code> に <code>substr</code> がなければ <code>0</code> を返します。

<pre>mysql&gt; select LOCATE('bar', 'foobarbar',5);
        -&gt; 7
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX388"></a>
</dd><dt><code>INSTR(str,substr)</code>
</dt><dd>
文字列 <code>str</code> 内の最初の文字列 <code>substr</code> の位置を返します。
これは引数が入れ替わっていることをのぞいて、
2つの引数を与えた <code>LOCATE</code> と同じです。


<pre>mysql&gt; select INSTR('foobarbar', 'bar');
        -&gt; 4
mysql&gt; select INSTR('xbar', 'foobar');
        -&gt; 0
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX389"></a>
</dd><dt><code>LPAD(str,len,padstr)</code>
</dt><dd>
<code>str</code> の長さが <code>len</code> になるまで文字列 <code>str</code> の始めに <code>padstr</code> を埋めます。

<pre>mysql&gt; select LPAD('hi',4,'??');
        -&gt; '??hi'
</pre>

<a name="IDX390"></a>
</dd><dt><code>RPAD(str,len,padstr)</code>
</dt><dd>
<code>str</code> の長さが <code>len</code> になるまで文字列 <code>str</code> の終わりに <code>padstr</code> を埋めます。

<pre>mysql&gt; select RPAD('hi',5,'?');
        -&gt; 'hi???'
</pre>

<a name="IDX391"></a>
</dd><dt><code>LEFT(str,len)</code>
</dt><dd>
文字列 <code>str</code> の最初から <code>len</code> 個の文字を得ます。


<pre>mysql&gt; select LEFT('foobarbar', 5);
        -&gt; 'fooba'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX392"></a>
</dd><dt><code>RIGHT(str,len)</code>
</dt><dd>
文字列 <code>str</code> の最後から <code>len</code> 個の文字を得ます。


<pre>mysql&gt; select RIGHT('foobarbar', 4);
        -&gt; 'rbar'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX393"></a>
<a name="IDX394"></a>
</dd><dt><code>SUBSTRING(str,pos,len)</code>
</dt><dd>
</dd><dt><code>SUBSTRING(str FROM pos FOR len)</code>
</dt><dd>
</dd><dt><code>MID(str,pos,len)</code>
</dt><dd>
<code>str</code> の <code>pos</code> 位置から <code>len</code> 文字数分の文字列を返します。
<code>FROM</code> の違いは ANSI SQL 92 構文です。


<pre>mysql&gt; select SUBSTRING('Quadratically',5,6);
        -&gt; 'ratica'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX395"></a>
</dd><dt><code>SUBSTRING(str,pos)</code>
</dt><dd>
</dd><dt><code>SUBSTRING(str FROM pos)</code>
</dt><dd>
文字列 <code>str</code> の 位置 <code>pos</code> 以降の文字を返します。


<pre>mysql&gt; select SUBSTRING('Quadratically',5);
        -&gt; 'ratically'
mysql&gt; select SUBSTRING('foobarbar' FROM 4);
        -&gt; 'rbar'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX396"></a>
</dd><dt><code>SUBSTRING_INDEX(str,delim,count)</code>
</dt><dd>
<code>str</code> から、区切り文字 <code>delim</code> が <code>count</code> 個現れた位置から前の
文字列を返します。<code>count</code> が正の場合は文字列は左から検索され、
<code>count</code> が負の場合は文字列は右から検索されます。


<pre>mysql&gt; select SUBSTRING_INDEX('www.mysql.com', '.', 2);
        -&gt; 'www.mysql'
mysql&gt; select SUBSTRING_INDEX('www.mysql.com', '.', -2);
        -&gt; 'mysql.com'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX397"></a>
</dd><dt><code>LTRIM(str)</code>
</dt><dd>
文字列 <code>str</code> の最初から空白文字を削除します。

<pre>mysql&gt; select LTRIM('  barbar');
        -&gt; 'barbar'
</pre>

<a name="IDX398"></a>
</dd><dt><code>RTRIM(str)</code>
</dt><dd>
文字列 <code>str</code> の最後から空白文字を削除します。

<pre>mysql&gt; select RTRIM('barbar   ');
        -&gt; 'barbar'
</pre>

<a name="IDX399"></a>
</dd><dt><code>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</code>
</dt><dd>
全ての <code>remstr</code> プレフィックスまたはサフィックスを  <code>str</code> から削除した
文字列を返します。<code>BOTH</code>, <code>LEADING</code> そして <code>TRAILING</code> が
使用されない場合、<code>BOTH</code> が適用されます。<code>remstr</code> が与えられないと、
空白が削除されます。

<pre>mysql&gt; select TRIM('  bar   ');
        -&gt; 'bar'
mysql&gt; select TRIM(LEADING 'x' FROM 'xxxbarxxx');
        -&gt; 'barxxx'
mysql&gt; select TRIM(BOTH 'x' FROM 'xxxbarxxx');
        -&gt; 'bar'
mysql&gt; select TRIM(TRAILING 'xyz' FROM 'barxxyz');
        -&gt; 'barx'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX400"></a>
</dd><dt><code>SOUNDEX(str)</code>
</dt><dd>
<code>str</code> からの soundex 文字列を返します。発音が``大体同じ''２つの文字列
は同じ soundex 文字列を持ちます。``標準の'' soundex 文字列は4文字長ですが、
<code>SOUNDEX()</code> 関数は任意の長さの文字列を返します。<code>SUBSTRING()</code> を
結果に使用して、``標準の'' soundex 文字列を得ることができます。与えられた
文字列中の非アルファベット文字は無視されます。A-Z の半以外のすべての国際的
なアルファベット文字は母音とみなされます。


<pre>mysql&gt; select SOUNDEX('Hello');
        -&gt; 'H400'
mysql&gt; select SOUNDEX('Quadratically');
        -&gt; 'Q36324'
</pre>

<a name="IDX401"></a>
</dd><dt><code>SPACE(N)</code>
</dt><dd>
<code>N</code> 個の空白文字を返します。

<pre>mysql&gt; select SPACE(6);
        -&gt; '      '
</pre>

<a name="IDX402"></a>
</dd><dt><code>REPLACE(str,from_str,to_str)</code>
</dt><dd>
文字列 <code>str</code> 内の全ての文字列 <code>from_str</code> を <code>to_str</code> に
置き換えます。


<pre>mysql&gt; select REPLACE('www.mysql.com', 'w', 'Ww');
        -&gt; 'WwWwWw.mysql.com'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX403"></a>
</dd><dt><code>REPEAT(str,count)</code>
</dt><dd>
<code>str</code> を <code>count</code> 回繰り返します。<code>count &lt;= 0</code> の場合は
空の文字列を返します。<code>str</code> または <code>count</code> が <code>NULL</code> 
または、<code>LENGTH(str)*count &gt; max_allowed_packet</code> の場合は 
<code>NULL</code> を返します。


<pre>mysql&gt; select REPEAT('MySQL', 3);
        -&gt; 'MySQLMySQLMySQL'
</pre>

<a name="IDX404"></a>
</dd><dt><code>REVERSE(str)</code>
</dt><dd>
文字列 <code>str</code> を反転します。

<pre>mysql&gt; select REVERSE('abc');
        -&gt; 'cba'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX405"></a>
</dd><dt><code>INSERT(str,pos,len,newstr)</code>
</dt><dd>
<code>str</code> 中の <code>pos</code> 位置から <code>len</code> 長の文字列を 
<code>newstr</code> で置き換えます。<code>str</code> 内の最初の位置は1です。


<pre>mysql&gt; select INSERT('Quadratic', 3, 4, 'What');
        -&gt; 'QuWhattic'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX406"></a>
</dd><dt><code>ELT(N,str1,str2,str3...)</code>
</dt><dd>
<code>N</code> = <code>1</code> なら <code>str1</code> を、<code>N</code> = <code>2</code> なら <code>str2</code> を返します。
<code>N</code> が <code>1</code> より小さい場合、または引数の数より大きい場合は <code>NULL</code> 
が返されます。
<code>ELT()</code> は <code>FIELD()</code> の逆です。


<pre>mysql&gt; select ELT(1, 'ej', 'Heja', 'hej', 'foo');
        -&gt; 'ej'
mysql&gt; select ELT(4, 'ej', 'Heja', 'hej', 'foo');
        -&gt; 'foo'
</pre>

<a name="IDX407"></a>
</dd><dt><code>FIELD(str,str1,str2,str3,...)</code>
</dt><dd>
<code>str1</code>, <code>str2</code>, <code>str3</code>, <code>...</code> リスト内の <code>str</code> のインデックスを
返します。<code>str</code> が見つからなければ <code>0</code> を返します。
<code>FIELD()</code> は <code>ELT()</code> の逆です。


<pre>mysql&gt; select FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&gt; 2
mysql&gt; select FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&gt; 0
</pre>

<a name="IDX408"></a>
</dd><dt><code>FIND_IN_SET(str,strlist)</code>
</dt><dd>
<code>str</code> が <code>strlist</code> 中にあれば、値 <code>1</code> から <code>N</code> を返します。
<code>strlist</code> は、それぞれの異なる値が ',' で分割された文字列です。最初の
引数が定数文字列で２番目が <code>SET</code> 型のフィールドの場合<code>FIND_IN_SET</code> は
ビット演算を使用して最適化されます！
<code>strlist</code> が空文字なら <code>0</code> を返します。
どちらかの引数が <code>NULL</code> なら <code>NULL</code> を返します.
この関数は最初の引数が  ',' を含んだ場合、うまく動かないでしょう。


<pre>mysql&gt; SELECT FIND_IN_SET('b','a,b,c,d');
        -&gt; 2
</pre>

<a name="IDX409"></a>
</dd><dt><code>MAKE_SET(bits,str1,str2,...)</code>
</dt><dd>
<code>bits</code> に指定されたビットに対応する文字列のセットを返します。
(文字列が複数の場合、 <samp>`,'</samp> で区切られます) 
<code>str1</code> が ビット 0 に対応し、<code>str2</code> が ビット 1 に対応し、
<code>str3</code> が ビット 2 に対応し... となります。
<code>str1</code>, <code>str2</code>, <code>...</code> 中に含まれている <code>NULL</code> 文字は
結果には追加されません。


<pre>mysql&gt; SELECT MAKE_SET(1,'a','b','c');
        -&gt; 'a'
mysql&gt; SELECT MAKE_SET(1 | 4,'hello','nice','world');
        -&gt; 'hello,world'
mysql&gt; SELECT MAKE_SET(0,'a','b','c');
        -&gt; ''
</pre>

<a name="IDX410"></a>
</dd><dt><code>EXPORT_SET(bits,on,off,[separator,[number_of_bits]])</code>
</dt><dd>
'bits' に与えられた数値に対し、
全てのセットされているビットを 'on' で指定された文字で表し、
リセットされているビットを 'off' で指定された文字で表した文字列を返します。
それぞれの文字は 'separator' (デフォルト',') で示された文字で区切られ、
'number_of_bits' (default 64) に与えられた桁数だけのビットを表示します。


<pre>mysql&gt; SELECT EXPORT_SET(5,'Y','N',',',4);
        -&gt; Y,N,Y,N 
</pre>

<a name="IDX411"></a>
<a name="IDX412"></a>
</dd><dt><code>LCASE(str)</code>
</dt><dd>
</dd><dt><code>LOWER(str)</code>
</dt><dd>
<code>str</code> を現在のキャラクターセットマッピング
 (デフォルト ISO-8859-1 Latin1) にしたがって小文字に変換します。

この関数はマルチバイトでも安全です。


<pre>mysql&gt; select LCASE('QUADRATICALLY');
        -&gt; 'quadratically'
</pre>

<a name="IDX413"></a>
<a name="IDX414"></a>
</dd><dt><code>UCASE(str)</code>
</dt><dd>
</dd><dt><code>UPPER(str)</code>
</dt><dd>
<code>str</code> を現在のキャラクターセットマッピング
 (デフォルト ISO-8859-1 Latin1) にしたがって大文字に変換します。


<pre>mysql&gt; select UCASE('Hej');
        -&gt; 'HEJ'
</pre>

この関数はマルチバイトでも安全です。

<a name="IDX415"></a>
</dd><dt><code>LOAD_FILE(file_name)</code>
</dt><dd>
ファイルを読み込み、ファイルの中身を文字として返します。 ファイルは
サーバー上になくてはならず、ファイルをフルパスで指定しなければなりません。
そして、 <strong>file</strong> 権限がなければなりません。 ファイルは全員に
読み込み可能でなければならず、そして、 <code>max_allowed_packet</code> より
小さいサイズでなければなりません。

このうちどれかの理由で、もしファイルが存在しないか読み込めない場合、
この関数は <code>NULL</code> を返します。


<pre>mysql&gt; UPDATE table_name
           SET blob_column=LOAD_FILE("/tmp/picture")
           WHERE id=1;
</pre>

</dd></dl>

<p>
<strong>MySQL</strong> は必要とあらば数値を文字列に変換します。
逆も同様に行います：

</p>

<pre>mysql&gt; SELECT 1+"1";
       -&gt; 2
mysql&gt; SELECT concat(2,' test');
       -&gt; '2 test'
</pre>

<p>
明示的に数値を文字列に変換したければ、<code>CONCAT()</code> に引数として渡して下
さい。

</p>
<p>
文字列関数は引数としてバイナリ文字列が与えられると、結果の文字列もバイナリ
文字列になります。文字列に変換された数値はバイナリ文字列とみなされます。こ
れは比較にだけ影響します。

</p>
<p>
<a name="IDX416"></a>
<a name="IDX417"></a>


</p><h3><a name="Date_and_time_functions" href="manual.ja_toc.html#Date_and_time_functions">7.4.11  日付と時刻関数</a></h3>

<p>
それぞれの型がもつ値の範囲と日と時間の値が記述される有効な形式については
  「<a href="manual.ja_Reference.html#Date_and_time_types">7.3.6  日付と時間の型</a>」節. 

</p>
<p>
日付関数を使用する例:
<code>date_col</code> が最新の30日である全てのレコードを選択します:

</p>

<pre>mysql&gt; SELECT something FROM table
           WHERE TO_DAYS(NOW()) - TO_DAYS(date_col) &lt;= 30;
</pre>

<dl compact="">

<dt><code>DAYOFWEEK(date)</code>
</dt><dd>
<a name="IDX418"></a>
 
<code>date</code> の曜日を得ます (<code>1</code> = 日曜日, <code>2</code> = 月曜日, ... <code>7</code> = 土曜日)
これは ODBC 標準に従います。

<pre>mysql&gt; select DAYOFWEEK('1998-02-03');
        -&gt; 3
</pre>

<a name="IDX419"></a>
</dd><dt><code>WEEKDAY(date)</code>
</dt><dd>
<code>date</code> の曜日を得ます (<code>0</code> = 日曜日, <code>1</code> = 月曜日, ... <code>6</code> = 土曜日)

<pre>mysql&gt; select WEEKDAY('1997-10-04 22:23:00');
        -&gt; 5
mysql&gt; select WEEKDAY('1997-11-05');
        -&gt; 2
</pre>

<a name="IDX420"></a>
</dd><dt><code>DAYOFMONTH(date)</code>
</dt><dd>
月の日を返します (<code>1</code> - <code>31</code>)

<pre>mysql&gt; select DAYOFMONTH('1998-02-03');
        -&gt; 3
</pre>

<a name="IDX421"></a>
</dd><dt><code>DAYOFYEAR(date)</code>
</dt><dd>
年の日を返します (<code>1</code>-<code>366</code>)

<pre>mysql&gt; select DAYOFYEAR('1998-02-03');
        -&gt; 34
</pre>

<a name="IDX422"></a>
</dd><dt><code>MONTH(date)</code>
</dt><dd>
月を返します (<code>1</code> - <code>12</code>)

<pre>mysql&gt; select MONTH('1998-02-03');
        -&gt; 2
</pre>

<a name="IDX423"></a>
</dd><dt><code>DAYNAME(date)</code>
</dt><dd>
曜日の名前を返します。

<pre>mysql&gt; select DAYNAME("1998-02-05");
        -&gt; 'Thursday'
</pre>

<a name="IDX424"></a>
</dd><dt><code>MONTHNAME(date)</code>
</dt><dd>
月の名前を返します。

<pre>mysql&gt; select MONTHNAME("1998-02-05");
        -&gt; 'February'
</pre>

<a name="IDX425"></a>
</dd><dt><code>QUARTER(date)</code>
</dt><dd>
<code>date</code> についての年の四半期を返します。範囲は <code>1</code> から 
<code>4</code> です。

<pre>mysql&gt; select QUARTER('98-04-01');
        -&gt; 2
</pre>

<a name="IDX426"></a>
</dd><dt><code>WEEK(date)</code>
</dt><dd>
</dd><dt><code>WEEK(date,first)</code>
</dt><dd>
引数が一つの場合、<code>date</code> についての週を返します。範囲は <code>0</code> から 
<code>53</code> (そう、53週の最初というのもありえます)で、日曜日が週の
最初の日です。引数が二つの形式の <code>WEEK()</code> は、週の開始を日曜日か月曜
日か指定できます。第2引数が <code>0</code> の場合、週の開始は日曜日です。第2引数
が <code>1</code> の場合、週の開始は月曜日です。

<pre>mysql&gt; select WEEK('1998-02-20');
        -&gt; 7
mysql&gt; select WEEK('1998-02-20',0);
        -&gt; 7
mysql&gt; select WEEK('1998-02-20',1);
        -&gt; 8
mysql&gt; select WEEK('1998-12-31',1);
        -&gt; 53
</pre>

<a name="IDX427"></a>
</dd><dt><code>YEAR(date)</code>
</dt><dd>
年を返します (<code>1000</code> - <code>9999</code>).

<pre>mysql&gt; select YEAR('98-02-03');
        -&gt; 1998
</pre>

</dd><dt><code>YEARWEEK(date)</code>
</dt><dd>
</dd><dt><code>YEARWEEK(date,first)</code>
</dt><dd>
データの年と週を返します。第2引数は <code>WEEK()</code> の第2引数とまったく同じ
ように働きます。注意: 年の最初と最後の週では、年が date 引数内の年とは異な
ることがあります！

<pre>
mysql&gt; select YEARWEEK('1987-01-01');
        -&gt; 198653
</pre>

<a name="IDX428"></a>
</dd><dt><code>HOUR(time)</code>
</dt><dd>
時を返します (<code>0</code> - <code>23</code>)

<pre>mysql&gt; select HOUR('10:05:03');
        -&gt; 10
</pre>

<a name="IDX429"></a>
</dd><dt><code>MINUTE(time)</code>
</dt><dd>
分を返します (<code>0</code>-<code>59</code>)

<pre>mysql&gt; select MINUTE('98-02-03 10:05:03');
        -&gt; 5
</pre>

<a name="IDX430"></a>
</dd><dt><code>SECOND(time)</code>
</dt><dd>
秒を返します (<code>0</code> to <code>59</code>)

<pre>mysql&gt; select SECOND('10:05:03');
        -&gt; 3
</pre>

<a name="IDX431"></a>
</dd><dt><code>PERIOD_ADD(P,N)</code>
</dt><dd>
<code>N</code> 月を期間 <code>P</code> (型 <code>YYMM</code> または <code>YYYYMM</code>) に追加
します。<code>YYYYMM</code> を返します。

注意: 期間引数 <code>P</code> は日付値では<em>ありません</em>。


<pre>mysql&gt; select PERIOD_ADD(9801,2);
        -&gt; 199803
</pre>

<a name="IDX432"></a>
</dd><dt><code>PERIOD_DIFF(P1,P2)</code>
</dt><dd>
期間 <code>P1</code> と <code>P2</code> の差の月を返します。<code>P1</code> と <code>P2</code> は形
式 <code>YYMM</code> または <code>YYYYMM</code> です。

注意: 期間引数 <code>P1</code> と <code>P2</code> は日付値では<em>ありません</em>。


<pre>mysql&gt; select PERIOD_DIFF(9802,199703);
        -&gt; 11
</pre>

<a name="IDX433"></a>
<a name="IDX434"></a>
<a name="IDX435"></a>
<a name="IDX436"></a>
<a name="IDX437"></a>
</dd><dt><code>DATE_ADD(date,INTERVAL expr type)</code>
</dt><dd>
</dd><dt><code>DATE_SUB(date,INTERVAL expr type)</code>
</dt><dd>
</dd><dt><code>ADDDATE(date,INTERVAL expr type)</code>
</dt><dd>
</dd><dt><code>SUBDATE(date,INTERVAL expr type)</code>
</dt><dd>
これら関数は日付の演算に使用します。 これらは <strong>MySQL</strong> 3.22 の
新しい機能です。 <code>ADDDATE()</code> と <code>SUBDATE()</code> は
<code>DATE_ADD()</code> , <code>DATE_SUB()</code> と同義です。

<strong>MySQL</strong> 3.23 では, <code>+</code> と <code>-</code> を
<code>DATE_ADD()</code> , <code>DATE_SUB()</code> の代わりに使用できます. (See example)

<code>date</code> には、<code>DATETIME</code> か <code>DATE</code> 型の値を指定します。
この値から演算が開始されます。
<code>expr</code> には、date から増減させる値を指定します。
<code>expr</code> が <samp>`-'</samp> から始まっていれば、負数を示します。
<code>type</code> はどれぐらいの期間かを示すキーワードです。

<code>EXTRACT(type FROM date)</code> 関数は、date から 'type' の部分を返します。

以下の表に、<code>type</code> と <code>expr</code> の関連を示します：

<table border="" width="100%" nosave="">
<tbody><tr><td><code>type</code> <strong>値</strong> </td><td> <strong>意味</strong> </td><td> <code>expr</code> <strong>のフォーマット</strong>
</td></tr>
<tr><td><code>SECOND</code> </td><td> 秒 </td><td> <code>SECONDS</code>
</td></tr>
<tr><td><code>MINUTE</code> </td><td> 分 </td><td> <code>MINUTES</code>
</td></tr>
<tr><td><code>HOUR</code> </td><td> 時間 </td><td> <code>HOURS</code>
</td></tr>
<tr><td><code>DAY</code> </td><td> 日 </td><td> <code>DAYS</code>
</td></tr>
<tr><td><code>MONTH</code> </td><td> 月 </td><td> <code>MONTHS</code>
</td></tr>
<tr><td><code>YEAR</code> </td><td> 年 </td><td> <code>YEARS</code>
</td></tr>
<tr><td><code>MINUTE_SECOND</code> </td><td> 分と秒 </td><td> <code>"MINUTES:SECONDS"</code>
</td></tr>
<tr><td><code>HOUR_MINUTE</code> </td><td> 時間と分 </td><td> <code>"HOURS:MINUTES"</code>
</td></tr>
<tr><td><code>DAY_HOUR</code> </td><td> 日 と時間 </td><td> <code>"DAYS HOURS"</code>
</td></tr>
<tr><td><code>YEAR_MONTH</code> </td><td> 年 と月 </td><td> <code>"YEARS-MONTHS"</code>
</td></tr>
<tr><td><code>HOUR_SECOND</code> </td><td> 時間と分 </td><td> <code>"HOURS:MINUTES:SECONDS"</code>
</td></tr>
<tr><td><code>DAY_MINUTE</code> </td><td> 日、時、分 </td><td> <code>"DAYS HOURS:MINUTES"</code>
</td></tr>
<tr><td><code>DAY_SECOND</code> </td><td> 日、時、分、秒 </td><td> <code>"DAYS HOURS:MINUTES:SECONDS"</code>
</td></tr>
</tbody></table>

<strong>MySQL</strong> は、 <code>expr</code> フォーマット内のいかなる句読点区切りをも許します。
上の表中の区切り文字は提案する区切り文字です。 もし <code>date</code> 引数が
 <code>DATE</code> 値で、<code>YEAR</code>, <code>MONTH</code>, <code>DAY</code> の部分のみを含む
計算をするなら、結果は <code>DATE</code> 値が返ります。 それ以外なら <code>DATETIME</code> 値が
返ります。


<pre>mysql&gt; SELECT "1997-12-31 23:59:59" + INTERVAL 1 SECOND;
        -&gt; 1998-01-01 00:00:00
mysql&gt; SELECT INTERVAL 1 DAY + "1997-12-31";
        -&gt; 1998-01-01
mysql&gt; SELECT "1998-01-01" - INTERVAL 1 SECOND;
       -&gt; 1997-12-31 23:59:59 
mysql&gt; SELECT DATE_ADD("1997-12-31 23:59:59",
                       INTERVAL 1 SECOND);
        -&gt; 1998-01-01 00:00:00
mysql&gt; SELECT DATE_ADD("1997-12-31 23:59:59",
                       INTERVAL 1 DAY);
        -&gt; 1998-01-01 23:59:59
mysql&gt; SELECT DATE_ADD("1997-12-31 23:59:59",
                       INTERVAL "1:1" MINUTE_SECOND);
        -&gt; 1998-01-01 00:01:00
mysql&gt; SELECT DATE_SUB("1998-01-01 00:00:00",
                       INTERVAL "1 1:1:1" DAY_SECOND);
        -&gt; 1997-12-30 22:58:59
mysql&gt; SELECT DATE_ADD("1998-01-01 00:00:00",
                       INTERVAL "-1 10" DAY_HOUR);
        -&gt; 1997-12-30 14:00:00
mysql&gt; SELECT DATE_SUB("1998-01-02", INTERVAL 31 DAY);
        -&gt; 1997-12-02
mysql&gt; SELECT EXTRACT(YEAR FROM "1999-07-02");
       -&gt; 1999
mysql&gt; SELECT EXTRACT(YEAR_MONTH FROM "1999-07-02 01:02:03");
       -&gt; 199907
mysql&gt; SELECT EXTRACT(DAY_MINUTE FROM "1999-07-02 01:02:03");
       -&gt; 20102
</pre>

もしあなたの指定する interval 値が短すぎるなら( <code>type</code> キーワードから
類推される値を含んでいない場合)、 <strong>MySQL</strong> は interval 値の一番
左の部分を指定し忘れたものだと仮定します。
例えば、もし <code>type</code> を <code>DAY_SECOND</code> に指定した場合、
 <code>expr</code> の値は 日、時、分、秒 からなる物と期待されます。
ここであなたが <code>"1:10"</code> のような値を指定していたなら、
 <strong>MySQL</strong> は、日、時 の部分が忘れ去られて、分、秒 が与えられたと
推定します。
つまり、 <code>"1:10" DAY_SECOND</code> は <code>"1:10" MINUTE_SECOND</code> で
あると理解されるのです。
これは、<strong>MySQL</strong> が <code>TIME</code> 値を時刻ではなく経過時間の表現と解釈
する方法に類似しています。

もし、不正な値が使用されたなら、結果は <code>NULL</code> です.
もし <code>MONTH</code> や <code>YEAR_MONTH</code> や <code>YEAR</code> を足し算して、
結果となる日付が新しい月の最大日よりも大きい日になるようなら、
その日は、新しい月の最大日に修正されます。


<pre>mysql&gt; select DATE_ADD('1998-01-30',Interval 1 month);
        -&gt; 1998-02-28
</pre>

例のように、<code>INTERVAL</code> と <code>type</code> キーワードは
ケース依存ではありません。

<a name="IDX438"></a>
</dd><dt><code>TO_DAYS(date)</code>
</dt><dd>
日付 <code>date</code> を与えると、0年からの日数を返します。


<pre>mysql&gt; select TO_DAYS(950501);
        -&gt; 728779
mysql&gt; select TO_DAYS('1997-10-07');
        -&gt; 729669
</pre>

<code>TO_DAYS()</code> はグレゴリオ歴の開始(1582)より前の値での使用を意図されて
いません。歴が変更された時に失われた日を考慮に入れてないからです。

<a name="IDX439"></a>
</dd><dt><code>FROM_DAYS(N)</code>
</dt><dd>
Given a daynumber <code>N</code>, returns a <code>DATE</code> value.


<pre>mysql&gt; select FROM_DAYS(729669);
        -&gt; '1997-10-07'
</pre>

<code>FROM_DAYS()</code> はグレゴリオ歴の開始(1582)より前の値での使用を意図され
ていません。歴が変更された時に失われた日を考慮に入れてないからです。

<a name="IDX440"></a>
</dd><dt><code>DATE_FORMAT(date,format)</code>
</dt><dd>
<code>date</code> 値を <code>format</code> 文字列に従って整形します。次の指定が 
<code>format</code> 文字列で使用できます:
<table border="" width="100%" nosave="">
<tbody><tr><td><code>%M</code> </td><td> 月名 (<code>January</code>..<code>December</code>)
</td></tr>
<tr><td><code>%W</code> </td><td> 曜日 (<code>Sunday</code>..<code>Saturday</code>)
</td></tr>
<tr><td><code>%D</code> </td><td> 英語サフィックス付き月の日 (<code>1st</code>, <code>2nd</code>, <code>3rd</code>, etc.)
</td></tr>
<tr><td><code>%Y</code> </td><td> 4桁の年
</td></tr>
<tr><td><code>%y</code> </td><td> 2桁の年
</td></tr>
<tr><td><code>%X</code> </td><td> 週の年。週の最初の日は日曜日。4桁の数値。'%V' と共に使用されます
</td></tr>
<tr><td><code>%x</code> </td><td> 週の年。週の最初の日は月曜日。4桁の数値。'%v' と共に使用されます
</td></tr>
<tr><td><code>%a</code> </td><td> 省略された曜日名 (<code>Sun</code>..<code>Sat</code>)
</td></tr>
<tr><td><code>%d</code> </td><td> 月の日, 数値 (<code>00</code>..<code>31</code>)
</td></tr>
<tr><td><code>%e</code> </td><td> 月の日, 数値 (<code>0</code>..<code>31</code>)
</td></tr>
<tr><td><code>%m</code> </td><td> 月, 数値 (<code>01</code>..<code>12</code>)
</td></tr>
<tr><td><code>%c</code> </td><td> 月, 数値 (<code>1</code>..<code>12</code>)
</td></tr>
<tr><td><code>%b</code> </td><td> 省略された月名 (<code>Jan</code>..<code>Dec</code>)
</td></tr>
<tr><td><code>%j</code> </td><td> 年の日 (<code>001</code>..<code>366</code>)
</td></tr>
<tr><td><code>%H</code> </td><td> 時 (<code>00</code>..<code>23</code>)
</td></tr>
<tr><td><code>%k</code> </td><td> 時 (<code>0</code>..<code>23</code>)
</td></tr>
<tr><td><code>%h</code> </td><td> 時 (<code>01</code>..<code>12</code>)
</td></tr>
<tr><td><code>%I</code> </td><td> 時 (<code>01</code>..<code>12</code>)
</td></tr>
<tr><td><code>%l</code> </td><td> 時 (<code>1</code>..<code>12</code>)
</td></tr>
<tr><td><code>%i</code> </td><td> 分, 数値 (<code>00</code>..<code>59</code>)
</td></tr>
<tr><td><code>%r</code> </td><td> 時刻, 12時間 (<code>hh:mm:ss [AP]M</code>)
</td></tr>
<tr><td><code>%T</code> </td><td> 時刻, 24時間 (<code>hh:mm:ss</code>)
</td></tr>
<tr><td><code>%S</code> </td><td> 秒 (<code>00</code>..<code>59</code>)
</td></tr>
<tr><td><code>%s</code> </td><td> 秒 (<code>00</code>..<code>59</code>)
</td></tr>
<tr><td><code>%p</code> </td><td> <code>AM</code> or <code>PM</code>
</td></tr>
<tr><td><code>%w</code> </td><td> 週の日 (<code>0</code>=Sunday..<code>6</code>=Saturday)
</td></tr>
<tr><td><code>%U</code> </td><td> 週 (<code>0</code>..<code>53</code>), 週のはじまりを 日曜とした場合
</td></tr>
<tr><td><code>%u</code> </td><td> 週 (<code>0</code>..<code>53</code>), 週のはじまりを 月曜とした場合
</td></tr>
<tr><td><code>%V</code> </td><td> 週 (<code>1</code>..<code>53</code>), 週のはじまりは日曜日。'%X' と共に使用されます
</td></tr>
<tr><td><code>%v</code> </td><td> 週 (<code>1</code>..<code>53</code>), 週のはじまりは月曜日。'%x' と共に使用されます
</td></tr>
<tr><td><code>%%</code> </td><td> リテラル <samp>`%'</samp>。
</td></tr>
</tbody></table>

他の全ての文字は解釈されずに結果にコピーされます。


<pre>mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');
        -&gt; 'Saturday October 1997'
mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');
        -&gt; '22:23:00'
mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00',
                          '%D %y %a %d %m %b %j');
        -&gt; '4th 97 Sat 04 10 Oct 277'
mysql&gt; select DATE_FORMAT('1997-10-04 22:23:00',
                          '%H %k %I %r %T %S %w');
        -&gt; '22 22 10 10:23:00 PM 22:23:00 00 6'
mysql&gt; select DATE_FORMAT('1999-01-01', '%X %V');
        -&gt; '1998 52'
</pre>

<strong>MySQL</strong> 3.23 では、 <code>%</code> 文字はフォーマット文字の前に必ず必要とされます。
それより前のバージョンでは、 <code>%</code> 文字はオプションでした。

<a name="IDX441"></a>
</dd><dt><code>TIME_FORMAT(time,format)</code>
</dt><dd>
これは上記の <code>DATE_FORMAT()</code> のように使用されますが、
<code>format</code> オプションでは、時,分,秒だけを操作できます。
他のオプションは <code>NULL</code> or <code>0</code> を与えます。

<a name="IDX442"></a>
<a name="IDX443"></a>
</dd><dt><code>CURDATE()</code>
</dt><dd>
</dd><dt><code>CURRENT_DATE</code>
</dt><dd>
今日の日付を返します。日付の形式は、<code>CURDATE()</code> が数値または文字列のどち
らの文脈で使用されたかに依存して <code>YYYYMMDD</code> または <code>'YYYY-MM-DD'</code> で返されます。


<pre>mysql&gt; select CURDATE();
        -&gt; '1997-12-15'
mysql&gt; select CURDATE() + 0;
        -&gt; 19971215
</pre>

<a name="IDX444"></a>
<a name="IDX445"></a>
</dd><dt><code>CURTIME()</code>
</dt><dd>
</dd><dt><code>CURRENT_TIME</code>
</dt><dd>
現在の時刻を <code>HHMMSS</code> または <code>'HH:MM:SS'</code> の形式で返します。こ
れは <code>CURTIME()</code> が数値または文字列のどちらの文脈で使用されたかに依
存します。


<pre>mysql&gt; select CURTIME();
        -&gt; '23:50:26'
mysql&gt; select CURTIME() + 0;
        -&gt; 235026
</pre>

<a name="IDX446"></a>
<a name="IDX447"></a>
<a name="IDX448"></a>
</dd><dt><code>NOW()</code>
</dt><dd>
</dd><dt><code>SYSDATE()</code>
</dt><dd>
</dd><dt><code>CURRENT_TIMESTAMP</code>
</dt><dd>
現在の時刻を返します。数値または文字列のどちらの文脈で使用されたかに依存して
 <code>YYYYMMDDHHMMSS</code> または <code>'YYYY-MM-DD HH:MM:SS'</code> 形式で返されます。


<pre>mysql&gt; select NOW();
        -&gt; '1997-12-15 23:50:26'
mysql&gt; select NOW() + 0;
        -&gt; 19971215235026
</pre>

<a name="IDX449"></a>
</dd><dt><code>UNIX_TIMESTAMP()</code>
</dt><dd>
</dd><dt><code>UNIX_TIMESTAMP(date)</code>
</dt><dd>
引数なしで呼び出された場合は、UNIX timestamp (GMT <code>'1970-01-01 00:00:00'</code> か
らの秒数) です。通常は、<code>TIMESTAMP</code> フィールドを引数として呼び出し、フィールドの
値を秒数で返します。<code>date</code> はローカル時刻での <code>DATE</code> 文字列、<code>DATETIME</code> 
文字列、または <code>YYMMDD</code> または <code>YYYYMMDD</code> 形式の数値です。


<pre>mysql&gt; select UNIX_TIMESTAMP();
        -&gt; 882226357
mysql&gt; select UNIX_TIMESTAMP('1997-10-04 22:23:00');
        -&gt; 875996580
</pre>

<code>UNIX_TIMESTAMP</code> が <code>TIMESTAMP</code> フィールドに使用された場合、
この関数は、暗黙の ``文字から UNIX タイムスタンプ'' 変換をすることなく、
値を得ます。

<a name="IDX450"></a>
</dd><dt><code>FROM_UNIXTIME(Unix_timestamp)</code>
</dt><dd>
文脈(数値/文字列)に依存して、<code>'YYYY-MM-DD HH:MM:SS'</code> または 
<code>YYYYMMDDHHMMSS</code> 形式の timestamp 文字列を返します。


<pre>mysql&gt; select FROM_UNIXTIME(875996580);
        -&gt; '1997-10-04 22:23:00'
mysql&gt; select FROM_UNIXTIME(875996580) + 0;
        -&gt; 19971004222300
</pre>

<a name="IDX451"></a>
</dd><dt><code>FROM_UNIXTIME(unix_timestamp,format)</code>
</dt><dd>
<code>format</code> に従って整形された Unix timestamp 文字列を返します。
<code>format</code> は <code>DATE_FORMAT()</code> 関数のエントリに一覧されたのと同じ指
定子を含むことができます。


<pre>mysql&gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(),
                            '%Y %D %M %h:%i:%s %x');
        -&gt; '1997 23rd December 03:43:30 x'
</pre>

<a name="IDX452"></a>
</dd><dt><code>SEC_TO_TIME(seconds)</code>
</dt><dd>
<code>seconds</code> 引数を時分秒に変換して返します。関数が文字列文脈または数値
文脈のどちらで使用されたかに依存して、<code>'HH:MM:SS'</code> または 
<code>HHMMSS</code> 形式で値を返します。


<pre>mysql&gt; select SEC_TO_TIME(2378);
        -&gt; '00:39:38'
mysql&gt; select SEC_TO_TIME(2378) + 0;
        -&gt; 3938
</pre>

<a name="IDX453"></a>
</dd><dt><code>TIME_TO_SEC(time)</code>
</dt><dd>
<code>time</code> を秒に変換します。


<pre>mysql&gt; select TIME_TO_SEC('22:23:00');
        -&gt; 80580
mysql&gt; select TIME_TO_SEC('00:39:38');
        -&gt; 2378
</pre>

</dd></dl>

<p>
<a name="IDX454"></a>
<a name="IDX455"></a>


</p><h3><a name="Miscellaneous_functions" href="manual.ja_toc.html#Miscellaneous_functions">7.4.12  その他の関数</a></h3>

<dl compact="">

<dt><code>DATABASE()</code>
</dt><dd>
<a name="IDX456"></a>
 
現在のデータベース名を返します。

<pre>mysql&gt; select DATABASE();
        -&gt; 'test'
</pre>

もしデータベースが選択されていないなら、<code>DATABASE()</code> は空文字を返します。

<a name="IDX457"></a>
<a name="IDX458"></a>
<a name="IDX459"></a>
</dd><dt><code>USER()</code>
</dt><dd>
</dd><dt><code>SYSTEM_USER()</code>
</dt><dd>
</dd><dt><code>SESSION_USER()</code>
</dt><dd>
現在の <strong>MySQL</strong> ユーザ名を返します。

<pre>mysql&gt; select USER();
        -&gt; 'davida@localhost'
</pre>

<strong>MySQL</strong> 3.22.11 以降では、この関数はユーザー名とクライアントのホスト名を含みます。
ユーザー名の部分だけ取り出すには次のようにします。
（これはホスト名が含まれていなくとも動くでしょう）：


<pre>ysql&gt; select substring_index(USER(),"@",1);
        -&gt; 'davida'
</pre>

<a name="IDX460"></a>
</dd><dt><code>PASSWORD(str)</code>
</dt><dd>
プレーンテキストのパスワード <code>str</code> からパスワード文字列を計算します。
これは <code>user</code> 許可テーブルの <code>Password</code> フィールドに、
暗号化された <strong>MySQL</strong> パスワードを保存する際に使用されます。


<pre>mysql&gt; select PASSWORD('badpwd');
        -&gt; '7f84554057dd964b'
</pre>

<a name="IDX461"></a>
<code>PASSWORD()</code> 暗号は不可逆です。

<code>PASSWORD()</code> は UNIX のパスワードが暗号化するのと同じ方法で
暗号化を行うわけではありません。
UNIX のパスワードと <strong>MySQL</strong> のパスワードが同じと思ってはいけません。
UNIX のパスワードファイルに保存される値が <code>PASSWORD()</code> が返すと
考えてはいけません。
<code>ENCRYPT()</code> 参照。

<a name="IDX462"></a>
</dd><dt><code>ENCRYPT(str[,salt])</code>
</dt><dd>
UNIX の <code>crypt()</code> システムコールで <code>str</code> を暗号化します。
<code>salt</code> は2文字の文字列です。
(<strong>MySQL</strong> 3.22.16 で, <code>salt</code> は2文字以上許されるようになりました。)


<pre>mysql&gt; select ENCRYPT("hello");
        -&gt; 'VxuFAJXVARROc'
</pre>

システムで <code>crypt()</code> が利用できない場合は <code>ENCRYPT()</code> は常に 
<code>NULL</code> を返します。

少なくともいくつかのシステムでは、
<code>ENCRYPT()</code> は <code>str</code> 文字中の最初の 8 文字以外は全て無視します。
これは <code>crypt()</code> システムコールの振る舞いによって決定づけられます。

<a name="IDX463"></a>
</dd><dt><code>ENCODE(str,pass_str)</code>
</dt><dd>
パスワードとして <code>pass_str</code> を用いて <code>str</code> を暗号化します。結果
を復号化するには、<code>DECODE()</code>を使用します。

結果はバイナリ文字列です。フィールドにそれを保存したい場合は <code>BLOB</code> 
フィールド型を使用してください。

<a name="IDX464"></a>
</dd><dt><code>DECODE(crypt_str,pass_str)</code>
</dt><dd>
暗号化された文字列 <code>crypt_str</code> をパスワードとして <code>pass_str</code> を
用いて復号化します。<code>crypt_str</code> は <code>ENCODE()</code> から返された文字列
であるべきです。

<a name="IDX465"></a>
</dd><dt><code>MD5(string)</code>
</dt><dd>
文字列を MD5 チェックサムした結果を返します。 値は 32 桁の 16進表示です。
例えばハッシュキーとして使用できるように。


<pre>mysql&gt; select MD5("testing")
        -&gt; 'ae2b1fca515949e5d54fb22b8ed95575'
</pre>

これは "RSA Data Security, Inc. MD5 Message-Digest Algorithm".

<a name="IDX466"></a>
</dd><dt><code>LAST_INSERT_ID([expr])</code>
</dt><dd>
最後に <code>AUTO_INCREMENT</code> フィールドに挿入されて自動的に生成された値を返します。
 「<a href="manual.ja_Clients.html#mysql_insert_id">22.4.29  <code>mysql_insert_id()</code></a>」節参照.


<pre>mysql&gt; select LAST_INSERT_ID();
        -&gt; 195
</pre>

最後の作成された ID はそれぞれのコネクション毎にサーバーに維持されます。
これは他のクライアントからは変更できないでしょう。
もし他の非マジック値をもつ <code>AUTO_INCREMENT</code> フィールド
（値が <code>NULL</code> でも <code>0</code> でもないということ）
を更新しても、これは 変更されません。

<a name="IDX467"></a>
もし <code>UPDATE</code> 節内の <code>LAST_INSERT_ID()</code> の引数に <code>expr</code> を指定すると、
引数の値は <code>LAST_INSERT_ID()</code> の値として返ります。
これは シーケンス番号のシミュレーションに使用できます：

最初にテーブルを作成：


<pre>mysql&gt; create table sequence (id int not null);
mysql&gt; insert into sequence values (0);
</pre>

そして以下のようにしてシーケンス番号を生成：


<pre>mysql&gt; UPDATE sequence SET id=last_insert_id(id+1);
</pre>

<code>LAST_INSERT_ID()</code> の呼び出し無しでシーケンス番号を生成することが可能
ですが、この方法でこの関数を使用するユーティリティは、ID 値が最後に自動的
に生成された値としてサーバに管理されます。<strong>MySQL</strong> 内の通常の任意の 
<code>AUTO_INCREMENT</code> 値を読み込んで新しい ID を取り出すことができます。例
えば、<code>LAST_INSERT_ID()</code> (引数無し) は新しい ID を返します。C API 関
数 <code>mysql_insert_id()</code> もこの値を得るために使用できます。

<a name="IDX468"></a>
</dd><dt><code>FORMAT(X,D)</code>
</dt><dd>
<code>'#,###,###.##'</code> のような形式(小数部 <code>X</code> 桁)で数値 <code>D</code> を整形
します。 もし <code>D</code> が <code>0</code> なら, 結果にはいかなる
小数点も小数部も含まれません。


<pre>mysql&gt; select FORMAT(12332.123456, 4);
        -&gt; '12,332.1235'
mysql&gt; select FORMAT(12332.1,4);
        -&gt; '12,332.1000'
mysql&gt; select FORMAT(12332.2,0);
        -&gt; '12,332'
</pre>

<a name="IDX469"></a>
</dd><dt><code>VERSION()</code>
</dt><dd>
<strong>MySQL</strong> サーバのバージョンを返します。

<pre>mysql&gt; select VERSION();
        -&gt; '3.23.13-log'
</pre>

注意: バージョンが <code>-log</code> で終わる場合はロギングが有効であることを意
味します。

<a name="IDX470"></a>
</dd><dt><code>CONNECTION_ID()</code>
</dt><dd>
接続の接続 ID (<code>thread_id</code>) を返します。すべての接続は接続自身の一意
な ID を持ちます。

<pre>mysql&gt; select CONNECTION_ID();
        -&gt; 1
</pre>

<a name="IDX471"></a>
</dd><dt><code>GET_LOCK(str,timeout)</code>
</dt><dd>
<code>timeout</code> 秒のタイムアウトで、<code>str</code> と名付けられたロックの獲得を試み
ます。ロックを獲得した場合は <code>1</code>, タイムアウトの場合は <code>0</code>, エラーの場合(メ
モリ不足やスレッドが <code>mysqladmin kill</code> で殺された場合など)は <code>NULL</code>
が返ります。<code>RELEASE_LOCK</code> の実行、新しい <code>GET_LOCK</code> の実行、
スレッドの終了の場合に、ロックは解放されます。この関数はアプリケーション
ロックやレコードロックのシミュレートのために使用できます。
これは、同じ名前のロックを行おうとする他のクライアントからのリクエストを
ブロックします； 与えられた名前のロックに応じているクライアントは、
協調してロッキングを行うために、その文字列を使用できます。


<pre>mysql&gt; select GET_LOCK("lock1",10);
        -&gt; 1
mysql&gt; select GET_LOCK("lock2",10);
        -&gt; 1
mysql&gt; select RELEASE_LOCK("lock2");
        -&gt; 1
mysql&gt; select RELEASE_LOCK("lock1");
        -&gt; NULL
</pre>

２つ目の <code>RELEASE_LOCK()</code> は <code>NULL</code> を返します。
なぜなら、 <code>"lock1"</code> は、２つ目の <code>GET_LOCK()</code> の呼び出し時点で、
自動的に解放されるからです。

<a name="IDX472"></a>
</dd><dt><code>RELEASE_LOCK(str)</code>
</dt><dd>
<code>GET_LOCK</code> で獲得したロック <code>str</code> を解放します。ロックが解
放された場合は <code>1</code>, このスレッドによってロックされていない場合は <code>0</code> 
(この場合、ロックは解放されません), 
<code>str</code>が存在しない場合は <code>NULL</code> が返ります。
もし、 <code>GET_LOCK()</code> をコールして得られなかった場合、
あるいは、既に解放されている場合は、ロックは存在しないでしょう。

<a name="IDX473"></a>
</dd><dt><code>BENCHMARK(count,expr)</code>
</dt><dd>
<code>BENCHMARK()</code> 関数は <code>expr</code> で与えられた文を <code>count</code> 回
繰り返し実行します。 これは <strong>MySQL</strong> のその文の処理がどれぐらい
速いのか知るのに使用されるでしょう。 結果は常に <code>0</code> です。
想定している使用は、 <code>mysql</code> クライアントです。
あるクエリの実行時間を知るための使用です。


<pre>mysql&gt; select BENCHMARK(1000000,encode("hello","goodbye"));
+----------------------------------------------+
| BENCHMARK(1000000,encode("hello","goodbye")) |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+
1 row in set (4.74 sec)
</pre>

報告された時間は、クライアントでの経過時間です。 サーバー側の CPU 時間では
ありません。<code>BENCHMARK()</code> を何回か実行して、サーバマシンの負荷の重さ
を考慮して結果を解釈することを勧めます。

<a name="IDX474"></a>
</dd><dt><code>INET_NTOA(expr)</code>
</dt><dd>
数値表現に対するネットワークアドレス(4 または 8 バイト) を返します。


<pre>mysql&gt; select INET_NTOA(3520061480);
       -&gt;  "209.207.224.40"
</pre>

<a name="IDX475"></a>
</dd><dt><code>INET_NTOA(expr)</code>
</dt><dd>
ネットワークアドレスに対する数値を表す整数を返します。アドレスは 4 または 
8 バイトアドレスです。


<pre>mysql&gt; select INET_ATON("209.207.224.40");
       -&gt;  3520061480
</pre>

</dd></dl>

<p>
<a name="IDX476"></a>
<a name="IDX477"></a>


</p><h3><a name="Group_by_functions" href="manual.ja_toc.html#Group_by_functions">7.4.13  <code>GROUP BY</code> 節の関数</a></h3>

<p>
<code>GROUP BY</code> 節なしで グループ関数を使用するなら、
これは全てのレコードをグループ化することになります。

</p>
<dl compact="">

<dt><code>COUNT(expr)</code>
</dt><dd>
<a name="IDX478"></a>
 
<code>SELECT</code> 文によって得られるレコード 中、値が 非<code>NULL</code> で
あるレコードの数を返します。


<pre>mysql&gt; select student.student_name,COUNT(*)
           from student,course
           where student.student_id=course.student_id
           GROUP BY student_name;

</pre>

検索されたレコードの数が、レコード中に <code>NULL</code> 値を含むかどうかで、
<code>COUNT(*)</code> で返る値ははいくぶん異なります。

もし <code>SELECT</code> が一つのテーブルから検索し、かつ、
他のフィールドが検索されることもなく、かつ
<code>WHERE</code> 節が無いならば、
<code>COUNT(*)</code> は速く答えるために最適化されます。
例えば：


<pre>mysql&gt; select COUNT(*) from student;
</pre>

<a name="IDX479"></a>
<a name="IDX480"></a>
</dd><dt><code>COUNT(DISTINCT expr,[expr...])</code>
</dt><dd>
異なる値の数のカウントを返します。


<pre>mysql&gt; select COUNT(DISTINCT results) from student;
</pre>

<strong>MySQL</strong> では、式のリストを与えることで、別個の式の組合せの数を得る
ことができます。ANSI SQL では、すべての式を <code>CODE(DISTINCT ..)</code>  内で
結合する必要があります。

<a name="IDX481"></a>
</dd><dt><code>AVG(expr)</code>
</dt><dd>
<code>expr</code>の平均値。


<pre>mysql&gt; select student_name, AVG(test_score)
           from student
           GROUP BY student_name;
</pre>

<a name="IDX482"></a>
<a name="IDX483"></a>
</dd><dt><code>MIN(expr)</code>
</dt><dd>
</dd><dt><code>MAX(expr)</code>
</dt><dd>
<code>expr</code>.の最小/最大値。
<code>min()</code> と <code>max()</code> が文字列引数を取ると、最小/最大の文字列値を返します。


<pre>mysql&gt; select student_name, MIN(test_score), MAX(test_score)
           from student
           GROUP BY student_name;
</pre>

<a name="IDX484"></a>
</dd><dt><code>SUM(expr)</code>
</dt><dd>
<code>expr</code>の合計.
注意: 結果セットが何もレコードを返さない場合は、これは NULL を返します！

<a name="IDX485"></a>
<a name="IDX486"></a>
<a name="IDX487"></a>
<a name="IDX488"></a>
</dd><dt><code>STD(expr)</code>
</dt><dd>
</dd><dt><code>STDDEV(expr)</code>
</dt><dd>
<code>expt</code> の標準誘導(standard derivative)。これは <code>ANSI SQL</code> に対する拡張です。
この関数の <code>STDDEV()</code> 形式は、Oracle 互換のために提供されました。

<a name="IDX489"></a>
</dd><dt><code>BIT_OR(expr)</code>
</dt><dd>
<code>expr</code> 内の全てのビットの論理 <code>OR</code>。64 ビット(<code>BIGINT</code>)の精
度で計算されます。

<a name="IDX490"></a>
</dd><dt><code>BIT_AND(expr)</code>
</dt><dd>
<code>expr</code> 内の全てのビットの論理 <code>AND</code>。64 ビット(<code>BIGINT</code>)の
精度で計算されます。
</dd></dl>

<p>
<strong>MySQL</strong> は <code>GROUP BY</code> を拡張しています。<code>SELECT</code> 表現内で
<code>GROUP BY</code> 部に現れないフィールドまたは計算を使用できます。これは <em>このグルー
プのための全ての可能な値</em> を表しています。この使用により、必要ないフィールドで
のソートとグループが避けられるので、高い性能が得られます。例えば、次のク
エリでは <code>customer.name</code> でグループする必要はありません:

</p>

<pre>mysql&gt; select order.custid,customer.name,max(payments)
       from order,customer
       where order.custid = customer.custid
       GROUP BY order.custid;
</pre>

<p>
ANSI SQL では、<code>GROUP BY</code> 節に <code>customer.name</code> を追加する必要があります。
<strong>MySQL</strong> では、ANSI モードで実行していない場合は、name は冗長です。

</p>
<p>
<code>GROUP BY</code> 部から省略したフィールドがグループ内で一意でない場合は、こ
の機能を使用しないでください！

</p>
<p>
いくつかのケースでは、それが一意でない場合でも、<code>MIN()</code> と 
<code>MAX()</code> を特定のフィールド値を獲得するために使用することができます。
次は、<code>sort</code> フィールド内の最小の値を含むレコードからの 
<code>column</code> の値を与えます:

</p>

<pre>substr(MIN(concat(sort,space(6-length(sort)),column),7,length(column)))
</pre>

<p>
<a name="IDX491"></a>
<a name="IDX492"></a>
<a name="IDX493"></a>
<a name="IDX494"></a>
<a name="IDX495"></a>
<a name="IDX496"></a>
注意: <strong>MySQL</strong> 3.22 (またはそれ以前) を使用している場合、または
ANSI SQL に従おうとしている場合は、<code>GROUP BY</code> や <code>ORDER BY</code> 節で
式を使用できません。式の別名を使用することでこの制限を回避できます:

</p>

<pre>mysql&gt; SELECT id,FLOOR(value/100) AS val FROM tbl_name
           GROUP BY id,val ORDER BY val;
</pre>

<p>
<code>MySQL</code> 3.23 では次を行なうことができます:

</p>

<pre>mysql&gt; SELECT id,FLOOR(value/100) FROM tbl_name ORDER BY RAND();
</pre>

<p>
<a name="IDX497"></a>


</p><h2><a name="CREATE_DATABASE" href="manual.ja_toc.html#CREATE_DATABASE">7.5  <code>CREATE DATABASE</code>構文</a></h2>


<pre>CREATE DATABASE [IF NOT EXISTS] db_name
</pre>

<p>
<code>CREATE DATABASE</code> は与えられた名前のデータベースを作ります。データベースの名前として許される命名規則は、 「<a href="manual.ja_Reference.html#Legal_names">7.1.5  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</a>」節に依ります。
もし、データベースがすでに存在しているにもかかわらず <code>IF NOT EXISTS</code> を
指定していなかったら、エラーが発生します。

</p>
<p>
<strong>MySQL</strong>におけるデータベースは、データベース内のテーブルに相当するファイルを含むディレクトリとして実装されます。初期作成後はデータベース内にテーブルは存在せず、<code>CREATE DATABASE</code>ステートメントは、<strong>MySQL</strong>データディレクトリ下にディレクトリを作成するだけです。

</p>
<p>
<a name="IDX498"></a>
<code>mysqladmin</code>でもデータベースを作成することができます。
 「<a href="manual.ja_Tools.html#Programs">14.1  様々な <strong>MySQL</strong> プログラムの概要</a>」節参照.

</p>
<p>
<a name="IDX499"></a>


</p><h2><a name="DROP_DATABASE" href="manual.ja_toc.html#DROP_DATABASE">7.6  <code>DROP DATABASE</code>構文</a></h2>


<pre>DROP DATABASE [IF EXISTS] db_name
</pre>

<p>
<code>DROP DATABASE</code>は、データベース内の全てのテーブルと共にデータベースを破棄します。<strong>このコマンドの使用には万全の注意を払って下さい！</strong> 

</p>
<p>
<code>DROP DATABASE</code>は、データベースディレクトリから削除されたファイルの数を返します。それぞれのテーブルは<tt>`.MYD'</tt>ファイル／<tt>`.MYI'</tt>ファイル／<tt>`.frm'</tt>ファイルに相当することから、通常この値はテーブルの３倍の数となります。

</p>
<p>
<strong>MySQL</strong> 3.22以降では、データベースが存在しないことに起因するエラーを防ぐために、キーワード <code>IF EXISTS</code> を使用することができます。

</p>
<p>
<a name="IDX500"></a>
<code>mysqladmin</code>でもデータベースを破棄することができます。
 「<a href="manual.ja_Tools.html#Programs">14.1  様々な <strong>MySQL</strong> プログラムの概要</a>」節参照.

</p>
<p>
<a name="IDX501"></a>


</p><h2><a name="CREATE_TABLE" href="manual.ja_toc.html#CREATE_TABLE">7.7  <code>CREATE TABLE</code>構文</a></h2>


<pre>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)]
[table_options] [select_statement]

create_definition:
  col_name type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT]
            [PRIMARY KEY] [reference_definition]
  or    PRIMARY KEY (index_col_name,...)
  or    KEY [index_name] (index_col_name,...)
  or    INDEX [index_name] (index_col_name,...)
  or    UNIQUE [INDEX] [index_name] (index_col_name,...)
  or    [CONSTRAINT symbol] FOREIGN KEY index_name (index_col_name,...)
            [reference_definition]
  or    CHECK (expr)

type:
        TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  or    SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  or    MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  or    INT[(length)] [UNSIGNED] [ZEROFILL]
  or    INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  or    BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  or    REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]
  or    NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]
  or    CHAR(length) [BINARY]
  or    VARCHAR(length) [BINARY]
  or    DATE
  or    TIME
  or    TIMESTAMP
  or    DATETIME
  or    TINYBLOB
  or    BLOB
  or    MEDIUMBLOB
  or    LONGBLOB
  or    TINYTEXT
  or    TEXT
  or    MEDIUMTEXT
  or    LONGTEXT
  or    ENUM(value1,value2,value3,...)
  or    SET(value1,value2,value3,...)

index_col_name:
        col_name [(length)]

reference_definition:
        REFERENCES tbl_name [(index_col_name,...)]
                   [MATCH FULL | MATCH PARTIAL]
                   [ON DELETE reference_option]
                   [ON UPDATE reference_option]

reference_option:
        RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

table_options:
	TYPE = {ISAM | MYISAM | HEAP}
or	AUTO_INCREMENT = #
or	AVG_ROW_LENGTH = #
or	CHECKSUM = {0 | 1}
or	COMMENT = "string"
or	MAX_ROWS = #
or	MIN_ROWS = #
or	PACK_KEYS = {0 | 1}
or	PASSWORD = "string"
or	DELAY_KEY_WRITE = {0 | 1}
or      ROW_FORMAT= { default | dynamic | static | compressed }
or     RAID_TYPE= {1 | STRIPED | RAID0 } RAID_CHUNKS=#  RAID_CHUNKSIZE=#;

select_statement:
	[IGNORE | REPLACE] SELECT ...  (Some legal select statement)
</pre>

<p>
<code>CREATE TABLE</code>はカレントデータベースに、与えられた名前のテーブルを
作成します。テーブルの名前として許される命名規則は、 「<a href="manual.ja_Reference.html#Legal_names">7.1.5  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</a>」節参照に
依ります。
カレントデータベースが無い場合や、テーブルが既に存在している場合はエラーが
発生します。

</p>
<p>
<strong>MySQL</strong> 3.22 以降ではテーブル名は <code>db_name.tbl_name</code> という形で与える事もできます。
これはカレントデータベースがあるかどうかにに関係なく動作します。

</p>
<p>
<strong>MySQL</strong> 3.23 では、テーブル作成時に <code>TEMPORARY</code> キーワードを使用することが
できます。 一時テーブルは、もし、コネクションが落ちた場合、自動で消去されます。
一時テーブルの名前はそれぞれの接続ごとです。
これは、二つの違う接続で、同じ名前の一時テーブルを
衝突することなく、使用できるという事です。
さらには、既に存在するテーブルと同名であっても、一時テーブルは使用できます。
(一時テーブルが削除されるまで、実在するテーブルは隠されます)

</p>
<p>
<strong>MySQL</strong> 3.23 以降では、 <code>IF NOT EXISTS</code> キーワードを使用できます。
これは、もしテーブルが既に存在していた場合、エラーを発生させません。
テーブルの構造が一意かどうかまでは検査しないことに注意。

</p>
<p>
それぞれのテーブルは、データベースディレクトリにおける以下の複数の
ファイルで表されます。これは MyISAM 型 のテーブル場合：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>ファイル</strong> </td><td> <strong>目的</strong>
</td></tr>
<tr><td><code>tbl_name.frm</code> </td><td> テーブル定義(書式)ファイル
</td></tr>
<tr><td><code>tbl_name.MYD</code> </td><td> データファイル
</td></tr>
<tr><td><code>tbl_name.MYI</code> </td><td> インデックスファイル
</td></tr>
</tbody></table>

<p>
フィールドに対する種々の型属性の詳細は、 「<a href="manual.ja_Reference.html#Column_types">7.3  フィールド型</a>」節を参照のこと。

</p>

<ul>
<li>

 <code>NULL</code>も<code>NOT NULL</code>も指定されなかった場合、フィールドは<code>NULL</code>が指定されたものとして扱われます。

</li><li>

   整数型のフィールドには付加属性<code>AUTO_INCREMENT</code>も指定することができます。<code>AUTO_INCREMENT</code>のフィールドに値<code>NULL</code>又は<code>0</code>を挿入した場合、フィールドには<code>value+1</code>の値がセットされます。<code>value</code>は、そのテーブル内の当該フィールドにおける現在の最大値です。
<code>AUTO_INCREMENT</code> は <code>1</code> からはじまります.
 「<a href="manual.ja_Clients.html#mysql_insert_id">22.4.29  <code>mysql_insert_id()</code></a>」節参照.

 削除したレコードが、<code>AUTO_INCREMENT</code>フィールドの最大値を含んでいた場合、その値は次に再利用されます(ただし、これは ISAM テーブルの場合で、MyISAM テーブルでは起こりません)。
また、テーブル内の全てのレコードを <code>DELETE FROM TABLE</code> (<code>WHERE</code>節無しで) を
使用して削除した場合は、始めから採番し直します。

<strong>注意:</strong> 1つのテーブルには1つしか<code>AUTO_INCREMENT</code>フィールドを指定できません。また、インデックスを指定する必要があります。
<strong>MySQL</strong> 3.23 は auto_increment フィールドが正の数を持っている場合に
だけ、正しく動作します。負の数の挿入はとても大きな正の数の挿入とみなされま
す。これは、数値が正から負への 'wrap' over する時の精度の問題を回避するた
めと、アクシデント的に 0 を含む auto_increment フィールドを得ることがない
ことを確実にするために、行なわれます。

<a name="IDX502"></a>
<a name="IDX503"></a>
<strong>MySQL</strong> をいくつかの ODBC アプリケーションと互換にするために、次の
クエリで最後に挿入されたレコードを見つけることができます:


<pre>SELECT * FROM tbl_name WHERE auto_col IS NULL
</pre>

</li><li>

<code>TIMESTAMP</code>フィールドにおける<code>NULL</code>値は、他のフィールド属性と違った扱われ方をします。定数<code>NULL</code>を<code>TIMESTAMP</code>フィールドに格納することはできません。<code>NULL</code>値の指定は現在時刻をセットすることを意味します。<code>TIMESTAMP</code>フィールドがこのように振舞うので、通常は<code>NULL</code>属性や<code>NOT NULL</code>属性は適用できません。それらを指定しても無視されます。

 一方、<strong>MySQL</strong>クライアントからは、より安易に<code>TIMESTAMP</code>フィールドを利用でき、サーバも<code>TIMESTAMP</code>フィールドへの<code>NULL</code>の適用を報告しますが、<code>TIMESTAMP</code>フィールドは実際には<code>NULL</code>値を保存することはありません。<code>DESCRIBE tbl_name</code>を使用して、テーブル定義文を取得することにより、この現象を確認することができます。

 <code>TIMESTAMP</code>フィールドに<code>0</code>を指定することは、<code>NULL</code>を指定することと等しくないことに注意してください。なぜなら、<code>0</code>は<code>TIMESTAMP</code>の値として不正であるからです。

</li><li>

フィールドに対して <code>DEFAULT</code> 値が指定されない場合は <strong>MySQL</strong> が
自動的にそれを割り当てます。

フィールドが <code>NULL</code> を値として取り得る場合は、デフォルト値は 
<code>NULL</code> です。

フィールドが <code>NOT NULL</code> として宣言された場合は、デフォルト値はフィー
ルド型に依存します:


<ul>
<li>

<code>AUTO_INCREMENT</code> 定義された以外の数値型のフィールドに対しては、
初期値は<code>0</code>となります。
<code>AUTO_INCREMENT</code>フィールドでは、デフォルト値は次のシーケンス番号になります。

</li><li>

<code>TIMESTAMP</code> 型以外の日付型と時刻型のフィールドに対しては、
初期値はその型において適切な``ゼロ''値となります。
例外: フィールドがそのテーブル内で最初の<code>TIMESTAMP</code>フィールドである場合、初期値は現在時刻になります。
 「<a href="manual.ja_Reference.html#Date_and_time_types">7.3.6  日付と時間の型</a>」節参照.

</li><li>

<code>ENUM</code> 以外の文字列型のフィールドに対しては、初期値は空文字列となります。
<code>ENUM</code> では、デフォルト値は最初の列挙値です。
</li></ul>

</li><li>

<code>KEY</code>は、<code>INDEX</code>の同義語です。

</li><li>

<strong>MySQL</strong>では、<code>UNIQUE</code>キーは固有値しか持つことができません。既に存在するレコードとキーの値が重複するレコードを挿入しようとした場合、エラーが発生します。

</li><li>

<code>PRIMARY KEY</code> はユニーク <code>KEY</code> で、すべてのキーフィールドは 
<code>NOT NULL</code> として定義されなければならないという特別な制限を伴います。
<strong>MySQL</strong> ではキーは <code>PRIMARY</code> と名付けられます。テーブルは 
<code>PRIMARY KEY</code> を一つだけ持つことができます。<code>PRIMARY KEY</code> を持た
ない場合に、アプリケーションがテーブル内の <code>PRIMARY KEY</code> を尋ねると、
<strong>MySQL</strong> は <code>PRIMARY KEY</code> として、<code>NULL</code> フィールドを持た
ない最初の <code>UNIQUE</code> キーを返します。

</li><li>

<code>PRIMARY KEY</code>は複数フィールドインデックスとできます。しかしながら、1つのフィールド定義内では<code>PRIMARY KEY</code>属性を用いて複合インデックスを定義することができませんので、フィールド定義内における指定は、プライマリ・キーが単独フィールドの場合のみとして下さい。複合フィールドの場合は、<code>PRIMARY KEY(index_col_name,...)</code>文を使用しなければなりません。

</li><li>

<code>PRIMARY</code> や <code>UNIQUE</code> キーが１つのフィールドだけからなり、その型が整数の
場合、それを <code>_rowid</code> としても参照することができます(3.23.11 での新機
能)。

</li><li>

インデックスに名前を割り当てない場合、一意な名前を付けるために、<code>index_col_name</code>内の最初のフィールド名に(<code>_2</code>, <code>_3</code>, ...)のようなサフィックスを付加したものが割り当てられます。テーブルが使用しているインデックス名は、<code>SHOW INDEX FROM tbl_name</code>により確認することができます。
 「<a href="manual.ja_Reference.html#SHOW">7.23  <code>SHOW</code> 構文 (テーブルやフィールドなどについての情報を得る)</a>」節参照.

</li><li>

<a name="IDX504"></a>
<a name="IDX505"></a>
<code>MyISAM</code> テーブルのみが、<code>NULL</code> 値をもつフィールドに対して
インデックスを持つことが出来ます。
その他のテーブル型の場合、フィールドを <code>NOT NULL</code> で定義しなくてはなりません。

</li><li>

<code>col_name(length)</code>文を共に指定することで、<code>CHAR</code>フィールド又は<code>VARCHAR</code>フィールドの一部分だけをインデックスとして定義できます。これによりインデックスファイルを適度に小さくすることができます。
 「<a href="manual.ja_Reference.html#Indexes">7.3.9  フィールドインデックス</a>」節参照.

</li><li>

<a name="IDX506"></a>
<a name="IDX507"></a>
<a name="IDX508"></a>
<a name="IDX509"></a>
<code>MyISAM</code> テーブル型のみが、 <code>BLOB</code> と <code>TEXT</code> フィールド上に
インデックスを持つことが出来ます。 <code>BLOB</code> と <code>TEXT</code> フィールドに
インデックスを張る場合、常に、インデックスの長さを指定しなくてはなりません：

<pre>CREATE TABLE test (blob_col BLOB, index(blob_col(10)));
</pre>

</li><li>

<code>TEXT</code>フィールドや<code>BLOB</code>フィールドで <code>ORDER BY</code> や <code>GROUP BY</code> を
使用すると、最初の<code>max_sort_length</code>バイトだけが使用されます。
 「<a href="manual.ja_Reference.html#BLOB">7.3.7.2  <code>BLOB</code> と <code>TEXT</code> 型</a>」節参照.

</li><li>

<code>FOREIGN KEY</code>、<code>CHECK</code>及び<code>REFERENCES</code>節は実際には何も行いません。これらの構文は、互換性のためだけに用意されており、他のSQLサーバからのコードの移植を容易にしたり、参照情報と共にテーブルを作成するようなアプリケーションを動作させることを目的としています。
 「<a href="manual.ja_Compatibility.html#Missing_functions">5.4  <strong>MySQL</strong> に無い機能</a>」節参照.

</li><li>

全ての<code>NULL</code>フィールドは、1ビット余計に消費し、直近のバイトに丸められます。

</li><li>

レコードの最大長は、以下のようにして求められます:


<pre>レコードの長さ = 1
           + (フィールドの長さの合計)
           + (NULLフィールドの数 + 7)/8
           + (可変長フィールドの数)
</pre>

</li><li><code>table_options</code> と <code>SELECT</code> オプションは、

<strong>MySQL</strong> 3.23 以上でのみ実装されます。
 
テーブル型は：

<table border="" width="100%" nosave="">
<tbody><tr><td>ISAM </td><td> オリジナルのテーブル  「<a href="manual.ja_Table_types.html#ISAM">8.2  ISAM tables</a>」節参照.
</td></tr>
<tr><td>MyISAM </td><td> 新しい、バイナリ互換のテーブル  「<a href="manual.ja_Table_types.html#MyISAM">8.1  MyISAM tables</a>」節参照.
</td></tr>
<tr><td>HEAP </td><td> このテーブルのデータは、メモリー内にのみ蓄えられる  「<a href="manual.ja_Table_types.html#HEAP">8.3  HEAP tables</a>」節参照.
</td></tr>
<tr><td>BDB または Berkeley_db </td><td> トランザクション安全なテーブル  「<a href="manual.ja_Table_types.html#BDB">8.4  BDB or Berkeley_db tables</a>」節参照.
</td></tr>
</tbody></table>
 「<a href="manual.ja_Table_types.html#Table_types">8  MySQL table types</a>」節参照.

その他のテーブルオプションを使って、テーブルの振る舞いを最適化します。
たいていの場合は、オプションを明示する必要がありません。 
明示的に指定されなかった場合、オプションはすべてのテーブル型に作用します。

<table border="" width="100%" nosave="">
<tbody><tr><td><code>AUTO_INCREMENT</code> </td><td> あなたがこのテーブルにセットしたい、次の auto_increment 値
</td></tr>
<tr><td><code>AVG_ROW_LENGTH</code> </td><td> テーブルに含まれるレコードの長さのおおよその平均値。 可変長のレコードを持つ場合にのみ、これをセットします。
</td></tr>
<tr><td><code>CHECKSUM</code> </td><td> <strong>MySQL</strong> に全てのレコードをチェックさせたい場合、これを 1 にセットします。 (これは更新を遅くさせますが、不整合の生じたテーブルを見つけ出しやすくなります) (MyISAM)
</td></tr>
<tr><td><code>COMMENT</code> </td><td> テーブルの、60文字コメント
</td></tr>
<tr><td><code>MAX_ROWS</code> </td><td> あなたがテーブルに保存したいと考えている最大レコード数。
</td></tr>
<tr><td><code>MIN_ROWS</code> </td><td> あなたがテーブルに保存したいと考えている最低レコード数
</td></tr>
<tr><td><code>PACK_KEYS</code> </td><td> より小さいインデックスにしたいなら、これを 1 にします。 これは更新を遅くしますが、読み出しは速くなります (MyISAM, ISAM).
</td></tr>
<tr><td><code>PASSWORD</code> </td><td> <code>.frm</code> ファイルをパスワード付きで暗号化。 このオプションは、標準の <strong>MySQL</strong> バージョンではなにも行いません。
</td></tr>
<tr><td><code>DELAY_KEY_WRITE</code> </td><td> テーブルがクローズされるまでキーテーブルの更新を送らせたい場合、1に設定します(MyISAM)。
</td></tr>
<tr><td><code>ROW_FORMAT</code> </td><td> レコードがどのように格納されるかを定義します(将来のため)。
</td></tr>
</tbody></table>

<code>MyISAM</code> テーブルを使用するならば、<strong>MySQL</strong> は
<code>max_rows * avg_row_length</code> の値を、テーブルがどのくらい大きくなるか
の推定に使用します。 
もし、上記のオプションをなにも指定しなかった場合、テーブルの最大サイズは
4G になります。(か、あなたの OS が 2G しかサポートしていなければ 2G まで)

<code>PACK_KEYS</code> を使用しない場合、デフォルトは文字列だけをパックし、数値
はパックしません。<code>PACK_KEYS=1</code> を使用するとさらに数値もパックされま
す。

バイナリ数値キーをパックする時、<strong>MySQL</strong> はプレフィックス圧縮を使用
します。これは、同じ数値を多く持つ場合にだけこの大きな恩恵を得るということ
を意味します。プレフィックス圧縮は、前のキーの何バイトが次のキーと同じであ
るかを示すための余計な1バイトがすべてのキーに必要となることを意味します(注
意: レコードへのポインタは、圧縮の向上のため high-byte-first-order でキー
の直後に格納されます)。これは、2つのレコードが同じキー多く持つ場合、後のす
べての'同じ'キーは通常2バイト(レコードへのポインタを含む)だけを必要とする
ということです。これを、通常のケースと比較してみてください。通常のケースは、
後のキーは'キーの格納サイズ' + ポインタサイズ(通常4)を必要とします。一方、
すべてのキーが全く異なっていると、キーが <code>NULL</code> 値を持つことができる
キーではない場合では、キー毎に1バイトを消費します(この場合、パックされたキー
の長さは、キーが <code>NULL</code> の時にマークのために使用されるのと同じバイト
数で格納されます)。

</li><li>

もし <code>CREATE STATEMENT</code> の後に <code>SELECT</code> を指定するならば、
<strong>MySQL</strong> は、<code>SELECT</code> で返ってくる全ての項目を収めるために、
新しいフィールドを作成します。
例えば：


<pre>mysql&gt; CREATE TABLE test (a int not null auto_increment,
           primary key (a), key(b))
           TYPE=HEAP SELECT b,c from test2;
</pre>

これは 3つのフィールドを <code>HEAP</code> テーブルに作成します。
もしデータをテーブルにコピーしている最中にエラーが起きたなら、
このテーブルは自動的に消去されることに注意してください。

</li><li>

<code>RAID_TYPE</code> オプションは、大規模ファイルをサポートしていない OS 上の
2G/4Gの制限を破る手助けをします。また、<code>RAID</code> ディレクトリを別の物理
ディスクに置くことにより、IO ボトルネックからさらに速度を得ることができま
す。<code>RAID_TYPE</code> は、<strong>MySQL</strong> を <code>--with-raid</code> でコンフィグ
すれば、どんな OS 上でも働きます。現在、<code>RAID_TYPE</code> は 
<code>STRIPED</code> だけが許されています(<code>1</code> と <code>RAID0</code> はこれの別名
です)。

<code>RAID_TYPE=STRIPED</code> を <code>MyISAM</code> テーブルに指定すると、
<code>MyISAM</code> はデータベースディレクトリ中に 00, 01, 02 という名前の 
<code>RAID_CHUNKS</code> サブディレクトリを生成します。これらのディレクトリのそ
れぞれに、<code>MyISAM</code> は <code>table_name.MYD</code> を生成します。データファ
イルにデータが書き込まれる時、<code>RAID</code> ハンドラは最初の 
<code>RAID_CHUNKSIZE</code> *1024 バイトを最初のファイルに、次の 
<code>RAID_CHUNKSIZE</code> *1024 バイトを次のファイルにマップします。
</li></ul>



<h3><a name="Silent_column_changes" href="manual.ja_toc.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a></h3>

<p>
いくつかのケースにおいて<strong>MySQL</strong>は、<code>CREATE TABLE</code>ステートメントで与えられたフィールド定義を暗黙の内に変更します
(これは <code>ALTER TABLE</code> で起きるかもしれません)

</p>

<ul>
<li>

フィールド長が4未満の<code>VARCHAR</code>フィールドは<code>CHAR</code>に変更されます。

</li><li>

テーブル内にいくつかの可変長フィールドがある場合、結果的にレコード全体が可変長となります。
その結果、テーブルがいくつかの可変長フィールド(<code>VARCHAR</code>、<code>TEXT</code>及び<code>BLOB</code>)
を持つならば、3文字より大きいフィールド長の全ての<code>CHAR</code>フィールドは、
<code>VARCHAR</code>フィールドに変更されます。
このことは、フィールドの使用方法には影響しません。
<strong>MySQL</strong>では、<code>VARCHAR</code>は文字列を格納するための1つの手段に過ぎません。
<strong>MySQL</strong>は、スペース埋めのコンバージョンを行いますし、テーブル操作もより速く行います。
 「<a href="manual.ja_Table_types.html#Table_types">8  MySQL table types</a>」節参照.
 
</li><li>

<code>TIMESTAMP</code>フィールドの表示サイズは、2～14の範囲の偶数でなければなりません。表示サイズを0や14より大きく指定した場合、サイズは14に強制されます。1から13の範囲の奇数の場合、大きい方の偶数値に強制されます。

</li><li>

<code>TIMESTAMP</code> フィールドには <code>NULL</code> を代入できません； <code>NULL</code> は
現在の日時をセットします。
<code>NULL</code> and <code>NOT NULL</code> 属性は通常の方法では適用されず、それらを
与えた場合は無視されます。
<code>DESCRIBE tbl_name</code> は常に <code>TIMESTAMP</code> フィールドに <code>NULL</code> 値が割り当て
られた事を告げます。

</li><li>

<strong>MySQL</strong> は他の SQL データベースの使用している型を <strong>MySQL</strong> 型に
マップします。  「<a href="manual.ja_Reference.html#Other-vendor_column_types">7.3.11  他のデータベースエンジンのフィールド型の使用</a>」節参照.
</li></ul>

<p>
もし <strong>MySQL</strong> がフィールドの型をあなたが指定したものと違うものにしたかどうかを
知りたい場合、テーブルの作成、alter 後に、 <code>DESCRIBE tbl_name</code> 構文
を発行します。

</p>
<p>
<a name="IDX510"></a>
<code>myisampack</code>を使用してテーブルを圧縮した場合、別のフィールド定義変更がある程度起こることがあります。
 「<a href="manual.ja_Table_types.html#Compressed_format">8.1.2.3  Compressed table characteristics</a>」節参照.

</p>
<p>
<a name="IDX511"></a>


</p><h2><a name="ALTER_TABLE" href="manual.ja_toc.html#ALTER_TABLE">7.8  <code>ALTER TABLE</code>構文</a></h2>


<pre>ALTER [IGNORE] TABLE tbl_name alter_spec [, alter_spec ...]

alter_specification:
        ADD [COLUMN] create_definition [FIRST | AFTER column_name ]
  or    ADD [COLUMN] (create_definition, create_definition,...)
  or    ADD INDEX [index_name] (index_col_name,...)
  or    ADD PRIMARY KEY (index_col_name,...)
  or    ADD UNIQUE [index_name] (index_col_name,...)
  or    ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
  or    CHANGE [COLUMN] old_col_name create_definition
  or    MODIFY [COLUMN] create_definition
  or    DROP [COLUMN] col_name
  or    DROP PRIMARY KEY
  or    DROP INDEX index_name
  or    RENAME [AS] new_tbl_name
  or    table_options
</pre>

<p>
<code>ALTER TABLE</code>は、既存のテーブルの構造変更を可能にします。
例えば、フィールドの追加や削除、インデックスの作成や破棄、既存のフィールド属性の変更、及びフィールドやテーブルそのものの名前の変更です。
また、テーブルのコメントやテーブルの型式を変更することも可能です。
 「<a href="manual.ja_Reference.html#CREATE_TABLE">7.7  <code>CREATE TABLE</code>構文</a>」節参照.

</p>
<p>
もし <code>ALTER TABLE</code> でフィールド定義を変えても <code>DESCRIBE tbl_name</code> が
フィールドを変更していないと示すなら、これは <strong>MySQL</strong> が
  「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節. に述べている理由の一つで変更していない可能性が
あります。 例えば、 <code>VARCHAR</code> フィールドを <code>CHAR</code> にしようとすると, 
<strong>MySQL</strong> はそのテーブルに他の可変長のフィールドがあるかぎり、
<code>VARCHAR</code> のままにしようとします。

</p>
<p>
<code>ALTER TABLE</code>はオリジナルのテーブルの一時的なコピーを作成することにより動作します。
コピーへの変更作業が完了すると、オリジナルのテーブルは削除され新しく作られた方の名前が変更されます。これは全ての変更が自動的に新しいテーブルに対して実施されることにより、誤った変更無しに完了します。<code>ALTER TABLE</code>が実行されている間、オリジナルのテーブルは他のクライアントから読みだしが可能です。このテーブルへの更新や書き込みは、新しいテーブルが準備完了となるまで遅らされます。

</p>

<ul>
<li>

<code>ALTER TABLE</code>を使うには、そのテーブルに<strong>select</strong>、<strong>insert</strong>、
<strong>delete</strong>、<strong>update</strong>、<strong>create</strong>、それから<strong>drop</strong>
権限が必要です。

</li><li>

<code>IGNORE</code>はANSI SQL92に対する<strong>MySQL</strong>の拡張です。
これは、新しいテーブルのユニークキーで重複があった場合の動作を制御します。
<code>IGNORE</code>が指定されない場合、コピーは異常終了し、ロールバックされます。
<code>IGNORE</code>が指定された場合、ユニークキーの重複があったレコードに対し、最初のレコードだけを使用し、他は削除されます。

</li><li>

1つの<code>ALTER TABLE</code>ステートメントの中で、<code>ADD</code>、<code>ALTER</code>、
<code>DROP</code>、それから<code>CHANGE</code>節の複合的な発行が可能です。
これは、<code>ALTER TABLE</code>ステートメント毎に1つだけしかこれらの節を
許さないANSI SQL92に対する<strong>MySQL</strong>の拡張です。

</li><li>

<code>CHANGE col_name</code>、<code>DROP col_name</code>及び<code>DROP
INDEX</code>はANSI SQL92に対する<strong>MySQL</strong>の拡張です。

</li><li>

<code>MODIFY</code> は <code>Oracle</code> の <code>ALTER TABLE</code> 拡張です。

</li><li>

オプション語<code>COLUMN</code>は蛇足であり、記述を省くことが可能です。

</li><li>

他のオプション無しで<code>ALTER TABLE tbl_name RENAME AS new_name</code>を使用すると、
<strong>MySQL</strong>は<code>tbl_name</code>に一致するテーブルの名前を単純に変更します。
テンポラリテーブルの作成は必要としません。

</li><li>

<code>create_definition</code>は、<code>CREATE TABLE</code>における<code>ADD</code>や<code>CHANGE</code>と同じ構文を使用します。
 「<a href="manual.ja_Reference.html#CREATE_TABLE">7.7  <code>CREATE TABLE</code>構文</a>」節参照.

</li><li>

<code>CHANGE old_col_name create_definition</code>節を使用することによりフィールドの名前を変更することができます。
このようなことを行うためには、フィールドの旧名称と新名称、それからそのフィールドの現在の型を指定する必要があります。例えば、ある<code>INTEGER</code>フィールドを<code>a</code>から<code>b</code>に変更する場合、以下のように実行することができます:


<pre>mysql&gt; ALTER TABLE t1 CHANGE a b INTEGER;
</pre>

もしフィールドの名前を変えることなく、型だけを変更したい場合であっても、
この <code>CHANGE</code> 構文は、たとえ同じ名前であっても、
２つの名前を指定するよう要求します。
例:


<pre>mysql&gt; ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;
</pre>

しかし <strong>MySQL</strong> 3.22.16a からは,  <code>MODIFY</code> を使用して、
名称変更をすることなくフィールドの型を変更することができます。


<pre>mysql&gt; ALTER TABLE t1 MODIFY b BIGINT NOT NULL;
</pre>

</li><li>

<code>CHANGE</code> や <code>MODIFY</code> を使用して、フィールドの一部にインデックス
が存在するようなフィールドを短くしようとしても(例えば <code>VARCHAR</code> フィー
ルドの最初の10文字上ににインデックスがある場合)、インデックスされた文字数
よりもフィールドを短くすることはできません。

</li><li>

<code>CHANGE</code> や <code>MODIFY</code> を用いてフィールドの型を変更する場合、
<strong>MySQL</strong>は可能な限り新しい型にデータをコンバートしようと試みます。

</li><li>

<strong>MySQL</strong> 3.22以降では、<code>FIRST</code>又は<code>ADD ... AFTER col_name</code>を使用して、テーブルのレコード内の指定した位置に、フィールドを追加することができます。
デフォルトでは、フィールドは(そのレコードの)最後に追加されます。

</li><li>

<code>ALTER COLUMN</code>は、フィールドの新たな初期値を指定したり、フィールドの古い初期値を削除したりします。
古い初期値が削除され、フィールドが<code>NULL</code>を許す場合、新たな初期値は<code>NULL</code>となります。
<code>NULL</code>が許されない場合、<strong>MySQL</strong>はある初期値を割り当てます。
割り当てる初期値は、
 「<a href="manual.ja_Reference.html#CREATE_TABLE">7.7  <code>CREATE TABLE</code>構文</a>」節. で説明されています。

</li><li>

<code>DROP INDEX</code>は、インデックスを削除します。これはANSI SQL92に対する<strong>MySQL</strong>の拡張です。

</li><li>

フィールドがテーブルから削除されると、そのフィールドが含まれているインデックスからもそのフィールドが削除されます。
インデックスを構成する全てのフィールドが削除されると、そのインデックスも削除されます。

</li><li>

<code>DROP PRIMARY KEY</code>は、プライマリ・インデックスを削除します。もしプライマリインデックスが存在しなければ、そのテーブルの最初の<code>UNIQUE</code>インデックスが削除されます。
(<strong>MySQL</strong>は、明示的に<code>PRIMARY KEY</code>が指定されなければ最初の<code>UNIQUE</code>キーを<code>PRIMARY KEY</code>として扱います。)

</li><li>

<a name="IDX512"></a>
C API関数<code>mysql_info()</code>により、どれだけのレコードがコピーされたか、(<code>IGNORE</code>が指定されている時は)どれだけのレコードがユニークキーの重複により削除されたかを調べることができます。

</li><li>

<a name="IDX513"></a>
<a name="IDX514"></a>
<code>FOREIGN KEY</code>、<code>CHECK</code>及び<code>REFERENCES</code>節は、実際には
何もしません。これらの構文は、互換性のためだけに用意されており、
他のSQLサーバからのコードの移植を容易にしたり、
参照情報と共にテーブルを作成するようなアプリケーションを動作
させることを目的としています。
 「<a href="manual.ja_Compatibility.html#Missing_functions">5.4  <strong>MySQL</strong> に無い機能</a>」節参照.
</li></ul>

<p>
以下は、<code>ALTER TABLE</code>の使用例を表す例です。
次に示すように作成されたテーブル<code>t1</code>から始めます:

</p>

<pre>mysql&gt; CREATE TABLE t1 (a INTEGER,b CHAR(10));
</pre>

<p>
テーブル<code>t1</code>の名前を<code>t2</code>に変更するには:

</p>

<pre>mysql&gt; ALTER TABLE t1 RENAME t2;
</pre>

<p>
フィールド <code>a</code>を <code>INTEGER</code> から <code>TINYINT NOT NULL</code> に
(名前は同じままで)変更し、
<code>b</code> を <code>CHAR(10)</code> から <code>CHAR(20)</code> に変更しつつ、
名前を <code>b</code> から <code>c</code>に変更するには:

</p>

<pre>mysql&gt; ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</pre>

<p>
<code>TIMESTAMP</code>を追加し、名前を<code>d</code>とするには:

</p>

<pre>mysql&gt; ALTER TABLE t2 ADD d TIMESTAMP;
</pre>

<p>
フィールド<code>d</code>にインデックスを追加し、フィールド<code>a</code>をプライマリ・キーとするには:

</p>

<pre>mysql&gt; ALTER TABLE t2 ADD INDEX (d), ADD PRIMARY KEY (a);
</pre>

<p>
フィールド<code>c</code>を削除するには:

</p>

<pre>mysql&gt; ALTER TABLE t2 DROP COLUMN c;
</pre>

<p>
<code>c</code> という名前の <code>NULL</code> を許可しない <code>AUTO_INCREMENT</code> 整数
フィールドを追加し、作成するには:

</p>

<pre>mysql&gt; ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
           ADD INDEX (c);
</pre>

<p>
ここで我々が <code>c</code> をインデックス指定したのは、 <code>AUTO_INCREMENT</code> フィールドは
インデックスであるべきだからで、 <code>c</code> を <code>NOT NULL</code> 指定しているのは
インデックスフィールドは <code>NULL</code> にできないからです。

</p>
<p>
<code>AUTO_INCREMENT</code> フィールドを追加した場合、フィールドの値は
自動的にシーケンス番号で埋められます。

</p>
<p>
See also  「<a href="manual.ja_Problems.html#ALTER_TABLE_problems">20.19  Problems with <code>ALTER TABLE</code>.</a>」節参照.

</p>

<p>
<a name="IDX515"></a>


</p><h2><a name="DROP_TABLE" href="manual.ja_toc.html#DROP_TABLE">7.9  <code>DROP TABLE</code>構文</a></h2>


<pre>DROP TABLE [IF EXISTS] tbl_name [, tbl_name,...]
</pre>

<p>
<code>DROP TABLE</code>は、1つ又は1つ以上のテーブルを破棄します。テーブルの全てのデータとテーブル定義は<em>破棄</em>されますので、このコマンドの使用は慎重に行ってください！

</p>
<p>
<strong>MySQL</strong> 3.22以降では、テーブルが存在しないことに起因するエラーを防ぐために、キーワード <code>IF EXISTS</code> を使用することができます。

</p>

<p>
<a name="IDX516"></a>


</p><h2><a name="OPTIMIZE_TABLE" href="manual.ja_toc.html#OPTIMIZE_TABLE">7.10  <code>OPTIMIZE TABLE</code>構文</a></h2>


<pre>OPTIMIZE TABLE tbl_name
</pre>

<p>
<code>OPTIMZE TABLE</code>は、テーブルの大部分を削除したり、可変長となっているテーブル(<code>VARCHAR</code>、<code>BLOB</code>もしくは<code>TEXT</code>フィールドを持つテーブル)に多くの変更を加えた場合に使用すべきです。
削除されたレコードはリンクリストで維持され、次の<code>INSERT</code>操作は、古いレコード位置を再利用します。
未使用領域を再生するために<code>OPTIMIZE TABLE</code>を使用することができます。

</p>
<p>
<code>OPTIMIZE TABLE</code>は、オリジナルのテーブルの一時的なコピーを作成することにより動作します。
古いテーブルは新しいテーブルに(未使用レコードを除いて)コピーされ、
元のテーブルが削除されてから新しいテーブルの名前が変更されます。
<code>OPTIMIZE TABLE</code>が実行されている間、オリジナルのテーブルは他のクライアントから読みだしが可能です。
このテーブルへの更新や書き込みは、新しいテーブルが準備完了となるまで遅らされます。
これは全ての変更が自動的に新しいテーブルに対して実施されることにより、誤った変更無しに完了します。

</p>

<p>
<a name="IDX517"></a>


</p><h2><a name="CHECK_TABLE" href="manual.ja_toc.html#CHECK_TABLE">7.11  <code>CHECK TABLE</code> 構文</a></h2>


<pre>CHECK TABLE tbl_name[,tbl_name...] [TYPE = QUICK]
</pre>

<p>
テーブルのエラーをチェックします。このコマンドは次のフィールドを持つテーブ
ルを返します:

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td>Table </td><td> テーブル名
</td></tr>
<tr><td>Op </td><td> 常に 'check'
</td></tr>
<tr><td>Msg_type </td><td> <code>status</code>, <code>error</code>, <code>info</code>, <code>warning</code> の一つ。
</td></tr>
<tr><td>Msg_text </td><td> メッセージ。
</td></tr>
</tbody></table>

<p>
注意: チェックされた各テーブルに対する情報の多くのレコードが得られます。最
後の１レコードは <code>Msg_type status</code> になり、通常は <code>OK</code> であるべ
きです。<code>OK</code> が得られない場合は、テーブルの修復を通常通り実行すべきで
す。 「<a href="manual.ja_Maintenance.html#Table_maintenance">15.1  テーブルのメンテナンス、クラッシュからの修復のための <code>myisamchk</code> 使用</a>」節参照。

</p>
<p>
<code>TYPE=QUICK</code> が与えられた場合は、<strong>MySQL</strong> は固定長レコードテー
ブルのレコードを走査しません。

</p>
<p>
<code>CHECK TABLE</code> は <code>MyISAM</code> テーブルだけで動作し、テーブルに対する 
<code>myisamchk -m table_name</code> の実行と同じことです。

</p>
<p>
<a name="IDX518"></a>


</p><h2><a name="REPAIR_TABLE" href="manual.ja_toc.html#REPAIR_TABLE">7.12  <code>REPAIR TABLE</code> 構文</a></h2>


<pre>REPAIR TABLE tbl_name[,tbl_name...] [TYPE = QUICK]
</pre>

<p>
<code>REPAIR TABLE</code> は <code>MyISAM</code> テーブルだけで動作します。テーブルに 
<code>myisamchk -r table_name</code> を実行することと同じです。

</p>
<p>
壊れたテーブルを修復します。コマンドは次のフィールドを含むテーブルを返しま
す:

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td>Table </td><td> テーブル名
</td></tr>
<tr><td>Op </td><td> 常に 'repair'
</td></tr>
<tr><td>Msg_type </td><td> <code>status</code>, <code>error</code>, <code>info</code>, <code>warning</code> のどれか
</td></tr>
<tr><td>Msg_text </td><td> メッセージ
</td></tr>
</tbody></table>

<p>
注意: 修復された各テーブルの情報の多くのレコードを得ることがあります。最後
の１レコードは <code>Msg_type status</code> になり、通常は <code>OK</code> であるべき
です。<code>OK</code> が得られなければ、<code>myisamchk -o</code> でテーブルの修復を試
みるべきです。<code>REPAIR TABLE</code> はまだ <code>myisamchk</code> のすべてのオプショ
ンを実装していないためです。近い将来、我々はこれをより柔軟にする予定です。

</p>
<p>
If <code>TYPE=QUICK</code> is given then <strong>MySQL</strong> will try to do a
<code>REPAIR</code> of only the index tree.

</p>
<p>
<a name="IDX519"></a>


</p><h2><a name="DELETE" href="manual.ja_toc.html#DELETE">7.13  <code>DELETE</code>構文</a></h2>


<pre>DELETE [LOW_PRIORITY] FROM tbl_name
    [WHERE where_definition] [LIMIT rows]
</pre>

<p>
<code>DELETE</code>は、<code>tbl_name</code>より、<code>where_definition</code>にて与えられた条件を満たすレコードを削除し、削除されたレコード数を返します。

</p>
<p>
<code>WHERE</code>節を指定することなしに<code>DELETE</code>を発行した場合、全てのレコードが削除されます。
<strong>MySQL</strong>は、これを空テーブルを再作成することで実現しており、これは、全てのレコードを実際に削除するよりもかなり早く動作します。
この場合<code>DELETE</code>は、影響のあったレコード数として0を返します。
(再作成は、元のデータが格納されているファイルをオープンすることなく実施されますから、<strong>MySQL</strong>は実際に削除されたレコード数を返すことができません。
たとえデータファイルやインデックスファイルが乱されたとしても、テーブル定義ファイル<tt>`tbl_name.frm'</tt>が有効である限り、このような方法でテーブルの再作成が可能となります。)

</p>
<p>
もし全てのレコードを削除している時に、いくつのレコードが消され、いくつのレコードが
スピードを犠牲にしているのか、本当に知りたいならば、
<code>DELETE</code> 構文を以下のように使用します：

</p>

<pre>mysql&gt; DELETE FROM tbl_name WHERE 1&gt;0;
</pre>

<p>
これは <code>DELETE FROM tbl_name</code> を <code>WHERE</code> 節なしで行うよりも、
とても遅いです。なぜなら一度で消そうとするからです。

</p>
<p>
キーワード<code>LOW_PRIORITY</code>を指定した場合、そのテーブルを読んでいるクライアントがいなくなるまで<code>DELETE</code>の実行は遅らせられます。

</p>
<p>
削除されたレコードはリンクリストで維持され、次の<code>INSERT</code>操作は、古いレコード位置を再利用します。
ファイルをより小さくしたい場合は、<code>OPTIMIZE TABLE</code>ステートメントかテーブルの再編成のために<code>myisamchk</code>ユティリティを使用してください。
<code>OPTIMIZE TABLE</code>の方が簡単ですが、<code>myisamchk</code>の方が早く動作します。
 「<a href="manual.ja_Reference.html#OPTIMIZE_TABLE">7.10  <code>OPTIMIZE TABLE</code>構文</a>」節参照, と
 「<a href="manual.ja_Maintenance.html#Optimization">15.6.3  テーブルの最適化</a>」節.

</p>
<p>
<strong>MySQL</strong>-特化  <code>DELETE</code> の <code>LIMIT rows</code> オプションは
サーバーに消す最大のレコード数をつげます。これは <code>DELETE</code> コマンドが
あまりに多くの時間を取らないために使用されます。
<code>LIMIT</code> 値よりも affected row の数が少なくなるまで、
単純に <code>DELETE</code> コマンドを繰り返すだけです。

</p>
<p>
<a name="IDX520"></a>


</p><h2><a name="SELECT" href="manual.ja_toc.html#SELECT">7.14  <code>SELECT</code>構文</a></h2>


<pre>SELECT [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
       [HIGH_PRIORITY]
       [DISTINCT | DISTINCTROW | ALL]
    select_expression,...
    [INTO {OUTFILE | DUMPFILE} 'file_name' export_options]
    [FROM table_references
        [WHERE where_definition]
        [GROUP BY {unsigned_integer | col_name | formula}]
        [HAVING where_definition]
        [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] ,...]
        [LIMIT [offset,] rows]
        [PROCEDURE procedure_name] ]
</pre>

<p>
<code>SELECT</code>は通常、1つまたは1つ以上のテーブルからレコードを検索して抽出するのに使用されます。
<code>select_expression</code> は取り出したいフィールドを示します。
<code>SELECT</code>はまた、テーブルの参照なしに計算によって求められたレコードを取り出すために使用されます。例:

</p>

<pre>mysql&gt; SELECT 1 + 1;
         -&gt; 2
</pre>

<p>
全てのキーワードの使用は、上記に示すような順序で正確に与えられる必要があります。例えば、<code>HAVING</code>節は必ず<code>GROUP BY</code>節の後、<code>ORDER BY</code>節の前でなければなりません。

</p>

<ul>

<li>

<a name="IDX521"></a>
<a name="IDX522"></a>
<code>SELECT</code>の表現では、<code>AS</code>による別名の指定が可能です。別名は、フィールド名の表現として使われ、<code>ORDER BY</code>及び<code>HAVING</code>節とともに使用することができます。
例:


<pre>mysql&gt; select concat(last_name,', ',first_name) AS full_name
    from mytable ORDER BY full_name;
</pre>

</li><li>

<code>FROM table_references</code>節は、(例えば、選択するレコードにより、1つ又はそれ以上の)結合するテーブルのリストを示します。
このリストはまた、<code>LEFT OUTER JOIN</code>参照を含むことがあります。
 「<a href="manual.ja_Reference.html#JOIN">7.15  <code>JOIN</code> 構文</a>」節参照.

</li><li>

<code>col_name</code>、<code>tbl_name.col_name</code>、<code>db_name.tbl_name.col_name</code>のようにしてフィールドを表すことができます。
<code>SELECT</code>ステートメント内での列の参照が曖昧でなければ、<code>tbl_name</code>や<code>db_name.tbl_name</code>のようなプリフィックスを詳細に記述する必要はありません。
より明示的なフィールドの指定形式をを必要とする曖昧な参照の例は、 「<a href="manual.ja_Reference.html#Legal_names">7.1.5  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</a>」節を参照のこと。

</li><li>

<a name="IDX523"></a>
<a name="IDX524"></a>
テーブル参照は、<code>tbl_name AS alias_name</code>又は<code>tbl_name alias_name</code>を使って別名を使用することが可能です。


<pre>mysql&gt; select t1.name, t2.salary from employee AS t1, info AS t2
           where t1.name = t2.name;
mysql&gt; select t1.name, t2.salary from employee t1, info t2
           where t1.name = t2.name;
</pre>

</li><li>

<code>LIKE</code>の表現において、ワイルドカード・キャラクタである<samp>`%'</samp>や<samp>`_'</samp>
は、これらの通常のワイルドカードとしての意味を抑制するために<samp>`\'</samp>の後に置かれることにより、定数<samp>`%'</samp>や<samp>`_'</samp>の検索に使われます。

</li><li>

出力用に選択されたフィールドは、<code>ORDER BY</code>節や<code>GROUP BY</code>節において、フィールド名、フィールドのエイリアス名、又はフィールド番号にて指し示すことができます。フィールド番号は1から始まります。


<pre>mysql&gt; select college, region, seed from tournament
           ORDER BY region, seed;
mysql&gt; select college, region AS r, seed AS s from tournament
           ORDER BY r, s;
mysql&gt; select college, region, seed from tournament
           ORDER BY 2, 3;
</pre>

逆順で並べたい場合には、 <code>ORDER BY</code> 節の中で、あなたが並べたいと思っている
フィールドの名前の後ろに、 <code>DESC</code> (descending) キーワードを
追加します。
デフォルトは昇順です； これは <code>ASC</code> キーワードを指定したことになります。

</li><li>

<code>HAVING</code>節は、<code>select_expression</code>においてどのフィールドの名前やエイリアス名でも指し示すことができます。
これは最後に適用され、クライアントにアイテムが送られる直前に実行されるので、最適化されません。
<code>WHERE</code>節で書くべきものに<code>HAVING</code>を用いてはいけません。
例えば、次のように書いてはいけません:


<pre>mysql&gt; select col_name from tbl_name HAVING col_name &gt; 0;
</pre>

その代わりに、次のように書いてください:


<pre>mysql&gt; select col_name from tbl_name WHERE col_name &gt; 0;
</pre>

<strong>MySQL</strong> 3.22.5以降では、次のようにクエリを記述することができます:


<pre>mysql&gt; select user,max(salary) from users
           group by user HAVING max(salary)&gt;10;
</pre>

<strong>MySQL</strong>の古いバージョンでは、この代わりに次のように記述できます:


<pre>mysql&gt; select user,max(salary) AS sum from users
           group by user HAVING sum&gt;10;
</pre>

</li><li>

<code>SQL_SMALL_RESULT</code>, <code>SQL_BIG_RESULT</code>, <code>SQL_BUFFER_RESULT</code>,
<code>STRAIGHT_JOIN</code>, <code>HIGH_PRIORITY</code> は ANSI SQL92 に対する <strong>MySQL</strong> 拡張です。

</li><li>

<code>HIGH_PRIORITY</code> は、テーブルの更新よりも <code>SELECT</code> を優先させます。
これは一度で完了する、とても速いクエリにのみ適用すべきです。
もしリードロックされているテーブルがあったとし、
たとえ update 文がこのテーブルの解除を待っていたとしても、
<code>SELECT HIGH_PRIORITY</code> クエリは実行されます。

</li><li>

<code>SQL_BIG_RESULT</code> は <code>GROUP BY</code> や <code>DISTINCT</code> と共に使用する
事ができ、結果セットが多くのレコードを持つことをオプティマイザに知らせます。
この場合、必要なら <strong>MySQL</strong> はディスクベースの一時テーブルを直接使用
します。<code>MySQL</code> はこの場合、<code>GROUP BY</code> 要素上のキーで一時テーブ
ルを行なう代わりにソートを行なうことを選択します。

</li><li>

<code>SQL_SMALL_RESULT</code> (<strong>MySQL</strong> 固有のオプション) は <code>GROUP BY</code>
か <code>DISTINCT</code> と共に使用する事ができ、
結果セットが小さくなることをオプティマイザに知らせます。この場合、
<strong>MySQL</strong> はソートする代わりに、速い一時テーブルを結果の保存のた
めに使用します。 <strong>MySQL</strong> 3.23 では、これは通常必要ではありません。

</li><li>

<code>STRAIGHT_JOIN</code>は、<code>FROM</code>節にて記述されたテーブルの順序に従って結合するよう、オプティマイザに強制します。オプティマイザが、テーブルを最適な順序で結合しない場合に、クエリのスピードアップのためにこれを使用することが可能です。
 「<a href="manual.ja_Reference.html#EXPLAIN">7.24  <code>EXPLAIN</code> 構文 (<code>SELECT</code>についての情報を得る)</a>」節参照.

</li><li>

<code>LIMIT</code> 節は、 <code>SELECT</code> 構文で返されるレコード数を指定するのに
使用されます。 <code>LIMIT</code> は一つか二つの数字の引数を取ります。

引数が2つ与えられたならば、最初の引数は最初のレコードからのオフセットを示し、2つめの引数は返すレコードの最大数を示します。
初めのレコードのオフセットは0です(1ではありません)。


<pre>mysql&gt; select * from table LIMIT 5,10;  # 6～15行目を返す
</pre>

もし引数が一つなら、返すべきレコードの最大行数を指定したことになります。


<pre>mysql&gt; select * from table LIMIT 5;     # 最初の5行を取り出す
</pre>

いいかえれば、<code>LIMIT n</code> は <code>LIMIT 0,n</code> と同じです。

</li><li>

<a name="IDX525"></a>
<code>SELECT</code>の書式、<code>SELECT ... INTO OUTFILE 'file_name'</code>は、選択されたレコードをファイルに書き込みます。
ファイルはサーバ機に作成され、既に存在するファイルであってはなりません(<tt>`/etc/passwd'</tt>のようなファイルの破壊を防止します)。
<code>SELECT ... INTO OUTFILE</code>は、<code>LOAD DATA INFILE</code>の逆です。<code>export_options</code>の構文は、<code>LOAD DATA INFILE</code>ステートメントの一部で使われる<code>FIELDS</code>節や<code>LINES</code>節と同じような構成です。
 「<a href="manual.ja_Reference.html#LOAD_DATA">7.18  <code>LOAD DATA INFILE</code>構文</a>」節参照.

<code>INTO OUTFILE</code>を使うとき、エスケープ・キャラクタ、<code>ASCII 0</code> (nul)、そして全てのターミネータ・キャラクタは、デフォルトでエスケープされることに気をつけてください。
 「<a href="manual.ja_Reference.html#LOAD_DATA">7.18  <code>LOAD DATA INFILE</code>構文</a>」節参照.

結果として取り出されるテキストファイルでは、
以下に示す文字が <code>ESCAPED BY</code> 指定の文字によってエスケープされます：


<ul>
<li><code>ESCAPED BY</code> 文字自身

</li><li><code>FIELDS TERMINATED BY</code> の最初の文字

</li><li><code>LINES TERMINATED BY</code> の最初の文字

</li></ul>

さらに、 <code>ASCII 0</code> は、<code>ESCAPED BY</code> 0 (<code>ASCII 48</code>) にコンバートされます。

いかなる <code>FIELDS TERMINATED BY</code>, <code>ESCAPED BY</code>, <code>LINES TERMINATED BY</code>
指定されている文字も、エスケープしなければならない理由は、
テキストファイルを読み返せれるようにするためなのです。
<code>ASCII 0</code> はいくつかのページャーでも見れるようにするために
エスケープされるのです。

結果のファイルは SQL の文を含んでいないので、何もエスケープする必要はありません。
</li></ul>

<p>
<a name="IDX526"></a>
<code>INTO OUTFILE</code> の代わりに <code>INTO DUMPFILE</code> を使用すると、
<strong>MySQL</strong> はファイルに１レコードだけを書きます。フィールドや行の終端
とすべてのエスケープを含みません。これはファイル内に BLOB を格納したい場合
に便利です。

</p>
<p>
<a name="IDX527"></a>
<a name="IDX528"></a>
<a name="IDX529"></a>
<a name="IDX530"></a>
<a name="IDX531"></a>
<a name="IDX532"></a>
<a name="IDX533"></a>
<a name="IDX534"></a>


</p><h2><a name="JOIN" href="manual.ja_toc.html#JOIN">7.15  <code>JOIN</code> 構文</a></h2>

<p>
<strong>MySQL</strong>は、以下に示す<code>SELECT</code>ステートメントにおける<code>JOIN</code>構文をサポートします:

</p>

<pre>table_reference, table_reference
table_reference [CROSS] JOIN table_reference
table_reference INNER JOIN table_reference
table_reference STRAIGHT_JOIN table_reference
table_reference LEFT [OUTER] JOIN table_reference ON conditional_expr
table_reference LEFT [OUTER] JOIN table_reference USING (column_list)
table_reference NATURAL LEFT [OUTER] JOIN table_reference
{ oj table_reference LEFT OUTER JOIN table_reference ON conditional_expr }
</pre>

<p>
Where <code>table_reference</code> is defined as

</p><pre>table_name [[AS] alias] [USE INDEX (key_list)] [IGNORE INDEX (key_list)]
</pre>

<p>
<a name="IDX535"></a>
<a name="IDX536"></a>
上に示す最後の<code>LEFT OUTER JOIN</code>構文は、ODBCとの互換性のためだけに存在します。

</p>

<ul>
<li>

table referenceは、<code>tbl_name AS alias_name</code>や<code>tblname alias_name</code>による別名を指定することができます。


<pre>mysql&gt; select t1.name, t2.salary from employee AS t1, info AS t2
           where t1.name = t2.name;
</pre>

</li><li>

<code>INNER JOIN</code>と<code>,</code> (コンマ)は、同義語です。どちらも使用されるテーブル間の直積をとります。通常は<code>WHERE</code>条件にて、テーブルがどのようにリンクされるべきかを定義します。

</li><li>

<code>ON</code>条件節は、<code>WHERE</code>節で使用されるような条件文の書式です。

</li><li>

もし、<code>LEFT JOIN</code>において右側のテーブルにマッチするレコードが無かった場合、全てのフィールドが<code>NULL</code>である1つのレコードが、右側のテーブルとして使用されます。
この事実は、あるテーブルについて、他のテーブルに対応するレコードが存在しないレコードを探すということに利用できます:


<pre>mysql&gt; select table1.* from table1
           LEFT JOIN table2 ON table1.id=table2.id
           where table2.id is NULL;
</pre>

この例は、<code>table1</code>の内、<code>id</code>の値が<code>table2</code>に存在しない全てのレコードを検索します。(即ち、<code>table2</code>内のレコードと一致しない<code>table1</code>の全てのレコード。)
もちろん、この場合の<code>table2.id</code>は、<code>NOT NULL</code>と定義されているものと仮定します。

</li><li>

<code>USING</code> <code>(column_list)</code>節のフィールド名リストは、両方のテーブルに存在しなければなりません。<code>USING</code>節が次のように:


<pre>A LEFT JOIN B USING (C1,C2,C3,...)
</pre>

定義されることは、<code>ON</code>式がこのように定義されるのと同義です:


<pre>A.C1=B.C1 AND A.C2=B.C2 AND A.C3=B.C3,...
</pre>

</li><li>

2つのテーブルの<code>NATURAL LEFT JOIN</code>は、<code>USING</code>により両方のテーブルに存在する全てのフィールドを定義することと同義です。

</li><li>

<code>STRAIGHT_JOIN</code>は、右側のテーブルの前に、常に左側のテーブルを読むことを除けば、<code>JOIN</code>と全く同じことです。これは、結合オプティマイザが、不当な順序でテーブルを出力するようなまれな事態に使用できます。

</li><li>

<strong>MySQL</strong> 3.23.12 から、テーブルから情報を取り出す時に、
<strong>MySQL</strong> がどのインデックスを使用すべきかというヒントを与えることが
できるようになりました。これは、<strong>MySQL</strong> が間違ったインデックスを使
用していることを <code>EXPLAIN</code> が示す場合に有用です。<code>USE INDEX
(key_list)</code> を指定することによって、テーブルからレコードを見つけるために、
指定されたインデックスの一つだけを使用するように <strong>MySQL</strong> に伝えるこ
とができます。別の構文 <code>IGNORE INDEX (key_list)</code> は、<strong>MySQL</strong> 
に特定のインデックスを使用しないように伝えるために使用できます。
</li></ul>

<p>
例:

</p>

<pre>mysql&gt; select * from table1,table2 where table1.id=table2.id;
mysql&gt; select * from table1 LEFT JOIN table2 ON table1.id=table2.id;
mysql&gt; select * from table1 LEFT JOIN table2 USING (id);
mysql&gt; select * from table1 LEFT JOIN table2 ON table1.id=table2.id
           LEFT JOIN table3 ON table2.id=table3.id;
mysql&gt; select * from table1 USE INDEX (key1,key2) WHERE key1=1 and key2=2 AND
       key3=3;
mysql&gt; select * from table1 IGNORE INDEX (key3) WHERE key1=1 and key2=2 AND
       key3=3;
</pre>

<p>
 「<a href="manual.ja_Performance.html#LEFT_JOIN_optimization">12.5.4  MySQL はどのように <code>LEFT JOIN</code> を最適化するか？</a>」節参照.

</p>
<p>
<a name="IDX537"></a>


</p><h2><a name="INSERT" href="manual.ja_toc.html#INSERT">7.16  <code>INSERT</code>構文</a></h2>


<pre>    INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...),(...),...
or  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
or  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name
        SET col_name=expression, col_name=expression, ...
</pre>

<p>
<code>INSERT</code>は、既存のテーブルに新しいレコードを挿入します。
<code>INSERT ... VALUES</code>書式は、値の明示指定を基本としてレコードを挿入します。
<code>INSERT ... SELECT</code>書式は、他の表(複数可)から抽出したレコードを挿入します。
複数の値リストを用いる<code>INSERT ... VALUES</code>書式は、<strong>MySQL</strong> 3.22.5以降でサポートされています。
<code>col_name=expression</code>構文は、<strong>MySQL</strong> 3.22.10以降でサポートされています。

</p>
<p>
<code>tbl_name</code>は、レコードを挿入するテーブルです。フィールド名リストは、後続の値定義ステートメントのフィールドを指し示します。

</p>

<ul>
<li>

もしいかなるフィールドも <code>INSERT ... VALUES</code> や <code>INSERT ... SELECT</code> などで
明示しなければ、全てのフィールドの値が <code>VALUES()</code> の中に与えられなくてはなりません。
テーブル内のフィールド順が不明な場合、これを調べるために<code>DESCRIBE tbl_name</code>を使用して下さい。

</li><li>

テーブル内の一部のフィールドしか指定しない場合、指定されなかったフィールドには、それぞれの初期値が指定されます。初期値の割当ては、 「<a href="manual.ja_Reference.html#CREATE_TABLE">7.7  <code>CREATE TABLE</code>構文</a>」節. で述べられています。

</li><li>

<code>NULL</code>を<code>TIMESTAMP</code>フィールドに挿入した場合、フィールドには現在時刻がセットされます。他の値を挿入した場合、指定された値が単純にセットされます。

</li><li>

<code>expression</code>は、値リスト内で先頭に近い方のフィールドを参照しなければなりません。
例えば、次のように記述できます:


<pre>mysql&gt; INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);
</pre>

しかし、次のようには記述できません:


<pre>mysql&gt; INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);
</pre>

</li><li>

キーワード<code>LOW_PRIORITY</code>を指定した場合、<code>INSERT</code>の実行はそのテー
ブルから値を読み込むクライアントがいなくなるまで遅らされます。この場合、ク
ライアントは insert 文が完了するまで待たされます。テーブルが頻繁に使用され
る場合、長い時間かかります。これはクライアントを一度に継続させる 
<code>INSERT DELAYED</code> と対称的です。

</li><li>

もし <code>IGNORE</code> キーワードを <code>INSERT</code> に 値とともに 与えるなら、
テーブル内の <code>PRIMARY</code> や <code>UNIQUE</code> キーにすでに存在する重複した
ものは無視され、挿入されません。
多重行の値を含むレコードの <code>INSERT</code> にキーワード <code>IGNORE</code> を指定しない場合、
テーブルの <code>PRIMARY</code> キーや <code>UNIQUE</code> キーに重複が起こる際に、
挿入処理が異常終了します。
<code>IGNORE</code> を指定した場合、重複するキー値を持つレコードは挿入されません。
C API 関数 <code>mysql_info()</code> により、テーブルにいくつのレコードが挿入されたか
チェックすることができます。

</li><li>

<strong>MySQL</strong>が、<code>DONT_USE_DEFAULT_FIELDS</code>オプションにより制限されていた場合、<code>NULL</code>値を許さない全てのフィールドに明示的に値をしないと<code>INSERT</code>ステートメントは、エラーを生成します。
 「<a href="manual.ja_Installing.html#configure_options">4.7.3  典型的な configure オプション</a>」節参照.

</li><li>

以下の条件は、<code>INSERT INTO ... SELECT</code>ステートメントのために用意されています:


<ul>
<li>

クエリーは、<code>ORDER BY</code>節を含むことができません。

</li><li>

<code>INSERT</code>ステートメントのターゲットとなるテーブルは、クエリー内<code>SELECT</code>部の<code>FROM</code>節に指定できません。なぜなら、挿入先のテーブルからの<code>SELECT</code>はANSI SQLで禁じられているからです。(問題は、<code>SELECT</code>が実行中に挿入したレコードを抽出することが可能であることです。副問い合わせ節を使用するときに、このような状況で混乱しやすくなります！)

</li><li>

<code>AUTO_INCREMENT</code>フィールドは、通常通り動作します。
</li></ul>

</li></ul>

<p>
<a name="IDX538"></a>
多重の値リストを持つ <code>INSERT ... SELECT ...</code> 又は <code>INSERT ... VALUES()</code> ステートメントを使用する場合、クエリーに関する情報を得るために C API関数 <code>mysql_info()</code> を使用することができます。
その情報の書式は以下に示す文字列のようになります:

</p>

<pre>Records: 100 Duplicates: 0 Warnings: 0
</pre>

<p>
<code>Duplicates</code>は、既に存在するユニークインデックスの値と重複することにより、挿入できなかったレコード数を表します。
<code>Warnings</code>は、挿入されたフィールドが何らかの疑わしい値であったという数を表します。警告は、次のような条件の下で発生します:

</p>

<ul>
<li>

<code>NOT NULL</code>定義されたフィールドへの<code>NULL</code>の挿入。フィールドには初期値が設定されます。

</li><li>

数値フィールドの範囲を超える値のセット。値は範囲内の限界値に補正されます。

</li><li>

数値フィールドへの <code>`10.34 a'</code> のような値のセット。引きずっているゴミは取り除かれ、残りの数値部分が挿入されます。値が数値として判断できなかった場合、フィールドには <code>0</code> がセットされます。

</li><li>

<code>CHAR</code>、<code>VARCHAR</code>、<code>VARCHAR</code>、<code>TEXT</code>又は<code>BLOB</code>フィールドへの最大長を超える文字列の挿入。値はフィールドの最大長に切り捨てられます。

</li><li>

日付又は時刻フィールドへのフィールド属性に反した挿入。その属性に適した``ゼロ''値がセットされます。
</li></ul>

<p>
<a name="IDX539"></a>
<a name="IDX540"></a>

</p>
<p>
<code>INSERT</code> 構文の <code>DELAYED</code> オプションは <strong>MySQL</strong> 独自の
オプションで、これは <code>INSERT</code> が完全に終了することを待てない
クライアントを持つ場合に、とても役立ちます。
これは、ロギングのために <strong>MySQL</strong> を使用する時の一般的な問題で、完了
に長い時間がかかる <code>SELECT</code> ステートメントも定期的に実行できます。
<code>DELAYED</code> は <strong>MySQL</strong> 3.22.15 で導入されました。  これは
 ANSI SQL92 に対する <strong>MySQL</strong> 拡張です。

</p>
<p>
<code>INSERT DELAYED</code> を使用する時、クライアントは一度 ok となり、テーブル
が他のスレッドで使用中でない時にレコードが挿入されます。

</p>
<p>
<code>INSERT DELAYED</code> を使用して得られるほかの利益は、
多くのクライアントからの insert が同時に束ねられ、一つのブロックで
書かれることです。 これは多くの別々の insert を実行するより
とても速くなります。

</p>
<p>
現在、キューイングされたレコードは、それらがテーブルに代入されるまで
メモリーに保持されているだけです。 これは、もし <code>mysqld</code> を
強引な方法 (<code>kill -9</code>) でキルしたり、 <code>mysqld</code> が予期せず
死んだ場合、キューイングされているレコードはディスクに書かれず失われます！

</p>
<p>
<code>DELAYED</code> オプションを <code>INSERT</code> や <code>REPLACE</code> で使用する場合、
以下のことがおきます。
ここで ``スレッド'' とは <code>INSERT DELAYED</code> コマンドを受けたスレッドをさし、
``ハンドラー'' とは特定のテーブルのための全ての
<code>INSERT DELAYED</code> 構文を操作するスレッドを指します。

</p>

<ul>
<li>

スレッドがあるテーブルに対し <code>DELAYED</code> 構文を実行するとき、
そのテーブルに対する全ての <code>DELAYED</code> 構文
を処理するためにハンドラースレッドが作成されます。
もしそのようなハンドラーが存在していない場合には。

</li><li>

そのスレッドは、そのハンドラーが <code>DELAYED</code> ロックを既に持っているか
どうかをチェックします； もし持っていないなら、そうするように
ハンドラーに告げます。 
たとえ他のスレッドが <code>READ</code> か <code>WRITE</code> ロックをそのテーブルに
持っていたとしても、 <code>DELAYED</code> ロックを得ることができます。
しかし、そのハンドラーは全ての <code>ALTER TABLE</code> ロックか
 <code>FLUSH TABLES</code> を待ちます。 そのテーブル構造が最新であるのを
確実にするために。

</li><li>

スレッドは <code>INSERT</code> ステートメントを実行しますが、レコードをテーブル
に書く代わりに、ハンドラスレッドによって管理されるキューに最後のレコードの
コピーを置きます。文法エラーはスレッドによって通知され、クライアントプログ
ラムに報告されます。

</li><li>

クライアントは結果行の重複数や <code>AUTO_INCREMENT</code> の値を
報告できません； それはサーバーから得ることができません。 なぜなら、
 <code>INSERT</code> はインサートオペレーションが完全に終了する前に
返るからです。 もし C API を使用しているなら、 <code>mysql_info()</code> 関数は
同様の理由によりなにも返しません。

</li><li>

更新ログは、レコードがそのテーブルに insert されたとき、そのハンドラースレッド
によって更新されます。 複数レコードの挿入の場合、 更新ログは最初の行が
挿入されたときに更新されます。

</li><li>

それぞれの <code>delayed_insert_limit</code> レコードが書かれた後、そのハンドラーは
いかなる <code>SELECT</code> 文もまだ延期されていないかを確認します。
もしそうなら、続ける前にこれらに対して実行を可能にします。

</li><li>

ハンドラーのキュー内にレコードがなくなったとき、テーブルはアンロックされます。
もし新しい <code>INSERT DELAYED</code> コマンドが <code>delayed_insert_timeout</code> 秒以内に
受け付けられなければ、ハンドラーは終了します。

</li><li>

もし、特定のハンドラーのキュー内に <code>delayed_queue_size</code> 以上のレコードが
既に延期されているならば、そのスレッドは、キューに余裕がある間待ちます。
これは <code>mysqld</code> サーバーが delayed されたキューに全ての
メモリーを確実に使用しないようにするのに役立ちます。

</li><li>

そのハンドラースレッドは  <strong>MySQL</strong> プロセスリストの <code>Command</code> 項
内に、 <code>delayed_insert</code> と共に表示されます。
これは <code>FLUSH TABLES</code> コマンドか <code>KILL thread_id</code> を実行することで、
kill できるでしょう。
しかし、これらは、終了する前に、キュー内の全てのレコードをテーブルに
保存しようとします。
この間、このスレッドは、他のスレッドから来たいかなる
新しい <code>INSERT</code> コマンドも受け付けません。
もし、この後に <code>INSERT DELAYED</code> コマンドを実行するなら、
新しいハンドラースレッドが作成されます。

</li><li>

上記のことは、もし <code>INSERT DELAYED</code> コマンドが既に走っているなら、
 <code>INSERT DELAYED</code> コマンドは、普通の <code>INSERT</code> コマンドよりも高い
優先度を持つということです！
他の update コマンドは <code>INSERT DELAY</code> キューが空になるまで、
あるいは誰かが <code>KILL thread_id</code> や <code>FLUSH TABLES</code> を実行して
ハンドラーをキルするまで、
待たされます。

</li><li>

以下のステータス変数は <code>INSERT DELAYED</code> コマンドについての情報を
与えます：

<table border="" width="100%" nosave="">
<tbody><tr><td><code>Delayed_insert_threads</code> </td><td> ハンドラースレッドの数
</td></tr>
<tr><td><code>Delayed_writes</code> </td><td> <code>INSERT DELAYED</code> で書かれるレコード数
</td></tr>
<tr><td><code>Not_flushed_delayed_rows</code> </td><td> 書き込みを待つレコード数
</td></tr>
</tbody></table>

これらの変数は <code>SHOW STATUS</code> 構文を発行したり
 <code>mysqladmin extended-status</code> コマンドを実行することで見れます.
</li></ul>

<p>
注意: <code>INSERT DELAYED</code> は、テーブルが使用中でない場合、通常の 
INSERT よりも遅くなります。<code>INSERT DELAYED</code> を使用する各テーブルにつ
いて別のスレッドを操作するサーバの、追加のオーバーヘッドもあります。これは、
確実にそれを必要とする時にだけ <code>INSERT DELAYED</code> を使用すべきことを意
味します！

</p>
<p>
<a name="IDX541"></a>


</p><h2><a name="REPLACE" href="manual.ja_toc.html#REPLACE">7.17  <code>REPLACE</code>構文</a></h2>


<pre>    REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...)
or  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
or  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name
          SET col_name=expression, col_name=expression,...
</pre>

<p>
<code>REPLACE</code>は、テーブル中の古いレコードがユニークインデックス上の
新しいレコードと同じ値を持つ場合に、新しいレコードを挿入する前に、
古いレコードを削除するということを除けば、<code>INSERT</code>と全く同じように
動作します。 
 「<a href="manual.ja_Reference.html#INSERT">7.16  <code>INSERT</code>構文</a>」節参照.

</p>
<p>
<a name="IDX542"></a>


</p><h2><a name="LOAD_DATA" href="manual.ja_toc.html#LOAD_DATA">7.18  <code>LOAD DATA INFILE</code>構文</a></h2>


<pre>LOAD DATA [LOW_PRIORITY] [LOCAL] INFILE 'file_name.txt' [REPLACE | IGNORE]
    INTO TABLE tbl_name
    [FIELDS
        [TERMINATED BY '\t']
        [OPTIONALLY] ENCLOSED BY '']
        [ESCAPED BY '\\' ]]
    [LINES TERMINATED BY '\n']
    [IGNORE number LINES]
    [(col_name,...)]
</pre>

<p>
<code>LOAD DATA INFILE</code>ステートメントは、テキストファイルからテーブルへと、
レコードを高速に読み込みます。 <code>LOCAL</code> キーワードが指定されれば、ファイルは
クライアント・ホストから読み込まれます。
<code>LOCAL</code>が指定されなければ、ファイルはサーバに位置する必要があります
(<code>LOCAL</code>は、<strong>MySQL</strong> 3.22.6以降で利用できます)。

</p>
<p>
セキュリティ上の理由から、サーバからテキストファイルを読み出す時は、
ファイルがデータベースディレクトリに存在するか、
全てに読み込み権限がある必要があります。
また、サーバファイルで <code>LOAD DATA INFILE</code> を使用するには、
データベースの <strong>file</strong> 権限も持たなければなりません。
 「<a href="manual.ja_Privilege_system.html#Privileges_provided">6.6  <strong>MySQL</strong> が提供する権限</a>」節参照.

</p>
<p>
もし <code>LOW_PRIORITY</code> を指定した場合、<code>LOAD DATA</code> 構文は
そのテーブルから他のクライアントが読み込みを行っている間、
遅らされます。

</p>
<p>
<code>LOCAL</code> 使用をすると、クライアント・ホストからサーバ・ホストへ
ファイルの内容が転送される分、多少遅くなるでしょう。
いうならば、ローカルのファイルを読み込むのに、
<strong>file</strong> 権限は必要ないということです。

</p>
<p>
<a name="IDX543"></a>
<code>mysqlimport</code>ユティリティは、データファイルの読み込みに使用することができます。; これは、サーバに<code>LOAD DATA INFILE</code>コマンドを送信することによって処理を実現しています。
<code>--local</code>オプションは、<code>mysqlimport</code>に、クライアント・ホストからデータファイルを読み込ませます。
クライアントとサーバが圧縮プロトコルをサポートしていれば、低速なネットワークでより良いパフォーマンスを得るために、<code>--compress</code>オプションを指定することができます。

</p>
<p>
サーバ・ホストにファイルを置く場合、サーバは、以下のルールを使用します:

</p>

<ul>
<li>

完全なパスでファイル名が与えられた場合、サーバはパス名をそのまま使用します。

</li><li>

１つ又は複数の構成要素から成る相対パスと共にファイル名が与えられた場合、サーバは、サーバのデータディレクトリ以下からファイルを探します。

</li><li>

ファイル名だけが単に与えられた場合、サーバは、
カレントのデータベースディレクトリを探します。
</li></ul>

<p>
これらのルールは、ファイルが <tt>`myfile.txt'</tt> のように与えられれば
データベースディレクトリからファイルが読み出され、
<tt>`./myfile.txt'</tt> のように与えられれば、現在選択しているデータベースのデータディレクトリから
ファイルが読み出されるという意味であることに注意して下さい。

</p>
<p>
例えば、以下の <code>LOAD DATA</code> 文は、<tt>`data.txt'</tt> ファイルを
<code>db1</code> データベースディレクトリから読みます。 なぜなら、<code>db1</code> は
現在選択されているデータベースだからです。 たとえ、<code>db2</code> データベース
のテーブルに、ファイルから読み込んだデータを挿入するとしても。：

</p>
<p>
以下に示すような構文では、ファイルは <code>db1</code> データベースディレクトリ
から読まれます。<code>db2</code> ではありません:

</p>

<pre>mysql&gt; USE db1;
mysql&gt; LOAD DATA INFILE "data.txt" INTO TABLE db2.my_table; 
</pre>

<p>
<code>REPLACE</code> と <code>IGNORE</code> キーワードは、すでに存在するユニークキーに
重複しているレコードの入力に対する制御です。
<code>REPLACE</code> 指定の場合、同じユニークキーを持つ既存のレコードは新しいレコードで
置き換えられます。
<code>IGNORE</code> 指定の場合、既存のレコードのユニークキーと重複するキーをもつ新しいレコードは
飛ばされます。 もし、どちらも指定しなかった場合、重複したキーが見つかった場合
エラーが発生し、テキストファイルは無視されます。

</p>
<p>
<code>LOCAL</code> キーワードを使用してデータをローカルからロードする場合、
サーバーは操作の途中で転送をとめる方法を知りません。
それでデフォルトの動作としては <code>IGNORE</code> が指定されたのと
同じになります。

</p>
<p>
<code>LOAD DATA INFILE</code>は、<code>SELECT ... INTO OUTFILE</code>の逆です。
 「<a href="manual.ja_Reference.html#SELECT">7.14  <code>SELECT</code>構文</a>」節参照.
データベースからファイルへデータを書き込むには、<code>SELECT ... INTO OUTFILE</code>を使用します。
ファイルからデータベースに読み戻すには、<code>LOAD DATA INFILE</code>を使用します。
<code>FIELDS</code>と<code>LINES</code>節の構文は両方のコマンドとも同じです。
どちらの節もオプションですが、両方を指定する場合は、<code>FIELDS</code>は、<code>LINES</code>より先に指定しなければなりません。

</p>
<p>
<code>FIELDS</code>節を指定した場合、その段落(<code>TERMINATED BY</code>、<code>[OPTIONALLY] ENCLOSED BY</code>及び<code>ESCAPED BY</code>)は、少なくとも１つを指定しなければならないことを除いて、それらもまたオプションとなります。

</p>
<p>
<code>FIELDS</code>節を指定しなかった場合、初期値は以下のように記述したのと等価となります:

</p>

<pre>FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
</pre>

<p>
<code>LINES</code>節を指定しなかった場合、初期値は以下のように記述したのと等価となります:

</p>

<pre>LINES TERMINATED BY '\n'
</pre>

<p>
言い換えると、<code>LOAD DATA INFILE</code> の初期値は、出力へ書き込む際に以下のように振舞います:

</p>

<ul>
<li>

改行をレコードの境界とみなす

</li><li>

タブ文字によってフィールドを区切る

</li><li>

クォート文字でフィールドを囲んでいないものとする

</li><li>

タブ文字や改行文字及び<samp>`\'</samp>の前に<samp>`\'</samp>があることにより、それらをフィールド値の一部のリテラル文字であるとして処理する。
</li></ul>

<p>
逆に、<code>LOAD DATA INFILE</code>の初期値は、入力を読み込む際に以下のように振舞います:

</p>

<ul>
<li>

フィールド間にタブ文字を書く

</li><li>

いずれのクォート文字でもフィールドを囲まない

</li><li>

<samp>`\'</samp>の使用により、フィールド値の中で使用するタブ文字や改行文字、<samp>`\'</samp>をエスケープする

</li><li>

レコードの終りに改行文字を書く
</li></ul>

<p>
 <code>FIELDS ESCAPED BY '\\'</code>と書いた場合、単一のバックスラッシュとして読み出される値とするために、２つのバックスラッシュを指定しなければならないことに注意して下さい。

</p>
<p>
<code>IGNORE number LINES</code> オプションはファイルの先頭にあるレコードを無視するのに
使用されます：

</p>

<pre>mysql&gt; LOAD DATA INFILE "/tmp/file_name" into table test IGNORE 1 LINES;
</pre>

<p>
データベースからファイルへデータを書き、それから後でそのファイルからデータベースへデータを読み戻すために、<code>SELECT ... INTO OUTFILE</code>と対に<code>LOAD DATA INFILE</code>を使う場合、双方のフィールドとレコードの取扱いに関するオプションは、一致しなければなりません。さもなければ、<code>LOAD DATA INFILE</code>は適切にファイルを処理しないでしょう。
 フィールドをコンマで区切ってファイルへ書き出すために、<code>SELECT ... INTO OUTFILE</code>を使用するとすれば:

</p>

<pre>mysql&gt; SELECT * FROM table1 INTO OUTFILE 'data.txt'
           FIELDS TERMINATED BY ','
           FROM ...
</pre>

<p>
コンマ区切りファイルから読み戻すため、正しいステートメントはこうなるでしょう:

</p>

<pre>mysql&gt; LOAD DATA INFILE 'data.txt' INTO TABLE table2
           FIELDS TERMINATED BY ',';
</pre>

<p>
その代わりとして次に示すようなステートメントでファイルを読み込もうとしても、正しく動作しないでしょう。なぜなら、これは、<code>LOAD DATA INFILE</code>に対してフィールドの間にタブを探すよう指示するからです:

</p>

<pre>mysql&gt; LOAD DATA INFILE 'data.txt' INTO TABLE table2
           FIELDS TERMINATED BY '\t';
</pre>

<p>
おそらく、それぞれの入力行は単一のフィールドとして処理されるでしょう。

</p>
<p>
<code>LOAD DATA INFILE</code>は外部ソースからもファイルを読み出すことができます。
例えば、dBASEフォーマットのファイルは、フィールドをコンマで区切られ、ダブルクォーテーションで囲まれています。
レコードが改行文字で区切られているとしたら、次に示すフィールド及びレコードの取扱オプションを指定したコマンドが、このようなファイルを読み込むのに使用できます。

</p>

<pre>mysql&gt; LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name
           FIELDS TERMINATED BY ',' ENCLOSED BY '"'
           LINES TERMINATED BY '\n';
</pre>

<p>
いくつかのフィールド及びレコードの取扱オプションに、空文字列(<code>''</code>)を指定することがあります。空でないなら、<code>FIELDS [OPTIONALLY] ENCLOSED BY</code>と<code>FIELDS ESCAPED BY</code>の値は単一の文字でなければなりません。<code>FIELDS TERMINATED BY</code>と<code>LINES TERMINATED BY</code>は２つ以上の文字となるでしょう。例えば、リターン文字と改行文字のペアで区切られたレコードを書き込んだり、このようなレコードを含んだファイルを読み込んだりするには、<code>LINES TERMINATED BY '\r\n'</code>節を指定します。

</p>
<p>
<code>FIELDS [OPTIONALLY] ENCLOSED BY</code>は、フィールドの引用符を制御します。出力の際(<code>SELECT ... INTO OUTFILE</code>)、<code>OPTIONALLY</code>語を省いたなら、全てのフィールドは<code>ENCLOSED BY</code>文字で囲まれます。このような出力(フィールド区切りにコンマを使用)の例を次に示します:

</p>

<pre>"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"
</pre>

<p>
<code>OPTIONALLY</code>を指定すれば、<code>ENCLOSED BY</code>文字は、 <code>CHAR</code>フィールドと<code>VARCHAR</code>フィールドのみ囲むのに使用されます:

</p>

<pre>1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
</pre>

<p>
フィールド値の中における<code>ENCLOSED BY</code>文字の出現は、<code>ESCAPED BY</code>文字をその前に置くことによりエスケープされることに注意して下さい。<code>ESCAPED BY</code>値に空を指定すると、<code>LOAD DATA INFILE</code>により正しく読み込めない出力を生成するでしょう。例えば、このようにエスケープ文字を空にした場合、以下に示すような出力となります。４行目の２つ目のフィールドに、(誤って)フィールドを区切るかのようなクォートに続くコンマを含んでいることに注視して下さい:

</p>

<pre>1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20
</pre>

<p>
入力において、<code>ENCLOSED BY</code>文字が指定されており、それがフィールド値の両端に現れた場合、その文字は取り去られます。(これは、<code>OPTIONALLY</code>が指定されたかどうかに拘らず、当てはまります;<code>OPTIONALLY</code>は入力解析には効果がありません。)
 <code>ESCAPED BY</code>文字を前置きされた<code>ENCLOSED BY</code>文字の出現は、現在のフィールド値の一部として処理されます。具体的には、あるフィールドがそれ自身、た<code>ENCLOSED BY</code>文字で始まっている場合、フィールドらの内部で発生する２重の<code>ENCLOSED BY</code>文字は、単一の<code>ENCLOSED BY</code>文字として処理されます。
 例えば、<code>ENCLOSED BY '"'</code>が指定されると、引用符は以下のように操作されます:

</p>

<pre>"The ""BIG"" boss"  -&gt; The "BIG" boss
The "BIG" boss      -&gt; The "BIG" boss
The ""BIG"" boss    -&gt; The ""BIG"" boss
</pre>

<p>
<code>FIELDS ESCAPED BY</code>は、特殊文字をどのように書き込んだり読み込んだりするかを制御します。
 <code>FIELDS ESCAPED BY</code>文字が空でない場合、出力において次のような文字(文字列)のプリフィックスに使用されます:

</p><ul>
<li>

<code>FIELDS ESCAPED BY</code>文字
</li><li>

<code>FIELDS [OPTIONALLY] ENCLOSED BY</code>文字
</li><li>

<code>FIELDS TERMINATED BY</code>値と<code>LINES TERMINATED BY</code>値の最初の文字
</li><li>

ASCII 0 (エスケープ文字の後に続いて実際に書かれる文字はASCII <code>'0'</code>で、'ゼロ値'バイトではありません)
</li></ul>

<p>
<code>FIELDS ESCAPED BY</code>文字が空であれば、どの文字もエスケープされません。
特に、フィールド値が上に示した文字を含んでいるならば、エスケープ文字に空を指定するのはあまり良い考えとは言えないでしょう。

</p>
<p>
入力において、<code>FIELDS ESCAPED BY</code>文字が空でない場合、この文字の出現は取り去られ、後続の文字はフィールド値の一部としてそのまま受け取られます。
例外は、エスケープされた<samp>`0'</samp>や<samp>`N'</samp>です(例えば、エスケープ文字が<samp>`\'</samp>である時の<code>\0</code>や<code>\N</code>)。
 これらのシーケンスは、ASCII 0('ゼロ値'バイト) 、<code>NULL</code>として処理されます。<code>NULL</code>操作の規則は下を参照して下さい。

</p>
<p>
<samp>`\'</samp>-escape syntaxに関するこれ以外の情報は、 「<a href="manual.ja_Reference.html#Literals">7.1  リテラル:文字列と数値をどのように書くか？</a>」節参照。

</p>
<p>
フィールドとレコード操作オプションが確実に相互作用する事例:

</p>

<ul>
<li>

<code>LINES TERMINATED BY</code>が空文字列で<code>FIELDS TERMINATED BY</code>が空でない場合、各レコードもまた<code>FIELDS TERMINATED BY</code>で終らせられます。

</li><li>

<code>FIELDS TERMINATED BY</code>と<code>FIELDS ENCLOSED BY</code>値が両方とも空(<code>''</code>)の時、(区切られない)固定長行フォーマットが使用されます。
固定長行フォーマットでは、フィールド間に区切り文字列が使用されません。
その代わり、フィールド値は、フィールドの``表示''幅を使って書き込まれたり、読み込まれます。
例えば、あるフィールドが<code>INT(7)</code>で定義されている場合、フィールドの値は7文字の桁を使って書き込まれます。
入力においてフィールドは、７文字の読み込みにより得られます。
固定長行フォーマットはまた、<code>NULL</code>値の操作に好んで用いられます;下を参照のこと。
注意: マルチバイト文字セットを使用している場合は固定長フォーマットは働きま
せん。
</li></ul>

<p>
<code>FIELDS</code>と<code>LINES</code>オプションによる<code>NULL</code>値の多様な取扱い:

</p>

<ul>
<li>

<code>FIELDS</code>と<code>LINES</code>の初期値のために、出力時に<code>NULL</code>は<code>\N</code>として書き込まれ、入力時に<code>\N</code>は<code>NULL</code>として読み込まれます(当然のことながら、<code>ESCAPED BY</code>文字は<samp>`\'</samp>とします)。

</li><li>

<code>FIELDS ENCLOSED BY</code>が空で無い時、定数<code>NULL</code>のフィールド値は<code>NULL</code>値として読み込まれます(これは、文字列<code>'NULL'</code>として読み込まれる<code>FIELDS ENCLOSED BY</code>文字列で囲まれた<code>NULL</code>とは異なります)。

</li><li>

<code>FIELDS ESCAPED BY</code>が空の時、<code>NULL</code>は<code>NULL</code>として書き込まれます。

</li><li>

固定長行フォーマット(<code>FIELDS TERMINATED BY</code>と<code>FIELDS ENCLOSED BY</code>がいずれも空の場合に起こります)において、<code>NULL</code>は、空白文字列として書き込まれます。
これは、ファイル内では、<code>NULL</code>値と空白値の見分けがつかないということを示していることに注意して下さい。ファイルからデータを読み戻す時に両者を区別しなければならない場合、固定長行フォーマットは使用すべきではありません。
</li></ul>

<p>
キーワード<code>REPLACE</code>と<code>IGNORE</code>は、ユニーク・キー値が重複するレコードが存在する入力レコードの取扱いを制御します。
<code>REPLACE</code>を指定した場合、同じユニーク・キー値を持つ新しいレコードは、既に存在する同じユニーク・キーであるレコードを置き換えます。
<code>IGNORE</code>を指定した場合、既に存在するレコードのユニーク・キー値と重複する入力レコードは、スキップされます。
いずれのオプションも指定していない場合、重複キーが発見された時点でエラーが発生し、テキストファイルの残りは無視されます。

</p>
<p>
<code>LOAD DATA INFILE</code>でサポートされないケース:

</p><ul>

<li>

固定長行(<code>FIELDS TERMINATED BY</code>と<code>FIELDS ENCLOSED BY</code>の両方が空)と<code>BLOB</code>フィールド。
</li><li>

あるセパレータを他と同じかもしくは他のプリフィックスとした場合、<code>LOAD DATA INFILE</code>は、正しい入力処理ができないでしょう。
例えば、以下の<code>FIELDS</code>節は問題の原因となります:


<pre>FIELDS TERMINATED BY '"' ENCLOSED BY '"'
</pre>

</li><li>

<code>FIELDS ESCAPED BY</code>が空で、フィールド値に、<code>FIELDS ENCLOSED BY</code>値や<code>LINES TERMINATED BY</code>値の後に<code>FIELDS TERMINATED BY</code>値がくるようなものを含む場合、フィールドや行の読み込みが早めに打ち切られてしまいます。
これは、<code>LOAD DATA INFILE</code>が、フィールドやレコードの終了位置を正しく決められないことにより発生します。
</li></ul>

<p>
次の例は、<code>persondata</code>テーブルの全てのフィールドを読み込みます:

</p>

<pre>mysql&gt; LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</pre>

<p>
フィールドリストが指定されていませんから、<code>LOAD DATA INFILE</code>は、入力レコードがテーブルのそれぞれのフィールドを含むものと想定します。
<code>FIELDS</code>と<code>LINES</code>の初期値が使用されます。

</p>
<p>
テーブルの一部のフィールドのみ読み込みたい場合、フィールドリストを指定します:

</p>

<pre>mysql&gt; LOAD DATA INFILE 'persondata.txt'
           INTO TABLE persondata (col1,col2,...);
</pre>

<p>
テーブル内のフィールド順と入力ファイルのフィールド順が異なる場合にも、<strong>MySQL</strong>にテーブルのフィールドと入力フィールドの対応を教えるために、フィールドリストを指定しなければなりません。

</p>
<p>
入力レコードのフィールド数の方が少ない場合、入力フィールド値が与えられないフィールドは、初期値が設定されます。
初期値の割当てについては、 「<a href="manual.ja_Reference.html#CREATE_TABLE">7.7  <code>CREATE TABLE</code>構文</a>」節.
で述べられています。

</p>
<p>
空のフィールド値は変換されます：

</p>

<ul>
<li>

文字型の場合、 フィールドの値は空文字にセットされます。

</li><li>

数値型の場合、フィールドの値は <code>0</code> にセットされます。

</li><li>

日付と時刻の型の場合、 フィールドの値は ``zero'' の意味する値がセットされます。
 「<a href="manual.ja_Reference.html#Date_and_time_types">7.3.6  日付と時間の型</a>」節参照.
</li></ul>

<p>
<code>TIMESTAMP</code> フィールドは、フィールド値に <code>NULL</code> 値が指定されていた場合もしくは、
フィールドリストが指定されている時に <code>TIMESTAMP</code> フィールドがそのリストから除外されていた場合
(最初の<code>TIMESTAMP</code>フィールドのみ)、現在時刻が設定されるだけです。

</p>
<p>
入力レコードのフィールド数の方が多い場合、余分なフィールドは無視され、警告の数が増やされます。

</p>
<p>
<code>LOAD DATA INFILE</code>は全ての入力を文字列と文字列とみなすことから、<code>INSERT</code>ステートメントでできるような<code>ENUM</code>フィールドや<code>SET</code>フィールドへの数値の指定はできません。全ての<code>ENUM</code>及び<code>SET</code>値は文字列として与えられなければいけません！

</p>
<p>
<a name="IDX544"></a>
<code>LOAD DATA INFILE</code>クエリの終了時、クエリの情報を得るためにC API関数<code>mysql_info()</code>を使用することができます。情報の書式は以下に示すようなものです:

</p>

<pre>Records: 1  Deleted: 0  Skipped: 0  Warnings: 0
</pre>

<p>
<code>LOAD DATA INFILE</code> が、入力レコードのフィールド数の過不足があった時にも
警告を引き起こす事を除けば、<code>INSERT</code> ステートメント
( 「<a href="manual.ja_Reference.html#INSERT">7.16  <code>INSERT</code>構文</a>」節参照. ) により値が挿入される時に
警告が発生するのと同じ状況下で、警告が発生します。
警告はどこにも保存されません； 警告の数は全てうまくいった場合にだけ
使用できます。 もし警告を知りたい、その警告の理由を知りたいのなら、
一つ方法があります。 <code>SELECT ... INTO OUTFILE</code> を使用して
他のファイルに落とし、オリジナルのファイルと比べます。

</p>
<p>
<code>INSERT</code>と比較した<code>LOAD DATA INFILE</code>の効率や<code>LOAD DATA INFILE</code>の高速化についてのより詳しい情報は、 「<a href="manual.ja_Performance.html#Insert_speed">12.5.6  <code>INSERT</code> クエリの速度</a>」節参照を参照のこと。

</p>
<p>
<a name="IDX545"></a>


</p><h2><a name="UPDATE" href="manual.ja_toc.html#UPDATE">7.19  <code>UPDATE</code> 構文</a></h2>


<pre>UPDATE [LOW_PRIORITY] [IGNORE] tbl_name SET col_name1=expr1,col_name2=expr2,...
    [WHERE where_definition] [LIMIT #]
</pre>

<p>
<code>UPDATE</code> はテーブルに存在するレコードのフィールドを、新しい値に更新します。
<code>SET</code> 節はどのフィールドをどういった値にすべきかを示します。
<code>WHERE</code> 節が与えられた場合、更新すべきレコードを特定することになります。
それ以外は、全てのレコードを更新します。

</p>
<p>
<code>LOW_PRIORITY</code> キーワードを指定した場合、<code>UPDATE</code> の実行は、
テーブルを読んでいるクライアントがなくなるまで、遅らされます。

</p>
<p>
<code>IGNORE</code> キーワードを指定した場合は、update ステートメントは、
update 中に二重キーのエラーを得たとしても、異常終了しません。

</p>
<p>
表記中の <code>tbl_name</code> からのフィールドをアクセスすると、<code>UPDATE</code> 
は現在のフィールド値を使用します。例えば、次のステートメントは 
<code>age</code> フィールドにその現在値より１大きい値を設定します:

</p>

<pre>mysql&gt; UPDATE persondata SET age=age+1;
</pre>

<p>
<code>UPDATE</code> は左から右に評価されます。例えば、以下の文は <code>age</code> フィールドを
2倍にし、そのあと1増やします：

</p>

<pre>mysql&gt; UPDATE persondata SET age=age*2, age=age+1;
</pre>

<p>
もしフィールドに現在もっている値を指定した場合、<strong>MySQL</strong> はそれを通知し、
値は更新しません。

</p>
<p>
<a name="IDX546"></a>
<code>UPDATE</code> は変更されたレコード数を返します。
<strong>MySQL</strong> 3.22 以上では、C API 関数 <code>mysql_info()</code> が
マッチし更新されたレコード数を返します。また <code>UPDATE</code> 中に起きた
ワーニングの数も返します。

</p>
<p>
<strong>MySQL</strong> 3.23 では、 <code>LIMIT #</code> で指定した数だけレコードを変更
できます。

</p>
<p>
<a name="IDX547"></a>


</p><h2><a name="USE" href="manual.ja_toc.html#USE">7.20  <code>USE</code> 構文</a></h2>


<pre>USE db_name
</pre>

<p>
<code>USE db_name</code> 構文は、 <strong>MySQL</strong> に <code>db_name</code> データベースを
この後のクエリのデフォルトのデータベースにするように指示します。
指定されたデータベースは、セッションの最後まで、あるいは、他の <code>USE</code> 構文
が発行されるまで残ります：

</p>

<pre>mysql&gt; USE db1;
mysql&gt; SELECT count(*) FROM mytable;      # selects from db1.mytable
mysql&gt; USE db2;
mysql&gt; SELECT count(*) FROM mytable;      # selects from db2.mytable
</pre>

<p>
<code>USE</code> 構文で特定のデータベースをカレントにしても、
他のデータベースのテーブルからアクセスすることを妨げません。
以下は <code>db1</code> データベースの <code>author</code> テーブルと、
 <code>db2</code> データベースの <code>editor</code> テーブルにアクセスする例です：

</p>

<pre>mysql&gt; USE db1;
mysql&gt; SELECT author_name,editor_name FROM author,db2.editor
           WHERE author.editor_id = db2.editor.editor_id;
</pre>

<p>
<a name="IDX548"></a>
<a name="IDX549"></a>
<code>USE</code> 構文は Sybase の互換のために提供されています。

</p>
<p>
<a name="IDX550"></a>
<a name="IDX551"></a>


</p><h2><a name="FLUSH" href="manual.ja_toc.html#FLUSH">7.21  <code>FLUSH</code> 構文 (キャッシュのクリア)</a></h2>


<pre>FLUSH flush_option [,flush_option]
</pre>

<p>
<code>FLUSH</code> コマンドで <strong>MySQL</strong> が使用している内部キャッシュの
いくつかをきれいに消すことができます。
<code>FLUSH</code> を実行するには、 <strong>reload</strong> 権限がなければなりません。

</p>
<p>
<code>flush_option</code> には以下の内一つが指定できます：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><code>HOSTS</code> </td><td> ホストキャッシュテーブルを空にします。あなたのホストの
IP アドレスを変えたり、<code>Host ... is blocked</code> というエラーメッセージが
出る場合はホストテーブルキャッシュを一度空にしなくてはなりません。
（指定したホストに対して <code>max_connect_errors</code> 以上の接続エラーが出る場合、
<strong>MySQL</strong> は何か起きたと
推定し、そのホストからのいかなる接続要求も拒否します。ホストテーブルキャッシュの消去は、
再び接続を許すようにします。 「<a href="manual.ja_Problems.html#Blocked_host">20.2.3  <code>Host '...' is blocked</code> エラー</a>」節参照.）
<code>mysqld</code> を
<code>-O max_connection_errors=999999999</code> 開始し、このエラーメッセージを
回避できます

</td></tr>
<tr><td><code>LOGS</code> </td><td> 標準のログファイルと更新ログファイルを
一度閉じて再び開きます。
もし更新ログファイルを拡張子無しで指定している場合、新しい更新ログファイルの
拡張子の番号は、一つ前のファイルより 1 増やした数になります。
ファイル名に拡張を使用した場合、<strong>MySQL</strong> は更新ログファイルを閉じて開きます。
 「<a href="manual.ja_Common_problems.html#Update_log">21.3  更新ログ</a>」節参照.

</td></tr>
<tr><td><code>PRIVILEGES</code> </td><td> <code>mysql</code> データベースの許可テーブルから、
権限情報を再読込します。

</td></tr>
<tr><td><code>TABLES</code> </td><td> 全ての開いているテーブルを閉じます。

</td></tr>
<tr><td><code>STATUS</code> </td><td> ほとんどのステータス変数を 0 にします。
</td></tr>
</tbody></table>

<p>
上に示したコマンドは、<code>mysqladmin</code> を使用しても実行できます。
<code>mysqladmin</code> の引数はそれぞれ、
<code>flush-hosts</code>, <code>flush-logs</code>, <code>reload</code>, <code>flush-tables</code> と
なります。

</p>
<p>
<code>FLUSH</code> コマンドを実行するには、<strong>reload</strong> 権限がなければなりません。

</p>
<p>
<a name="IDX552"></a>
<a name="IDX553"></a>


</p><h2><a name="KILL" href="manual.ja_toc.html#KILL">7.22  <code>KILL</code> 構文</a></h2>


<pre>KILL thread_id
</pre>

<p>
<code>thread_id</code> には、<code>mysqld</code> に接続して走っているスレッドの ID を
空白で区切って指定します。
<code>SHOW PROCESSLIST</code> コマンドで走っているスレッドを知ることができ、
 <code>KILL thread_id</code> コマンドでスレッドを KILL できます。

</p>
<p>
もし <strong>process</strong> 権限があるなら、全てのスレッドを確認し、KILL 出来ます。
そうでなければ、自分のスレッドだけを、
確認し、KILL する事ができます。

</p>
<p>
<code>mysqladmin processlist</code> と <code>mysqladmin kill</code> をスレッドの
検査と KILL に使用できます。

</p>
<p>
<a name="IDX554"></a>
<a name="IDX555"></a>
<a name="IDX556"></a>
<a name="IDX557"></a>
<a name="IDX558"></a>
<a name="IDX559"></a>
<a name="IDX560"></a>
<a name="IDX561"></a>
<a name="IDX562"></a>
<a name="IDX563"></a>
<a name="IDX564"></a>


</p><h2><a name="SHOW" href="manual.ja_toc.html#SHOW">7.23  <code>SHOW</code> 構文 (テーブルやフィールドなどについての情報を得る)</a></h2>


<pre>   SHOW DATABASES [LIKE wild]
or SHOW TABLES [FROM db_name] [LIKE wild]
or SHOW COLUMNS FROM tbl_name [FROM db_name] [LIKE wild]
or SHOW INDEX FROM tbl_name [FROM db_name]
or SHOW STATUS [LIKE wild]
or SHOW VARIABLES [LIKE wild]
or SHOW [FULL] PROCESSLIST
or SHOW TABLE STATUS [FROM db_name] [LIKE wild]
or SHOW GRANTS FOR user
</pre>

<p>
<code>SHOW</code> はデータベース、テーブル、フィールド、サーバーについての情報を与えます。
<code>LIKE wild</code> が使用された場合、<code>wild</code> 文字列は通常の SQL ワイルドカード
 (<samp>`%'</samp> と <samp>`_'</samp>) です。

</p>
<p>
<code>tbl_name FROM db_name</code> の代わりに、<code>db_name.tbl_name</code> が使用できます。
これら二つは同じです：

</p>

<pre>mysql&gt; SHOW INDEX FROM mytable FROM mydb;
mysql&gt; SHOW INDEX FROM mydb.mytable;
</pre>

<p>
<code>SHOW DATABASES</code> は <strong>MySQL</strong> サーバー上のデータベースを示します。
<code>mysqlshow</code> コマンドでも同じ情報が得られます。

</p>
<p>
<code>SHOW TABLES</code> は指定されたデータベースのテーブルを一覧表示します。
<code>mysqlshow db_name</code> コマンドでも同じ情報が得られます。

</p>
<p>
<strong>NOTE</strong>: もしユーザーにテーブルに対する権限が無い場合、
テーブルは <code>SHOW TABLES</code> や <code>mysqlshow db_name</code> の要求で
表示されません。

</p>
<p>
<code>SHOW COLUMNS</code> は与えられたテーブルのフィールドを表示します。
もしそのフィールドの型が、あなたが <code>CREATE TABLE</code> 構文実行時に与えたものと
違う場合は、 <strong>MySQL</strong> は、フィールドの型をときおり変更することが
あることに注意してください。
 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

</p>
<p>
<code>DESCRIBE</code> 文は <code>SHOW COLUMNS</code> と似たような情報を提供します。
 「<a href="manual.ja_Reference.html#DESCRIBE">7.25  <code>DESCRIBE</code> 構文 (フィールドについての情報を得る)</a>」節参照.

</p>
<p>
<code>SHOW TABLE STATUS</code> (バージョン 3.23 の新機能) は <code>SHOW STATUS</code> 
のようですが、それぞれのテーブルについてより多くの情報を提供します。
<code>mysqlshow --status db_name</code> コマンドを実行しても同じものが得られます。
以下の項目が返ってきます：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>項目</strong> </td><td> <strong>意味</strong>
</td></tr>
<tr><td><code>Name</code> </td><td> テーブル名
</td></tr>
<tr><td><code>Type</code> </td><td> テーブルの種類 (BDB, ISAM, MyISAM or HEAP)
</td></tr>
<tr><td><code>Row_format</code> </td><td> レコードの保存形式 (Fixed, Dynamic, or Compressed)
</td></tr>
<tr><td><code>Rows</code> </td><td> レコード数
</td></tr>
<tr><td><code>Avg_row_length</code> </td><td> レコードの平均長
</td></tr>
<tr><td><code>Data_length</code> </td><td> データファイルの大きさ
</td></tr>
<tr><td><code>Max_data_length</code> </td><td> データファイルの最大値
</td></tr>
<tr><td><code>Index_length</code> </td><td> インデックスファイルの大きさ
</td></tr>
<tr><td><code>Data_free</code> </td><td> 割り当てられたが使用されていないバイト数
</td></tr>
<tr><td><code>Auto_increment</code> </td><td> 次の autoincrement 値
</td></tr>
<tr><td><code>Create_time</code> </td><td> テーブル作成時刻
</td></tr>
<tr><td><code>Update_time</code> </td><td> 一番最後に更新された時刻
</td></tr>
<tr><td><code>Check_time</code> </td><td> 一番最後にチェックされた時刻
</td></tr>
<tr><td><code>Create_options</code> </td><td> <code>CREATE TABLE</code> で使用された拡張オプション
</td></tr>
<tr><td><code>Comment</code> </td><td> テーブル作成時につけられたコメント (あるいは、なぜこのテーブルに<strong>MySQL</strong> がアクセスできないかのいくつかの情報).
</td></tr>
</tbody></table>

<p>
<code>SHOW FIELDS</code> は <code>SHOW COLUMNS</code> の別名として使用され、
<code>SHOW KEYS</code> は <code>SHOW INDEX</code> の別名として使用されます。
テーブルのフィールドやインデックスは <code>mysqlshow db_name tbl_name</code>
か <code>mysqlshow -k db_name tbl_name</code> でも見れます。

</p>
<p>
<code>SHOW INDEX</code> は ODBC でいう <code>SQLStatistics</code> 
に近い形式で、インデックスの情報を表示します。
以下の項目が返ります：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>項目</strong> </td><td> <strong>意味</strong>
</td></tr>
<tr><td><code>Table</code> </td><td> テーブル名
</td></tr>
<tr><td><code>Non_unique</code> </td><td> インデックスが重複を含まないなら 0
</td></tr>
<tr><td><code>Key_name</code> </td><td> インデックス名
</td></tr>
<tr><td><code>Seq_in_index</code> </td><td> インデックスの項目番号。1 から始まります。
</td></tr>
<tr><td><code>Column_name</code> </td><td> フィールド名。
</td></tr>
<tr><td><code>Collation</code> </td><td> いかにこのフィールドがインデックス中でソートされるか.  <strong>MySQL</strong> では, これは <code>A</code> (Ascending) か <code>NULL</code> (Not sorted) になります。
</td></tr>
<tr><td><code>Cardinality</code> </td><td> インデックス中のユニークな値の数。 これは <code>isamchk -a</code> の実行で更新されます。
</td></tr>
<tr><td><code>Sub_part</code> </td><td> もしこのフィールドがインデックスに一部分だけ使用している場合、そのインデックスに使用しているキャラクター数をしめす。 もしキー全体がインデックスされているなら <code>NULL</code> 。
</td></tr>
</tbody></table>

<p>
<a name="IDX565"></a>
<code>SHOW STATUS</code> は <code>mysqladmin extended-status</code> と同様に、サーバからのステー
タス情報を与えます。出力は次とは異なるかもしれません:

</p>

<pre>+--------------------------+--------+
| Variable_name            | Value  |
+--------------------------+--------+
| Aborted_clients          | 0      |
| Aborted_connects         | 0      |
| Connections              | 17     |
| Created_tmp_tables       | 0      |
| Delayed_insert_threads   | 0      |
| Delayed_writes           | 0      |
| Delayed_errors           | 0      |
| Flush_commands           | 2      |
| Handler_delete           | 2      |
| Handler_read_first       | 0      |
| Handler_read_key         | 1      |
| Handler_read_next        | 0      |
| Handler_read_rnd         | 35     |
| Handler_update           | 0      |
| Handler_write            | 2      |
| Key_blocks_used          | 0      |
| Key_read_requests        | 0      |
| Key_reads                | 0      |
| Key_write_requests       | 0      |
| Key_writes               | 0      |
| Max_used_connections     | 1      |
| Not_flushed_key_blocks   | 0      |
| Not_flushed_delayed_rows | 0      |
| Open_tables              | 1      |
| Open_files               | 2      |
| Open_streams             | 0      |
| Opened_tables            | 11     |
| Questions                | 14     |
| Slow_launch_threads      | 0      |
| Slow_queries             | 0      |
| Threads_connected        | 1      |
| Threads_running          | 1      |
| Uptime                   | 149111 |
+--------------------------+--------+
</pre>

<p>
上に示したステータス変数は以下に示すの意味を持ちます：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><code>Aborted_clients</code> </td><td> クライアントが接続を閉じる前に死んでしまったために中断されたコネクション数。
</td></tr>
<tr><td><code>Aborted_connects</code> </td><td> <strong>MySQL</strong> サーバーに接続を試みて失敗した数
</td></tr>
<tr><td><code>Bytes_received</code> </td><td> クライアントから受信したバイト数
</td></tr>
<tr><td><code>Bytes_sent</code> </td><td> クライアントに送信したバイト数
</td></tr>
<tr><td><code>Cached_threads</code> </td><td> スレッドキャッシュ内のスレッド数
</td></tr>
<tr><td><code>Connections</code> </td><td> <strong>MySQL</strong> サーバーに接続を試みた数
</td></tr>
<tr><td><code>Created_tmp_tables</code> </td><td> ステートメント実行中に暗黙のうちに作成された一時テーブルの数
</td></tr>
<tr><td><code>Delayed_insert_threads</code> </td><td> 使用中の delayed insert ハンドラースレッドの数
</td></tr>
<tr><td><code>Delayed_writes</code> </td><td> <code>INSERT DELAYED</code> で書かれたレコード数
</td></tr>
<tr><td><code>Delayed_errors</code> </td><td> <code>INSERT DELAYED</code> で書かれたレコードでなんらかのエラーのあったレコード数 (たぶん <code>duplicate key</code>).
</td></tr>
<tr><td><code>Flush_commands</code> </td><td> <code>FLUSH</code> コマンドの実行回数
</td></tr>
<tr><td><code>Handler_delete</code> </td><td> テーブルからレコードを削除するためのリクエスト数
</td></tr>
<tr><td><code>Handler_read_first</code> </td><td> テーブル中の最初のレコードを読むためのリクエスト数。
</td></tr>
<tr><td><code>Handler_read_key</code> </td><td> キーに基づいてレコードを読むためのリクエスト数。
</td></tr>
<tr><td><code>Handler_read_next</code> </td><td> キー順で次のレコードを読むためのリクエスト数。
</td></tr>
<tr><td><code>Handler_read_rnd</code> </td><td> 固定位置に基づいてレコードを読むためのリクエスト数。
</td></tr>
<tr><td><code>Handler_read_rnd_next</code> </td><td> データファイルの次のレコードを読む要求の数。
多くのテーブルスキャンを行なう場合、これは高くなります - 通常、これはテー
ブルが正しくインデックスされていないか、存在するインデックスを有利に使うよ
うにクエリが書かれていないことを示唆します。
</td></tr>
<tr><td><code>Handler_update</code> </td><td> テーブルのレコードを更新するための要求数
</td></tr>
<tr><td><code>Handler_write</code> </td><td> テーブルにレコードを挿入するためのリクエスト数
</td></tr>
<tr><td><code>Key_blocks_used</code> </td><td> キーキャッシュ中で使用されたブロック数
</td></tr>
<tr><td><code>Key_read_requests</code> </td><td> キャッシュからキーブロックを読み込んだリクエスト数
</td></tr>
<tr><td><code>Key_reads</code> </td><td> Disk から物理的にキーブロックを読んだ回数
</td></tr>
<tr><td><code>Key_write_requests</code> </td><td> キャッシュにキーブロックを書き込んだリクエスト数
</td></tr>
<tr><td><code>Key_writes</code> </td><td> Diskに物理的にキーブロックを書き込んだ回数
</td></tr>
<tr><td><code>Max_used_connections</code> </td><td> 最大同時接続数
</td></tr>
<tr><td><code>Not_flushed_key_blocks</code> </td><td> キーキャッシュ中にあるキーブロックで、変更されたもののいまだDiskに書き出されていないキーブロック数
</td></tr>
<tr><td><code>Not_flushed_delayed_rows</code> </td><td> <code>INSERT DELAY</code> クエリで書き出しを待っているレコード数
</td></tr>
<tr><td><code>Open_tables</code> </td><td> オープンされているテーブル数
</td></tr>
<tr><td><code>Open_files</code> </td><td> オープンされているファイル数
</td></tr>
<tr><td><code>Open_streams</code> </td><td> 開いているストリーム数 (主にログに使用される)
</td></tr>
<tr><td><code>Opened_tables</code> </td><td> オープンされたテーブル数
</td></tr>
<tr><td><code>Questions</code> </td><td> サーバーに送られたクエリの数
</td></tr>
<tr><td><code>Slow_launch_threads</code> </td><td> 接続に <code>slow_launch_time</code> 以上を要したスレッド数
</td></tr>
<tr><td><code>Slow_queries</code> </td><td> <code>long_query_time</code> 以上に時間のかかったクエリの数
</td></tr>
<tr><td><code>Threads_connected</code> </td><td> 現在開いている接続数
</td></tr>
<tr><td><code>Threads_running</code> </td><td> スリープしていないスレッドの数
</td></tr>
<tr><td><code>Uptime</code> </td><td> サーバーが走っている秒数
</td></tr>
</tbody></table>

<p>
上についてのいくつかコメント：

</p>

<ul>
<li>

もし <code>Opened_tables</code> が大きければ、 <code>table_cache</code> 変数が小さすぎる
のでしょう。
</li><li>

もし <code>key_reads</code> が大きければ、 <code>key_cache</code> が少なすぎるでしょう。
キャッシュヒットレートは
<code>key_reads</code>/<code>key_read_requests</code> で計算できます。
</li><li>

もし <code>Handler_read_rnd</code> が大きければ、
<strong>MySQL</strong> にテーブルをスキャンさせるような多くのクエリ
や、 キーを使用しない JOIN がもてます。
</li></ul>

<p>
<code>SHOW VARIABLES</code> は <strong>MySQL</strong> システム変数のいくつかの値を示します。
<code>mysqlshow variables</code> コマンドでも同じ情報が得られます。
もし標準値が適さないなら、ほとんどの変数を <code>mysqld</code> 起動時に
コマンドラインのオプションとして与えることにより、変更できます。
出力は以下のようになりますが、フォーマットや数はいくぶん違うでしょう：

</p>

<pre>+------------------------+--------------------------+
| Variable_name          | Value                    |
+------------------------+--------------------------+
| back_log               | 5                        |
| connect_timeout        | 5                        |
| basedir                | /my/monty/               |
| datadir                | /my/monty/data/          |
| delayed_insert_limit   | 100                      |
| delayed_insert_timeout | 300                      |
| delayed_queue_size     | 1000                     |
| join_buffer_size       | 131072                   |
| flush_time             | 0                        |
| interactive_timeout    | 28800                    |
| key_buffer_size        | 1048540                  |
| language               | /my/monty/share/english/ |
| log                    | OFF                      |
| log_update             | OFF                      |
| long_query_time        | 10                       |
| low_priority_updates   | OFF                      |
| max_allowed_packet     | 1048576                  |
| max_connections        | 100                      |
| max_connect_errors     | 10                       |
| max_heap_table_size    | 16777216                 |
| max_delayed_threads    | 20                       |
| max_join_size          | 4294967295               |
| max_sort_length        | 1024                     |
| max_tmp_tables         | 32                       |
| net_buffer_length      | 16384                    |
| port                   | 3306                     |
| protocol-version       | 10                       |
| record_buffer          | 131072                   |
| skip_locking           | ON                       |
| slow_launch_time       | 2                        |
| socket                 | /tmp/mysql.sock          |
| sort_buffer            | 2097116                  |
| table_cache            | 64                       |
| thread_stack           | 131072                   |
| tmp_table_size         | 1048576                  |
| tmpdir                 | /machine/tmp/            |
| version                | 3.23.0-alpha-debug       |
| wait_timeout           | 28800                    |
+------------------------+--------------------------+
</pre>

<p>
 「<a href="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</a>」節参照.

</p>
<p>
<a name="IDX566"></a>
<a name="IDX567"></a>
<code>SHOW PROCESSLIST</code> はどのスレッドが走っているかを表示します。
<code>mysqlshow processlist</code> コマンドでも同じ情報が得られます。
もし <strong>process</strong> 権限があるなら、全てのスレッドがみれます。
しかし権限がないなら、自分のスレッドしか見れません。
 「<a href="manual.ja_Reference.html#KILL">7.22  <code>KILL</code> 構文</a>」節参照.
<code>FULL</code> オプションを使用しない場合、各クエリの最初の100文字だけが表示
されます。

</p>
<p>
<code>SHOW GRANTS FOR user</code> はユーザの許可を複製するために発行する必要があ
る grant コマンドをリストします。

</p>

<pre>mysql&gt; SHOW GRANTS FOR root@localhost;
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
+---------------------------------------------------------------------+
</pre>

<p>
<a name="IDX568"></a>
<a name="IDX569"></a>


</p><h2><a name="EXPLAIN" href="manual.ja_toc.html#EXPLAIN">7.24  <code>EXPLAIN</code> 構文 (<code>SELECT</code>についての情報を得る)</a></h2>


<pre>    EXPLAIN tbl_name
or  EXPLAIN SELECT select_options
</pre>

<p>
<code>EXPLAIN tbl_name</code> は、 <code>DESCRIBE tbl_name</code> や
<code>SHOW COLUMNS FROM tbl_name</code> と同義です。

</p>
<p>
もし <code>EXPLAIN</code> をともなって <code>SELECT</code> 構文を実行した場合、
<strong>MySQL</strong> はこの <code>SELECT</code> がいかに動作するかを説明し、
いかにテーブルが結合されるかの情報を与えます。

</p>
<p>
<code>EXPLAIN</code> の情報を元に、インデックスを使用した速い <code>SELECT</code> を
得るためにテーブルにインデックスを加えなくてはならないという事がわかります。
テーブル結合の最適化もオプションによって見ることができます。
<code>SELECT</code> 構文での結合を強制的に最適化するには <code>STRAIGHT_JOIN</code> 節を加えます。

</p>
<p>
単純ではない join のために、<code>EXPLAIN</code> は <code>SELECT</code> 文で使用されている
それぞれのテーブルの情報を返します。
テーブルは読まれる順に表示されます。<strong>MySQL</strong> は one-sweep multi-join method
を用いた全ての join を解決します。これは <strong>MySQL</strong> は最初のテーブルから
一レコード読み込み、二つ目のテーブルからマッチしたレコードを探し、そして三番目を探すということです。
全てのテーブルが処理される時、選択されたフィールドを出力し、テーブルの一覧は
よりマッチするレコードをもつテーブルを見つけるまで back-track されます。
次のレコードはこのテーブルから読まれ、次のテーブルから処理を続けます。

</p>
<p>
<code>EXPLAIN</code> の出力は以下のフィールドを含みます：

</p>
<dl compact="">

<dt><code>table</code>
</dt><dd>
出力レコードが参照されるテーブル

</dd><dt><code>type</code>
</dt><dd>
　join タイプ.  様々なタイプの説明は後述します

</dd><dt><code>possible_keys</code>
</dt><dd>
<code>possible_keys</code> 項目は、<strong>MySQL</strong> がテーブルからレコードを見つけるために
どのインデックスを使用する事ができたかを示します。
注意: このフィールドはテーブルの順にまったく依存しません。これは、
possible_keys 内のいくつかのキーは、生成されたテーブル順での実行に使用でき
ないことを意味します。

この項目が空なら、関連した
インデックスは無いということです。この場合、あなたは <code>WHERE</code> 節を
調べることによって、クエリの性能を向上させることができるかもしれません。
もしそれがインデックスに適合したフィールドを参照しているならば。
仮にそうだとすると、適切なインデックスを作成し、 <code>EXPLAIN</code> でクエリを
もう一度チェックしてみてください。

テーブルがどんなインデックスを持っているかみるには、<code>SHOW INDEX FROM tbl_name</code> とします。

</dd><dt><code>key　　　</code>
</dt><dd>
<code>key</code> 項目は、 <strong>MySQL</strong> が使用すると実際に決めたキーを示します。
どのインデックスも選ばれなかったならば、キーは <code>NULL</code> です。
<strong>MySQL</strong> が間違ったインデックスを選択する場合、たいていは 
<strong>MySQL</strong> に他のインデックスを使用するように強制することができます。
<code>myisamchk --analyze</code> の使用、 「<a href="manual.ja_Maintenance.html#myisamchk_syntax">15.2  <code>myisamchk</code> 起動構文</a>」節参照、または 
<code>USE INDEX/IGNORE INDEX</code> の使用によって。 「<a href="manual.ja_Reference.html#JOIN">7.15  <code>JOIN</code> 構文</a>」節参照。

</dd><dt><code>key_len</code>
</dt><dd>
<code>key_len</code> 項目は、<strong>MySQL</strong> が使用すると決めたキーの長さを示します。
もし <code>key</code> が <code>NULL</code> なら、長さは <code>NULL</code> です。
注意: これは<strong>MySQL</strong> がマルチパートキーのいくつのパートを実際に使用
するかを示します。

</dd><dt><code>ref　　　</code>
</dt><dd>
<code>ref</code> 項目は、テーブルからレコードを select するために、どのフィールドや定数が
 <code>key</code> と共に使用されたかを示します。

</dd><dt><code>rows　　　</code>
</dt><dd>
<code>rows</code> フィールドは、<strong>MySQL</strong> がクエリを実行するために検査する
必要があると考えているレコードの数を示します。

</dd><dt><code>Extra　</code>
</dt><dd>
インデックスツリー(index tree)のからの情報だけが、
テーブルの情報を検索するために使用されたことを意味します。
通常、これは全てのテーブルを走査するより速いはずです。

<code>Extra</code> 項目に <code>where used</code> という字句が含まれる場合、
次のテーブルにマッチするレコードを限定するために、
あるいはクライアントに送られるレコードを限定するために、
<code>WHERE</code> 節が使用されたことを意味します。
</dd></dl>

<p>
join type は以下のものがあります。良い物から順に書いています：

</p>
<p>
<a name="IDX570"></a>
<a name="IDX571"></a>
</p><dl compact="">

<dt><code>system</code>
</dt><dd>
テーブルが一レコードだけ持っている (= system table). これは <code>const</code> join type
の特別な場合です。

<a name="IDX572"></a>
<a name="IDX573"></a>
</dd><dt><code>const</code>
</dt><dd>
テーブルは、最もマッチするレコードを１つもっており、これはクエリの
最初に読まれます。
1 つのレコードであるため、このレコード中のフィールドの値は
オプティマイザーによって常数としてみなされます。
1回だけ読まれるので、<code>const</code> テーブルはとても速いです! 

</dd><dt><code>eq_ref</code>
</dt><dd>
前のテーブルのそれぞれのレコードと結合する際、このテーブルから1レコード読まれます。
これは join では <code>const</code> よりも良い形です。
インデックスの全てのパートが join で使用され、かつ、インデックスが
<code>UNIQUE</code> か <code>PRIMARY KEY</code> であるときに、これは使用されます。

</dd><dt><code>ref　　　</code>
</dt><dd>
インデックスの値に合ったすべてのレコードは、前のテーブルからレコードと結合するために、
このテーブルから読まれるでしょう。
もしその join がキーの一番左の接頭部分だけを使用するならば、
あるいは、
もしそのキーが <code>UNIQUE</code> や <code>PRIMARY KEY</code> でなければ
(言い換えるなら、もし join がキーの値を元に一つだけの、レコードを選択できなければ)、
<code>ref</code> は使用されます。
もしそのキーがいくつかのマッチするレコードに使用されるだけなら、
join は良い形です。

</dd><dt><code>range</code>
</dt><dd>
示された範囲内にあるレコードのみが検索されます。
<code>ref</code> 項目はどのインデックスが使用されているか示します。

</dd><dt><code>index</code>
</dt><dd>
<code>ALL</code> と同じですが、インデックスツリーが走査される場合のみを除きます。
これは、インデックスファイルはデータファイルよりも小さいため、通常 <code>ALL</code> より速いです。

</dd><dt><code>ALL</code>
</dt><dd>
前のテーブルのレコードとのそれぞれの結合において、全テーブルが走査されます。
もしそのテーブルが最初のテーブルで <code>const</code> 状態ではないなら、通常
これは良くありません。他の状態では<strong>とても</strong>悪くなります。
これは普通、レコードががより早いテーブルからから定数値に基づいて検索することができるように、
インデックスを追加することにより <code>ALL</code> を避けることが可能です。 
</dd></dl>

<p>
<code>EXPLAIN</code> 出力の <code>rows</code> フィールド内のすべての値を増やすことによ
り、join がどのように良くなるかの良い表示を得ることができます。これは、
<strong>MySQL</strong> がクエリ実行の検査をする必要があるレコードのおおよその数を
知らせます。この数は <code>max_join_size</code> 変数でのクエリを制限する時にも使
用します。
 「<a href="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</a>」節参照.

</p>
<p>
以下の例は、<code>EXPLAIN</code> が提供する情報を元に、いかに <code>JOIN</code> が最適化
できるかの例です。

</p>
<p>
以下のような <code>EXPLAIN</code> で検査する <code>SELECT</code> 構文があるとします：

</p>

<pre>EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
            tt.ProjectReference, tt.EstimatedShipDate,
            tt.ActualShipDate, tt.ClientID,
            tt.ServiceCodes, tt.RepetitiveID,
            tt.CurrentProcess, tt.CurrentDPPerson,
            tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
            et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do
        WHERE tt.SubmitTime IS NULL
            AND tt.ActualPC = et.EMPLOYID
            AND tt.AssignedPC = et_1.EMPLOYID
            AND tt.ClientID = do.CUSTNMBR;
</pre>

<p>
この例では、以下のように仮定します：

</p>

<ul>
<li>

フィールドは以下のように定義されています：

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Table</strong> </td><td> <strong>Column</strong> </td><td> <strong>Column type</strong>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ActualPC</code> </td><td> <code>CHAR(10)</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>AssignedPC</code> </td><td> <code>CHAR(10)</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ClientID</code> </td><td> <code>CHAR(10)</code>
</td></tr>
<tr><td><code>et</code> </td><td> <code>EMPLOYID</code> </td><td> <code>CHAR(15)</code>
</td></tr>
<tr><td><code>do</code> </td><td> <code>CUSTNMBR</code> </td><td> <code>CHAR(15)</code>
</td></tr>
</tbody></table>

</li><li>

テーブルは以下のインデックスを持ちます：

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Table</strong> </td><td> <strong>Index</strong>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ActualPC</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>AssignedPC</code>
</td></tr>
<tr><td><code>tt</code> </td><td> <code>ClientID</code>
</td></tr>
<tr><td><code>et</code> </td><td> <code>EMPLOYID</code> (primary key)
</td></tr>
<tr><td><code>do</code> </td><td> <code>CUSTNMBR</code> (primary key)
</td></tr>
</tbody></table>

</li><li>

<code>tt.ActualPC</code> の値は、いちように分布して(配置されて)いません。
</li></ul>

<p>
最初、いかなる最適化も行われていない状態では、<code>EXPLAIN</code> 構文は
以下の情報を提示します：

</p>

<pre>table type possible_keys                key  key_len ref  rows  Extra
et    ALL  PRIMARY                      NULL NULL    NULL 74
do    ALL  PRIMARY                      NULL NULL    NULL 2135
et_1  ALL  PRIMARY                      NULL NULL    NULL 74
tt    ALL  AssignedPC,ClientID,ActualPC NULL NULL    NULL 3872
      range checked for each record (key map: 35)
</pre>

<p>
それぞれのテーブルで、<code>type</code> が <code>ALL</code> になっています。
これは <strong>MySQL</strong> が全てのテーブルを全結合することを示します！
それぞれのテーブル内の行数分から作った物が調べられるので、とても長い時間がかかります！
この場合、<code>74 * 2135 * 74 * 3872 = 45,268,558,720</code> 行調べることになります。
テーブルが肥大化したときにかかる時間を考えてください....

</p>
<p>
一つ問題があります。(まだ) <strong>MySQL</strong> がフィールドのインデックスを効果的に
使用できていません。
この例の場合では、<code>VARCHAR</code> と <code>CHAR</code> は、それらが同じ長さで定義されていれば、
変わりがありません。
<code>tt.ActualPC</code> は <code>CHAR(10)</code> と定義されており、
<code>et.EMPLOYID</code> は <code>CHAR(15)</code> です。これらの長さは違います。

</p>
<p>
この不釣り合いを修正するにあたり、<code>ALTER TABLE</code> を使って
<code>ActualPC</code> の長さを 10 文字から 15 文字にします：

</p>

<pre>mysql&gt; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
</pre>

<p>
これで <code>tt.ActualPC</code> and <code>et.EMPLOYID</code> は両方とも <code>VARCHAR(15)</code> になりました。
 <code>EXPLAIN</code> 構文を実行し直すと、以下を提示します：

</p>

<pre>table type   possible_keys   key     key_len ref         rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL 3872    where used
do    ALL    PRIMARY         NULL    NULL    NULL        2135
      range checked for each record (key map: 1)
et_1  ALL    PRIMARY         NULL    NULL    NULL        74
      range checked for each record (key map: 1)
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC 1
</pre>

<p>
まだ完全ではありませんが、よりよくなっています(<code>rows</code> 値の
生成量は 74 より小さくなります)。この場合、実行は数秒でしょう。

</p>
<p>
<code>tt.AssignedPC = et_1.EMPLOYID</code> と <code>tt.ClientID =
do.CUSTNMBR</code> の比較において、フィールドの長さの違いを排除することができます:

</p>

<pre>mysql&gt; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
                      MODIFY ClientID   VARCHAR(15);
</pre>

<p>
これで <code>EXPLAIN</code> は以下を出力します：

</p>

<pre>table type   possible_keys   key     key_len ref            rows     Extra
et    ALL    PRIMARY         NULL    NULL    NULL           74
tt    ref    AssignedPC,ClientID,ActualPC ActualPC 15 et.EMPLOYID 52 where used
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</pre>

<p>
これは ``ほとんど'' 最良に近いです。

</p>
<p>
残る問題は、デフォルトでは、<strong>MySQL</strong> は <code>tt.ActualPC</code> フィールド内の値が
まんべんなく分布していると想定しており、この <code>tt</code> テーブルの場合には適合しません。
幸運にも、これを <strong>MySQL</strong> に教えるのはとても簡単です：

</p>

<pre>shell&gt; myisamchk --analyze PATH_TO_MYSQL_DATABASE/tt
shell&gt; mysqladmin refresh
</pre>

<p>
これで join は ``完璧'' です。
<code>EXPLAIN</code> は以下の結果を示します：

</p>

<pre>table type   possible_keys   key     key_len ref            rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL    3872    where used
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC    1
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</pre>

<p>
 <code>EXPLAIN</code> の出力中の <code>rows</code> 項目は、 <strong>MySQL</strong> JOIN オプティマイザー
による、``推測'' です；  
クエリの最適化のために、この数値が実際に近いかどうかをチェックすべきです。
そうでなければ、<code>SELECT</code> ステートメントで <code>STRAIGHT_JOIN</code> を使用
し、<code>FROM</code> 節に異なる順でテーブルを並べることで、良いパフォーマンスを
得られます。

</p>
<p>
<a name="IDX574"></a>
<a name="IDX575"></a>


</p><h2><a name="DESCRIBE" href="manual.ja_toc.html#DESCRIBE">7.25  <code>DESCRIBE</code> 構文 (フィールドについての情報を得る)</a></h2>


<pre>{DESCRIBE | DESC} tbl_name {col_name | wild}
</pre>

<p>
<code>DESCRIBE</code> はフィールドについての情報を与えます。
<code>col_name</code> はフィールドはフィールド名または文字列です。
文字列は SQL <samp>`%'</samp>,<samp>`_'</samp> ワイルドカードを含めます。

</p>
<p>
もしフィールドの型があなたが <code>CREATE TABLE</code> 文で与えた物と違っているなら、
これは <strong>MySQL</strong> がフィールドの型を変更していることに注意してください。
 「<a href="manual.ja_Reference.html#Silent_column_changes">7.7.1  暗黙のフィールド定義変更</a>」節参照.

</p>
<p>
<a name="IDX576"></a>
<a name="IDX577"></a>
このコマンドは Oracle の互換のためにあります。

</p>
<p>
<code>SHOW</code> 構文は似たような情報を提供します。
 「<a href="manual.ja_Reference.html#SHOW">7.23  <code>SHOW</code> 構文 (テーブルやフィールドなどについての情報を得る)</a>」節参照.

</p>
<p>
<a name="IDX578"></a>
<a name="IDX579"></a>


</p><h2><a name="COMMIT" href="manual.ja_toc.html#COMMIT">7.26  <code>COMMIT/ROLLBACK</code> 構文</a></h2>

<p>
デフォルトでは <strong>MySQL</strong> は <code>autocommit</code> モードで動作します。こ
れは、更新を実行するとすぐに <strong>MySQL</strong> が更新をディスクに格納すること
を意味します。

</p>
<p>
もし <code>BDB</code> 型のテーブルを使用するなら, 以下のコマンドで <strong>MySQL</strong> を
autocommit モードではない状態にすることができます：

</p>

<pre>SET AUTOCOMMIT=0
</pre>

<p>
この後、ディスクに変更を格納するためには <code>COMMIT</code> を使用し、また、変
更を無視するためには <code>ROLLBACK</code> する必要があります。

</p>
<p>
注意: トランザクション安全テーブルを使用していない場合は、autocommit モー
ドのステータスには依存せずに、変更はすぐに格納されます。 「<a href="manual.ja_Table_types.html#Table_types">8  MySQL table types</a>」節参照.

</p>
<p>
<a name="IDX580"></a>
<a name="IDX581"></a>


</p><h2><a name="LOCK_TABLES" href="manual.ja_toc.html#LOCK_TABLES">7.27  <code>LOCK TABLES/UNLOCK TABLES</code> 構文</a></h2>


<pre>LOCK TABLES tbl_name [AS alias] {READ | [READ LOCAL] | [LOW_PRIORITY] WRITE}
             [, tbl_name {READ | [LOW_PRIORITY] WRITE} ...]
...
UNLOCK TABLES
</pre>

<p>
<code>LOCK TABLES</code> はカレントのスレッドのためにテーブルをロックします。
<code>UNLOCK TABLES</code> はこのスレッドの全てのロックを解除します。
カレントスレッドによってロックされた全てのテーブルは、
スレッドが他の <code>LOCK TABLES</code> を発行した場合やサーバーが接続を閉じた場合、
自動で解除されます。

</p>
<p>
スレッドがテーブルに <code>READ</code> ロックを持つ場合、そのスレッド(と他の全てのスレッド)は
テーブルからの読み込みだけができます。スレッドがテーブルに <code>WRITE</code> ロックを持つ場合、
このスレッドだけがテーブルの <code>READ</code> と <code>WRITE</code> ができます。
他のスレッドはブロックされます。

</p>
<p>
<code>READ LOCAL</code> と <code>READ</code> の違いは、<code>READ LOCAL</code> は、ロックが
保持されている間にコンフリクトしない <code>INSERT</code> ステートメントを実行で
きることです。ただし、これはロックを保持している間に <strong>MySQL</strong> の外で
データベースファイルを操作しようとする場合は使用できません。

</p>
<p>
それぞれのスレッドはそれらが全てのロックを得るまで待ちます(タイムアウト無し)。

</p>
<p>
<code>WRITE</code> ロックは普通、できる限り更新を行わせるため、
 <code>READ</code> ロックよりも優先順位が高くなっています。
これはあるスレッドが <code>READ</code> ロックをかけ、それ以外のスレッドが <code>WRITE</code> を
要求した場合、 <code>READ</code> は、<code>WRITE</code> スレッドがロックをし、それを解除するまで
待つということです。
<code>LOW_PRIORITY WRITE</code> を使用すれば、
<code>WRITE</code> ロックを待っているスレッドに <code>READ</code> ロックを得させることができます。
<code>LOW_PRIORITY WRITE</code> は <code>READ</code> ロックをしているスレッドが一つもないと
わかっている場合に使用すべきです。

</p>
<p>
<code>LOCK TABLES</code> を使用するとき、使用しようとする全てのテーブルをロッ
クすべきです！ 
そしてクエリで使用しようとしているのと同じエイリアスを使わなければなりません！
もしクエリで並列に複数回テーブルを使用するなら(alias をともなって)、
それぞれの alias をロックすべきです！
このポリシーはテーブルロックをデッドロックフリーにすることを確かにします。

</p>
<p>
<code>INSERT DELAYED</code> で使用しているいかなるテーブルも、ロックすべきではありません。
この場合 <code>INSERT</code> は別のスレッドで行なわれるからです。

</p>
<p>
通常、全ての単一の <code>UPDATE</code> 構文においては、テーブルをロックする必要はありません；
スレッドは、他のスレッドが現在実行している SQL 文に干渉することができません。
これらはテーブルをロックした方がよい、まれな場合です：

</p>

<ul>
<li>

テーブルをまとめて多くの操作を実行しようとする場合、使用しようとしているテー
ブルをロックするととても速くなります。もちろん、他のスレッドは <code>READ</code> ロッ
クされたテーブルの更新はできませんし、他のスレッドは <code>WRITE</code> ロックされた
テーブルを読むことはできません。
</li><li>

<code>MySQL</code> はトランザクション環境をサポートしないため、他のスレッドが
<code>SELECT</code>,<code>UPDATE</code>の間に来ないことを保証したい場合は、
<code>LOCK TABLES</code> を使用する必要があります。
次の例は安全のためには <code>LOCK TABLES</code> を必要とします：
 

<pre>mysql&gt; LOCK TABLES trans READ, customer WRITE;
mysql&gt; select sum(value) from trans where customer_id= some_id;
mysql&gt; update customer set total_value=sum_from_previous_statement
           where customer_id=some_id;
mysql&gt; UNLOCK TABLES;
</pre>

 <code>LOCK TABLES</code> を使用しない場合、<code>SELECT</code> の実行と <code>UPDATE</code> の
実行を行う間に、他のスレッドが新しい <code>trans</code> 行を挿入する隙ができます。
</li></ul>

<p>
増加更新 (<code>UPDATE customer SET value=value+new_value</code>) または 
<code>LAST_INSERT_ID()</code> 関数の使用により、多くの場合 <code>LOCK TABLES</code> を回避
できます。

</p>
<p>
いくつかの場合、ユーザレベルロック: <code>GET_LOCK()</code> と <code>RELEASE_LOCK()</code> の使用
によっても解決できます。これらのロックはサーバ内のハッシュテーブル内に保
持され、高速のため <code>pthread_mutex_lock()</code> で実装されました。
 「<a href="manual.ja_Reference.html#Miscellaneous_functions">7.4.12  その他の関数</a>」節参照.

</p>
<p>
ロックポリシーのさらなる情報については  「<a href="manual.ja_Performance.html#Internal_locking">12.2.8  <strong>MySQL</strong> はどのようにテーブルをロックするか</a>」節 を見てくださ
い。

</p>
<p>
<a name="IDX582"></a>


</p><h2><a name="SET_OPTION" href="manual.ja_toc.html#SET_OPTION">7.28  <code>SET OPTION</code> 構文</a></h2>


<pre>SET [OPTION] SQL_VALUE_OPTION= value, ...
</pre>

<p>
<code>SET OPTION</code> はサーバやクライアントの操作に影響する様々なオプションを設定します. 
現在のセッションが終わるか,またはあなたが異なった値にオプションを設定するまで,
設定されたオプション値は残っています.

</p>
<dl compact="">

<dt><code>CHARACTER SET character_set_name | DEFAULT</code>
</dt><dd>
これは指定されたマッピングに従って、すべての文字列をクライアントからクライアントにマップします.
現在、<code>character_set_name</code> に指定できるオプションは <code>cp1251_koi8</code> だけですが,
<strong>MySQL</strong> のソース中にある <tt>`sql/convert.cc'</tt> ファイルを編集することによって,
容易に新しいマッピングを加えることができます. 標準のマッピングに戻すには、
<code>character_set_name</code> に <code>DEFAULT</code> を指定します。

<code>CHARACTER SET</code> オプションを設定するための構文は、
他のオプションを設定する構文と異なっていることに注意してください.

</dd><dt><code>PASSWORD = PASSWORD('some password')</code>
</dt><dd>
<a name="IDX583"></a>
現在のユーザのパスワードを設定します。いかなる非匿名のユーザも、
自分自身パスワードを変えることができます!

</dd><dt><code>PASSWORD FOR user = PASSWORD('some password')</code>
</dt><dd>
<a name="IDX584"></a>
現在ログインしているホストの特定ユーザのパスワードを設定します。
<code>mysql</code> データベースにアクセスができるユーザーだけが実行できます。
ユーザは <code>user@hostname</code> 形式で与えなくてはなりません。
ここで <code>user</code> と <code>hostname</code> は、<code>mysql.user</code> テーブルの
<code>User</code>, <code>Host</code> フィールドに登録されていなくてはなりません。
例えば、<code>User</code> と <code>Host</code> フィールドが <code>'bob'</code> と
<code>'%.loc.gov'</code> ならば、以下のようにします：


<pre>mysql&gt; SET PASSWORD FOR bob@"%.loc.gov" = PASSWORD("newpass");

または

mysql&gt; UPDATE mysql.user SET password=PASSWORD("newpass") where user="bob' and host="%.loc.gov";
</pre>

</dd><dt><code>SQL_AUTO_IS_NULL = 0 | 1</code>
</dt><dd>
<code>1</code> (デフォルト) を設定すると、次のようにして、auto_increment レコー
ドを持つテーブルで、最後に挿入されたレコードを見つけることができます:
<code>WHERE auto_increment_column IS NULL</code>。これは、Access のようないくつ
かの ODBC プログラムによって使用されます。

</dd><dt><code>SET AUTOCOMMIT= 0 | 1</code>
</dt><dd>
<code>1</code> を設定すると、テーブルへのすべての変更はすぐに行なわれます。
<code>0</code> を設定すると、そのトランザクションを許可/破棄するために、
<code>COMMIT</code> / <code>ROLLBACK</code> を使用する必要があります。 「<a href="manual.ja_Reference.html#COMMIT">7.26  <code>COMMIT/ROLLBACK</code> 構文</a>」節参照。
注意: 非 <code>AUTOCOMMIT</code> モードから <code>AUTOCOMMIT</code> モードに変更する時、
<strong>MySQL</strong> はすべてのオープントランザクションを自動的に 
<code>COMMIT</code> します。

</dd><dt><code>SQL_BIG_TABLES = 0 | 1</code>
</dt><dd>
<a name="IDX585"></a>
<code>0</code> の場合、全ての一時テーブルはメモリーではなくディスクに書き出されます。
これは少し遅くなりますが、多くの一時テーブルを必要とする大きな <code>SELECT</code> を
実行しても、<code>The table tbl_name is full</code> エラーが出なくなります。
新しい接続におけるこの値のデフォルト値は <code>1</code> (メモリーに一時テーブルを作る)
です。

</dd><dt><code>SQL_BIG_SELECTS = 0 | 1</code>
</dt><dd>
<code>1</code> の場合、とても時間のかかる <code>SELECT</code> が実行された場合、
<strong>MySQL</strong> はそれを中止します。
これはあまり芳しくない(間違った) <code>WHERE</code> 構文が発行されたときに役立ちます。
<code>max_join_size</code> 行以上を検討するような <code>SELECT</code> が
大きなクエリと定義されます。
新しい接続におけるこの値のデフォルト値は <code>0</code> です。
(全ての <code>SELECT</code> 構文を許します)

</dd><dt><code>SQL_BUFFER_RESULT = 0 | 1</code>
</dt><dd>
<code>SQL_BUFFER_RESULT</code> は一時ファイルに置かれる <code>SELECT</code> からの結果
を強制的に置きます。これは <strong>MySQL</strong> がテーブルロックを早く解放する手
助けをし、クライアントへ結果セットを送信するために長い時間が掛かる場合に役
立ちます。

</dd><dt><code>SQL_LOW_PRIORITY_UPDATES = 0 | 1</code>
</dt><dd>
<code>1</code> の場合、全ての <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>,
 <code>LOCK TABLE WRITE</code>構文は、
対象となるテーブルを処理中の <code>SELECT</code> や <code>LOCK TABLE READ</code>
がなくなるまで待ちます。

</dd><dt><code>SQL_MAX_JOIN_SIZE = value | DEFAULT</code>
</dt><dd>
おそらく <code>value</code> よりも多いレコードの組合せを試験する必要があるような
<code>SELECT</code> を許可しません。この値を設定することで、キーが使用されないで
あろう <code>SELECT</code> と長い時間が掛かるであろう <code>SELECT</code> を捕捉できま
す。これを <code>DEFAULT</code> 以外の値に設定すると、<code>SQL_BIG_SELECTS</code> フ
ラグをリセットします。<code>SQL_BIG_SELECTS</code> フラグを再び設定すると、
<code>SQL_MAX_JOIN_SIZE</code> 変数は無視されます。<code>-O max_join_size=#</code> で 
<code>mysqld</code> を起動することで、この変数のデフォルト値を設定できます。

</dd><dt><code>SQL_SAFE_MODE = 0 | 1</code>
</dt><dd>
<code>1</code> に設定すると、<code>WHERE</code> 節内でキーや <code>LIMIT</code> を使用しない
で <code>UPDATE</code> または <code>DELETE</code> を行なおうとした場合に 
<strong>MySQL</strong> がアボートします。これは、手で SQL コマンドを生成する時の間
違った更新の捕捉を可能にします。

</dd><dt><code>SQL_SELECT_LIMIT = value | DEFAULT</code>
</dt><dd>
<code>SELECT</code> 構文から返されるレコードの最大値。
もし <code>SELECT</code> に <code>LIMIT</code> 節を使用している場合、<code>LIMIT</code> は
 <code>SQL_SELECT_LIMIT</code> の値より優先されます。
新しい接続におけるこの値の標準値は ``unlimited''.
もしリミットを変えているならば、<code>SQL_SELECT_LIMIT</code> に
 <code>DEFAULT</code> を指定することにより、標準値に戻すことができます。

</dd><dt><code>SQL_LOG_OFF = 0 | 1</code>
</dt><dd>
この値が <code>1</code> の場合、もしクライアントが <strong>process</strong> 権限を持っているならば、
このクライアントのログが行われません。
これは更新ログに影響しません！

</dd><dt><code>SQL_LOG_UPDATE = 0 | 1</code>
</dt><dd>
<code>0</code> の場合、もしクライアントが <strong>process</strong> 権限を持っているならば、
このクライアントの更新ログの記録は行われません。
これは通常のログには影響しません！

</dd><dt><code>TIMESTAMP = timestamp_value | DEFAULT</code>
</dt><dd>
クライアントに時間を設定します。
もしレコードのリストアに更新ログを使用する場合、オリジナルのタイムスタンプを得るために使用します。

</dd><dt><code>LAST_INSERT_ID = #</code>
</dt><dd>
<code>LAST_INSERT_ID()</code> からの返り値を設定します。
テーブルを更新するコマンド中に <code>LAST_INSERT_ID()</code> を使用した場合、
これは更新ログに保存されます。

</dd><dt><code>INSERT_ID = #</code>
</dt><dd>
 <code>AUTO_INCREMENT</code> 値を挿入する時、
<code>INSERT</code> コマンドに従って使用される値をセットします。
これは更新ログによって使用されます。

</dd></dl>

<p>
<a name="IDX586"></a>
<a name="IDX587"></a>


</p><h2><a name="GRANT" href="manual.ja_toc.html#GRANT">7.29  <code>GRANT</code> と <code>REVOKE</code> 構文</a></h2>


<pre>GRANT priv_type [(column_list)] [, priv_type [(column_list)] ...]
    ON {tbl_name | * | *.* | db_name.*}
    TO user_name [IDENTIFIED BY 'password']
        [, user_name [IDENTIFIED BY 'password'] ...]
    [WITH GRANT OPTION]

REVOKE priv_type [(column_list)] [, priv_type [(column_list)] ...]
    ON {tbl_name | * | *.* | db_name.*}
    FROM user_name [, user_name ...]
</pre>

<p>
<code>GRANT</code> は <strong>MySQL</strong> 3.22.11 以上で実装されています; 前の 
<strong>MySQL</strong> バージョンでは、<code>GRANT</code> ステートメントは何も行ないま
せん。

</p>
<p>
<code>GRANT</code> と <code>REVOKE</code> コマンドセットの主な目的は、システム管理者
が <strong>MySQL</strong> ユーザに次の４つの権限レベルの権利を与えたり取り消すこ
とをできるようにすることです:

</p>
<dl compact="">

<dt><strong>Global レベル</strong>
</dt><dd>
Global 権限は与えられたサーバ上の全てのデータベースに適用します。これらの権限は 
<code>mysql.user</code> テーブル内に格納されます。

</dd><dt><strong>Database レベル</strong>
</dt><dd>
Database 権限は与えられたデータベース内の全てのテーブルに適用します。こ
れらの権限は <code>mysql.db</code> テーブルと <code>mysql.host</code> テーブル内に格納されます。

</dd><dt><strong>Table レベル</strong>
</dt><dd>
Table 権限は与えられたテーブル内の全てのフィールドに適用します。これらの権限は 
<code>mysql.tables_priv</code> テーブル内に格納されます。

</dd><dt><strong>Column レベル</strong>
</dt><dd>
Column 権限は与えられたテーブル内の一つのフィールドに適用します。これらの権限は 
<code>mysql.column_priv</code> テーブル内に格納されます。
</dd></dl>

<p>
<code>GRANT</code> の動作例は →  「<a href="manual.ja_Privilege_system.html#Adding_users">6.12  新しいユーザ権限を <strong>MySQL</strong> へ追加</a>」節.

</p>
<p>
<code>GRANT</code> と <code>REVOKE</code> ステートメントにおいて <code>priv_type</code> には
以下が指定できます:

</p>

<pre>ALL PRIVILEGES      FILE                RELOAD
ALTER               INDEX               SELECT
CREATE              INSERT              SHUTDOWN
DELETE              PROCESS             UPDATE
DROP                REFERENCES          USAGE
</pre>

<p>
<code>ALL</code> は <code>ALL PRIVILEGES</code> の同義語です.
<code>REFERENCES</code> はまだ実行されません。
<code>USAGE</code> は ``no privileges'' と同義です.
これはなんの権限も持たないユーザーを作る場合に使用します.

</p>
<p>
ユーザーから権限許可を取り除くには、<code>GRANT OPTION</code> オプションの値に
<code>priv_type</code> を指定します：

</p>

<pre>REVOKE GRANT OPTION ON ... FROM ...;
</pre>

<p>
テーブルに対する許可のために指定できる <code>priv_type</code> は次のフィールドだけです：
<code>SELECT</code>,<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE</code>, <code>DROP</code>,
<code>GRANT</code>, <code>INDEX</code>, <code>ALTER</code>.

</p>
<p>
フィールドに対する許可のために指定できる <code>priv_type</code> は次のフィールドだけです
(これは <code>column_list</code> 節を使用する場合に適用されます)：
<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>.

</p>
<p>
<code>WITH GRANT OPTION</code> 節は、<code>GRANT</code> 構文を使用して
他のユーザーに権限を与えることができるようにします。

</p>
<p>
<code>ON *.*</code> を使用してグローバル権限を設定できます。
<code>ON db_name.*</code> を使用してデータベース権限を設定できます。<code>ON *</code> を
指定すると、現在のデータベースの権限を設定できます。
(<strong>警告：</strong> 現在のデータベースを持たない状態で <code>ON *</code> を指定した場合、
global 権限に影響します！)

</p>
<p>
ユーザへの権利の供与を他のホストから適応するために、<strong>MySQL</strong> は
 <code>user_name</code> の値を <code>user@host</code> の形で書けるようにしています。
特殊文字(<samp>`%'</samp> のような)で <code>user_name</code> の値を指定したい場合、
ユーザやホスト名をクォートできます;
(例えば <code>'test-user'@'test-hostname'</code>)。

</p>
<p>
ホスト名にワイルドカードを使用できます。例えば、<code>user@"%.loc.gov"</code> は
<code>loc.gov</code> ドメインの全てのホストの <code>user</code> を与え、
<code>user@"144.155.166.%"</code> は <code>144.155.166</code> クラスCサブネットの
あらゆるホストの <code>user</code> となります。

</p>
<p>
単に <code>user</code> と書くと <code>user@"%"</code> と同じです.
<strong>注意：</strong> もし匿名ユーザーからの <strong>MySQL</strong> サーバーへの接続を
許す場合(デフォルトです)、全てのローカルユーザー <code>username@localhost</code> を加えるべきです。
なぜなら、匿名ユーザーは同じマシンから <strong>MySQL</strong> サーバーに入ろうとした場合に
使用されるからです！
匿名ユーザーは <code>mysql.user</code> ユーザーテーブルに、 <code>User=''</code> として登録されています。
これを確認するには、以下のようにします：

</p>

<pre>mysql&gt; SELECT Host,User FROM mysql.user WHERE User='';
</pre>

<p>
さしあたり, <code>GRANT</code> はホスト名、テーブル名、データベース名、フィールド名に
最大60文字まで使用できます。ユーザー名は最大16文字までです。

</p>
<p>
テーブル/フィールドの権限は global(ユーザとデータベース)権限と 
<code>GRANT</code> 権限と <code>OR</code> されます。例えば、ユーザが 
<code>mysql.user</code> テーブル内の global <strong>select</strong> 権限を持っている場合、
これはデータベースやテーブル/フィールドレベル内のエントリでは拒否できません。

</p>
<p>
フィールドの権利は次のように計算できます:

</p><pre>global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
</pre>

<p>
多くの場合、異なる権限レベルの一つでユーザに権利を与えるので、人生は通常
上述のようには複雑ではありません。:)
アクセス制限のチェックの詳細は→ 「<a href="manual.ja_Privilege_system.html#Privilege_system">6  <strong>MySQL</strong> のユーザー権限はどのように動くか？</a>」節.

</p>
<p>
ユーザへの権利の供与を他のホストから適応するために、<strong>MySQL</strong> はユー
ザ名が形式 <code>user@host</code> で指定できることをサポートします。簡単な形
式 <code>user</code> は <code>user@%</code> の同義語です。特殊文字(<code>.</code> のよう
な)でホスト名を指定したい場合、<code>"user"@"hostname"</code> 構文を使用でき
ます。

</p>
<p>
ユーザとホスト名の組が存在しない場合、エントリは <code>mysql.user</code> テー
ブルに追加され、<code>DELETE</code> コマンドで削除されるまでそこに残ります。
いうならば <code>GRANT</code> は <code>user</code> テーブルの登録を作りますが、
 <code>REVOKE</code> はそれらを削除できません;
そうするには <code>DELETE</code> を使用しなくてはなりません。

</p>
<p>
<a name="IDX588"></a>
<strong>MySQL</strong> 3.22.12 以上では、
新しいユーザーが作成された場合、あるいは、あなたがグローバルな権限を許可されている場合、
ユーザーのパスワードは <code>IDENTIFIED BY</code> 節を使用して設定できます。
すでにユーザーにパスワードがある場合、新しく設定されたパスワードに置き換えられます。

</p>
<p>
<strong>警告：</strong> もし新しいユーザーを作っても
<code>IDENTIFIED BY</code> 節を指定しなければ、 そのユーザーはノーパスワードです。
これは危険です。

</p>
<p>
パスワードは <code>SET PASSWORD</code> コマンドでも設定できます。
 「<a href="manual.ja_Reference.html#SET_OPTION">7.28  <code>SET OPTION</code> 構文</a>」節参照.

</p>
<p>
データベースに権限を <code>GRANT</code> する場合、<code>mysql.db</code> テーブル内の
エントリは必要な場合に生成されます。全てのデータベース権限が 
<code>REVOKE</code> で削除された時、このエントリは削除されます。

</p>
<p>
ユーザがテーブルに何も権限を持っていない場合、テーブルの一覧要求時(例え
ば、<code>SHOW TABLES</code> ステートメントで)には、テーブルは現れません。

</p>
<p>
<code>WITH GRANT OPTION</code> 節は、他のユーザーに、自分が持っている権限を与えることができます。
<strong>権限許可</strong>を他に与える場合は注意してください。
あなたと許可を与えるユーザーが違う権限を持っている場合、
与えられる権限の許可は、二つを合わせた物になります！

</p>
<p>
自分自身が持っていない権限を他のユーザーに与えることはできません；
<strong>権限許可</strong>はあなたが所有する権限の許可だけを与えることができます。

</p>
<p>
あなたがユーザーに格別の権限レベルを与えた場合、既にユーザーが持っているいかなる権限
(あるいは 将来持つ権限) はそのユーザーによっても許可が与えられます。
あなたがデータベースに対する <strong>insert</strong> 許可をあるユーザーに与えたと仮定します。
もし、データベースに対する <strong>select</strong> 権限を与えたり、
<code>WITH GRANT OPTION</code> を行うと、ユーザーは <strong>select</strong> 権限だけでなく
 <strong>insert</strong> も得ることになります。
もし <strong>update</strong> 権限をユーザーに与えると、そのユーザーは
<strong>insert</strong>, <strong>select</strong>, <strong>update</strong> が可能です。

</p>
<p>
<strong>alter</strong> 権限を一般ユーザに与えるべきではありません。この場合
ユーザはテーブルをリネームでき、この方法で権限を回ることを試みることがで
きます！

</p>
<p>
注意：もし table/column 権限を一人のユーザーにだけ与えた場合、
 <strong>MySQL</strong> は全てのユーザーに対してテーブルとフィールドの承認権限を検討します。
これは <strong>MySQL</strong> を少し遅くします。

</p>
<p>
<code>mysqld</code> 開始時、全ての権限はメモリに読み込まれます。データベース、
テーブル、フィールド権限は一度効果を得ます。ユーザレベル権限はユーザ再接続時に
効果を得ます。
これらの許可テーブルを <code>GRANT</code> や <code>REVOKE</code> を使って変更しても
サーバーにはすぐに反映されません。
もしこれらの許可テーブルを手動で変更した場合(<code>INSERT</code>, <code>UPDATE</code>, 等で変更した場合)、
<code>FLUSH PRIVILEGES</code> 構文を実行するか、<code>mysqladmin flush-privileges</code> を実行して
サーバーに許可テーブルの再読み込みを行わせなくてはなりません。
 「<a href="manual.ja_Privilege_system.html#Privilege_changes">6.10  いつ権限の変更が反映されるか</a>」節参照.

</p>
<p>
<code>ANSI SQL GRANT</code> と <strong>MySQL</strong> <code>GRANT</code> との大きな違いは:

</p>

<ul>
<li>

ANSI SQL はグローバルとデータベースレベル承認を持たず、ANSI SQL は
 <strong>MySQL</strong> がサポートする全ての権限をサポートしません。
</li><li>

ANSI SQL でテーブルを破棄する時、そのテーブルの全ての権限は破棄さ
れます。<code>ANSI SQL</code> で権限を取り消す場合、この権限に基づいて承認され
た全ての権限も取り消されます。<code>MySQL</code> では、全ての権限は明示的な 
<code>REVOKE</code> コマンドまたは <strong>MySQL</strong> 権限テーブルの操作によっての
み破棄されます。
</li></ul>

<p>
<a name="IDX589"></a>
<a name="IDX590"></a>
<a name="IDX591"></a>
<a name="IDX592"></a>


</p><h2><a name="CREATE_INDEX" href="manual.ja_toc.html#CREATE_INDEX">7.30  <code>CREATE INDEX</code> 構文</a></h2>


<pre>CREATE [UNIQUE] INDEX index_name ON tbl_name (col_name[(length)],... )
</pre>

<p>
<code>CREATE INDEX</code> 構文は <strong>MySQL</strong> 3.22 より以前のバージョンではなにもしません。
3.22 以降で、<code>CREATE INDEX</code> はインデックスの作成のために <code>ALTER TABLE</code>
 を呼びだしています。
 「<a href="manual.ja_Reference.html#ALTER_TABLE">7.8  <code>ALTER TABLE</code>構文</a>」節参照.

</p>
<p>
通常、テーブル内の全てのインデックスは <code>CREATE TABLE</code> で
テーブルを作るときに一度に作成されます。
 「<a href="manual.ja_Reference.html#CREATE_TABLE">7.7  <code>CREATE TABLE</code>構文</a>」節参照.
<code>CREATE INDEX</code> は既に存在するテーブルに対し、インデックスを追加します。

</p>
<p>
フィールドを <code>(col1,col2,...)</code> として指定すると、複数フィールドインデックスを作成します。
インデックスの値は、与えられたフィールドの値を連結して、構成されます。

</p>
<p>
<code>CHAR</code> と <code>VARCHAR</code> フィールドでは、インデックスはフィールドの一部分だけを使用して
作成されます。これは <code>col_name(length)</code> 構文を使用します。
(<code>BLOB</code> と <code>TEXT</code> 節では length が必要です)。
最初の10文字をインデックスとして使用するには、この構文は以下のようにして使用します(<code>name</code> フィールドにインデックスを作ります)：

</p>

<pre>mysql&gt; CREATE INDEX part_of_name ON customer (name(10));
</pre>

<p>
フィールドの一部分だけをインデックスに使用すれば、インデックスファイルをはるかに小さくすることができます。
ほとんどの名前が最初の10文字において通常異なるので、
このインデックスは <code>name</code> フィールド全部を使用して創り出したインデックスに比べて
遅くなることはありません。また、多くのディスクスペースを節約でき、
 <code>INSERT</code> を速くするのです！

</p>
<p>
<strong>MySQL</strong> version 3.23.2 以上で <code>MyISAM</code> 型のテーブルを使用している場合、
<code>NULL</code> 値をもつフィールドや、 <code>BLOB</code>/<code>TEXT</code> フィールドに対して
インデックスを張ることが可能です。

</p>
<p>
<strong>MySQL</strong> がどのようにしてインデックスを使用するかは →
　 「<a href="manual.ja_Performance.html#MySQL_indexes">12.4  MySQL はどのようにインデックスを使用するか？</a>」節.

</p>
<p>
<a name="IDX593"></a>


</p><h2><a name="DROP_INDEX" href="manual.ja_toc.html#DROP_INDEX">7.31  <code>DROP INDEX</code> 構文</a></h2>


<pre>DROP INDEX index_name ON tbl_name
</pre>

<p>
<code>DROP INDEX</code> は <code>index_name</code> という名前のインデックスをテーブル 
<code>tbl_name</code> から破棄します。
<code>DROP INDEX</code> は <strong>MySQL</strong> 3.22 より以前のバージョンではなにもしません。
3.22 以降で、<code>DROP INDEX</code> はインデックスの破棄のために
<code>ALTER TABLE</code> を呼びだしています。
 「<a href="manual.ja_Reference.html#ALTER_TABLE">7.8  <code>ALTER TABLE</code>構文</a>」節参照.

</p>
<p>
<a name="IDX594"></a>


</p><h2><a name="Comments" href="manual.ja_toc.html#Comments">7.32  コメント 構文</a></h2>

<p>
<strong>MySQL</strong> は <code># 行末まで</code> , <code>-- 行末まで</code> そして <code>/* 
行中または複数行 */</code> コメント書式をサポートします:

</p>

<pre>mysql&gt; select 1+1;     # このコメントは行末まで続く
mysql&gt; select 1+1;     -- このコメントは行末まで続く
mysql&gt; select 1 /* これは行中コメント */ + 1;
mysql&gt; select 1+
/*
これは
複数行コメント
*/
1;
</pre>

<p>
<code>--</code> コメントスタイルは <code>--</code> の後ろに最低一つのスペースが
必要であることに注意！

</p>
<p>
サーバーはコメント構文を理解しますが、 <code>mysql</code> クライアントが
 <code>/* ... */</code> コメントを分析するにはいくつか制限があります：

</p>

<ul>
<li>

シングルクウォートとダブルクオート文字は引用文字列のトークンの開始を
示します。たとえコメントの中であっても。
もしコメントの中でクオートが二つ目のクオートにマッチしなかった場合、
パーサーはコメントが終了していないと認識します。
<code>mysql</code> を対話モードで実行している場合、
プロンプトが <code>mysql&gt;</code> から <code>'&gt;</code> か <code>"&gt;</code> に変わります。

</li><li>

セミコロンは SQL 構文の終了を示し、これに続く文字は次の構文の開始と
なります。
</li></ul>

<p>
これらの制限は <code>mysql</code> を対話モードで実行している場合と、
<code>mysql</code> にファイルを読み込ませている場合 ( <code>mysql &lt; some-file</code> ) の
両方で現れます。

</p>
<p>
<strong>MySQL</strong> は ANSI SQL コメントの <samp>`--'</samp> をサポートしません。
 「<a href="manual.ja_Compatibility.html#Missing_comments">5.4.7  コメント開始としての <samp>`--'</samp></a>」節参照.

</p>

<p>
<a name="IDX595"></a>
<a name="IDX596"></a>
<a name="IDX597"></a>
<a name="IDX598"></a>
<a name="IDX599"></a>


</p><h2><a name="CREATE_FUNCTION" href="manual.ja_toc.html#CREATE_FUNCTION">7.33  <code>CREATE FUNCTION/DROP FUNCTION</code> 構文</a></h2>


<pre>CREATE [AGGREGATE] FUNCTION function_name RETURNS {STRING|REAL|INTEGER}
       SONAME shared_library_name

DROP FUNCTION function_name
</pre>

<p>
ユーザー定義関数 (UDF : user-definable functions) は
 <strong>MySQL</strong> に新しい関数を持たせれる拡張方法です。
これは <strong>MySQL</strong> のネイティブ(埋め込み)関数
(<code>ABS()</code>, <code>CONCAT()</code> のような)と同じように動作します。

</p>
<p>
<code>AGGREGATE</code> は <strong>MySQL</strong> 3.23 の新しいオプションです。
<code>AGGREGATE</code> 関数は、<code>SUM</code> や <code>COUNT()</code> のようなネイティブな 
<strong>MySQL</strong> <code>GROUP</code> 関数のように正確に動作します。

</p>
<p>
<code>CREATE FUNCTION</code> は、関数名、型、共有ライブラリ名を、
<code>mysql.func</code> システムテーブルに、保存します。
関数の作成、破棄を行うには、 <code>mysql</code> データベースに対して、
 <strong>insert</strong> , <code>delete</code> 権限がなければなりません。

</p>
<p>
全ての関数はサーバーの起動時に読み込まれます。
ただし <code>--skip-grant-tables</code> オプションを <code>mysqld</code> につけていなければ。
この場合、UDF の初期化は飛ばされ、UDF で作った関数は使用できません。
(関数は <code>CREATE FUNCTION</code> でロードされ、 <code>DROP FUNCTION</code> で削除されます)

</p>
<p>
ユーザー定義関数に関するさらなる情報は →  「<a href="manual.ja_Adding_functions.html#Adding_functions">16  <strong>MySQL</strong> への新しい関数の追加</a>」節. 
UDF メカニズムで動かすためには、関数は C か C++ で書かれていなければなりません。
かつ、あなたのオペレーティングシステムがダイナミックローディングを
サポートしていなければなりません。さらに <code>mysqld</code> はスタティックではなく
ダイナミックでコンパイルされていなければなりません。

</p>
<p>
<a name="IDX600"></a>
<a name="IDX601"></a>
<a name="IDX602"></a>


</p><h2><a name="Reserved_words" href="manual.ja_toc.html#Reserved_words">7.34  Is <strong>MySQL</strong> picky about reserved words?</a></h2>

<p>
共通の問題は、フィールドの名前を、 <code>TIMESTAMP</code> とか <code>GROUP</code> とかの
 <strong>MySQL</strong> に埋め込まれているデータ型や関数名と同名にして、
テーブルを作った場合に起こります。
このようなことは行えます(例えば <code>ABS</code> はフィールド名にできます)。
しかし、関数として使用する場合、
この名前がフィールド名として使用されているなら、
関数名と <samp>`('</samp> の間の空白は許されません。

</p>
<p>
以下の語は <strong>MySQL</strong> に予約されています。
これらのほとんどは、 ANSI SQL92 によって、
テーブル、フィールド名としての使用は禁止されています。(例えば <code>group</code>)。
またいくつかの語は <strong>MySQL</strong> が必要とし、 <code>yacc</code> パーサーで
使用しているので予約されています。

</p>

<table border="" width="100%" nosave="">
<tbody><tr><td><code>action</code> </td><td> <code>add</code> </td><td> <code>aggregate</code> </td><td> <code>all</code>
</td></tr>
<tr><td><code>alter</code> </td><td> <code>after</code> </td><td> <code>and</code> </td><td> <code>as</code>
</td></tr>
<tr><td><code>asc</code> </td><td> <code>avg</code> </td><td> <code>avg_row_length</code> </td><td> <code>auto_increment</code>
</td></tr>
<tr><td><code>between</code> </td><td> <code>bigint</code> </td><td> <code>bit</code> </td><td> <code>binary</code>
</td></tr>
<tr><td><code>blob</code> </td><td> <code>bool</code> </td><td> <code>both</code> </td><td> <code>by</code>
</td></tr>
<tr><td><code>cascade</code> </td><td> <code>case</code> </td><td> <code>char</code> </td><td> <code>character</code>
</td></tr>
<tr><td><code>change</code> </td><td> <code>check</code> </td><td> <code>checksum</code> </td><td> <code>column</code>
</td></tr>
<tr><td><code>columns</code> </td><td> <code>comment</code> </td><td> <code>constraint</code> </td><td> <code>create</code>
</td></tr>
<tr><td><code>cross</code> </td><td> <code>current_date</code> </td><td> <code>current_time</code> </td><td> <code>current_timestamp</code>
</td></tr>
<tr><td><code>data</code> </td><td> <code>database</code> </td><td> <code>databases</code> </td><td> <code>date</code>
</td></tr>
<tr><td><code>datetime</code> </td><td> <code>day</code> </td><td> <code>day_hour</code> </td><td> <code>day_minute</code>
</td></tr>
<tr><td><code>day_second</code> </td><td> <code>dayofmonth</code> </td><td> <code>dayofweek</code> </td><td> <code>dayofyear</code>
</td></tr>
<tr><td><code>dec</code> </td><td> <code>decimal</code> </td><td> <code>default</code> </td><td> <code>delayed</code>
</td></tr>
<tr><td><code>delay_key_write</code> </td><td> <code>delete</code> </td><td> <code>desc</code> </td><td> <code>describe</code>
</td></tr>
<tr><td><code>distinct</code> </td><td> <code>distinctrow</code> </td><td> <code>double</code> </td><td> <code>drop</code>
</td></tr>
<tr><td><code>end</code> </td><td> <code>else</code> </td><td> <code>escape</code> </td><td> <code>escaped</code>
</td></tr>
<tr><td><code>enclosed</code> </td><td> <code>enum</code> </td><td> <code>explain</code> </td><td> <code>exists</code>
</td></tr>
<tr><td><code>fields</code> </td><td> <code>file</code> </td><td> <code>first</code> </td><td> <code>float</code>
</td></tr>
<tr><td><code>float4</code> </td><td> <code>float8</code> </td><td> <code>flush</code> </td><td> <code>foreign</code>
</td></tr>
<tr><td><code>from</code> </td><td> <code>for</code> </td><td> <code>full</code> </td><td> <code>function</code>
</td></tr>
<tr><td><code>global</code> </td><td> <code>grant</code> </td><td> <code>grants</code> </td><td> <code>group</code>
</td></tr>
<tr><td><code>having</code> </td><td> <code>heap</code> </td><td> <code>high_priority</code> </td><td> <code>hour</code>
</td></tr>
<tr><td><code>hour_minute</code> </td><td> <code>hour_second</code> </td><td> <code>hosts</code> </td><td> <code>identified</code>
</td></tr>
<tr><td><code>ignore</code> </td><td> <code>in</code> </td><td> <code>index</code> </td><td> <code>infile</code>
</td></tr>
<tr><td><code>inner</code> </td><td> <code>insert</code> </td><td> <code>insert_id</code> </td><td> <code>int</code>
</td></tr>
<tr><td><code>integer</code> </td><td> <code>interval</code> </td><td> <code>int1</code> </td><td> <code>int2</code>
</td></tr>
<tr><td><code>int3</code> </td><td> <code>int4</code> </td><td> <code>int8</code> </td><td> <code>into</code>
</td></tr>
<tr><td><code>if</code> </td><td> <code>is</code> </td><td> <code>isam</code> </td><td> <code>join</code>
</td></tr>
<tr><td><code>key</code> </td><td> <code>keys</code> </td><td> <code>kill</code> </td><td> <code>last_insert_id</code>
</td></tr>
<tr><td><code>leading</code> </td><td> <code>left</code> </td><td> <code>length</code> </td><td> <code>like</code>
</td></tr>
<tr><td><code>lines</code> </td><td> <code>limit</code> </td><td> <code>load</code> </td><td> <code>local</code>
</td></tr>
<tr><td><code>lock</code> </td><td> <code>logs</code> </td><td> <code>long</code> </td><td> <code>longblob</code>
</td></tr>
<tr><td><code>longtext</code> </td><td> <code>low_priority</code> </td><td> <code>max</code> </td><td> <code>max_rows</code>
</td></tr>
<tr><td><code>match</code> </td><td> <code>mediumblob</code> </td><td> <code>mediumtext</code> </td><td> <code>mediumint</code>
</td></tr>
<tr><td><code>middleint</code> </td><td> <code>min_rows</code> </td><td> <code>minute</code> </td><td> <code>minute_second</code>
</td></tr>
<tr><td><code>modify</code> </td><td> <code>month</code> </td><td> <code>monthname</code> </td><td> <code>myisam</code>
</td></tr>
<tr><td><code>natural</code> </td><td> <code>numeric</code> </td><td> <code>no</code> </td><td> <code>not</code>
</td></tr>
<tr><td><code>null</code> </td><td> <code>on</code> </td><td> <code>optimize</code> </td><td> <code>option</code>
</td></tr>
<tr><td><code>optionally</code> </td><td> <code>or</code> </td><td> <code>order</code> </td><td> <code>outer</code>
</td></tr>
<tr><td><code>outfile</code> </td><td> <code>pack_keys</code> </td><td> <code>partial</code> </td><td> <code>password</code>
</td></tr>
<tr><td><code>precision</code> </td><td> <code>primary</code> </td><td> <code>procedure</code> </td><td> <code>process</code>
</td></tr>
<tr><td><code>processlist</code> </td><td> <code>privileges</code> </td><td> <code>read</code> </td><td> <code>real</code>
</td></tr>
<tr><td><code>references</code> </td><td> <code>reload</code> </td><td> <code>regexp</code> </td><td> <code>rename</code>
</td></tr>
<tr><td><code>replace</code> </td><td> <code>restrict</code> </td><td> <code>returns</code> </td><td> <code>revoke</code>
</td></tr>
<tr><td><code>rlike</code> </td><td> <code>row</code> </td><td> <code>rows</code> </td><td> <code>second</code>
</td></tr>
<tr><td><code>select</code> </td><td> <code>set</code> </td><td> <code>show</code> </td><td> <code>shutdown</code>
</td></tr>
<tr><td><code>smallint</code> </td><td> <code>soname</code> </td><td> <code>sql_big_tables</code> </td><td> <code>sql_big_selects</code>
</td></tr>
<tr><td><code>sql_low_priority_updates</code> </td><td> <code>sql_log_off</code> </td><td> <code>sql_log_update</code> </td><td> <code>sql_select_limit</code>
</td></tr>
<tr><td><code>sql_small_result</code> </td><td> <code>sql_big_result</code> </td><td> <code>sql_warnings</code> </td><td> <code>straight_join</code>
</td></tr>
<tr><td><code>starting</code> </td><td> <code>status</code> </td><td> <code>string</code> </td><td> <code>table</code>
</td></tr>
<tr><td><code>tables</code> </td><td> <code>temporary</code> </td><td> <code>terminated</code> </td><td> <code>text</code>
</td></tr>
<tr><td><code>then</code> </td><td> <code>time</code> </td><td> <code>timestamp</code> </td><td> <code>tinyblob</code>
</td></tr>
<tr><td><code>tinytext</code> </td><td> <code>tinyint</code> </td><td> <code>trailing</code> </td><td> <code>to</code>
</td></tr>
<tr><td><code>type</code> </td><td> <code>use</code> </td><td> <code>using</code> </td><td> <code>unique</code>
</td></tr>
<tr><td><code>unlock</code> </td><td> <code>unsigned</code> </td><td> <code>update</code> </td><td> <code>usage</code>
</td></tr>
<tr><td><code>values</code> </td><td> <code>varchar</code> </td><td> <code>variables</code> </td><td> <code>varying</code>
</td></tr>
<tr><td><code>varbinary</code> </td><td> <code>with</code> </td><td> <code>write</code> </td><td> <code>when</code>
</td></tr>
<tr><td><code>where</code> </td><td> <code>year</code> </td><td> <code>year_month</code> </td><td> <code>zerofill</code>
</td></tr>
</tbody></table>

<p>
以下は ANSI SQL ではフィールド、テーブル名としての使用を禁止されていますが、
 <strong>MySQL</strong> では許可されています。
これは、これらの名前は凄く自然な名前で、多くの人がこれらを既に名前として
使用しているからです。

</p>

<ul>
<li><code>ACTION</code>

</li><li><code>BIT</code>

</li><li><code>DATE</code>

</li><li><code>ENUM</code>

</li><li><code>NO</code>

</li><li><code>TEXT</code>

</li><li><code>TIME</code>

</li><li><code>TIMESTAMP</code>

</li></ul>

<p>
<a name="IDX603"></a>
<a name="IDX604"></a>
<a name="IDX605"></a>
<a name="IDX606"></a>
<a name="IDX607"></a>
<a name="IDX608"></a>
<a name="IDX609"></a>
</p><p></p><hr><p>
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_Privilege_system.html">previous</a>, <a href="manual.ja_Table_types.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
 
 
</p></body></html>