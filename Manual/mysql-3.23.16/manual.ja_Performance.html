  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 22 May 2000 -->

  <TITLE>MySQL Reference Manual for version 3.23.16-alpha. - 12  MySQL の最大性能をひきだすには</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Replication.html">previous</A>, <A HREF="manual.ja_MySQL_Benchmarks.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Performance" HREF="manual.ja_toc.html#Performance">12  MySQL の最大性能をひきだすには</A></H1>

<P>
Optimization is a complicated task because it ultimately requires
understanding of the whole system. While it may be possible to do some
local optimizations with small knowledge of your system/application, the
more optimal you want your system to become the more you will have to
know about it.

</P>
<P>
So this chapter will try to explain and give some examples of different
ways to optimize <STRONG>MySQL</STRONG>. But remember that there are always some
(increasingly harder) ways to make the system even faster left to do.

</P>



<H2><A NAME="Optimize_Basics" HREF="manual.ja_toc.html#Optimize_Basics">12.1  最適化 概要</A></H2>

<P>
システムを速くするための最も重要な部分は、もちろん基礎的な設計です。
You also need to know that kinds of things your system will be
doing. That is your bottlenecks are.

</P>
<P>
主なボトルネックは：

<UL>
<LI>Disk シーク ：

一片のデータを見つけるためには、ディスクに時間がかかります。
1999年の最新型のディスクでは、このための平均時間は、10msよりも通常より小さいです。
したがって、我々は、理論上は 1秒で約1000 シークすることができます。
この時間は、一つのテーブルであるならば、データの増加と共にディスクアクセスの時間が
少しずつ増加することになり、とても最適化するのは難しくなっていきます。
これを最適化する方法は、データを 1個以上のディスクに分散する事です。
<LI>CPU cycles ：

データをメイン・メモリーの中に入れた(または既にメモリに存在している)場合に、
結果を得るためには、それを処理する必要があります。
メモリー容量よりも小さなテーブルを持っている場合、これは、制限の要因となります。
小さいテーブルでは、スピードは、通常問題にはなりません。
<LI>Memory bandwidth ：

CPU がキャッシュに収まらないようなデータを要求した場合、メイン・メモリー
のバンド幅はボトルネックになります。
これはほとんどのシステムで分かりにくいボトルネックとなりますが、
誰かはそれを知っているべきです。
</UL>



<H2><A NAME="System" HREF="manual.ja_toc.html#System">12.2  システム、コンパイル時、スタートパラメターのチューニング</A></H2>

<P>
We start with the system level things sine some of these decisions have
to be made very early. In other cases a fast look at this part may
suffice because it not that important for the big gains. But it is always
nice to have a feeling about how much one gould gain by chancing things
at this level.

</P>
<P>
使うべき OS はとても重要です！ 複数の CPU を持つマシンでは、
Solaris (なぜなら、Solaris のスレッドはとても素晴らしく動作するから)、
あるいは、Linux ( kernel 2.2 は良い SMP をサポートしているから) を
使用すべきです。 32bit マシンの Linux では、2G bytes のファイルサイズの
制限があります。 これは新しいファイルシステム (XFS) のリリース時に
なくなって欲しいものです。

</P>
<P>
Because we have not run production <STRONG>MySQL</STRONG> on that many platforms we
advice you to test your intended platform before choosing it if possible.

</P>
<P>
Other tips:

<UL>
<LI>

充分 RAM があるならば、全ての swap を外してもよいでしょう。
いくつかのシステムでは、たとえメモリーが空いていても、
swap を使用する場合があります。

<LI>

外部のロックを避けるため、<CODE>--skip-locking</CODE> <STRONG>MySQL</STRONG> オプション
を使用します。 
Note that this will not impact <STRONG>MySQL</STRONG> functionality as
long that only run one server.
<CODE>myisamchk</CODE> を実行する前に、サーバーを止めることを忘れないでください。
On some system
this switch is mandatory because the external locking does not work in any
case.

MIT スレッドでコンパイルする時は <CODE>--skip-locking</CODE> がデフォルトです。
これは全てのプラットフォームで MIT スレッドが <CODE>flock()</CODE> を完全にサポートし
ていないためです。

<CODE>--skip-locking</CODE> が使用できないただ一つの状態は、
もしあなたが複数の <STRONG>MySQL</STRONG> SERVER (クライアントではないです) を
同じデータに対して走らせている場合です。
Or run
<CODE>myisamchk</CODE> on the table without first flushing and locking the
<CODE>mysqld</CODE> server tables first.

たとえ <CODE>--skip-locking</CODE> を使用していても、
<CODE>LOCK TABLES</CODE> / <CODE>UNLOCK TABLES</CODE> の使用は可能です。
</UL>



<H3><A NAME="Compile_and_link_options" HREF="manual.ja_toc.html#Compile_and_link_options">12.2.1  MySQL の速度に影響するコンパイルとリンク方法</A></H3>

<P>
次のテストの多くは Linux 上で <STRONG>MySQL</STRONG> ベンチマークで行われました。
しかし、これらは他の OS についてもいくつかの指標を与えます。 

</P>
<P>
<CODE>-static</CODE> でのリンク時に最速の実行形式を得ます。
TCP/IP の代わりに Unix ソケットをデータベースへの
接続に使用することも、より良い性能を与えます。

</P>
<P>
Linux では、<CODE>pgcc</CODE> と <CODE>-O6</CODE> でコンパイルした時に最速のコードを得られます。
このオプションで <TT>`sql_yacc.cc'</TT> をコンパイルすると、<CODE>gcc/pgcc</CODE> は
全ての関数をインラインにするために多くのメモリを必要とするので、200M のメモリが必要です。
<CODE>libstdc++</CODE> ライブラリの増加を避けるためには、
<STRONG>MySQL</STRONG> の configure 時に <CODE>CXX=gcc</CODE> も設定すべきです。 

</P>
<P>
より良いコンパイラー、そしてコンパイラーのオプションは、10-30% の
速度の向上をもたらします。 これはあなた自身が MySQL をコンパイルする
時に重要なことです！

</P>
<P>
Intel では、例えば pgcc か Cygnus CodeFusion compiler で最速となります。
我々は 新しい Fujitsu コンパイラーでもテストしましたが、
<STRONG>MySQL</STRONG> を最適化オプションでコンパイルするには、
まだ完全なバグ・フリーではありませんでした。

</P>
<P>
Here is a list of some mesurements that we have done:

<UL>
<LI>

<CODE>pgcc</CODE> を使用して <CODE>-O6</CODE> で全てをコンパイルすると、
<CODE>gcc</CODE> 2.95.2 より古いバージョンでは、
<CODE>mysqld</CODE> サーバーは 11% 速くなります。 

<LI>

動的リンク(<CODE>-static</CODE>) 無し)の場合、結果は 13% 遅くなります。
Note that you still can use a dynamic linked MySQL library. It
is only the server that is critical for performance.

<LI>

(localhost への接続に) Unix ソケットの代わりに TCP/IP を使用すると、結果は 7.5% 遅くなります。 

<LI>

SPARCstation 10 では、<CODE>gcc</CODE> 2.7.3 は Sun Pro C++ 4.2 より 13% 速くなります。

<LI>

Solaris 2.5.1 では、mit-pthreads は Solaris ネイティブスレッドより 8-12% 遅くなります。
With more load/cpus the difference should
get bigger.
</UL>

<P>
TCX により配布されている <STRONG>MySQL</STRONG>-Linux 配布は <CODE>pgcc</CODE> でコンパイルされて
いますが、
but we had to go back to regular gcc because of a bug in pgcc that would
generate the code that does not run on AMD. We will continue using gcc until that bug is resolved.
In the meantime, if you have a non-AMD machine, you can get a faster binary by compiling with pgcc.
The Linux binary is linked statically.

</P>


<H3><A NAME="Disk_issues" HREF="manual.ja_toc.html#Disk_issues">12.2.2  Disk の問題</A></H3>


<UL>
<LI>

前に述べたディスクシークが大きなボトルネックです。 この問題は、データが効果的に
キャッシングが不可能になるほど、大きくなり始めるときに、だんだん明白になってきます。
For large databases,
where you access data more or less random, you can count on that you
will need at least one disk seek to read and a couple of disk seeks to
write things. この問題を少なくするには、diskシーク時間の少ないディスクを
使用します。
<LI>

利用できるディスクスピンドルの数を増やします(それによってディスクシーク
のオーバーヘッドは縮小します)。
これは違うディスクにシンボリックリンクをはったり、ストライプを行うことで
可能です。
<DL COMPACT>

<DT><STRONG>symbolic link の使用</STRONG>
<DD>
これは通常のデータディレクトリから、違うディスクへ、
インデックスやデータファイルをシンボリック・リンクすることです。
これは シーク と リード を速くします。 (もしそのディスクが
他に使用されていなければ).  「<A HREF="manual.ja_Performance.html#Symbolic_links">12.2.2.1  データベースとテーブルにシンボリックリンクを使用する</A>」節参照.
<DT><STRONG>Striping</STRONG>
<DD>
ストライピングは、複数のディスクに対して、まずデータの最初のブロックを
1番目の disk に書き、2番目のブロックを2つ目のdiskに書き、順次 N 番目
(N は disk の数) まで順に書いていきます。 これは、もしデータがストライプの
サイズよりも小さければ、よりよいパフォーマンスを得ることが出来ます。
ストライピングは、OS や ストライプのサイズにとても依存していることに注意してください。
そのため、あなたのアプリケーションのベンチマークがストライプサイズによって
変わるでしょう。  「<A HREF="manual.ja_Performance.html#Benchmarks">12.7  Using your own benchmarks</A>」節参照.

ストライピングのスピードの違いは、<STRONG>とても</STRONG> パラメターに依存しています。
Depending on how you set the striping parameters and
number of disks you may get difference in orders of magnitude. Note that
you have to choose to optimize for random or sequential access.
</DL>
<LI>

信頼性のため、あなたは RAID 0+1 (striping + mirroring) を使用したいと
思うかもしれません。 しかしこれは N 個のドライブのデータを収めるのに
2*N 個のドライブが必要となります。
これはもし資金があるならば一番よい方法でしょう！ しかし、能率的にそれを
取り扱うために、ボリューム・マネージメント・ソフトウェアに投資する必要が
あってもよいです。
<LI>

A good option is to have semi-important data (that can be re-generated)
on RAID 0 disk while store really important data (like host information
and logs) on a RAID 0+1 or RAID N disks. RAID N can be a problem if you
have many writes because of the time to update the parity bits.
<LI>

データベースに使用しているファイルシステムの mount パラメターを変更しても
良いでしょう。 一つの簡単な方法としては、noatime オプションでファイルシステムを
マウントします。 これは inode にある最後にアクセスした時間の更新を
スキップします。 これでいくらか ディスクシークを避けることができるでしょう。
</UL>



<H4><A NAME="Symbolic_links" HREF="manual.ja_toc.html#Symbolic_links">12.2.2.1  データベースとテーブルにシンボリックリンクを使用する</A></H4>

<P>
テーブルとデータベースのファイルを MySQL のデータベースディレクトリーから
違う場所に移動し、 それに対してシンボリックリンクを張ることができます。
これは例えばディスク容量が少なくなって、データベースを移動したい場合にそうしたくなるでしょう。 

</P>
<P>
<STRONG>MySQL</STRONG> が、テーブルがシンボリックリンクであることに気づいた場合、
symlink を解析し、代わりにその実体のテーブルを使用します。
これは <CODE>realpath()</CODE> コールをサポートする全てのシステムで働きます（少
なくとも Linux と Solaris は <CODE>realpath()</CODE> をサポートします！）。
<CODE>realpath()</CODE> をサポー トしないシステム上では、symlink とテーブルを
同時に使用すべきでありません！ テーブルはテーブルの更新後に矛盾する事になるでしょう。 

</P>
<P>
<STRONG>MySQL</STRONG> はデフォルトではデータベース同士のリンクをサポートしません。
が、データベース間のシンボリックリンクを作成しない限り、これは正常に働くでしょう。
<STRONG>MySQL</STRONG> データディレクトリに <CODE>db1</CODE> データベースがあるとして、
仮に <CODE>db2</CODE> を <CODE>db1</CODE> のシンボリックリンクにしたとします: 

</P>

<PRE>
shell&#62; cd /path/to/datadir
shell&#62; ln -s db1 db2
</PRE>

<P>
すると、<CODE>db1</CODE> 中の <CODE>tbl_a</CODE> テーブルは <CODE>db2</CODE> の  <CODE>tbl_a</CODE> テーブルとして見えます。
もしあるスレッドが <CODE>db1.tbl_a</CODE> を更新し、他のスレッドが <CODE>db2.tbl_a</CODE> を
更新した場合、 問題が発生します。 

</P>
<P>
こういった使用をどうしてもしたい場合、<TT>`mysys/mf_format.c'</TT> を以下のように変更します: 

</P>

<PRE>
if (!lstat(to,&#38;stat_buff))  /* Check if it's a symbolic link */
    if (S_ISLNK(stat_buff.st_mode) &#38;& realpath(to,buff))
</PRE>

<P>
Change the code to this:

</P>

<PRE>
if (realpath(to,buff))
</PRE>

<P>
<A NAME="IDX622"></A>


<H3><A NAME="Server_parameters" HREF="manual.ja_toc.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</A></H3>

<P>
<CODE>mysqld</CODE> サーバーが使用している現在のバッファサイズを次で得ることができます:

</P>

<PRE>
shell&#62; mysqld --help
</PRE>

<P>
この結果、全ての <CODE>mysqld</CODE> オプションと次のようなコンフィグ可能変数のリスト
を得られます。出力結果にはデフォルト値が含まれ、以下のように表示されます:

</P>

<PRE>
Possible variables for option --set-variable (-O) are:
back_log              current value: 5
connect_timeout       current value: 5
delayed_insert_timeout  current value: 300
delayed_insert_limit  current value: 100
delayed_queue_size    current value: 1000
flush_time            current value: 0
interactive_timeout   current value: 28800
join_buffer_size      current value: 131072
key_buffer_size       current value: 1048540
lower_case_table_names  current value: 0
long_query_time       current value: 10
max_allowed_packet    current value: 1048576
max_connections       current value: 100
max_connect_errors    current value: 10
max_delayed_threads   current value: 20
max_heap_table_size   current value: 16777216
max_join_size         current value: 4294967295
max_sort_length       current value: 1024
max_tmp_tables        current value: 32
max_write_lock_count  current value: 4294967295
net_buffer_length     current value: 16384
query_buffer_size     current value: 0
record_buffer         current value: 131072
sort_buffer           current value: 2097116
table_cache           current value: 64
thread_concurrency    current value: 10
tmp_table_size        current value: 1048576
thread_stack          current value: 131072
wait_timeout          current value: 28800
</PRE>

<P>
もし <CODE>mysqld</CODE> サーバーを走らせているなら、以下のコマンドでも変数の値を見ることができます:

</P>

<PRE>
shell&#62; mysqladmin variables
</PRE>

<P>
これらのオプションは以下のように決めてください。
buffer size, buffer length, stack size は byte 単位で与えます。
これらの値の後ろに <SAMP>`K'</SAMP> や <SAMP>`M'</SAMP> を追加すると、キロバイト、メガバイトになります。
例えば、<CODE>16M</CODE> は16メガバイトを示します。大文字小文字の区別はなく、
<CODE>16M</CODE> と <CODE>16m</CODE> は同じ意味になります。

</P>
<P>
稼働中のサーバーの統計情報は <CODE>SHOW STATUS</CODE> で参照できます.  「<A HREF="manual.ja_Reference.html#SHOW">7.23  <CODE>SHOW</CODE> 構文 (テーブルやフィールドなどについての情報を得る)</A>」節参照. 

</P>
<DL COMPACT>

<DT><CODE><CODE>ansi_mode</CODE>.</CODE>
<DD>
もし <CODE>mysqld</CODE> が <CODE>--ansi</CODE> オプションで起動されているなら、<CODE>ON</CODE>.
 「<A HREF="manual.ja_Compatibility.html#Ansi_mode">5.2  ANSI モードでの MySQL の実行</A>」節参照.

<DT><CODE><CODE>back_log</CODE></CODE>
<DD>
<STRONG>MySQL</STRONG> が持てる未解決の接続要求の数です。これは <STRONG>MySQL</STRONG> 
スレッドが<STRONG>ものすごく</STRONG>多くの接続要求をとても短い時間に得た時に、働き
ます。接続のチェックと新しいスレッドの開始はメインスレッドにすこし時間
(しかしほんのわずか)がかかります。back_log は、<STRONG>MySQL</STRONG> が瞬間的に新
しい要求への回答を停止する前に、この短い時間の間にスタックできる接続数です。
短い期間に多くの接続を期待する場合にだけ、これを増加する必要があります。

いいかえるなら、これは TCP/IP 接続の入力 listen キューのサイズです。
オペレーティングシステムはこのキューの大きさを制限しています。
UNIX システムコール <CODE>listen(2)</CODE> のマニュアルページに、さらに詳細があります。
この値を最大限にしたい場合、お使いのOSのドキュメントを見てください。
<CODE>back_log</CODE> をこのOSの制限値より多く取ってもは全く効果ありません。

<DT><CODE><CODE>thread_cache_size</CODE></CODE>
<DD>
How many threads we should keep keep in a cache for reuse.  When a
client disconnects the clients threads is put in the cache if there
isn't more than <CODE>thread_cache_size</CODE> threads from before.  All new
threads are first taken from the cache and only when the cache is empty
a new thread is created.  This variable can be increased to improve
performance if you have a lot of new connections (Normally this doesn't
however give a notable performance improvement if you have a good
thread implementation).

<DT><CODE><CODE>concurrent_inserts</CODE></CODE>
<DD>
もし <CODE>ON</CODE> (これはデフォルトです) なら、<CODE>MySQL</CODE> は、
<CODE>SELECT</CODE> クエリが実行されている <CODE>MyISAM</CODE> テーブルに対して、
同時に <CODE>INSERT</CODE> が使用できるようにします。
このオプションは <CODE>mysqld</CODE> のオプションに <CODE>--safe</CODE> か <CODE>--skip-new</CODE> を
指定することで  <CODE>OFF</CODE> にできます。

<DT><CODE><CODE>connect_timeout</CODE></CODE>
<DD>
<CODE>mysqld</CODE> サーバーが接続パケットを待つ秒数。 (<CODE>Bad handshake</CODE> を返すまでの秒数)

<DT><CODE><CODE>delayed_insert_timeout</CODE></CODE>
<DD>
どれぐらい <CODE>INSERT DELAYED</CODE> スレッドが <CODE>INSERT</CODE> 文を待つべきか。

<DT><CODE><CODE>delayed_insert_limit</CODE></CODE>
<DD>
<CODE>delayed_insert_limit</CODE> 個のレコードを挿入した後、 <CODE>INSERT DELAYED</CODE> ハンドラーは
待たされている <CODE>SELECT</CODE> 文がないかチェックします。 もしあるなら、
挿入を続ける前にそれらの実行を許します。

<DT><CODE><CODE>delay_key_write</CODE></CODE>
<DD>
もし enabled であれば(これがデフォルト)、<STRONG>MySQL</STRONG> は <CODE>CREATE TABLE</CODE> 文の
<CODE>DELAY_KEY_WRITE</CODE> オプションを尊重します。
<CODE>DELAY_KEY_WRITE</CODE>オプションを指定されて作られたテーブルのキーバッファは、
毎回のインデックスの更新にはフラッシュされず、ただテーブルが閉じられたときにだけ
フラッシュされます。 これはキーの書き出しを速くしますが、もしこれを使用するなら、
全てのテーブルを <CODE>myisamchk --fast --force</CODE> で自動的に検査するようにすべきです。
もし <CODE>mysqld</CODE> を <CODE>--delay-key-write_for_all_tables</CODE> オプション付きで
起動した場合、これは、全てのテーブルが <CODE>delay_key_write</CODE> オプション指定されて
作成されたものとして扱われる事に注意してください。
このフラグは、<CODE>mysqld</CODE> を <CODE>--skip-new</CODE> や <CODE>--safe-mode</CODE> オプション
で起動すれば無効にすることも出来ます。

<DT><CODE><CODE>delayed_queue_size</CODE></CODE>
<DD>
How big a queue (in rows) should be allocated for handling <CODE>INSERT
DELAYED</CODE>.  If the queue becomes full, any client that does <CODE>INSERT
DELAYED</CODE> will wait until there is room in the queue again.

<DT><CODE><CODE>flush_time</CODE></CODE>
<DD>
これがもし、非ゼロにセットされたなら、毎 <CODE>flush_time</CODE> 秒ごとに
全てのテーブルが閉じられます。 (リソースの解放とDiskへのsyncのために)

<DT><CODE><CODE>init_file</CODE></CODE>
<DD>
サーバー起動時に、<CODE>--init-file</CODE> オプションに与えたファイルの名前です。
このファイルには、サーバー起動時に実行したい SQL 文を書いておきます。

<DT><CODE><CODE>interactive_timeout</CODE></CODE>
<DD>
The number of seconds the server waits for activity on a interactive 
connection before closing it.  インタラクティブ クライアントを作るには、
C API <CODE>mysql_real_connect()</CODE> に <CODE>CLIENT_INTERACTIVE</CODE> オプションを
セットします。  See also <CODE>wait_timeout</CODE>.

<DT><CODE><CODE>join_buffer_size</CODE></CODE>
<DD>
このバッファは(インデックス無しの)完全な結合に使用されます。それは2つの
テーブル間の完全な結合ごとに1回割り当てられます。インデックスの追加がで
きない時、より速い完全な結合を得るために、これを増加してください。通常、
速い結合を得る一番良い方法は、インデックスを追加することです。

<DT><CODE><CODE>key_buffer_size</CODE></CODE>
<DD>
インデックス・ブロックはバッファされ、そして全てのスレッドに共有されます。
<CODE>key_buffer_size</CODE> はインデックス・ブロックのためのバッファ・サイズです。

Increase this get better index handling (for all reads and multiple
writes) to as much as you can afford; 64M on a 256M machine that mainly
runs <STRONG>MySQL</STRONG> is quite common.  If you however make this too big
(more than 50 % of your total memory?) your system may start to page
and become REAL slow. Remember that because <STRONG>MySQL</STRONG> does not cache data
read that you will have to leave some room for the OS filesystem cache.

You can check the performance of the key buffer by doing <CODE>show
status</CODE> and examine the variables <CODE>Key_read_requests</CODE>,
<CODE>Key_reads</CODE>, <CODE>Key_write_requests</CODE> and <CODE>Key_writes</CODE>.  The
<CODE>Key_reads/Key_read_request</CODE> ratio should normally be &#60; 0.01.
The <CODE>Key_write/Key_write_requests</CODE> is usually near 1 if you are
using mostly updates/deletes but may be much smaller if you tend to
do updates that affect a lot of rows at the same time or if you are
using <CODE>delay_key_write</CODE>.  「<A HREF="manual.ja_Reference.html#SHOW">7.23  <CODE>SHOW</CODE> 構文 (テーブルやフィールドなどについての情報を得る)</A>」節参照.

To get even more speed when writing many rows at the same time use
<CODE>LOCK TABLES</CODE>.   「<A HREF="manual.ja_Reference.html#LOCK_TABLES">7.27  <CODE>LOCK TABLES/UNLOCK TABLES</CODE> 構文</A>」節参照.

<DT><CODE><CODE>lower_case_table_names</CODE></CODE>
<DD>
Change all table names to lower case on disk.

<DT><CODE><CODE>long_query_time</CODE></CODE>
<DD>
もしあるクエリがこの値(秒)より時間がかかれば、<CODE>Slow_queries</CODE> カウンター
が増やされます。

<DT><CODE><CODE>max_allowed_packet</CODE></CODE>
<DD>
一つのパケットの最大サイズ。メッセージバッファは <CODE>net_buffer_length</CODE> バイトに初期化されますが、
<CODE>max_allowed_packet</CODE>まで大きくすることができます。このデフォルト値は、
大きなパケット、間違ったパケットをを受けるには小さい値です。
大きな <CODE>BLOB</CODE> を使用している場合は、これを増加する必要があります。使用した
い最大の <CODE>BLOB</CODE> と同じくらい大きくするべきです。

<DT><CODE><CODE>max_connections</CODE></CODE>
<DD>
許される同時クライアントの数。これを増加する場合は、<CODE>mysqld</CODE> が持つファイ
ルディスクリプタの数を増やす必要があるでしょう。
後述のファイルデスクリプターの制限の説明を参照のこと。  「<A HREF="manual.ja_Problems.html#Too_many_connections">20.2.4  <CODE>Too many connections</CODE> エラー</A>」節参照.

<DT><CODE><CODE>max_connect_errors</CODE></CODE>
<DD>
もしあるホストからの接続中断がこの値を以上になった場合、これ以後、
そのホストからの接続を拒絶します。<CODE>FLUSH HOSTS</CODE> コマンドで
ホストの拒否を解除できます。

<DT><CODE><CODE>max_delayed_threads</CODE></CODE>
<DD>
この値を超えて <CODE>INSERT DELAYED</CODE> を扱うスレッドを起動できません。
もし全ての <CODE>INSERT DELAYED</CODE> スレッドが使用されていて、さらに新しいテーブルに
データを挿入しようとすると、そのレコードは <CODE>DELAYED</CODE> が与えられていない
場合と同様に挿入されます。

<DT><CODE><CODE>max_join_size</CODE></CODE>
<DD>
<CODE>max_join_size</CODE> より多いレコードを触るとエラーが返ります。長い時間をかけて
百万行を返すような <CODE>WHERE</CODE> なしの結合を作成するようなユーザを持って
いる場合にこれを設定してください。

<DT><CODE><CODE>max_heap_table_size</CODE></CODE>
<DD>
Don't allow creation of heap tables bigger than this.

<DT><CODE><CODE>max_sort_length</CODE></CODE>
<DD>
<CODE>BLOB</CODE> または <CODE>TEXT</CODE> 項目上でソートする時に使用するバイト数。
(最初の <CODE>max_sort_length</CODE> バイトだけがそれぞれの値で使用でき、残りは無視されます)

<DT><CODE><CODE>max_tmp_tables</CODE></CODE>
<DD>
(このオプションはまだなにも行いません).
クライアントが同時にオープンできるテーブル数の最大値。

<DT><CODE><CODE>max_write_lock_count</CODE></CODE>
<DD>
After this many write locks, allow some read locks to run in between.

<DT><CODE><CODE>net_buffer_length</CODE></CODE>
<DD>
通信バッファがクエリ間でこのサイズにリセットされます。これは通常は変更す
べきではありませんが、とても小さなメモリしかない場合は、これを期待される
クエリのサイズに設定してください。
( これは、クライアントから送られてくるSQL文の長さ分あればいいでしょう。
もし構文がこの値をこえた場合、バッファは自動的に大きくなります。
ただし <CODE>max_allowed_packet</CODE> バイトまでです)

<DT><CODE><CODE>net_retry_count</CODE></CODE>
<DD>
If a read on a communication port is interrupted, retry this many times
before giving up.  This value should be quite high on <CODE>FreeBSD</CODE> as
internal interrupts is sent to all threads.

<DT><CODE><CODE>record_buffer</CODE></CODE>
<DD>
順序スキャンを行う各スレッドが、スキャンするテーブル毎に、このサイズのバッ
ファを割り当てます。多くの順序スキャンを行う場合は、これを増加させてくだ
さい。

<DT><CODE><CODE>query_buffer_size</CODE></CODE>
<DD>
The initial allocation of the query buffer. If most of your queries are
long (like when inserting blobs), you should increase this!

<DT><CODE><CODE>skip_show_databases</CODE></CODE>
<DD>
これは、 <CODE>PROCESS_PRIV</CODE> 権限を持っていないユーザーが
 <CODE>SHOW DATABASES</CODE> する事を阻止します。 もし、他人のデータベースや
テーブルを見ようとする人がいる事を、あなたが心配するならば、
これはセキュリティを強化できます。

<DT><CODE><CODE>sort_buffer</CODE></CODE>
<DD>
ソートを行う必要がある各スレッドがこのサイズのバッファを割り当てます。よ
り速い <CODE>ORDER BY</CODE> または <CODE>GROUP BY</CODE> のためにはこれを増やしてく
ださい。
 「<A HREF="manual.ja_Problems.html#Temporary_files">20.5  <STRONG>MySQL</STRONG> が一時ファイルを格納する場所</A>」節参照.

<DT><CODE><CODE>table_cache</CODE></CODE>
<DD>
全てのスレッドについてのオープンテーブルの数。これを増加する場合は、
<CODE>mysqld</CODE>が要求するオープンファイルディスクリプタの数も
増加することに注意しないといけません。
<STRONG>MySQL</STRONG> はユニークテーブル毎に2つのファイルディスクリプタを必要と
します。
後述のファイルデスクリプターの制限の説明を参照のこと。
You can check if you
need to increase the table cache by checking the <CODE>Opened_tables</CODE>
variable.  「<A HREF="manual.ja_Reference.html#SHOW">7.23  <CODE>SHOW</CODE> 構文 (テーブルやフィールドなどについての情報を得る)</A>」節参照.  If this variable is big and you don't do
<CODE>FLUSH TABLES</CODE> a lot (which just forces all tables to be closed and
reopenend), then you should increase the value of this variable.

テーブルキャッシュがどのように働くかはこちらを参照  「<A HREF="manual.ja_Performance.html#Table_cache">12.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A>」節.

<DT><CODE><CODE>tmp_table_size</CODE></CODE>
<DD>
メモリー内の 一時テーブルがこの値を超えようとした場合、<STRONG>MySQL</STRONG> は
自動的に、これを、disk ベースの <CODE>MyISAM</CODE> テーブルに変換します。
多くの先進的な <CODE>GROUP BY</CODE> クエリを行う場合は、
この <CODE>tmp_table_size</CODE> を増加してください。

<DT><CODE><CODE>thread_stack</CODE></CODE>
<DD>
各スレッドのスタックの大きさ。<CODE>crash-me</CODE> によって検出される多く
の制限がこれに依存します。デフォルトでは、通常のオペレーションに対して
十分とってあります。
 「<A HREF="manual.ja_Performance.html#Benchmarks">12.7  Using your own benchmarks</A>」節参照.

<DT><CODE><CODE>wait_timeout</CODE></CODE>
<DD>
サーバーがコネクションを閉じるまでにアクティブなコネクションを待つ秒数。
<CODE>interactive_timeout</CODE> も参照のこと。
</DL>

<P>
<STRONG>MySQL</STRONG> はとてもスケーラブルなアルゴリズムを使用します。そのため
通常はとても少ないメモリで動作し、またより良い性能を得るために 
<STRONG>MySQL</STRONG> に多くのメモリを与えることができます。

</P>
<P>
When tuning a <STRONG>MySQL</STRONG> server, the two most important variables to use
are <CODE>key_buffer_size</CODE> and <CODE>table_cache</CODE>.  You should first feel
confident that you have got these right before trying to change any of the
other variables.

</P>
<P>
多くのメモリ(&#62;=256M)と多くのテーブルを持っていて、適度のクライアント数で最大性能を得た
い場合、次のようなものを使用します:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=64M -O table_cache=256 \
           -O sort_buffer=4M -O record_buffer=1M &#38;
</PRE>

<P>
If you have only 128M and only a few tables, but you still do a lot of
sorting, you can use something like:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=16M -O sort_buffer=1M
</PRE>

<P>
多くの接続で少ないメモリしかない場合、次のようなものを使用します:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=100k \
           -O record_buffer=100k &#38;
</PRE>

<P>
or even:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=16k \
           -O table_cache=32 -O record_buffer=8k -O net_buffer=1K &#38;
</PRE>

<P>
もしとても多くの接続があり、<CODE>mysqld</CODE> が各接続に対して少ないメモリーで
動作するように設定されていれば、スワップの読み書きによるパフォーマンスの低下がおきます。
もちろん十分なメモリーがあれば、全ての接続にたいして <CODE>mysqld</CODE> のパフォーマンス良くなります。

</P>
<P>
<CODE>mysqld</CODE> へのオプションを変更する場合、そのサーバのインスタンスにだけに
有効であることに注意して下さい。

</P>
<P>
パラメータ変更の効果を見るには、このようにします:

</P>

<PRE>
shell&#62; mysqld -O key_buffer=32m --help
</PRE>

<P>
<CODE>--help</CODE> オプションは最後につけてください。
その他のオプションを --help の後につけると、そのオプションは反映されません。

</P>
<P>
<A NAME="IDX623"></A>
<A NAME="IDX624"></A>


<H3><A NAME="Table_cache" HREF="manual.ja_toc.html#Table_cache">12.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A></H3>

<P>
<CODE>table_cache</CODE> , <CODE>max_connections</CODE> , <CODE>max_tmp_tables</CODE> は
サーバーが開いた状態にしておく事が出来るファイルの最大数に影響します。
もしこれらの変数のうちの一つ、あるいは複数を増加させるなら、
あなたのオペレーティング・システムの、1 プロセスあたりに開かれる
 ファイル・デスクリプタ の最大値を増やすことになるかもしれません。
多くのシステムではこの制限を増やすことが可能です。
これをどうやって行うかは、あなたの使用している OS のドキュメントを見てください。
制限値の変更方法は、システムによってまちまちだからです。

</P>
<P>
<CODE>table_cache</CODE> は <CODE>max_connections</CODE> に関連します。
例えば 200 のコネクションを同時に開けるなら、少なくとも <CODE>200 * n</CODE> の
テーブル・キャッシュが必要です。 ここで <CODE>n</CODE> は join におけるテーブルの
最大数です。

</P>
<P>
オープンテーブルのキャッシュは最大で <CODE>table_cache</CODE> まで大きくなります(デ
フォルトは 64, <CODE>mysqld</CODE> のオプション <CODE>-O table_cache=#</CODE> で変更可能)。
キャッシュが一杯になって、他のスレッドがテーブルのオープンを試みた時、
または <CODE>mysqladmin refresh</CODE> <CODE>mysqladmin flush-tables</CODE>
を使用した場合を除いて、テーブルはクローズされません。

</P>
<P>
キャッシュがいっぱいになった場合、サーバーは以下の処置を取って
キャッシュを使用できるように配置します：

</P>

<UL>
<LI>

現在使われていないテーブルが解放されます。もっとも使用されていないテーブルからから順に。

<LI>

もしキャッシュが一杯でテーブルを解放することが出来ず、さらに新しいテーブルの
オープン要求がある場合、キャッシュは一時的な拡張を必要とします。

<LI>

もしそのキャッシュが一時拡張に配置されていて、かつ、テーブルが使用状態から
未使用状態に移行した場合、そのテーブルは閉じられ、キャッシュから解放されます。
</UL>

<P>
テーブルは各同時アクセスに (再び) オープンされます。これは、同じテーブルで2つのスレッ
ドが実行されている場合、または同じクエリで(<CODE>AS</CODE> で)テーブルを2回アクセス
する場合、テーブルは2回オープンする必要があることを意味します。最初のテーブルのオー
プンは2つのファイル記述子を使用し、続くテーブルの各使用は1つだけのファイル記述
子を使用します。

</P>



<H3><A NAME="Creating_many_tables" HREF="manual.ja_toc.html#Creating_many_tables">12.2.5  Drawbacks of creating large numbers of tables in the same database</A></H3>

<P>
もしたくさんのファイルが一つのディレクトリにある場合、オープン、クローズ、
作成操作は遅くなるでしょう、 もし <CODE>SELECT</CODE> 文を多くのテーブルに対し
実行した場合、テーブルキャッシュが一杯ならば、このオーバーヘッドは多くなるでしょう。
なぜなら、それぞれのテーブルにつきオープンし、クローズしなくてはならないからです。
このオーバーヘッドを緩和するには、テーブルキャッシュを大きくします。

</P>


<H3><A NAME="Open_tables" HREF="manual.ja_toc.html#Open_tables">12.2.6  何故そんなに多くのテーブルをオープンするのか？</A></H3>

<P>
<CODE>mysqladmin status</CODE> を実行すると、次のようなものが得られます:

</P>

<PRE>
Uptime: 426 Running threads: 1 Questions: 11082 Reloads: 1 Open tables: 12
</PRE>

<P>
確かにたった6個しかテーブルがないのに、このような結果が出るので少々戸惑われるかもしれません。

</P>
<P>
<STRONG>MySQL</STRONG> はマルチスレッドなので、同じテーブルで一度に多くのクエリを持て
ます。同じファイル上で異なる状態を持つ2つのスレッドで、問題を最小化する
ため、同時に動作する各スレッドのためテーブルを再びオープンします。これはいくつ
かのメモリとデータファイルについての一つの拡張ファイル記述子を使用します。
インデックスファイル記述子は全てのスレッド間で共有されます。

</P>

<P>
<A NAME="IDX625"></A>


<H3><A NAME="Memory_use" HREF="manual.ja_toc.html#Memory_use">12.2.7  MySQL はどのようにメモリを使用するのか？</A></H3>

<P>
以下に <CODE>mysqld</CODE> サーバーがどのようにメモリーを使用するか、いくつか示します。
サーバーに与える変数名は、サーバーのメモリーの使用方に関連した名前となっています。

</P>

<UL>
<LI>

キーバッファ (変数 <CODE>key_buffer</CODE>) は全てのスレッドで共有され、
残りは必要時に割り当てられます。
 「<A HREF="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</A>」節参照.

<LI>

各接続はいくつかのスレッド空間を使用します；
スタック (64K, 変数 <CODE>thread_stack</CODE>), 接続バッファ(variable
<CODE>net_buffer_length</CODE>), 結果バッファ(variable
<CODE>net_buffer_length</CODE>)。接続バッファと結果バッファは必要となった時、
動的に最大 <CODE>max_allowed_packet</CODE> まで増えます。
クエリが走っている時、そのクエリの文字のコピーが割り当てられます。

<LI>

全てのスレッドは同じベースメモリを共有します。

<LI>

まだ memory-mapped を使用していません (圧縮テーブルは除きますが、これは別の話)。
これは 4GB の 32bit メモリ空間は多くの大きなテーブルを扱うには小さいためです。
64bit アドレス空間を持つシステムを我々が手に入れた時、我々は mmemory-mapping を通常にサポートします。

<LI>

テーブルを越えて順次スキャンを行なう各要求は、読み込みバッファを割り当てます
(変数 record_buffer)

<LI>

全ての結合は1パスで行なわれ、多くの結合は一時テーブルを使用せずに行なわ
れます。多くの一時テーブルはメモリベース(HEAP)のテーブルです。大きなレコー
ドサイズ (= 全フィールド長の合計) を持つ一時テーブルまたは、<CODE>BLOB</CODE> を含む
テーブルはディスク上に置かれます。

<STRONG>MySQL</STRONG> 3.23.2 以前での問題は、HEAP テーブルが 
<CODE>tmp_table_size</CODE> のサイズを越えると、エラー <CODE>The table tbl_name is full</CODE>
が出ることです。将来我々は、必要時にメモリ (HEAP) テーブルをディスクベー
ス (NISAM) テーブルに自動的に変更することにより、これを修正します。この
問題を回避するため、<CODE>mysqld</CODE> への <CODE>tmp_table_size</CODE> オプションま
たはクライアント側で SQL オプション <CODE>SQL_BIG_TABLES</CODE> で増加できます。
 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.28  <CODE>SET OPTION</CODE> 構文</A>」節参照.
<STRONG>MySQL</STRONG> 3.20 では、一時テーブルの最大サイズは 
<CODE>recordbuffer*16</CODE> でした。そのため、このバージョンを使用していると、
<CODE>recordbuffer</CODE> を追加する必要があります。 <CODE>mysqld</CODE> を <CODE>--big-tables</CODE> で
開始することで、常に一時テーブルをディスク上に格納できます。しかしこれは
多くの複雑なクエリの速度に影響します。

<LI>

ほとんどのリクエストは、1,2個の一時ファイルとわずかなソートバッファへの割り当てを行います。
 「<A HREF="manual.ja_Problems.html#Temporary_files">20.5  <STRONG>MySQL</STRONG> が一時ファイルを格納する場所</A>」節参照.

<LI>

変形と演算時に使用されるほとんど全てのメモリはローカルメモリストア内で行
なわれます。小さな項目に必要とされるメモリオーバーヘッドはなく、通常の遅
いメモリ割り当て/解放が回避されます。メモリは予期しない大きな文字列にだ
け割り当てられます(これは <CODE>malloc()</CODE> と <CODE>free()</CODE> で行なわれます)。

<LI>

各インデックスファイルは一度オープンされ、データファイルは各同時実行スレッ
ド毎に一度オープンされます。各同時スレッドには、テーブル構造、各フィールドの構造そし
て <CODE>3 * n</CODE> のサイズのバッファが割り当てられます。
( <CODE>n</CODE> は <CODE>BLOB</CODE> 型のフィールドの長さを含めない、一レコードの最大長です )
<CODE>BLOB</CODE> は 5 から 8 バイト + <CODE>BLOB</CODE> データの長さを使用します。

<LI>

<CODE>BLOB</CODE> を持つ各テーブルでは、より大きな <CODE>BLOB</CODE> の読み込みでバッファ
は動的に拡大されます。テーブルのスキャンをする場合、割り当てられたバッファは最
も大きい <CODE>BLOB</CODE> と同じ大きさになります。

<LI>

全ての使用されているテーブルのテーブルハンドラーはキャッシュ内に保存され、
FIFO として管理されます。
通常、キャッシュは 64 個のテーブルです。テーブルが 2 つの実行しているス
レッドで同時に使用される場合、キャッシュ内にテーブルの 2 つのエントリが
あります。
 「<A HREF="manual.ja_Performance.html#Table_cache">12.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A>」節参照.

<LI>

<CODE>mysqladmin refresh</CODE> は使用されていない全てのテーブルをクローズし、
使用されている全てのテーブルを、実行中スレッドが終った時にクローズするよ
うにマークします。これは多くの使用メモリを解放するのに有効です。全てのロ
グファイルもクローズと再オープンされます。
</UL>

<P>
<STRONG>mysqld</STRONG> 実行時、<CODE>ps</CODE> や他のプログラムは、それが多くのメモリ
を使用していると報告するでしょう。これは異なったメモリアドレス上のスレッ
ドスタックによって発生します。例えば、Solaris ps はスタック間の未使用メ
モリを使用メモリとして計算します。'swap -s' で有効なスワップをチェックす
ることでこれを確かめられます。我々は市販のメモリリーク検出プログラムで 
<CODE>mysqld</CODE> をテストしました。そのため、メモリリークは全くありません。

</P>


<H3><A NAME="Internal_locking" HREF="manual.ja_toc.html#Internal_locking">12.2.8  <STRONG>MySQL</STRONG> はどのようにテーブルをロックするか</A></H3>

<P>
<STRONG>MySQL</STRONG> の全てのロックはデッドロックフリーです。これは、常にクエ
リ開始時に一度ロックを必要とする全てを要求し、常に同じ順でテーブルをロッ
クすることで管理されます。

</P>
<P>
<STRONG>MySQL</STRONG> が使用する <CODE>WRITE</CODE> ロックは次のように働きます:

</P>

<UL>
<LI>

テーブル上にロックがない場合 write ロックを置きます。
<LI>

そうでなければ write ロックキューにロックを置きます。
</UL>

<P>
<STRONG>MySQL</STRONG> の <CODE>READ</CODE> ロックは次のように動きます:

</P>

<UL>
<LI>

テーブル上に write ロックがない場合 read ロックを置きます。
<LI>

そうでなければ read ロックキューにロックを置きます。
</UL>

<P>
ロックが解放されたとき、最初に write ロックキュー内のスレッドに、その後 
read ロックキュー内のスレッドにロックを与えます。

</P>
<P>
これは、同じテーブルで多くの更新をする場合、<CODE>SELECT</CODE> 構文は 
update がなくなるまで待たされることを意味します。

</P>
<P>
同じテーブルで多くの <CODE>INSERT</CODE> と多くの <CODE>SELECT</CODE> を行う場合、これを解決するに
は、他のテーブルに行を挿入して、たまに、その一時テーブルから全てのレコー
ドをもう一方のテーブルに update します。

</P>
<P>
これは次のコードで行えます:

<PRE>
mysql&#62; LOCK TABLES real_table WRITE, insert_table WRITE;
mysql&#62; insert into real_table select * from insert_table;
mysql&#62; delete from insert_table;
mysql&#62; UNLOCK TABLES;
</PRE>

<P>
決まりきった検索に優先権を与えるため、<CODE>INSERT</CODE> 構文で <CODE>LOW_PRIORITY</CODE> か <CODE>HIGH_PRIORITY</CODE> オプションが使用できます。
 「<A HREF="manual.ja_Reference.html#INSERT">7.16  <CODE>INSERT</CODE>構文</A>」節参照.

</P>
<P>
一つのキューだけを使用するように <TT>`mysys/thr_lock.c'</TT> 内のロックコードを変更
することもできます。この場合、いくつかのアプリケーションのために、
write ロックは read ロックと同じ優先順位にします。

</P>


<H3><A NAME="Table_locking" HREF="manual.ja_toc.html#Table_locking">12.2.9  テーブル・ロッキングの問題</A></H3>

<P>
<STRONG>MySQL</STRONG> のテーブル・ロッキングのコードはデッドロック・フリーです。

</P>
<P>
<STRONG>MySQL</STRONG> はとても速いロックスピードを得るために、
(レコードのロックやフィールドのロックの代わりに) テーブルのロックを使用します。
大きなテーブルには、 テーブルのロックはレコードのロックよりはるかに良いですが、
いくつかの落とし穴があります。

</P>
<P>
<STRONG>MySQL</STRONG> 3.23.7 以上では、あるスレッドが <CODE>MyISAM</CODE> テーブルを読んでいる最中に、
同じテーブルにレコードを挿入する事ができます。
これは現在、削除がない場合にのみ動きます。

</P>
<P>
テーブルのロックはたくさんのスレッドが同時にあるテーブルから読み出すのを可能にしますが、
もしあるスレッドがあるテーブルに対し書込み要求を出す場合、
それはまず最初に排他的なアクセスを得なければなりません.
その更新の間、更新が完了するまで、この特定のテーブルにアクセスしようとする
他の全てのスレッドが待たされることになります。

</P>
<P>
通常データベースの更新は <CODE>SELECT</CODE> よりも重要とされるため、
テーブルを更新する全てのスレッドが、テーブルから情報を検索するスレッドよりも
高い優先順位を持ちます。 これは ある特定のテーブルに対して、多くの重いクエリが発行され
た場合に、 更新が不完全に終わらないことを確実にするためです。

</P>
<P>
<STRONG>MySQL 3.23.7</STRONG> から、<CODE>max_write_lock_count</CODE> 変数が使用できます。
これは、一つのテーブルに対して、指定された回数だけ INSERT が行われた後に、
<CODE>SELECT</CODE> を発行するようにします。

</P>
<P>
この1つの主な問題が以下です：

</P>

<UL>
<LI>

あるクライアントが実行に長い時間のかかる <CODE>SELECT</CODE> を発行。
<LI>

その後に、他のクライアントが、使用されているテーブルに対し <CODE>UPDATE</CODE> を発行；
このクライアントは先の <CODE>SELECT</CODE> が完了するまで待ちます
<LI>

さらに他のクライアントが同じテーブルに対して <CODE>SELECT</CODE> 構文を発行；
<CODE>UPDATE</CODE> は <CODE>SELECT</CODE> よりも高い優先度を持つので、
この <CODE>SELECT</CODE> は先の <CODE>UPDATE</CODE> が完了するまで待ちます。
これは一番最初の <CODE>SELECT</CODE> が 終了するまで待たされます！
</UL>

<P>
この問題のいくつかの可能な解決は以下の通りです：

</P>

<UL>
<LI>

<CODE>SELECT</CODE> 構文を速く実行できるように試みます； これを行うにあたり、
いくつかのサマリーテーブルを作成しなければならないかもしれません.

<LI>

<CODE>mysqld</CODE> を <CODE>--low-priority-updates</CODE> オプションで起動。
これは全てのあるテーブルを更新する構文に対して、 <CODE>SELECT</CODE> 構文よりも
低い優先度を与えます。 この場合、前述のシナリオ中の最後の <CODE>SELECT</CODE> 構文は
<CODE>INSERT</CODE> 構文が完了する前に実行されます。

<LI>

<CODE>LOW_PRIORITY</CODE> 属性指定を用いて、 <CODE>INSERT</CODE>,<CODE>UPDATE</CODE>,<CODE>DELETE</CODE> 構文
に低い優先度を与えることも出来ます。

<LI>

Start <CODE>mysqld</CODE> with a low value for <STRONG>max_write_lock_count</STRONG> to give
<CODE>READ</CODE> locks after a certain number of <CODE>WRITE</CODE> locks.

<LI>

SQL コマンドの <CODE>SET SQL_LOW_PRIORITY_UPDATES=1</CODE> を使用して、
ある特定のスレッドからの全ての更新を、低い優先度に指定する事ができます。
 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.28  <CODE>SET OPTION</CODE> 構文</A>」節参照.

<LI>

<CODE>HIGH_PRIORITY</CODE> 属性を用いて、特定の <CODE>SELECT</CODE> がとても重要であると
指定することが可能です。.  「<A HREF="manual.ja_Reference.html#SELECT">7.14  <CODE>SELECT</CODE>構文</A>」節参照.

<LI>

もし <CODE>INSERT</CODE> と <CODE>SELECT</CODE> をあわせて使用した場合に問題が起きた場合、
新しい <CODE>MyISAM</CODE> テーブルに切り替えます。 これは <CODE>SELECT</CODE>
と <CODE>INSERT</CODE> を同時に行えます。

<LI>

もし <CODE>INSERT</CODE> と <CODE>SELECT</CODE> 構文を主に混在させるのなら、
<CODE>INSERT</CODE> の <CODE>DELAYED</CODE> 属性指定はこの問題を解決させるでしょう。
 「<A HREF="manual.ja_Reference.html#INSERT">7.16  <CODE>INSERT</CODE>構文</A>」節参照.

<LI>

もし <CODE>SELECT</CODE> と <CODE>DELETE</CODE> で問題があるなら、
<CODE>DELETE</CODE> の <CODE>LIMIT</CODE> オプションが助けになるでしょう。
  「<A HREF="manual.ja_Reference.html#DELETE">7.13  <CODE>DELETE</CODE>構文</A>」節参照.
</UL>



<H2><A NAME="Data_size" HREF="manual.ja_toc.html#Data_size">12.3  可能な限りデータを小さくする</A></H2>

<P>
One of the most basic optimization is to get your data (and indexes) to
take as little space on the disk (and in memory) as possible. This can
give huge improvements because disk reads are faster and normally less
main memory will also be used. Indexing also takes less resources if
done on smaller columns.

</P>
<P>
<STRONG>MySQL</STRONG> supports a lot of different table types and row formats.
Choosing the right table format may give you a big performance gain.
 「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL table types</A>」節参照.

</P>
<P>
以下に挙げるテクニックを使用すれば、テーブルでのパフォーマンスの向上、
保存領域の縮小化が可能でしょう：

</P>

<UL>
<LI>

可能ならば、一番小さな型を使用します。 <STRONG>MySQL</STRONG> は
ディスクとメモリーを節約する多くの型を持っています。
<LI>

より小さな整数型を可能ならば使用します。 例えば、
<CODE>MEDIUMINT</CODE> は <CODE>INT</CODE> より良いでしょう。
<LI>

可能ならフィールドを <CODE>NOT NULL</CODE> に定義してください。これは全てをより速くし、
各フィールド毎に1ビットを節約します。
Note that if you really need
<CODE>NULL</CODE> in your application you should definitely use it. Just avoid
haveing it on all columns by default.
<LI>

可変長のフィールド (<CODE>VARCHAR</CODE>, <CODE>TEXT</CODE>, <CODE>BLOB</CODE>) を持たない場合は、
固定サイズレコード形式が使用されます。
これはかなり速いです。しかしあいにくいくらかの領域を浪費します。
 「<A HREF="manual.ja_Table_types.html#MyISAM_table_formats">8.1.2  MyISAM table formats</A>」節参照.
<LI>

それぞれのテーブルは可能な限り短いプライマリ・インデックスを持つべきです。
これは１レコードを一意にし、効率的にします。
<LI>

それぞれのテーブルについて、どのテーブルの形式を使用するかを
決めます。  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL table types</A>」節参照.
<LI>

本当に必要な物にだけインデックスを作成します。
インデックスは検索には良いですが、より速く保存したい場合には良くありません。
もしテーブルをフィールドの組み合わせでサーチすることがほとんどであれば、
それらにインデックスを作成します。 最初のインデックスの部分は、もっとも
使用されるフィールドにすべきです。
If you are
ALWAYS using many columns you should use the column with more duplicates
first to get better compression of the index.
<LI>

もしインデックスが頭からの何文字かで一意性を持っているなら、この部分にだけ
インデックスを張る方が良いでしょう。 <STRONG>MySQL</STRONG> は文字列フィールドの
一部分に対してのインデックスをサポートします。
短いインデックスは、ディスクスペースを節約するだけでなく、
インデックスのキャッシュに収まりやすくなることにより、ディスク・シークも少なくなるので、
速くなります。  「<A HREF="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</A>」節参照.
<LI>

いくつかの状況下で、とてもよく走査されるテーブルを２つに分割することは、
利益になることがあります。
Especially if it is a dynamic format table
and it is possible to a smaller static format table that can be used to
find the relevant rows then scanning.
</UL>



<H2><A NAME="MySQL_indexes" HREF="manual.ja_toc.html#MySQL_indexes">12.4  MySQL はどのようにインデックスを使用するか？</A></H2>

<P>
Indexes are used to find find a row with a specific calue on one column
fast. 
インデックスがない場合、<STRONG>MySQL</STRONG> は、そのレコードが見つかるまで、
最初のレコードからテーブルをなめていきます。 大きなテーブルでは多くの
手間がかかります。 もし問い合わせの中にインデックスを持ったフィールドが
ある場合、<STRONG>MySQL</STRONG> は全てのデータをみることなく、データの途中の位置を速く
得ることができます。 もしあるテーブルが1000レコード持っていたとすると、
順番に頭からなめていくことに比べて、これは少なくとも100倍速いことに
なります。 Note that is you need to access almost all 1000
rows it is faster to read sequentially because we then avoid disk seeks.

</P>
<P>
全ての <STRONG>MySQL</STRONG> インデックス, <CODE>PRIMARY</CODE>, <CODE>UNIQUE</CODE> そして <CODE>INDEX()</CODE> 
は B tree に格納されます。文字列は自動的に始めと終りの空白が圧縮されます。
 「<A HREF="manual.ja_Reference.html#CREATE_INDEX">7.30  <CODE>CREATE INDEX</CODE> 構文</A>」節参照.

</P>
<P>
Indexes are used to:

<UL>
<LI>

<CODE>WHERE</CODE>節にマッチした行の素早い検索

<LI>

join を実行したときの他のテーブルからの行の検索

<LI>

与えられたフィールドの <CODE>MAX()</CODE> や <CODE>MIN()</CODE> 値の割り出し

<LI>

テーブルをソートかグループ化する場合で、ソート(グループ化)が一番左(接頭部)の
キーを使用して行われる場合(例えば <CODE>ORDER BY key_part_1,key_part_2 </CODE>)。
もし <CODE>DESC</CODE> 指定があれば、全てのキーは逆順に読まれます。

The index can also be used even if the <CODE>ORDER BY</CODE> doesn't match the index
exactly, as long as all the not used index parts and all the extra
are <CODE>ORDER BY</CODE> columns are constants in the <CODE>WHERE</CODE> clause. The
following queries will use the index to resolve the <CODE>ORDER BY</CODE> part.


<PRE>
SELECT * FROM foo ORDER BY key_part1,key_part2,key_part3;
SELECT * FROM foo WHERE column=constant ORDER BY column, key_part1;
SELECT * FROM foo WHERE key_part1=const GROUP BY key_part2;
</PRE>

<LI>

データファイルを参照することなく値を検索する場合。
もし使用する全てのフィールドが数値でかつ、一番左から(接頭部から)キーを形成する場合、
値はインデックスツリーから検索され、これはとても速くなります。

</UL>

<P>
以下のような <CODE>SELECT</CODE> 文を発行したとします：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
</PRE>

<P>
もし <CODE>col1</CODE> と <CODE>col2</CODE> に複数フィールドインデックスが定義されている場合、
すぐに思ったとおりの結果が得られます。
If separate single-column
indexes exist on <CODE>col1</CODE> and <CODE>col2</CODE>, the optimizer tries to
find the most restrictive index by deciding which index will find fewer
rows and using that index to fetch the rows.

</P>
<P>
<A NAME="IDX626"></A>
<A NAME="IDX627"></A>
もしテーブルが複数フィールドインデックスを持つなら、インデックスの接頭部一番左の部分
がレコードを見つけるための最適化に使用されます。例えば、3つのフィールド
 <CODE>(col1,col2,col3)</CODE> に対して一つのインデックスを持っていたとします。
すると、これは <CODE>(col1)</CODE>, <CODE>(col1,col2)</CODE> ,
<CODE>(col1,col2,col3)</CODE> でインデックスがサーチされます。

</P>
<P>
もし一番左に指定しているフィールドがインデックスを作成していないなら、
<STRONG>MySQL</STRONG> は部分的なインデックスを使用しません。

</P>
<P>
以下のような <CODE>SELECT</CODE> 文を発行したとします：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
</PRE>

<P>
もしインデックスが <CODE>(col1,col2,col3)</CODE> にあるならば、
上に示した最初のクエリだけがインデックスを使用します。二番目三番目のクエリは
インデックスを持つフィールドを発動しますが、
<CODE>(col2)</CODE> と <CODE>(col2,col3)</CODE> は、<CODE>(col1,col2,col3)</CODE> の
接頭部一番左に指定されていません。

</P>
<P>
<A NAME="IDX628"></A>
<A NAME="IDX629"></A>
<A NAME="IDX630"></A>
<A NAME="IDX631"></A>
<STRONG>MySQL</STRONG> は、もし  <CODE>LIKE</CODE> がワイルドカードから始まっていなくて、
ある種固定された文字で始まっているなら、
<CODE>LIKE</CODE> の評価にインデックスを使用します。
例えば、以下の <CODE>SELECT</CODE> 文はインデックスを使用します:

</P>

<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE "Pat%_ck%";
</PRE>

<P>
一つ目の文は、<CODE>"Patrick" &#60;= key_col &#60; "Patricl"</CODE> となるレコードだけ、考慮されます。
二つ目の文は、<CODE>"Pat" &#60;= key_col &#60; "Pau"</CODE> となるレコードだけ、考慮されます。

</P>
<P>
以下の <CODE>SELECT</CODE> 文はインデックスを使用しません:

<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "%Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE other_col;
</PRE>

<P>
最初の文は、<CODE>LIKE</CODE> がワイルドカード文字で始まっています。
二つ目の文は、<CODE>LIKE</CODE> が定数ではありません。

</P>
<P>
<A NAME="IDX632"></A>
<A NAME="IDX633"></A>
Searching using <CODE>column_name IS NULL</CODE> will use indexes if column_name
is a index.

</P>
<P>
<STRONG>MySQL</STRONG> は通常、一番少ないレコード数を見つけるインデックスを使用します。
インデックスは、以下に示す演算子を用いて比較できるフィールドに対して、使用されます：
<CODE>=</CODE>, <CODE>&#62;</CODE>, <CODE>&#62;=</CODE>, <CODE>&#60;</CODE>, <CODE>&#60;=</CODE>, <CODE>BETWEEN</CODE> そして
<CODE>'something%'</CODE> の様に頭にワイルドカードがない <CODE>LIKE</CODE>。

</P>
<P>
<CODE>WHERE</CODE> 節内の全ての <CODE>AND</CODE> にかからないインデックスは、
全くクエリの最適化に使用されません。
In other words:  To be able to use an
index, a prefix of the index must be used in every <CODE>AND</CODE> group.

</P>
<P>
以下の <CODE>WHERE</CODE> 節はインデックスを使用します：

<PRE>
... WHERE index_part1=1 AND index_part2=2 AND other_column=3
... WHERE index=1 OR A=10 AND index=2      /* index = 1 OR index = 2 */
... WHERE index_part1='hello' AND index_part_3=5
          /* optimized like "index_part1='hello'" */
... WHERE index1=1 and index2=2 or index1=3 and index3=3;
          /* Can use index on index1 but not on index2 or index 3 */
</PRE>

<P>
以下の <CODE>WHERE</CODE> 節はインデックスを<STRONG>使用しません</STRONG>：

<PRE>
... WHERE index_part2=1 AND index_part3=2  /* index_part_1 is not used */
... WHERE index=1 OR A=10                  /* Index is not used in both AND parts */
... WHERE index_part1=1 OR index_part2=10  /* No index spans all rows */
</PRE>



<H2><A NAME="Query_Speed" HREF="manual.ja_toc.html#Query_Speed">12.5  データをアクセス・更新するクエリの速度</A></H2>

<P>
最初に、全てのクエリに影響する一つの事柄をのべます：
より複雑な権限の設定を行うと、オーバーヘッドが多くなります。

</P>
<P>
もしあなたがいかなる <CODE>GRANT</CODE> 文も行っていなければ、
<STRONG>MySQL</STRONG> はパーミッションの検査を少ししか最適化しないでしょう。
So if you have a very high volume it
may be worth the time to avoid grants. Otherwise more permission check
results in a larger overhead.

</P>
<P>
もし <STRONG>MySQL</STRONG> 関数のあるものが確実に問題を引き起こしているのならば、
常に <STRONG>MySQL</STRONG> クライアント側は以下のようになります：

</P>

<PRE>
mysql&#62; select benchmark(1000000,1+1);
+------------------------+
| benchmark(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</PRE>

<P>
上の例では <STRONG>MySQL</STRONG> は 1,000,000 <CODE>+</CODE> 式を 0.32 秒で実行できています
(たんなる <CODE>PentiumII 400MHz</CODE> マシンで)。

</P>
<P>
全ての <STRONG>MySQL</STRONG> 関数は最適化されていますが、
いくつかは例外があるかもしれません。
<CODE>benchmark(loop_count,expression)</CODE>はあなたのクエリの
問題を見つけるためのとてもよいツールです。

</P>



<H3><A NAME="Estimating_performance" HREF="manual.ja_toc.html#Estimating_performance">12.5.1  クエリの性能評価</A></H3>

<P>
ほとんどの場合、ディスク・シークを数えることでだいたいのパフォーマンスを予測できます。
小さなテーブルでは、通常、1回のディスク・シークでレコードを見つけれるでしょう
(インデックスがたぶんキャッシュされるので)。 大きなテーブルでは、
おおよその予測として、(B++ ツリーインデックスを使用している場合)、
<CODE>log(row_count) /
log(index_block_length / 3 * 2 / (index_length + data_pointer_length)) +
1</CODE> シーク、1レコードを見つけるのに必要となるでしょう。

</P>
<P>
<STRONG>MySQL</STRONG> では、インデックス・ブロックは通常 1024 バイトで、
データ・ポインターは通常 4 バイトです。 これは、
インデックス長が 3 (medium integer) 、データが 500,000 レコードあるテーブルでは、 
<CODE>log(500,000)/log(1024/3*2/(3+4)) + 1</CODE> = 4 シークとなります。

</P>
<P>
As the above index would require about 500,000 * 7 * 3/2 = 5.2M,
(assuming that the index buffers are filled to 2/3 (which is typical) )
you will probably have much of the index in memory and you will probably
only need 1-2 calls to read data from the OS to find the row.

</P>
<P>
書き込み時には、上の場合、新しいインデックスを書き込める場所を
探し出すのに、4 シークかかり、さらに、通常、インデックスを更新し、
レコードを書くのに 2 シーク必要です。

</P>
<P>
Note that the above doesn't mean that your application will slowly
degenerate by N log N!  As long as everything is cached by the OS or SQL
server things will only go marginally slower while the table gets
bigger. After the data gets too big to be cached, things will start to
go much slower until your applications is only bound by disk-seeks
(which increase by N log N). To avoid this increase the index cache as
the data grows.  「<A HREF="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>


<H3><A NAME="SELECT_speed" HREF="manual.ja_toc.html#SELECT_speed">12.5.2  <CODE>SELECT</CODE> クエリの速度</A></H3>

<P>
通常、遅い <CODE>SELECT ... WHERE</CODE> を速くするには、
まず最初にインデックスがあるかどうかをチェックします。 「<A HREF="manual.ja_Performance.html#MySQL_indexes">12.4  MySQL はどのようにインデックスを使用するか？</A>」節参照. 
違うテーブルを参照する場合には、普通はインデックスをともなうべきです。
<CODE>EXPLAIN</CODE> コマンドを使用すれば、<CODE>SELECT</CODE> でどのインデックスが
使用されているか確認できます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.24  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.

</P>
<P>
Some general tips:

</P>

<UL>
<LI>

To help <STRONG>MySQL</STRONG> optimize queries better, run <CODE>myisamchk
--analyze</CODE> on a table after it has been loaded with relevant data. This
updates a value for each index part that indicates the average number of
rows that have the same value.  (For unique indexes, this is always 1,
of course.).  <STRONG>MySQL</STRONG> will use this to decide which index to
choose when you connect two tables with 'a not constant expression'.
You can check the result from the <CODE>analyze</CODE> run by doing <CODE>SHOW
INDEX FROM table_name</CODE> and examining the <CODE>Cardinality</CODE> column.

<LI>

インデックスとデータをインデックス順に従ってソートするには、
<CODE>myisamchk --sort-index --sort-records=1</CODE> を使用します
(もし １番目のインデックス順にソートするなら)。 
If you
have a unique index from which you want to read all records in order
according to that index, this is a good way to make that faster. 
しかし、このソート方法は最適状態では書かれず、また大きなテーブルでは
多くの時間がかかることに注意してください！
</UL>

<P>
<A NAME="IDX634"></A>


<H3><A NAME="Where_optimizations" HREF="manual.ja_toc.html#Where_optimizations">12.5.3  MySQL はどのように <CODE>WHERE</CODE> 節を最適化するか？</A></H3>

<P>
where の最適化は、where がほとんど <CODE>SELECT</CODE> で使用されるため、
<CODE>SELECT</CODE> に置かれています。 しかし、同じ最適化は
<CODE>DELETE</CODE> や <CODE>UPDATE</CODE> 文でも使用されます。

</P>
<P>
このセクションの最適化の説明はまだ不十分です。
なぜなら、 <STRONG>MySQL</STRONG> はとても多くの最適化を行っており、
それら全てについての説明を書ける時間が、我々はとれません。

</P>
<P>
<STRONG>MySQL</STRONG>による最適化のいくつかを以下に示します:

</P>

<UL>
<LI>

括弧の除去 (全ての不必要な括弧は削除されます):

<PRE>
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&#62; (a AND b AND c) OR (a AND b AND c AND d)
</PRE>

<LI>

定数の保持:

<PRE>
   (a&#60;b AND b=c) AND a=5
-&#62; b&#62;5 AND b=c AND a=5
</PRE>

<LI>

定数条件の除去 (定数保持のために必要とされます):

<PRE>
   (B&#62;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&#62; B=5 OR B=6
</PRE>

<LI>

インデックスに使用される全ての表現は一度だけ評価されます。
<LI>

一つのテーブル上の <CODE>WHERE</CODE> がない <CODE>CONST(*)</CODE> は、テーブルから
直接取り出されます。これはまた同じ条件下での任意の <CODE>NOT NULL</CODE> 表現
のためにも行われます。
<LI>

不当な定数表現は早く検出されます。
<STRONG>MySQL</STRONG> は不可能な  <CODE>SELECT</CODE> 構文を素早く見つけ、0 行を結果として返します。
<LI>

<CODE>GROUP BY</CODE> または group 関数 (<CODE>COUNT()</CODE>, <CODE>MIN()</CODE>...) を使用しない場合は、
<CODE>HAVING</CODE> は <CODE>WHERE</CODE> とマージされます。
<LI>

各サブ結合についての速い <CODE>WHERE</CODE> 評価を得るために、また、可能な限り
早くレコードをスキップするために、各サブ結合についてより簡単な 
<CODE>WHERE</CODE> が構築されます。
<A NAME="IDX635"></A>
<A NAME="IDX636"></A>
<LI>

全ての定数テーブルをクエリー中の他のテーブルより先に読みます。
定数テーブルは次です:

<UL>
<LI>

0 または 1 行のテーブル。
<LI>

<CODE>WHERE</CODE> 節で <CODE>UNIQUE</CODE> インデックスや <CODE>PRIMARY KEY</CODE> が使用されたテーブルで、
かつ、全てのインデックスが定数式で使用されていて、
かつ、インデックスのパートが <CODE>NOT NULL</CODE> で定義されているテーブル。
</UL>

以下のテーブルのように定数だけを使用するテーブル:

<PRE>
mysql&#62; SELECT * FROM t WHERE primary_key=1;
mysql&#62; SELECT * FROM t1,t2
           WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
</PRE>

<LI>

テーブルを結合するために最良の結合の組合せを見つけます。全ての可能性を試して:( 。
<CODE>ORDER BY</CODE> または <CODE>GROUP</CODE> 内の全てのフィールドが同じテーブルの場合は、
このテーブルは結合時に最初に優先されます。
<LI>

<CODE>ORDER BY</CODE> 節と <CODE>GROUP BY</CODE> 節がある場合、または <CODE>ORDER BY</CODE> か <CODE>GROUP BY</CODE> が結合キュー
内の最初のテーブルではない他のテーブルからの項目を含む場合、一時テーブルが生成されます。
<LI>

もし <CODE>SQL_SMALL_RESULT</CODE> を使用するなら, <STRONG>MySQL</STRONG> はメモリー内の一次テーブルを
使用します
<LI>

<CODE>DISTINCT</CODE> は、全てのフィールドに対する <CODE>GROUP BY</CODE> に変換されるため、
<CODE>ORDER BY</CODE> と合わした <CODE>DISTINCT</CODE> は多くの場合で一時テーブルが
必要になります。
<LI>

各テーブルのインデックスはクエリされ、得られる行の 30% 未満の幅しかない最良のインデックスが使用されます。
そのようなインデックスが見つけられない場合、素早いテーブルの走査(quick table scan)が使用されます。
<LI>

同じように、<STRONG>MySQL</STRONG> はデータファイルを等しく調べはしないインデックスから
レコードを読むことが可能です。もし全てのフィールドが数値型のインデックスなら、
インデックスツリーだけがクエリの解決に使用されます。
<LI>

各レコードが出力される前に、<CODE>HAVING</CODE> 節に適合するものをスキップします。
</UL>

<P>
以下はとても速いクエリの例です:

</P>

<PRE>
mysql&#62; SELECT COUNT(*) FROM tbl_name;
mysql&#62; SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;
mysql&#62; SELECT MAX(key_part2) FROM tbl_name
           WHERE key_part_1=constant;
mysql&#62; SELECT ... FROM tbl_name
           ORDER BY key_part1,key_part2,... LIMIT 10;
mysql&#62; SELECT ... FROM tbl_name
           ORDER BY key_part1 DESC,key_part2 DESC,... LIMIT 10;
</PRE>

<P>
以下のクエリはインデックスツリーのみを使用します(インデックス化されているフィールドは
数値型と仮定します)：

</P>

<PRE>
mysql&#62; SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
mysql&#62; SELECT COUNT(*) FROM tbl_name
           WHERE key_part1=val1 AND key_part2=val2;
mysql&#62; SELECT key_part2 FROM tbl_name GROUP BY key_part1;
</PRE>

<P>
以下のクエリは、ソートされた行の検索にインデックスを使用します：

</P>

<PRE>
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1,key_part2,...
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1 DESC,key_part2 DESC,...
</PRE>



<H3><A NAME="LEFT_JOIN_optimization" HREF="manual.ja_toc.html#LEFT_JOIN_optimization">12.5.4  MySQL はどのように <CODE>LEFT JOIN</CODE> を最適化するか？</A></H3>

<P>
<CODE>A LEFT JOIN B</CODE> は <STRONG>MySQL</STRONG> に以下のように組みこまれています：

</P>

<UL>
<LI>

The table <CODE>B</CODE> is set to be dependent on table <CODE>A</CODE> and all tables
that <CODE>A</CODE> is dependent on.
<LI>

テーブル <CODE>A</CODE> が <CODE>LEFT JOIN</CODE> 条件中に使用される全てのテーブル
（ただし <CODE>B</CODE> は除く）に依存すると、セットされます。
<LI>

全ての <CODE>LEFT JOIN</CODE> 条件が <CODE>WHERE</CODE> 節に移動されます。
<LI>

All standard join optimizations are done, with the exception that a table is
always read after all tables it is dependent on.  If there is a circular
dependence then <STRONG>MySQL</STRONG> will issue an error.
<LI>

全ての <CODE>WHERE</CODE> 節の最適化が行われます。
<LI>

<CODE>WHERE</CODE> 節にマッチするレコードが <CODE>A</CODE> にあり、
<CODE>LEFT JOIN</CODE> 条件にマッチするレコードが <CODE>B</CODE> にない場合、
全てのフィールドが <CODE>NULL</CODE> にセットされた <CODE>B</CODE> のレコードが
作成されます。 
<LI>

If you use <CODE>LEFT JOIN</CODE> to find rows that doesn't exist in some
table and you have the following test: <CODE>column_name IS NULL</CODE> in the
<CODE>WHERE</CODE> part, where column_name is a column that is declared as
<CODE>NOT NULL</CODE>, then <CODE>MySQL</CODE> will stop searching after more rows
(for a particular key combination) after it has found one row that
matches the <CODE>LEFT JOIN</CODE> condition.
</UL>

<P>
The table read order forced by <CODE>LEFT JOIN</CODE> and <CODE>STRAIGHT JOIN</CODE> will help
the join optimizer (which calculates in which order tables should be joined) to do
its work much quickly as there are fewer table permutations to check.

</P>
<P>
Note that the above means that if you do a query of type:

</P>

<PRE>
SELECT * FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key) WHERE b.key=d.key
</PRE>

<P>
Then <STRONG>MySQL</STRONG> will do a full scan on <CODE>b</CODE> as the <CODE>LEFT JOIN</CODE> will
force it to be read before <CODE>d</CODE>.

</P>
<P>
The fix in this case is to change the query to:

</P>

<PRE>
SELECT * FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key) WHERE b.key=d.key
</PRE>



<H3><A NAME="LIMIT_optimization" HREF="manual.ja_toc.html#LIMIT_optimization">12.5.5  MySQL はどのように <CODE>LIMIT</CODE> を最適化するか？</A></H3>

<P>
In some cases <STRONG>MySQL</STRONG> will handle the query differently when you are
using <CODE>LIMIT #</CODE> and not using <CODE>HAVING</CODE>:

</P>

<UL>
<LI>

もし <CODE>LIMIT</CODE> を使用して限定した数だけ select を行うなら、 <STRONG>MySQL</STRONG> は、
ある場合、テーブルを全て走査するよりも、インデックスを使用しようとします。
<LI>

もし <CODE>LIMIT #</CODE> を <CODE>ORDER BY</CODE> と共に使用するなら, <STRONG>MySQL</STRONG> は
最初の <CODE>#</CODE> 行を見つけたらすぐに、全テーブルのソートは行わずに、
ソートを終わらせます。 
<LI>

<CODE>LIMIT #</CODE> を <CODE>DISTINCT</CODE> と共に使用するなら, <STRONG>MySQL</STRONG> は
<CODE>#</CODE> 個の一意なレコードを見つけた時点で終わります。
<LI>

In some cases a <CODE>GROUP BY</CODE> can be resolved by reading the key in order 
(or do a sort on the key) and then calculate summaries until the
key value changes.  In this case <CODE>LIMIT #</CODE> will not calculate any
unnecessary <CODE>GROUP</CODE>'s.
<LI>

<STRONG>MySQL</STRONG> は、最初の <CODE>#</CODE> 行をクライアントに送ったあと直に、
クエリを中断します。
<LI>

<CODE>LIMIT 0</CODE> は常に素早く空の結果を返します。
これはクエリのチェックや結果として得られるフィールドの型を得るために利用できます。
<LI>

一時テーブルの大きさは、クエリを解決するためにどれぐらいのスペースがいるかを
計算するのに、<CODE>LIMIT #</CODE> を使用します。
</UL>



<H3><A NAME="Insert_speed" HREF="manual.ja_toc.html#Insert_speed">12.5.6  <CODE>INSERT</CODE> クエリの速度</A></H3>

<P>
レコードを挿入する時間はおおよそ次からなります:

</P>

<UL>
<LI>

接続:                    (3)
<LI>

クエリをサーバへ送信:    (2)
<LI>

クエリの解析:            (2)
<LI>

レコードの挿入:          (1 x size of record)
<LI>

インデックスの挿入:      (1 x number of indexes)
<LI>

クローズ:                (1)
</UL>

<P>
ここで (数字) は比例時間です。これは、テーブルのオープンにかかる初期オーバーヘッ
ド(これは同時に動作する各クエリ毎に1回行なわれます)は考慮されていません。

</P>
<P>
テーブルのサイズはインデックスの挿入を N log N で遅くします (B-tree)。

</P>
<P>
INSERT を速くするいくつかの方法：

</P>

<UL>
<LI>

もし同じクライアントから多くのレコードを同時にインサートするなら、
複数の値が書ける <CODE>INSERT</CODE> 文を使用します。 これは個々に <CODE>INSERT</CODE> 文
を発行する場合に比べて、とても速くなります。
<LI>

もし違うクライアントから多くのレコードを同時にインサートするなら、
 <CODE>INSERT DELAYED</CODE> 文の使用で、より速くなるでしょう。  「<A HREF="manual.ja_Reference.html#INSERT">7.16  <CODE>INSERT</CODE>構文</A>」節参照.
<LI>

<CODE>MyISAM</CODE> では、複数の <CODE>SELECT</CODE> が走っているテーブルに対して、
同時に、レコードを挿入できます。 ただしそのテーブルに対して
レコードの削除がない場合に。
<LI>

テキストファイルからテーブルにデータをいれる場合は、 <CODE>LOAD DATA INFILE</CODE> を
使用します。 これはたくさんの <CODE>INSERT</CODE> 文の発行に比べて通常 20倍 程度
速くなります
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">7.18  <CODE>LOAD DATA INFILE</CODE>構文</A>」節参照.
<LI>

テーブルが多くのインデックスを持っている場合、ある方法で、 <CODE>LOAD DATA INFILE</CODE> の
実行を速くすることが可能です。
以下の手順で行います：


<OL>
<LI>

Optionally create the table with <CODE>CREATE TABLE</CODE>. For example using
<CODE>mysql</CODE> or Perl-DBI.

<LI>

<CODE>FLUSH TABLES</CODE> の実行。 あるいは <CODE>mysqladmin flush-tables</CODE> 
コマンドの実行。

<LI>

<CODE>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</CODE> の使用。
これは指定されたテーブルから全てのインデックスを削除します。

<LI>

そのテーブルに <CODE>LOAD DATA INFILE</CODE> を使用してデータを入れます. 
これはいかなるインデックスも更新しないでしょうし、そのため、速くもなるでしょう。

<LI>

もし <CODE>myisampack</CODE> をお持ちで、テーブルを圧縮したいなら、
<CODE>myisampack</CODE> を実行します.  「<A HREF="manual.ja_Table_types.html#Compressed_format">8.1.2.3  Compressed table characteristics</A>」節参照.

<LI>

<CODE>myisamchk -r -q /path/to/db/tbl_name</CODE> でインデックスを再構築. 
これは disk に書き込む前にインデックスをメモリに作成します。
これは多くのディスクシークを避けることが出来るのでとても速くなります。
でき上がったインデックスツリーは、バランスのよいものになります。

<LI>

<CODE>FLUSH TABLES</CODE> の実行。 あるいは <CODE>mysqladmin flush-tables</CODE> 
コマンドの実行。
</OL>

この手順は、将来の MySQL の <CODE>LOAD DATA INFILE</CODE> に組み込むかもしれません。
<LI>

テーブルをロックすることで、挿入を速くすることも可能です：


<PRE>
mysql&#62; LOCK TABLES a WRITE;
mysql&#62; INSERT INTO a VALUES (1,23),(2,34),(4,33);
mysql&#62; INSERT INTO a VALUES (8,26),(6,29);
mysql&#62; UNLOCK TABLES;
</PRE>

主な速度差は、全ての <CODE>INSERT</CODE> 構文でインデックスバッファが一度だけディスクにフ
ラッシュされることです。通常は  <CODE>INSERT</CODE> 構文があるのと同じくらい多くのインデッ
クスバッファフラッシュがあります。単一構文の全てのレコードは、ロックなしで挿入できます。

ロックも複数接続テストの合計時間を低くしますが、いくつかのスレッドの最大
待ち時間は上がります(ロックを待っているから)。
例えば:


<PRE>
thread 1 does 1000 inserts
thread 2, 3, and 4 does 1 insert
thread 5 does 1000 inserts
</PRE>

ロックを使用しない場合、2, 3 そして 4 は 1 と 5 の前に終ります。ロックを
使用する場合、2,3,4 は 1 や 5 の前に終わることはおそらくありませんが、合
計時間は約 40 % 速くなります。

<CODE>INSERT</CODE>, <CODE>UPDATE</CODE> , <CODE>DELETE</CODE> は、 <STRONG>MySQL</STRONG> ではとても速いので、
1 行で約 5 つ以上、値を 挿入・更新 をする操作に対して、
ロックを追加すれば、全般的により良い性能が得られます。
とても多い insert を行なう場合、
他のスレッドにそのロックしたテーブルへのアクセスを与えるために 、
だいたい 1000 レコードごとに一度、<CODE>UNLOCK TABLES</CODE> した後に
 <CODE>LOCK TABLES</CODE> を行います。 これでもまだ良い性能が得られます。

もちろん <CODE>LOAD DATA INFILE</CODE> はとても速いです。
</UL>

<P>
<CODE>LOAD DATA INFILE</CODE> と <CODE>INSERT</CODE> を共に速くするためには、
キーバッファを増やします。  「<A HREF="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>


<H3><A NAME="Update_speed" HREF="manual.ja_toc.html#Update_speed">12.5.7  <CODE>UPDATE</CODE> クエリの速度</A></H3>

<P>
<CODE>UPDATE</CODE> クエリは <CODE>SELECT</CODE> クエリのように最適化されますが、
書き込みのオーバーヘッドが加わります。
書き込み速度は、更新されるデータの大きさ、更新されるインデックス数に
依ります。 変更されないインデックスは更新されません。

</P>
<P>
Also another way to get fast updates is to delay updates and then do
many updates in a row later. 
一文で多くの更新を行えば、もしテーブルがロックされていれば、
一文で一個づつ更新するよりも、とても速くなります。

</P>
<P>
Not that with dynamic record format updating a record with to a longer
total length may split the record. So if you do this often it is very
important to <CODE>OPTIMIZE TABLE</CODE> sometimes.  「<A HREF="manual.ja_Reference.html#OPTIMIZE_TABLE">7.10  <CODE>OPTIMIZE TABLE</CODE>構文</A>」節参照.

</P>


<H3><A NAME="Delete_speed" HREF="manual.ja_toc.html#Delete_speed">12.5.8  <CODE>DELETE</CODE> クエリの速度</A></H3>

<P>
1レコードを削除する時間は、ちょうどインデックスの数に比例します。
より速くレコードを削除したいなら、インデックス・キャッシュを
増やします。  「<A HREF="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>
<P>
テーブル中からレコードの大きな部分を消すよりも、
全てのレコードを消すほうが、とても速いです。

</P>


<H2><A NAME="Tips" HREF="manual.ja_toc.html#Tips">12.6  最適化に関するその他の助言</A></H2>

<P>
Unsorted tips for faster systems:

</P>

<UL>
<LI>

コネクションオーバーヘッドを避けるために、データベースに対して、
逐次コネクションを落とさないように、常に接続を保ちます。
If you can't use persistent connections and you are doing a
lot of new connections to the database, you may want to change the value
of the <CODE>thread_cache_size</CODE> variable.  「<A HREF="manual.ja_Performance.html#Server_parameters">12.2.3  サーバーパラメーターのチューニング</A>」節参照.
<LI>

あなたのクエリがテーブルのインデックスを使用しているか、いつもチェックします。
<STRONG>MySQL</STRONG> では <CODE>EXPLAIN</CODE> コマンドでこれが行えれます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.24  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.
<LI>

たくさん変更されるようなテーブルに対して、複雑な <CODE>SELECT</CODE> クエリを
避けるように試みます。 これはテーブル・ロックの問題を避けるためです。
<LI>

新しい <CODE>MyISAM</CODE> テーブルでは、あるテーブルにレコードが挿入(削除は無しで)
されている最中に、同時に、同じテーブルからデータを読むことが可能です。
これがあなたにとって重要項目であるなら、
レコードの削除の必要のない方法や、多くのレコードを削除した後に <CODE>OPTIMIZE TABLE</CODE> を
実行することを、考慮すべきです。
<LI>

In some cases it may make sense to introduce a column that is 'hashed'
based on information from other columns. If this column is short and
reasonable unique it may be much faster than a big index on many
columns. In <STRONG>MySQL</STRONG> its very easy to use this extra column:
<CODE>SELECT * from table where hash='calculated hash on col1 and col2'
and col_1='constant' and col_2='constant' and ..</CODE>
<LI>

多くの変更がなされるテーブルに対しては、全ての <CODE>VARCHAR</CODE> や <CODE>BLOB</CODE> 
フィールドを避けるように試みるべきです。
You will get dynamic row length as soon as you
are using a single <CODE>VARCHAR</CODE> or <CODE>BLOB</CODE> columns.  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL table types</A>」節参照.
<LI>

通常、あるテーブルを違うテーブルに分けることは、レコードが大きくなる
ために役立ちません。
レコードにアクセスする際、そのレコードの最初のバイトを見つけるための
ディスク・シークが、一番かかります。
After finding
the data most new disks can read the whole row fast enough for most
applications. The only cases it really matters to split up a table is if
its a dynamic row size table (see above) that you can change to a fixed
row size. Or if you very often need to scan the table and don't need
most of the columns.  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL table types</A>」節参照.
<LI>

もし、多くのレコードからの情報を元にした計算(あるもののカウントとか)を
しょっちゅう行う必要があるなら、新しいテーブルを用意し、逐次カウンターを
更新した方が多分良いでしょう。
<CODE>UPDATE table set count=count+1 where index_column=constant</CODE> の更新は
とても速いです！

これは、<STRONG>MySQL</STRONG> のようなテーブル・ロッキング
(multiple readers / single writers)をもつデータベースを
使う上で、本当に重要なことです。
This will
also give better performance with most databases as the row locking
manager in this case will have less to do.
<LI>

もしたくさんの大きなテーブルから統計を収集する必要があるなら、
全テーブルを走査する代わりに、サマリーテーブルを使用します。
Maintaing the summarys should be
much faster than trying to do statistics 'live'. It's much faster to
re-generate new summary tables from the logs when things changes
(depending on business decisions) than to have to change the running
application!
<LI>

If possible one should classify reports as 'live' or 'statistical',
where data needed for statistical reports are only generated based on
summary tables that are generated from the actual data.
<LI>

フィールドにはデフォルト値があるという事を利用して下さい。
値がデフォルトとは違う場合に限り、値を挿入します。
これは <STRONG>MySQL</STRONG> が必要とする分析を少なくし、インサートの速度が向上します。
<LI>

ある場合では、BLOB にデータをパックして保存するのが便利です。
この場合、BLOB に入れた値を パック・アンパック するためのコードを
あなたのアプリケーションに組み込まなくてはなりません。
しかしこれは、多くのアクセスを抑制するでしょう。
これは、静的(固定長)テーブル構造に適しないデータを持っている場合に
実用になります。
<LI>

通常、あなたは全てのデータを冗長の無いように(データベース理論で
第３正規形 , 3rd Normal Form , 3NF と呼ばれる)
しようとするかもしれませんが、しかし、よりスピードを求める場合は、
重複やサマリーテーブルの作成をおそれてはいけません。
<LI>

ストアド・プロシージャ や UDF (ユーザー定義関数) はよりパフォーマンスを得る
ためにはよい方法かもしれません。
In this case you should however always have a way
to do this some other (slower) way if you use some database that doesn't
support this.
<LI>

You can always gain something by caching queries/answers in your
application and try to do many inserts/updates at the same time.  If
your database supports lock tables (like <STRONG>MySQL</STRONG> and Oracle),
this should help to ensure that the index cache is only flushed once
after all updates.
<LI>

データをすぐには書く必要がないとき、<CODE>INSERT /*! DELAYED */</CODE> を使用します。
これは、一回のディスクへの書き込みで、多くのレコードがかかれるので、
速くなります。
<LI>

SELECT がより重要な場合、<CODE>INSERT /*! LOW_PRIORITY */</CODE> を使用します。
<LI>

キューを無視して SELECT を優先的に行いたいときは
<CODE>SELECT /*! HIGH_PRIORITY */</CODE> を使用します。
これは、たとえ誰かが書き込みを待っていたとしても、その SELECT は
実行されます。
<LI>

複数行 <CODE>INSERT</CODE> 文の使用。 これは多くのレコードを一つの SQL コマンドで
挿入することが出来ます。
(多くの SQL サーバーがこれをサポートしています)
<LI>

大きなデータの読み込みには <CODE>LOAD DATA INFILE</CODE> を使用します。
This if
faster than normal inserts and will be even faster when <CODE>myisamchk</CODE>
is integrated in <CODE>mysqld</CODE>.
<LI>

一意の値を作るために、 <CODE>AUTO_INCREMENT</CODE> を使用します。
<LI>

動的テーブルフォーマットの使用時には、フラグメンテーションを避けるために、
<CODE>OPTIMIZE TABLE</CODE> を時々使用します。
 「<A HREF="manual.ja_Reference.html#OPTIMIZE_TABLE">7.10  <CODE>OPTIMIZE TABLE</CODE>構文</A>」節参照.

<LI>

可能ならば <CODE>HEAP</CODE> テーブルをスピードアップのために使用します.  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL table types</A>」節参照.
<LI>

通常の Web サーバーの設定ならば、イメージはファイルに保存すべきです。
データベースには、それらファイルの参照(パスとか)のみを入れます。
この主な理由は、通常の Web サーバーはデータベースよりもコンテンツを
よりよくキャッシュしてくれるからです。 それでファイルを使用するなら、
速いシステムをより簡単に得ることができます。
<LI>

重要でないデータで、よくアクセスされる物は、メモリテーブルにいれます。
(like
information about the last shown banner for users that doesn't have
cookies)
<LI>

Columns with identical information in different tables should be
declared identical and have identical names. Before version 3.23 you
got slow joins otherwise.

名前は単純にしてください（customer テーブルでは <CODE>customer_name</CODE> の
かわりに <CODE>name</CODE> を使うとか）。 他の SQL サーバーへの移植を考慮するなら、
名前は 18 文字より短くすべきです。
<LI>

もし本当にハイ・スピードが必要なら、SQL サーバーがサポートしている物とは
違う、ローレベルのデータ保存のインターフェースに注目すべきです。
例えば、 <STRONG>MySQL</STRONG> <CODE>MyISAM</CODE> を直接アクセスすることは、
SQL インターフェースを介してアクセスするよりも、2〜5倍速くなるでしょう。
これを可能にするには、そのデータは、アプリケーションと同じマシン上になくてはならず、
通常、一つのプロセスだけでアクセスされるべきです。
(なぜなら、外部ファイルロックは、とても遅いから)。
上の問題は、<STRONG>MySQL</STRONG> サーバー内の <CODE>MyISAM</CODE> のローレベルのコマンドの
導入で解決できるでしょう。 (これはよりよいパフォーマンスを得ることの出来る、
簡単な方法の一つです)。 By carefully designing the database interface
it should be quite easy to support this types of optimisations.
<LI>

多くの場合、データベースからデータをアクセスする方が(接続を維持していれば)、
テキストファイルからデータをアクセスするよりも速いです。 なぜなら、
データベースはテキストファイルよりもコンパクトになり（数値データの場合）、
このため、ディスクアクセスが少なくなるからです。
また、行や項目を見つけるために、テキストファイルを解析する必要も省けます。
<LI>

複製もスピードアップに使用できるでしょう。  「<A HREF="manual.ja_Replication.html#Replication">11  Replication in MySQL</A>」節参照.
<LI>

<CODE>DELAY_KEY_WRITE=1</CODE> が定義されたテーブルは、インデックスの更新が速くなります。
これはそのインデックス・ファイルが閉じられるまでディスクに記録されないからです。
したがって、なにかが途中で <CODE>mysqld</CODE> をキルしてもテーブルが大丈夫なようにするため、
<CODE>mysqld</CODE> を起動する前には、<CODE>myisamchk</CODE> をそれらのテーブルに対して実行すべきです。
As the key information can always be generated
from the data you should not lose anything by using <CODE>DELAY_KEY_WRITE</CODE>.
</UL>



<H2><A NAME="Benchmarks" HREF="manual.ja_toc.html#Benchmarks">12.7  Using your own benchmarks</A></H2>

<P>
You should definitely benchmark your application and database to find
out where is the bottlenecks.  By fixing it (or by replacing the
bottleneck with a 'dummy module') you can then easily identify the next
bottleneck (and so on).  Even if the overall performance for your
application is 'good enough' you should at least make a 'plan', for each
bottleneck, how to solve it if you someday 'really need it fix it'.

</P>
<P>
For some example portable benchmark programs look at the <STRONG>MySQL</STRONG>
benchmark suite.  「<A HREF="manual.ja_MySQL_Benchmarks.html#MySQL_Benchmarks">13  <STRONG>MySQL</STRONG> ベンチマークスイート</A>」節参照. You
can take any program this suite and modify it for your needs. By doing this,
you can try different solutions to your problem and test which is really the
fastest solution for you.

</P>
<P>
It is very common that some problems only occur then the system is very
heavily loaded. And we have had many customer who contacts us then they
have a (tested) system in production and have have got load problems. In
every on these cases so far it has been problems with basic design
(table scans are NOT good at high load) or OS/Library issues. Most of
this would be a <STRONG>LOT</STRONG> easier to fix if the system where not
already in production.

</P>
<P>
To avoid probles like this you should put some effort into benchmarking
your whole appliction under the worst possible load!

</P>


<H2><A NAME="Design" HREF="manual.ja_toc.html#Design">12.8  Design choices</A></H2>

<P>
<CODE>MySQL</CODE> は、レコードのデータとインデックスを別のファイルに保存します。
他の多くの(ほとんど全て)データベースでは、同じファイルにデータとインデックスを
混在させて保存します。 我々は、最近のシステムには、<STRONG>MySQL</STRONG> の選択の方が
良いと信じています。

</P>
<P>
Another way to store the row data is to keep the information for each
column in a separate area (examples are SDBM and Focus). This will get a
performance hit for every query that access more than one column. Because
this degenerates so quickly when more that when one columns are accessed
we believe that this model is not good for general purpose databases.

</P>
<P>
The more common case is there the index and data are stored together
(like in Oracle/Sybase at all). In this case you will find the row
information at the leaf page of the index. The good thing with this
layout is that it in many cases (depends on how well the index is
cached) saves a disk read.  The bad things with this layout is:

</P>
<DL COMPACT>

<DT>*
<DD>
Table scanning is much slower because you have to read through the indexes
to get at the data.
<DT>*
<DD>
You loose a lot of space as you must duplicate indexes from the nodes
(as you can't store the row in the nodes)
<DT>*
<DD>
Deletes will degenerate the table over times (as indexes in nodes are
usually not updated on delete).
<DT>*
<DD>
You can't use only the index table to retrieve data for a query.
<DT>*
<DD>
The index data is harder to cache.
</DL>



<H2><A NAME="Design_Limitations" HREF="manual.ja_toc.html#Design_Limitations">12.9  MySQL design limitations/tradeoffs</A></H2>

<P>
Because <STRONG>MySQL</STRONG> uses extremely fast table locking (multiple readers /
single writers) the biggest remaining problem is a mix of a steady stream of
inserts and slow selects on the same table.

</P>
<P>
We belive that for a huge number of systems the extremely fast
performance in other cases make this choice a win. This case is usually
also possible to solve by having multiple copies of the table. But it
takes more effort and hardware.

</P>
<P>
We are also working on some extension to solve this problem for some
common application niches.

</P>


<H2><A NAME="Portability" HREF="manual.ja_toc.html#Portability">12.10  Portability</A></H2>

<P>
Because all SQL servers implement different parts of SQL it takes work to
write portable SQL applications. For very simple selects/inserts it is
very easy but the more you need the harder it gets. And if you want a
application that is fast with many databases it becomes even harder!

</P>
<P>
To make a complex application portable you need to choose a number of
SQL server that it should work with.

</P>
<P>
When you can use the <STRONG>MySQL</STRONG> crash-me program/web-page
<a HREF="http://www.mysql.com/crash-me-choose.htmy">http://www.mysql.com/crash-me-choose.htmy</a> to find functions,
types and limits you can use with a selection of database
servers. Crash-me now test a long way from everything possible but it
still is vｴcomprehensive with about 450 things tested.

</P>
<P>
For example, you shouldn't have longer column names than 18 characters
if you want to be able to use Informix or DB2.

</P>
<P>
Both the <STRONG>MySQL</STRONG> benchmarks and Crash-me programs are very
database independent.  By taking a look of how we have handled this, you
can get a feeling of what you have to do to write your application
database independent.  The benchmark themselves can be found in the
<TT>`sql-bench'</TT> directory in the <STRONG>MySQL</STRONG> source
distribution. They are written in Perl with DBI database interface
(which solves the access part of the problem.

</P>
<P>
See <a HREF="http://www.mysql.com/benchmark.html">http://www.mysql.com/benchmark.html</a> the results from this
benchmark.

</P>
<P>
As you can see in these results all databases has some weak points. That
is they have different design compromises that lead to different
behavior. 

</P>
<P>
If you strive for database independence you need to get a good feeling
of each SQL servers bottlenecks. <STRONG>MySQL</STRONG> is VERY fast in
retrieving and updating things, but will have a problem in mixing slow
readers/writers on the same table. Oracle on the other hand has a big
problem when you try to access rows that you have recently updated
(until they are flushed to disk). Transaction databases in general are
not very good in generating summary tables from log tables as in this
case row locking is almost useless.

</P>
<P>
To get your application 'really database independent' you need to define
a easy extendable interface through which you manipulate your data. As
C++ is available on most systems, it makes sense to use a C++ classes
interface to the databases.

</P>
<P>
If you use some specific feature for some database (like the
<CODE>REPLACE</CODE> command in <STRONG>MySQL</STRONG>), you should code a method for
the other SQL servers to implement the same feature (but slower).  With
<STRONG>MySQL</STRONG> you can use the <CODE>/*!  */</CODE> syntax to add
<STRONG>MySQL</STRONG> specific keywords to a query.  The code inside
<CODE>/**/</CODE> will be treated as a comment (ignored) by most other SQL
servers.

</P>
<P>
If REAL high performance is more important than exactness, like in some
web applications. A possibility is to create a application layer that
caches all results to give you even higher performance. By just letting
old results 'expire' after a while you can keep the cache reasonable
fresh.  This is quite nice in case of extremely high load, in which case
you can dynamically increase the cache to be bigger and set the expire
timeout higher until things gets back to normal.

</P>
<P>
In this case the table creating information should contain information
of the initial size of the cache and how often the table should normally
be refreshed.

</P>


<H2><A NAME="Internal_use" HREF="manual.ja_toc.html#Internal_use">12.11  What have we used MySQL for?</A></H2>

<P>
<STRONG>MySQL</STRONG> の初期の開発期には、<STRONG>MySQL</STRONG> は我々のもっとも大口の顧客に合うように
機能が作成されました。 彼らは、いくつかのスウェーデン最大手の小売り業者
のために、倉庫に入れている（商品）データを取り扱います。

</P>
<P>
我々は、すべての店から、全ボーナス・カード取扱高の、その週間まとめを得ます。
そして、その店のオーナにとって有益な情報、その店の広告キャンペーンが
お客にどの程度影響を及ぼすか、を提供することが、我々に求められています。

</P>
<P>
そのデータは、とても大きくて (約700万/月 回の取り扱い)、
我々はその顧客に提供する必要のあるデータを 4〜10年分、持っています。
我々は、カスタマーから、彼らがこのデータからできる新しいレポートに
”即時に”アクセスしたいという、要求を受けました。

</P>
<P>
我々はこれを、全ての月ごとの情報を圧縮した 'transaction' テーブルに
保存することで解決しました。
We have a set of simple macros/script that
generate summary tables grouped by different criterias (product group,
customer id, store ...) from the transaction tables. 
そのレポートは Web ページで、これは小さな perl スクリプトで動的に
作成されます。 この perl script は Web Page を分析し、SQL 文を
実行し、結果を挿入します。
Now we would have used PHP or mod_perl instead but they where
not available at that time.

</P>
<P>
画像データのために、我々は簡単なツールを <CODE>C</CODE> でかきました。
これは SQL のクエリの結果を元に(結果にいくつか処理をして) GIF を提供します。
これも動的に perl スクリプト(<CODE>HTML</CODE> ファイルを分析する)から実行されます。

</P>
<P>
In most cases a new report can simple by done by copying a existing
script and modifying the SQL query in it.  In some cases we will need to
add more fields to an existing summary table or generate a new one, but
this is also quite simply as we keep all transactions tables on disk.
(Currently we have at least 50G of transactions tables and 200G of other
customer data).

</P>
<P>
We also let our customers access the summary tables directly with ODBC
so that the advanced users can themselves experiment with the data.

</P>
<P>
我々はこれらを  Sun Ultra sparcstation (2x200 Mz) で扱っていますが、
なんの問題もありません。
We recently upgrade one of our servers to a 2
CPU 400 Mz Ultra sparc and we are now planing to start handling
transactions on the product level, which would mean a 10 fold increase
of data. We think we can keep up with this by just adding more disk to
our systems.

</P>
<P>
We are also experimenting with Intel-Linux to be able to get more cpu
power cheaper.  現在、我々はバイナリ互換のデータベースフォーマットを持っており
(new in 3.23) 、我々はこれをアプリケーションのいくつかの部分に使用しはじめる事でしょう。

</P>
<P>
Our initial feelings are that Linux will perform much better on low to
medium load but Solaris will perform better when you start to get a a
high load because of extrema disk IO, but we don't yet have anything
conclusive about this. After some discussion with a Linux Kernel
developer this might be a side effect of Linux giving so much resources
to the batch job that the interactive performance gets very low. This
make the machine feel very slow and unresponsive while big batches are
going. Hopefully this will be better handled in future Linux Kernels.

</P>
<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Replication.html">previous</A>, <A HREF="manual.ja_MySQL_Benchmarks.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
