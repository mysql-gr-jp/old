  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 20 July 2001 -->

  <TITLE>MySQL Reference Manual for version 3.23.38. - 13  MySQL の最大性能をひきだすには</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Fulltext_Search.html">previous</A>, <A HREF="manual.ja_MySQL_Benchmarks.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Performance" HREF="manual.ja_toc.html#Performance">13  MySQL の最大性能をひきだすには</A></H1>

<P>
Optimization is a complicated task because it ultimately requires
understanding of the whole system. While it may be possible to do some
local optimizations with small knowledge of your system/application, the
more optimal you want your system to become the more you will have to
know about it.

</P>
<P>
So this chapter will try to explain and give some examples of different
ways to optimize <STRONG>MySQL</STRONG>. But remember that there are always some
(increasingly harder) additional ways to make the system even faster.

</P>



<H2><A NAME="Optimize_Basics" HREF="manual.ja_toc.html#Optimize_Basics">13.1  最適化 概要</A></H2>

<P>
システムを速くするための最も重要な部分は、もちろん基礎的な設計です。
You also need to know what kinds of things your system will be
doing, and what your bottlenecks are.

</P>
<P>
主なボトルネックは：

<UL>
<LI>Disk シーク ：

一片のデータを見つけるためには、ディスクに時間がかかります。
1999年の最新型のディスクでは、このための平均時間は、10msよりも通常より小さいです。
したがって、我々は、理論上は 1秒で約1000 シークすることができます。
この時間は、一つのテーブルであるならば、データの増加と共にディスクアクセスの時間が
少しずつ増加することになり、とても最適化するのは難しくなっていきます。
これを最適化する方法は、データを 1個以上のディスクに分散する事です。
<LI>Disk reading/writing

When the disk is at the correct position we need to read the data. With
modern disks in 1999, one disk delivers something like 10-20Mb/s. This
is easier to optimize than seeks because you can read in parallel from
multiple disks.
<LI>CPU cycles ：

データをメイン・メモリーの中に入れた(または既にメモリに存在している)場合に、
結果を得るためには、それを処理する必要があります。
メモリー容量よりも小さなテーブルを持っている場合、これは、制限の要因となります。
小さいテーブルでは、スピードは、通常問題にはなりません。
<LI>Memory bandwidth ：

CPU がキャッシュに収まらないようなデータを要求した場合、メイン・メモリー
のバンド幅はボトルネックになります。
これはほとんどのシステムで分かりにくいボトルネックとなりますが、
誰かはそれを知っているべきです。
</UL>

<P>
<A NAME="IDX1157"></A>
<A NAME="IDX1158"></A>
<A NAME="IDX1159"></A>


<H2><A NAME="System" HREF="manual.ja_toc.html#System">13.2  システム、コンパイル時、スタートパラメターのチューニング</A></H2>

<P>
We start with the system level things since some of these decisions have
to be made very early. In other cases a fast look at this part may
suffice because it not that important for the big gains. However, it is always
nice to have a feeling about how much one could gain by changing things
at this level.

</P>
<P>
使うべき OS はとても重要です！ 複数の CPU を持つマシンでは、
Solaris (なぜなら、Solaris のスレッドはとても素晴らしく動作するから)、
あるいは、Linux ( kernel 2.2 は良い SMP をサポートしているから) を
使用すべきです。 32bit マシンの Linux では、2G bytes のファイルサイズの
制限があります。 これは新しいファイルシステム (XFS/ReiserFS) のリリース時に
なくなって欲しいものです。
If you have a desperate need for files bigger
than 2G on Linux-intel 32 bit, you should get the LFS patch for the ext2
file system.

</P>
<P>
Because we have not run <STRONG>MySQL</STRONG> in production on that many platforms, we
advice you to test your intended platform before choosing it, if possible.

</P>
<P>
<A NAME="IDX1160"></A>
Other tips:

<UL>
<LI>

充分 RAM があるならば、全ての swap を外してもよいでしょう。
いくつかのシステムでは、たとえメモリーが空いていても、
swap を使用する場合があります。

<LI>

外部のロックを避けるため、<CODE>--skip-locking</CODE> <STRONG>MySQL</STRONG> オプション
を使用します。 
Note that this will not impact <STRONG>MySQL</STRONG>'s functionality as
long as you only run one server.
<CODE>myisamchk</CODE> を実行する前に、サーバーを止めることを忘れないでください。
On some system
this switch is mandatory because the external locking does not work in any
case.

MIT-pthread でコンパイルする時は <CODE>--skip-locking</CODE> がデフォルトです。
これは全てのプラットフォームで MIT-pthread が <CODE>flock()</CODE> を完全にサポートし
ていないためです。
It's also on default for Linux
as Linux file locking are not yet safe.

<CODE>--skip-locking</CODE> が使用できないただ一つの状態は、
もしあなたが複数の <STRONG>MySQL</STRONG> <EM>サーバー</EM> (クライアントではない) を
同じデータに対して走らせている場合です。
Or run
<CODE>myisamchk</CODE> on the table without first flushing and locking the
<CODE>mysqld</CODE> server tables first.

たとえ <CODE>--skip-locking</CODE> を使用していても、
<CODE>LOCK TABLES</CODE>/<CODE>UNLOCK TABLES</CODE> の使用は可能です。
</UL>



<H3><A NAME="Compile_and_link_options" HREF="manual.ja_toc.html#Compile_and_link_options">13.2.1  MySQL の速度に影響するコンパイルとリンク方法</A></H3>

<P>
次のテストの多くは Linux 上で <STRONG>MySQL</STRONG> ベンチマークで行われました。
しかし、これらは他の OS についてもいくつかの指標を与えます。 

</P>
<P>
<A NAME="IDX1161"></A>
<A NAME="IDX1162"></A>
<A NAME="IDX1163"></A>
<A NAME="IDX1164"></A>

</P>
<P>
<CODE>-static</CODE> でのリンク時に最速の実行形式を得ます。

</P>
<P>
Linux では、<CODE>pgcc</CODE> と <CODE>-O3</CODE> でコンパイルした時に最速のコードを得られます。
このオプションで <TT>`sql_yacc.cc'</TT> をコンパイルすると、<CODE>gcc/pgcc</CODE> は
全ての関数をインラインにするために多くのメモリを必要とするので、200M のメモリが必要です。
<CODE>libstdc++</CODE> ライブラリの増加を避けるためには、
<STRONG>MySQL</STRONG> の configure 時に <CODE>CXX=gcc</CODE> も設定すべきです。 
Note that with some versions of <CODE>pgcc</CODE>,
the resulting code will only run on true Pentium processors, even if you
use the compiler option that you want the resulting code to be working on
all x586 type processors (like AMD).

</P>
<P>
より良いコンパイラー、そしてコンパイラーのオプションは、10-30% の
速度の向上をもたらします。 これはあなた自身が MySQL をコンパイルする
時に重要なことです！

</P>
<P>
我々は Cygnus CodeFusion と Fujitsu コンパイラーでもテストしましたが、
<STRONG>MySQL</STRONG> を最適化オプションでコンパイルするには、
どちらもまだ完全なバグ・フリーではありませんでした。

</P>
<P>
When you compile <STRONG>MySQL</STRONG> you should only include support for the
character sets that you are going to use. (Option <CODE>--with-charset=xxx</CODE>).
The standard <STRONG>MySQL</STRONG> binary distributions are compiled with support
for all character sets.
  
Here is a list of some mesurements that we have done:

<UL>
<LI>

<CODE>pgcc</CODE> を使用して <CODE>-O6</CODE> で全てをコンパイルすると、
<CODE>gcc</CODE> 2.95.2 では、
<CODE>mysqld</CODE> サーバーは 1% 速くなります。 

<LI>

動的リンク(<CODE>-static</CODE>) 無し)の場合、結果は 13% 遅くなります。
Note that you still can use a dynamic linked <STRONG>MySQL</STRONG>
library. It is only the server that is critical for performance.

<LI>

If you strip your <CODE>mysqld</CODE> binary with <CODE>strip libexec/mysqld</CODE>,
the resulting binary can be up to 4 % faster.

<LI>

(localhost への接続に) Unix ソケットの代わりに TCP/IP を使用すると、結果は 7.5% 遅くなります。 
(<CODE>localhost</CODE> へ接続する場合、<STRONG>MySQL</STRONG> はデフォルトではソケット
を使用します)。

<LI>

If you connect using TCP/IP from another computer over a 100M Ethernet,
things will be 8-11 % slower.

<LI>

<CODE>--with-debug=full</CODE> でコンパイルすると、ほとんどのクエリで 20% 遅くな
りますが、いくつかのクエリは実質的にはもっと長くなります(<STRONG>MySQL</STRONG> ベ
ンチマークでは 35% 遅くなりました)。
<CODE>--with-debug</CODE> を使用すると、15% だけ遅くなります。
By starting a <CODE>mysqld</CODE> version compiled with <CODE>--with-debug=full</CODE>
with <CODE>--skip-safemalloc</CODE> the end result should be close to when
configuring with <CODE>--with-debug</CODE>.

<LI>

SPARCstation 20 では、<CODE>gcc</CODE> 2.95.2 は Sun Pro C++ 4.2 より 5% 速くなります。

<LI>

UltraSPARC で <CODE>gcc</CODE> 2.95.2 でオプション <CODE>-mcpu=v8
-Wa,-xarch=v8plusa</CODE> をつけてコンパイルすると 4% 良い性能が得られます。

<LI>

シングルプロセッサの Solaris 2.5.1 では、MIT-pthreads は Solaris ネイティブスレッドより 8-12% 遅くなります。
With more load/CPUs the difference should
get bigger.

<LI>

<CODE>--log-bin</CODE> での実行は <STRONG>MySQL</STRONG> を 1% 遅くします。

<LI>

Compiling on Linux-x86 using gcc without frame pointers
<CODE>-fomit-frame-pointer</CODE> or <CODE>-fomit-frame-pointer -ffixed-ebp</CODE>
<CODE>mysqld</CODE> 1-4% faster.
</UL>

<P>
The <STRONG>MySQL</STRONG>-Linux distribution provided by <STRONG>MySQL AB</STRONG> used
to be compiled with <CODE>pgcc</CODE>, but we had to go back to regular gcc
because of a bug in <CODE>pgcc</CODE> that would generate the code that does
not run on AMD. We will continue using gcc until that bug is resolved.
In the meantime, if you have a non-AMD machine, you can get a faster
binary by compiling with <CODE>pgcc</CODE>.  The standard <STRONG>MySQL</STRONG>
Linux binary is linked statically to get it faster and more portable.

</P>
<P>
<A NAME="IDX1165"></A>
<A NAME="IDX1166"></A>


<H3><A NAME="Disk_issues" HREF="manual.ja_toc.html#Disk_issues">13.2.2  Disk の問題</A></H3>


<UL>
<LI>

前に述べたディスクシークが大きなボトルネックです。 この問題は、データが効果的に
キャッシングが不可能になるほど、大きくなり始めるときに、だんだん明白になってきます。
For large databases,
where you access data more or less randomly, you can count on that you
will need at least one disk seek to read and a couple of disk seeks to
write things. この問題を少なくするには、diskシーク時間の少ないディスクを
使用します。
<LI>

利用できるディスクスピンドルの数を増やします(それによってディスクシーク
のオーバーヘッドは縮小します)。
これは違うディスクにシンボリックリンクをはったり、ストライピングを行うことで
可能です。
<DL COMPACT>

<DT><STRONG>symbolic link の使用</STRONG>
<DD>
これは通常のデータディレクトリから、違うディスクへ、
インデックスやデータファイルをシンボリック・リンクすることです。
これは シーク と リード を速くします。 (もしそのディスクが
他に使用されていなければ).  「<A HREF="manual.ja_Performance.html#Symbolic_links">13.2.2.1  データベースとテーブルにシンボリックリンクを使用する</A>」節参照.
<A NAME="IDX1167"></A>
<DT><STRONG>Striping</STRONG>
<DD>
ストライピングは、複数のディスクに対して、まずデータの最初のブロックを
1番目の disk に書き、2番目のブロックを2つ目のdiskに書き、順次 N 番目
(N は disk の数) まで順に書いていきます。 これは、もしデータがストライプの
サイズよりも小さければ、よりよいパフォーマンスを得ることが出来ます。
ストライピングは、OS や ストライプのサイズにとても依存していることに注意してください。
そのため、あなたのアプリケーションのベンチマークがストライプサイズによって
変わるでしょう。  「<A HREF="manual.ja_Performance.html#Benchmarks">13.7  Using Your Own Benchmarks</A>」節参照.

ストライピングのスピードの違いは、<STRONG>とても</STRONG> パラメターに依存しています。
Depending on how you set the striping parameters and
number of disks you may get a difference in orders of magnitude. Note that
you have to choose to optimize for random or sequential access.
</DL>
<LI>

信頼性のため、あなたは RAID 0+1 (striping + mirroring) を使用したいと
思うかもしれません。 しかしこれは N 個のドライブのデータを収めるのに
2*N 個のドライブが必要となります。
これはもし資金があるならば一番よい方法でしょう！ しかし、能率的にそれを
取り扱うために、ボリューム・マネージメント・ソフトウェアに投資する必要が
あってもよいです。
<LI>

A good option is to have semi-important data (that can be regenerated)
on RAID 0 disk while storing really important data (like host information
and logs) on a RAID 0+1 or RAID N disk. RAID N can be a problem if you
have many writes because of the time to update the parity bits.
<LI>

データベースに使用しているファイルシステムの mount パラメターを変更しても
良いでしょう。 一つの簡単な方法としては、noatime オプションでファイルシステムを
マウントします。 これは inode にある最後にアクセスした時間の更新を
スキップします。 これでいくらか ディスクシークを避けることができるでしょう。
<LI>

On Linux, you can get much more performance (up to 100 % under load is
not uncommon) by using hdpram to configure your disk's interface!  The
following should be quite good hdparm options for <STRONG>MySQL</STRONG> (and
probably many other applications):

<PRE>
hdparm -m 16 -d 1

</PRE>

Note that the performance/reliability when using the above depends on
your hardware, so we strongly suggest that you test your system
thoroughly after using <CODE>hdparm</CODE>!  Please consult the <CODE>hdparm</CODE>
man page for more information!  If <CODE>hdparm</CODE> is not used wisely,
filesystem corruption may result.  Backup everything before experimenting!
<LI>

On many operating systems you can mount the disks with the 'async' flag to set the file
system to be updated asynchronously.  If your computer is reasonable stable,
this should give you more performance without sacrificing too much reliability.
(This flag is on by default on Linux.)
<LI>

If you don't need to know when a file was last accessed (which is not
really useful on a database server), you can mount your file systems
with the noatime flag.
</UL>

<P>
<A NAME="IDX1168"></A>
<A NAME="IDX1169"></A>
<A NAME="IDX1170"></A>
<A NAME="IDX1171"></A>


<H4><A NAME="Symbolic_links" HREF="manual.ja_toc.html#Symbolic_links">13.2.2.1  データベースとテーブルにシンボリックリンクを使用する</A></H4>

<P>
テーブルとデータベースのファイルを MySQL のデータベースディレクトリーから
違う場所に移動し、 それに対してシンボリックリンクを張ることができます。
これは例えばディスク容量が少なくなって、データベースを移動したい場合にそうしたくなるでしょう。 

</P>
<P>
<STRONG>MySQL</STRONG> が、テーブルがシンボリックリンクであることに気づいた場合、
symlink を解析し、代わりにその実体のテーブルを使用します。
これは <CODE>realpath()</CODE> コールをサポートする全てのシステムで働きます（少
なくとも Linux と Solaris は <CODE>realpath()</CODE> をサポートします！）。
<CODE>realpath()</CODE> をサポー トしないシステム上では、symlink とテーブルを
同時に使用すべきでありません！ テーブルはテーブルの更新後に矛盾する事になるでしょう。 

</P>
<P>
<STRONG>MySQL</STRONG> はデフォルトではデータベース同士のリンクをサポートしません。
が、データベース間のシンボリックリンクを作成しない限り、これは正常に働くでしょう。
<STRONG>MySQL</STRONG> データディレクトリに <CODE>db1</CODE> データベースがあるとして、
仮に <CODE>db2</CODE> を <CODE>db1</CODE> のシンボリックリンクにしたとします: 

</P>

<PRE>
shell&#62; cd /path/to/datadir
shell&#62; ln -s db1 db2
</PRE>

<P>
すると、<CODE>db1</CODE> 中の <CODE>tbl_a</CODE> テーブルは <CODE>db2</CODE> の  <CODE>tbl_a</CODE> テーブルとして見えます。
もしあるスレッドが <CODE>db1.tbl_a</CODE> を更新し、他のスレッドが <CODE>db2.tbl_a</CODE> を
更新した場合、 問題が発生します。 

</P>
<P>
こういった使用をどうしてもしたい場合、<TT>`mysys/mf_format.c'</TT> を以下のように変更します: 

</P>

<PRE>
if (flag &#38; 32 || (!lstat(to,&#38;stat_buff) &#38;& S_ISLNK(stat_buff.st_mode)))
</PRE>

<P>
to

</P>

<PRE>
if (1)
</PRE>

<P>
On Windows you can use internal symbolic links to directories by compiling
<STRONG>MySQL</STRONG> with <CODE>-DUSE_SYMDIR</CODE>. This allows you to put different
databases on different disks.  「<A HREF="manual.ja_Installing.html#Windows_symbolic_links">4.13.6  Windows において、異なるディスクをまたがるようにデータを分割する</A>」節参照.

</P>
<P>
<A NAME="IDX1172"></A>
<A NAME="IDX1173"></A>
<A NAME="IDX1174"></A>
<A NAME="IDX1175"></A>


<H3><A NAME="Server_parameters" HREF="manual.ja_toc.html#Server_parameters">13.2.3  サーバーパラメーターのチューニング</A></H3>

<P>
<CODE>mysqld</CODE> サーバーが使用している現在のバッファサイズを次で得ることができます:

</P>

<PRE>
shell&#62; mysqld --help
</PRE>

<P>
<A NAME="IDX1176"></A>
<A NAME="IDX1177"></A>
この結果、全ての <CODE>mysqld</CODE> オプションと次のようなコンフィグ可能変数のリスト
を得られます。出力結果にはデフォルト値が含まれ、以下のように表示されます:

</P>

<PRE>
Possible variables for option --set-variable (-O) are:
back_log              current value: 5
bdb_cache_size        current value: 1048540
binlog_cache_size     current_value: 32768
connect_timeout       current value: 5
delayed_insert_timeout  current value: 300
delayed_insert_limit  current value: 100
delayed_queue_size    current value: 1000
flush_time            current value: 0
interactive_timeout   current value: 28800
join_buffer_size      current value: 131072
key_buffer_size       current value: 1048540
lower_case_table_names  current value: 0
long_query_time       current value: 10
max_allowed_packet    current value: 1048576
max_binlog_cache_size current_value: 4294967295
max_connections       current value: 100
max_connect_errors    current value: 10
max_delayed_threads   current value: 20
max_heap_table_size   current value: 16777216
max_join_size         current value: 4294967295
max_sort_length       current value: 1024
max_tmp_tables        current value: 32
max_write_lock_count  current value: 4294967295
myisam_sort_buffer_size  current value: 8388608
net_buffer_length     current value: 16384
net_retry_count       current value: 10
net_read_timeout      current value: 30
net_write_timeout     current value: 60
query_buffer_size     current value: 0
record_buffer         current value: 131072
slow_launch_time      current value: 2
sort_buffer           current value: 2097116
table_cache           current value: 64
thread_concurrency    current value: 10
tmp_table_size        current value: 1048576
thread_stack          current value: 131072
wait_timeout          current value: 28800
</PRE>

<P>
もし <CODE>mysqld</CODE> サーバーを走らせているなら、以下のコマンドでも変数の値を見ることができます:

</P>

<PRE>
shell&#62; mysqladmin variables
</PRE>

<P>
<CODE>SHOW VARIABLES</CODE> のすべての変数の説明はこちら →  「<A HREF="manual.ja_Reference.html#SHOW_VARIABLES">7.28.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.

</P>
<P>
稼働中のサーバーの統計情報は <CODE>SHOW STATUS</CODE> で参照できます.  「<A HREF="manual.ja_Reference.html#SHOW_STATUS">7.28.3  <CODE>SHOW STATUS</CODE></A>」節参照.

</P>
<P>
<STRONG>MySQL</STRONG> はとてもスケーラブルなアルゴリズムを使用します。そのため
通常はとても少ないメモリで動作します。しかし <STRONG>MySQL</STRONG> に多くのメモリを与えれば、
より良い性能を得ることができます。

</P>
<P>
When tuning a <STRONG>MySQL</STRONG> server, the two most important variables to use
are <CODE>key_buffer_size</CODE> and <CODE>table_cache</CODE>.  You should first feel
confident that you have these right before trying to change any of the
other variables.

</P>
<P>
多くのメモリ(&#62;=256M)と多くのテーブルを持っていて、適度のクライアント数で最大性能を得た
い場合、次のようなものを使用します:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=64M -O table_cache=256 \
           -O sort_buffer=4M -O record_buffer=1M &#38;
</PRE>

<P>
If you have only 128M and only a few tables, but you still do a lot of
sorting, you can use something like:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=16M -O sort_buffer=1M
</PRE>

<P>
多くの接続で少ないメモリしかない場合、次のようなものを使用します:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=100k \
           -O record_buffer=100k &#38;
</PRE>

<P>
or even:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=16k \
           -O table_cache=32 -O record_buffer=8k -O net_buffer=1K &#38;
</PRE>

<P>
When you have installed <STRONG>MySQL</STRONG>, the <TT>`support-files'</TT> directory will
contain some different <CODE>my.cnf</CODE> example files, <TT>`my-huge.cnf'</TT>,
<TT>`my-large.cnf'</TT>, <TT>`my-medium.cnf'</TT>, and <TT>`my-small.cnf'</TT>, you can
use as a base to optimize your system.

</P>
<P>
もしとても多くの接続があり、<CODE>mysqld</CODE> が各接続に対して少ないメモリーで
動作するように設定されていれば、スワップの読み書きによるパフォーマンスの低下がおきます。
もちろん十分なメモリーがあれば、全ての接続にたいして <CODE>mysqld</CODE> のパフォーマンス良くなります。

</P>
<P>
<CODE>mysqld</CODE> へのオプションを変更する場合、そのサーバのインスタンスにだけに
有効であることに注意して下さい。

</P>
<P>
パラメータ変更の効果を見るには、このようにします:

</P>

<PRE>
shell&#62; mysqld -O key_buffer=32m --help
</PRE>

<P>
<CODE>--help</CODE> オプションは最後につけてください。
その他のオプションを --help の後につけると、そのオプションは反映されません。

</P>
<P>
<A NAME="IDX1178"></A>
<A NAME="IDX1179"></A>
<A NAME="IDX1180"></A>
<A NAME="IDX1181"></A>
<A NAME="IDX1182"></A>
<A NAME="IDX1183"></A>


<H3><A NAME="Table_cache" HREF="manual.ja_toc.html#Table_cache">13.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A></H3>

<P>
<CODE>table_cache</CODE> , <CODE>max_connections</CODE> , <CODE>max_tmp_tables</CODE> は
サーバーが開いた状態にしておく事が出来るファイルの最大数に影響します。
もしこれらの変数のうちの一つ、あるいは複数を増加させるなら、
あなたのオペレーティング・システムの、1 プロセスあたりに開かれる
 ファイル・デスクリプタ の最大値を増やすことになるかもしれません。
多くのシステムではこの制限を増やすことが可能です。
これをどうやって行うかは、あなたの使用している OS のドキュメントを見てください。
制限値の変更方法は、システムによってまちまちだからです。

</P>
<P>
<CODE>table_cache</CODE> は <CODE>max_connections</CODE> に関連します。
例えば 200 のコネクションを同時に開けるなら、少なくとも <CODE>200 * n</CODE> の
テーブル・キャッシュが必要です。 ここで <CODE>n</CODE> は join におけるテーブルの
最大数です。

</P>
<P>
オープンテーブルのキャッシュは最大で <CODE>table_cache</CODE> まで大きくなります(デ
フォルトは 64, <CODE>mysqld</CODE> のオプション <CODE>-O table_cache=#</CODE> で変更可能)。
キャッシュが一杯になって、他のスレッドがテーブルのオープンを試みた時、
または <CODE>mysqladmin refresh</CODE> <CODE>mysqladmin flush-tables</CODE>
を使用した場合を除いて、テーブルはクローズされません。

</P>
<P>
キャッシュがいっぱいになった場合、サーバーは以下の処置を取って
キャッシュを使用できるように配置します：

</P>

<UL>
<LI>

現在使われていないテーブルが解放されます。もっとも使用されていないテーブルからから順に。

<LI>

もしキャッシュが一杯でテーブルを解放することが出来ず、さらに新しいテーブルの
オープン要求がある場合、キャッシュは一時的な拡張を必要とします。

<LI>

もしそのキャッシュが一時拡張に配置されていて、かつ、テーブルが使用状態から
未使用状態に移行した場合、そのテーブルは閉じられ、キャッシュから解放されます。
</UL>

<P>
テーブルは各同時アクセスに (再び) オープンされます。これは、同じテーブルで2つのスレッ
ドが実行されている場合、または同じクエリで(<CODE>AS</CODE> で)テーブルを2回アクセス
する場合、テーブルは2回オープンする必要があることを意味します。最初のテーブルのオー
プンは2つのファイル記述子を使用し、続くテーブルの各使用は1つだけのファイル記述
子を使用します。

</P>

<P>
You can check if your table cache is too small by checking the mysqld
variable <CODE>opened_tables</CODE>.  If this is quite big, even if you
haven't done a lot of <CODE>FLUSH TABLES</CODE>, you should increase your table
cache.  「<A HREF="manual.ja_Reference.html#SHOW_STATUS">7.28.3  <CODE>SHOW STATUS</CODE></A>」節参照.

</P>
<P>
<A NAME="IDX1184"></A>


<H3><A NAME="Creating_many_tables" HREF="manual.ja_toc.html#Creating_many_tables">13.2.5  Drawbacks of creating large numbers of tables in the same database</A></H3>

<P>
もしたくさんのファイルが一つのディレクトリにある場合、オープン、クローズ、
create 操作は遅くなるでしょう。 もし <CODE>SELECT</CODE> 文を多くのテーブルに対し
実行した場合、テーブルキャッシュが一杯ならば、このオーバーヘッドは多くなるでしょう。
なぜなら、それぞれのテーブルにつきオープンし、クローズしなくてはならないからです。
このオーバーヘッドを緩和するには、テーブルキャッシュを大きくします。

</P>
<P>
<A NAME="IDX1185"></A>
<A NAME="IDX1186"></A>


<H3><A NAME="Open_tables" HREF="manual.ja_toc.html#Open_tables">13.2.6  何故そんなに多くのテーブルをオープンするのか？</A></H3>

<P>
<CODE>mysqladmin status</CODE> を実行すると、次のようなものが得られます:

</P>

<PRE>
Uptime: 426 Running threads: 1 Questions: 11082 Reloads: 1 Open tables: 12
</PRE>

<P>
確かにたった6個しかテーブルがないのに、このような結果が出るので少々戸惑われるかもしれません。

</P>
<P>
<STRONG>MySQL</STRONG> はマルチスレッドなので、同じテーブルで一度に多くのクエリを持て
ます。同じファイル上で異なる状態を持つ2つのスレッドで、問題を最小化する
ため、同時に動作する各スレッドのためテーブルを再びオープンします。これはいくつ
かのメモリとデータファイルについての一つの拡張ファイル記述子を使用します。
インデックスファイル記述子は全てのスレッド間で共有されます。

</P>

<P>
<A NAME="IDX1187"></A>


<H3><A NAME="Memory_use" HREF="manual.ja_toc.html#Memory_use">13.2.7  MySQL はどのようにメモリを使用するのか？</A></H3>

<P>
以下に <CODE>mysqld</CODE> サーバーがどのようにメモリーを使用するか、いくつか示します。
サーバーに与える変数名は、サーバーのメモリーの使用方に関連した名前となっています:

</P>

<UL>
<LI>

キーバッファ (変数 <CODE>key_buffer</CODE>) は全てのスレッドで共有され、
残りは必要時に割り当てられます。
 「<A HREF="manual.ja_Performance.html#Server_parameters">13.2.3  サーバーパラメーターのチューニング</A>」節参照.

<LI>

各接続はいくつかのスレッド空間を使用します；
スタック (64K, 変数 <CODE>thread_stack</CODE>), 接続バッファ(variable
<CODE>net_buffer_length</CODE>), 結果バッファ(variable
<CODE>net_buffer_length</CODE>)。接続バッファと結果バッファは必要となった時、
動的に最大 <CODE>max_allowed_packet</CODE> まで増えます。
クエリが走っている時、そのクエリの文字のコピーが割り当てられます。

<LI>

全てのスレッドは同じベースメモリを共有します。

<LI>

圧縮された ISAM / MyISAM だけが、memory mapped されます。
これは 4GB の 32bit メモリ空間は多くの大きなテーブルを扱うには小さいためです。
64bit アドレス空間を持つシステムがより普及すれば、我々は mmemory mapping を通常にサポートします。

<LI>

テーブルを越えて順次スキャンを行なう各要求は、読み込みバッファを割り当てます
(変数 record_buffer)

<LI>

全ての結合は1パスで行なわれ、多くの結合は一時テーブルを使用せずに行なわ
れます。多くの一時テーブルはメモリベース(HEAP)のテーブルです。大きなレコー
ドサイズ (= 全フィールド長の合計) を持つ一時テーブルまたは、<CODE>BLOB</CODE> を含む
テーブルはディスク上に置かれます。

<STRONG>MySQL</STRONG> バージョン 3.23.2 以前での問題は、HEAP テーブルが 
<CODE>tmp_table_size</CODE> のサイズを越えると、エラー <CODE>The table tbl_name is full</CODE>
が出ることです。将来我々は、必要時にメモリ (HEAP) テーブルをディスクベー
ス (NISAM) テーブルに自動的に変更することにより、これを修正します。この
問題を回避するため、<CODE>mysqld</CODE> への <CODE>tmp_table_size</CODE> オプションま
たはクライアント側で SQL オプション <CODE>SQL_BIG_TABLES</CODE> で増加できます。
 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.33  <CODE>SET</CODE> 構文</A>」節参照.
<STRONG>MySQL</STRONG> バージョン 3.20 では、一時テーブルの最大サイズは 
<CODE>recordbuffer*16</CODE> でした。そのため、このバージョンを使用していると、
<CODE>recordbuffer</CODE> を追加する必要があります。 <CODE>mysqld</CODE> を <CODE>--big-tables</CODE> で
開始することで、常に一時テーブルをディスク上に格納できます。しかしこれは
多くの複雑なクエリの速度に影響します。

<LI>

ほとんどのリクエストは、0-2個の一時ファイルとわずかなソートバッファへの割り当てを行います。
 「<A HREF="manual.ja_Problems.html#Temporary_files">21.6  <STRONG>MySQL</STRONG> が一時ファイルを格納する場所</A>」節参照.

<LI>

変形と演算時に使用されるほとんど全てのメモリはローカルメモリストア内で行
なわれます。小さな項目に必要とされるメモリオーバーヘッドはなく、通常の遅
いメモリ割り当て/解放が回避されます。メモリは予期しない大きな文字列にだ
け割り当てられます(これは <CODE>malloc()</CODE> と <CODE>free()</CODE> で行なわれます)。

<LI>

各インデックスファイルは一度オープンされ、データファイルは各同時実行スレッ
ド毎に一度オープンされます。各同時スレッドには、テーブル構造、各フィールドの構造そし
て <CODE>3 * n</CODE> のサイズのバッファが割り当てられます。
( <CODE>n</CODE> は <CODE>BLOB</CODE> 型のフィールドの長さを含めない、一レコードの最大長です )
<CODE>BLOB</CODE> は 5 から 8 バイト + <CODE>BLOB</CODE> データの長さを使用します。
The <CODE>ISAM</CODE>/<CODE>MyISAM</CODE> table handlers will use one extra row
buffer for internal usage.

<LI>

<CODE>BLOB</CODE> を持つ各テーブルでは、より大きな <CODE>BLOB</CODE> の読み込みでバッファ
は動的に拡大されます。テーブルのスキャンをする場合、割り当てられたバッファは最
も大きい <CODE>BLOB</CODE> と同じ大きさになります。

<LI>

全ての使用されているテーブルのテーブルハンドラーはキャッシュ内に保存され、
FIFO として管理されます。
通常、キャッシュは 64 個のテーブルです。テーブルが 2 つの実行しているス
レッドで同時に使用される場合、キャッシュ内にテーブルの 2 つのエントリが
あります。
 「<A HREF="manual.ja_Performance.html#Table_cache">13.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A>」節参照.

<LI>

<CODE>mysqladmin flush-tables</CODE> は使用されていない全てのテーブルをクローズし、
使用されている全てのテーブルを、実行中スレッドが終った時にクローズするよ
うにマークします。これは多くの使用メモリを解放するのに有効です。全てのロ
グファイルもクローズと再オープンされます。
</UL>

<P>
<STRONG>mysqld</STRONG> 実行時、<CODE>ps</CODE> や他のプログラムは、それが多くのメモリ
を使用していると報告するでしょう。これは異なったメモリアドレス上のスレッ
ドスタックによって発生します。例えば、Solaris ps はスタック間の未使用メ
モリを使用メモリとして計算します。'swap -s' で有効なスワップをチェックす
ることでこれを確かめられます。我々は市販のメモリリーク検出プログラムで 
<CODE>mysqld</CODE> をテストしました。そのため、メモリリークは全くありません。

</P>
<P>
<A NAME="IDX1188"></A>
<A NAME="IDX1189"></A>
<A NAME="IDX1190"></A>


<H3><A NAME="Internal_locking" HREF="manual.ja_toc.html#Internal_locking">13.2.8  <STRONG>MySQL</STRONG> はどのようにテーブルをロックするか</A></H3>

<P>
You can find a discussion about different locking methods in the appendix.
 「<A HREF="manual.ja_Porting.html#Locking_methods">I.4  Locking methods</A>」節参照.

</P>
<P>
<STRONG>MySQL</STRONG> の全てのロックはデッドロックフリーです。これは、常にクエ
リ開始時に一度ロックを必要とする全てを要求し、常に同じ順でテーブルをロッ
クすることで管理されます。

</P>
<P>
<STRONG>MySQL</STRONG> が使用する <CODE>WRITE</CODE> ロックは次のように働きます:

</P>

<UL>
<LI>

テーブル上にロックがない場合 write ロックを置きます。
<LI>

そうでなければ write ロックキューにロックを置きます。
</UL>

<P>
<STRONG>MySQL</STRONG> の <CODE>READ</CODE> ロックは次のように動きます:

</P>

<UL>
<LI>

テーブル上に write ロックがない場合 read ロックを置きます。
<LI>

そうでなければ read ロックキューにロックを置きます。
</UL>

<P>
ロックが解放されたとき、最初に write ロックキュー内のスレッドに、その後 
read ロックキュー内のスレッドにロックを与えます。

</P>
<P>
これは、同じテーブルで多くの更新をする場合、<CODE>SELECT</CODE> 構文は 
update がなくなるまで待たされることを意味します。

</P>
<P>
同じテーブルで多くの <CODE>INSERT</CODE> と多くの <CODE>SELECT</CODE> を行う場合、これを解決するに
は、他のテーブルに行を挿入して、たまに、その一時テーブルから全てのレコー
ドをもう一方のテーブルに update します。

</P>
<P>
これは次のコードで行えます:

<PRE>
mysql&#62; LOCK TABLES real_table WRITE, insert_table WRITE;
mysql&#62; insert into real_table select * from insert_table;
mysql&#62; TRUNCATE TABLE insert_table;
mysql&#62; UNLOCK TABLES;
</PRE>

<P>
You can use the <CODE>LOW_PRIORITY</CODE> options with <CODE>INSERT</CODE>,
<CODE>UPDATE</CODE> or <CODE>DELETE</CODE> or <CODE>HIGH_PRIORITY</CODE> with
<CODE>SELECT</CODE> if you want to prioritize retrieval in some specific
cases.  You can also start <CODE>mysqld</CODE> with <CODE>--low-priority-updates</CODE>
to get the same behaveour.

</P>
<P>
Using <CODE>SQL_BUFFER_RESULT</CODE> can also help making table locks shorter.
 「<A HREF="manual.ja_Reference.html#SELECT">7.19  <CODE>SELECT</CODE>構文</A>」節参照.

</P>
<P>
一つのキューだけを使用するように <TT>`mysys/thr_lock.c'</TT> 内のロックコードを変更
することもできます。この場合、いくつかのアプリケーションのために、
write ロックは read ロックと同じ優先順位にします。

</P>
<P>
<A NAME="IDX1191"></A>


<H3><A NAME="Table_locking" HREF="manual.ja_toc.html#Table_locking">13.2.9  テーブル・ロッキングの問題</A></H3>

<P>
<STRONG>MySQL</STRONG> のテーブル・ロッキングのコードはデッドロック・フリーです。

</P>
<P>
<STRONG>MySQL</STRONG> はとても速いロックスピードを得るために、
(レコードのロックやフィールドのロックの代わりに) テーブルのロックを使用します。
大きなテーブルには、 テーブルのロックはレコードのロックよりはるかに良いですが、
いくつかの落とし穴があります。

</P>
<P>
For <CODE>BDB</CODE> and <CODE>InnoDB</CODE> tables, <STRONG>MySQL</STRONG> only uses table
locking if you explicitely lock the table with <CODE>LOCK TABLES</CODE> or
execute a command that will modify every row in the table, like
<CODE>ALTER TABLE</CODE>.  For these table types we recommend you to not use
<CODE>LOCK TABLES</CODE> at all.

</P>
<P>
<STRONG>MySQL</STRONG> バージョン 3.23.7 以上では、
あるスレッドが <CODE>MyISAM</CODE> テーブルを読んでいる最中に、
同じテーブルにレコードを挿入する事ができます。
Note that currently this only works if there are no holes after
deleted rows in the table at the time the insert is made. When all holes
has been filled with new data, concurrent inserts will automaticly be
enabled again.

</P>
<P>
テーブルのロックはたくさんのスレッドが同時にあるテーブルから読み出すのを可能にしますが、
もしあるスレッドがあるテーブルに対し書込み要求を出す場合、
それはまず最初に排他的なアクセスを得なければなりません.
その更新の間、更新が完了するまで、この特定のテーブルにアクセスしようとする
他の全てのスレッドが待たされることになります。

</P>
<P>
通常データベースの更新は <CODE>SELECT</CODE> よりも重要とされるため、
テーブルを更新する全てのスレッドが、テーブルから情報を検索するスレッドよりも
高い優先順位を持ちます。 これは ある特定のテーブルに対して、多くの重いクエリが発行され
た場合に、 更新が不完全に終わらないことを確実にするためです。
(You can change this by using
LOW_PRIORITY with the statement that does the update or
<CODE>HIGH_PRIORITY</CODE> with the <CODE>SELECT</CODE> statement.)

</P>
<P>
<STRONG>MySQL バージョン 3.23.7</STRONG> から、<CODE>max_write_lock_count</CODE> 変数が使用できます。
これは、一つのテーブルに対して、指定された回数だけ INSERT が行われた後に、
<CODE>SELECT</CODE> を発行するようにします。

</P>
<P>
テーブルロッキングは以下の場合にはあまり良くありません：

</P>

<UL>
<LI>

あるクライアントが実行に長い時間のかかる <CODE>SELECT</CODE> を発行。
<LI>

その後に、他のクライアントが、使用されているテーブルに対し <CODE>UPDATE</CODE> を発行；
このクライアントは先の <CODE>SELECT</CODE> が完了するまで待ちます
<LI>

さらに他のクライアントが同じテーブルに対して <CODE>SELECT</CODE> 構文を発行；
<CODE>UPDATE</CODE> は <CODE>SELECT</CODE> よりも高い優先度を持つので、
この <CODE>SELECT</CODE> は先の <CODE>UPDATE</CODE> が完了するまで待ちます。
これは一番最初の <CODE>SELECT</CODE> が 終了するまで待たされます！
<LI>

A thread is waiting for something like <CODE>full disk</CODE>, in which case all
threads that wants to access the problem table will also be put in a waiting
state until more disk space is made available.
</UL>

<P>
この問題のいくつかの可能な解決は以下の通りです：

</P>

<UL>
<LI>

<CODE>SELECT</CODE> 構文を速く実行できるように試みます； これを行うにあたり、
いくつかのサマリーテーブルを作成しなければならないかもしれません.

<LI>

<CODE>mysqld</CODE> を <CODE>--low-priority-updates</CODE> オプションで起動。
これは全てのあるテーブルを更新する構文に対して、 <CODE>SELECT</CODE> 構文よりも
低い優先度を与えます。 この場合、前述のシナリオ中の最後の <CODE>SELECT</CODE> 構文は
<CODE>INSERT</CODE> 構文が完了する前に実行されます。

<LI>

<CODE>LOW_PRIORITY</CODE> 属性指定を用いて、 <CODE>INSERT</CODE>,<CODE>UPDATE</CODE>,<CODE>DELETE</CODE> 構文
に低い優先度を与えることも出来ます。

<LI>

Start <CODE>mysqld</CODE> with a low value for <STRONG>max_write_lock_count</STRONG> to give
<CODE>READ</CODE> locks after a certain number of <CODE>WRITE</CODE> locks.

<LI>

SQL コマンドの <CODE>SET SQL_LOW_PRIORITY_UPDATES=1</CODE> を使用して、
ある特定のスレッドからの全ての更新を、低い優先度に指定する事ができます。
 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.33  <CODE>SET</CODE> 構文</A>」節参照.

<LI>

<CODE>HIGH_PRIORITY</CODE> 属性を用いて、特定の <CODE>SELECT</CODE> がとても重要であると
指定することが可能です。.  「<A HREF="manual.ja_Reference.html#SELECT">7.19  <CODE>SELECT</CODE>構文</A>」節参照.

<LI>

もし <CODE>INSERT</CODE> と <CODE>SELECT</CODE> をあわせて使用した場合に問題が起きた場合、
新しい <CODE>MyISAM</CODE> テーブルに切り替えます。 これは <CODE>SELECT</CODE>
と <CODE>INSERT</CODE> を同時に行えます。

<LI>

もし <CODE>INSERT</CODE> と <CODE>SELECT</CODE> 構文を主に混在させるのなら、
<CODE>INSERT</CODE> の <CODE>DELAYED</CODE> 属性指定はこの問題を解決させるでしょう。
 「<A HREF="manual.ja_Reference.html#INSERT">7.21  <CODE>INSERT</CODE>構文</A>」節参照.

<LI>

もし <CODE>SELECT</CODE> と <CODE>DELETE</CODE> で問題があるなら、
<CODE>DELETE</CODE> の <CODE>LIMIT</CODE> オプションが助けになるでしょう。
  「<A HREF="manual.ja_Reference.html#DELETE">7.17  <CODE>DELETE</CODE>構文</A>」節参照.
</UL>

<P>
<A NAME="IDX1192"></A>
<A NAME="IDX1193"></A>


<H3><A NAME="DNS" HREF="manual.ja_toc.html#DNS">13.2.10  How MySQL uses DNS</A></H3>

<P>
When a new thread connects to <CODE>mysqld</CODE>, <CODE>mysqld</CODE> will span a
new thread to handle the request.  This thread will first check if the
hostname is in the hostname cache. If not the thread will call
<CODE>gethostbyaddr_r()</CODE> and <CODE>gethostbyname_r()</CODE> to resolve the
hostname.

</P>
<P>
If the operating system doesn't support the above thread-safe calls, the
thread will lock a mutex and call <CODE>gethostbyaddr()</CODE> and
<CODE>gethostbyname()</CODE> instead. Note that in this case no other thread
can resolve other hostnames that is not in the hostname cache until the
first thread is ready.

</P>
<P>
You can disable DNS host lookup by starting <CODE>mysqld</CODE> with
<CODE>--skip-name-resolve</CODE>.  In this case you can however only use IP
names in the <STRONG>MySQL</STRONG> privilege tables.

</P>
<P>
If you have a very slow DNS and many hosts, you can get more performance by
either disabling DNS lookop with <CODE>--skip-name-resolve</CODE> or by
increasing the <CODE>HOST_CACHE_SIZE</CODE> define (default: 128) and recompile
<CODE>mysqld</CODE>.

</P>
<P>
You can disable the hostname cache with <CODE>--skip-host-cache</CODE>. You
can clear the hostname cache with <CODE>FLUSH HOSTS</CODE> or <CODE>mysqladmin
flush-hosts</CODE>.

</P>
<P>
If you don't want to allow connections over <CODE>TCP/IP</CODE>, you can do this
by starting mysqld with <CODE>--skip-networking</CODE>.

</P>
<P>
<A NAME="IDX1194"></A>
<A NAME="IDX1195"></A>
<A NAME="IDX1196"></A>
<A NAME="IDX1197"></A>
<A NAME="IDX1198"></A>


<H2><A NAME="Data_size" HREF="manual.ja_toc.html#Data_size">13.3  可能な限りデータを小さくする</A></H2>

<P>
One of the most basic optimization is to get your data (and indexes) to
take as little space on the disk (and in memory) as possible. This can
give huge improvements because disk reads are faster and normally less
main memory will be used. Indexing also takes less resources if
done on smaller columns.

</P>
<P>
<STRONG>MySQL</STRONG> supports a lot of different table types and row formats.
Choosing the right table format may give you a big performance gain.
 「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL Table types</A>」節参照.

</P>
<P>
以下に挙げるテクニックを使用すれば、テーブルでのパフォーマンスの向上、
保存領域の縮小化が可能でしょう：

</P>

<UL>
<LI>

可能ならば、一番小さな型を使用します。 <STRONG>MySQL</STRONG> は
ディスクとメモリーを節約する多くの型を持っています。
<LI>

より小さな整数型を可能ならば使用します。 例えば、
<CODE>MEDIUMINT</CODE> は <CODE>INT</CODE> より良いでしょう。
<LI>

可能ならフィールドを <CODE>NOT NULL</CODE> に定義してください。これは全てをより速くし、
各フィールド毎に1ビットを節約します。
Note that if you really need
<CODE>NULL</CODE> in your application you should definitely use it. Just avoid
haveing it on all columns by default.
<LI>

可変長のフィールド (<CODE>VARCHAR</CODE>, <CODE>TEXT</CODE>, <CODE>BLOB</CODE>) を持たない場合は、
固定サイズレコード形式が使用されます。
これはかなり速いです。しかしあいにくいくらかの領域を浪費します。
 「<A HREF="manual.ja_Table_types.html#MyISAM_table_formats">8.1.2  MyISAM Table Formats</A>」節参照.
<LI>

それぞれのテーブルは可能な限り短いプライマリ・インデックスを持つべきです。
これは１レコードを一意にし、効率的にします。
<LI>

それぞれのテーブルについて、どのテーブルの形式を使用するかを
決めます。  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL Table types</A>」節参照.
<LI>

本当に必要な物にだけインデックスを作成します。
インデックスは検索には良いですが、より速く保存したい場合には良くありません。
もしテーブルをフィールドの組み合わせでサーチすることがほとんどであれば、
それらにインデックスを作成します。 最初のインデックスの部分は、もっとも
使用されるフィールドにすべきです。
If you are
ALWAYS using many columns, you should use the column with more duplicates
first to get better compression of the index.
<LI>

もしインデックスが頭からの何文字かで一意性を持っているなら、この部分にだけ
インデックスを張る方が良いでしょう。 <STRONG>MySQL</STRONG> は文字列フィールドの
一部分に対してのインデックスをサポートします。
短いインデックスは、ディスクスペースを節約するだけでなく、
インデックスのキャッシュに収まりやすくなることにより、ディスク・シークも少なくなるので、
速くなります。  「<A HREF="manual.ja_Performance.html#Server_parameters">13.2.3  サーバーパラメーターのチューニング</A>」節参照.
<LI>

いくつかの状況下で、とてもよく走査されるテーブルを２つに分割することは、
利益になることがあります。
This is especially true if it is a dynamic
format table and it is possible to use a smaller static format table that
can be used to find the relevant rows when scanning the table.
</UL>

<P>
<A NAME="IDX1199"></A>


<H2><A NAME="MySQL_indexes" HREF="manual.ja_toc.html#MySQL_indexes">13.4  MySQL はどのようにインデックスを使用するか？</A></H2>

<P>
Indexes are used to find rows with a specific value of one column
fast. 
インデックスがない場合、<STRONG>MySQL</STRONG> は、そのレコードが見つかるまで、
最初のレコードからテーブルをなめていきます。 大きなテーブルでは多くの
手間がかかります。 もし問い合わせの中にインデックスを持ったフィールドが
ある場合、<STRONG>MySQL</STRONG> は全てのデータをみることなく、データの途中の位置を速く
得ることができます。 もしあるテーブルが1000レコード持っていたとすると、
順番に頭からなめていくことに比べて、これは少なくとも100倍速いことに
なります。 Note that is you need to access almost all 1000
rows it is faster to read sequentially because we then avoid disk seeks.

</P>
<P>
全ての <STRONG>MySQL</STRONG> インデックス, <CODE>PRIMARY</CODE>, <CODE>UNIQUE</CODE> そして <CODE>INDEX()</CODE> 
は B tree に格納されます。文字列は自動的に始めと終りの空白が圧縮されます。
 「<A HREF="manual.ja_Reference.html#CREATE_INDEX">7.36  <CODE>CREATE INDEX</CODE> 構文</A>」節参照.

</P>
<P>
Indexes are used to:

<UL>
<LI>

<CODE>WHERE</CODE>節にマッチした行の素早い検索

<LI>

join を実行したときの他のテーブルからの行の検索

<LI>

与えられたフィールドの <CODE>MAX()</CODE> や <CODE>MIN()</CODE> 値の割り出し
This is optimized by a preprocessor that checks if you are
using <CODE>WHERE</CODE> key_part_# = constant on all key parts &#60; N.  In this case
<STRONG>MySQL</STRONG> will do a single key lookup and replace the <CODE>MIN()</CODE>
expression with a constant.  If all expressions are replaced with
constants, the query will return at once:


<PRE>
SELECT MIN(key_part2),MAX(key_part2) FROM table_name where key_part1=10
</PRE>

<LI>

テーブルをソートかグループ化する場合で、ソート(グループ化)が一番左(接頭部)の
キーを使用して行われる場合(例えば <CODE>ORDER BY key_part_1,key_part_2 </CODE>)。
もし <CODE>DESC</CODE> 指定があれば、全てのキーは逆順に読まれます。

The index can also be used even if the <CODE>ORDER BY</CODE> doesn't match the index
exactly, as long as all the unused index parts and all the extra
are <CODE>ORDER BY</CODE> columns are constants in the <CODE>WHERE</CODE> clause. The
following queries will use the index to resolve the <CODE>ORDER BY</CODE> part:


<PRE>
SELECT * FROM foo ORDER BY key_part1,key_part2,key_part3;
SELECT * FROM foo WHERE column=constant ORDER BY column, key_part1;
SELECT * FROM foo WHERE key_part1=const GROUP BY key_part2;
</PRE>

<LI>

データファイルを参照することなく値を検索する場合。
もし使用する全てのフィールドが数値でかつ、一番左から(接頭部から)キーを形成する場合、
値はインデックスツリーから検索され、これはとても速くなります。


<PRE>
SELECT key_part3 FROM table_name WHERE key_part1=1
</PRE>

</UL>

<P>
以下のような <CODE>SELECT</CODE> 文を発行したとします：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
</PRE>

<P>
もし <CODE>col1</CODE> と <CODE>col2</CODE> に複数フィールドインデックスが定義されている場合、
すぐに思ったとおりの結果が得られます。
If separate single-column
indexes exist on <CODE>col1</CODE> and <CODE>col2</CODE>, the optimizer tries to
find the most restrictive index by deciding which index will find fewer
rows and using that index to fetch the rows.

</P>
<P>
<A NAME="IDX1200"></A>
<A NAME="IDX1201"></A>
もしテーブルが複数フィールドインデックスを持つなら、インデックスの接頭部一番左の部分
がレコードを見つけるための最適化に使用されます。例えば、3つのフィールド
 <CODE>(col1,col2,col3)</CODE> に対して一つのインデックスを持っていたとします。
すると、これは <CODE>(col1)</CODE>, <CODE>(col1,col2)</CODE> ,
<CODE>(col1,col2,col3)</CODE> でインデックスがサーチされます。

</P>
<P>
もし一番左に指定しているフィールドがインデックスを作成していないなら、
<STRONG>MySQL</STRONG> は部分的なインデックスを使用しません。

</P>
<P>
以下のような <CODE>SELECT</CODE> 文を発行したとします：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
</PRE>

<P>
もしインデックスが <CODE>(col1,col2,col3)</CODE> にあるならば、
上に示した最初のクエリだけがインデックスを使用します。二番目三番目のクエリは
インデックスを持つフィールドを発動しますが、
<CODE>(col2)</CODE> と <CODE>(col2,col3)</CODE> は、<CODE>(col1,col2,col3)</CODE> の
接頭部一番左に指定されていません。

</P>
<P>
<A NAME="IDX1202"></A>
<A NAME="IDX1203"></A>
<A NAME="IDX1204"></A>
<A NAME="IDX1205"></A>
<STRONG>MySQL</STRONG> は、もし  <CODE>LIKE</CODE> がワイルドカードから始まっていなくて、
ある種固定された文字で始まっているなら、
<CODE>LIKE</CODE> の評価にインデックスを使用します。
例えば、以下の <CODE>SELECT</CODE> 文はインデックスを使用します:

</P>

<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE "Pat%_ck%";
</PRE>

<P>
一つ目の文は、<CODE>"Patrick" &#60;= key_col &#60; "Patricl"</CODE> となるレコードだけ、考慮されます。
二つ目の文は、<CODE>"Pat" &#60;= key_col &#60; "Pau"</CODE> となるレコードだけ、考慮されます。

</P>
<P>
以下の <CODE>SELECT</CODE> 文はインデックスを使用しません:

<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "%Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE other_col;
</PRE>

<P>
最初の文は、<CODE>LIKE</CODE> がワイルドカード文字で始まっています。
二つ目の文は、<CODE>LIKE</CODE> が定数ではありません。

</P>
<P>
<A NAME="IDX1206"></A>
<A NAME="IDX1207"></A>
Searching using <CODE>column_name IS NULL</CODE> will use indexes if column_name
is an index.

</P>
<P>
<STRONG>MySQL</STRONG> は通常、一番少ないレコード数を見つけるインデックスを使用します。
インデックスは、以下に示す演算子を用いて比較できるフィールドに対して、使用されます：
<CODE>=</CODE>, <CODE>&#62;</CODE>, <CODE>&#62;=</CODE>, <CODE>&#60;</CODE>, <CODE>&#60;=</CODE>, <CODE>BETWEEN</CODE> そして
<CODE>'something%'</CODE> の様に頭にワイルドカードがない <CODE>LIKE</CODE>。

</P>
<P>
<CODE>WHERE</CODE> 節内の全ての <CODE>AND</CODE> にかからないインデックスは、
全くクエリの最適化に使用されません。
In other words:  To be able to use an
index, a prefix of the index must be used in every <CODE>AND</CODE> group.

</P>
<P>
以下の <CODE>WHERE</CODE> 節はインデックスを使用します：

<PRE>
... WHERE index_part1=1 AND index_part2=2 AND other_column=3
... WHERE index=1 OR A=10 AND index=2      /* index = 1 OR index = 2 */
... WHERE index_part1='hello' AND index_part_3=5
          /* optimized like "index_part1='hello'" */
... WHERE index1=1 and index2=2 or index1=3 and index3=3;
          /* Can use index on index1 but not on index2 or index 3 */
</PRE>

<P>
以下の <CODE>WHERE</CODE> 節はインデックスを<STRONG>使用しません</STRONG>：

<PRE>
... WHERE index_part2=1 AND index_part3=2  /* index_part_1 is not used */
... WHERE index=1 OR A=10                  /* Index is not used in both AND parts */
... WHERE index_part1=1 OR index_part2=10  /* No index spans all rows */
</PRE>

<P>
Note that in some cases <STRONG>MySQL</STRONG> will not use an index, even if one
would be available.  Some of the cases where this happens are:

</P>

<UL>
<LI>

If the use of the index would require <STRONG>MySQL</STRONG> to access more
than 30 % of the rows in the table.  (In this case a table scan is
probably much faster, as this will require us to do much fewer seeks).
Note that if such a query uses <CODE>LIMIT</CODE> to only retrieve
part of the rows, <STRONG>MySQL</STRONG> will use an index anyway, as it can
much more quickly find the few rows to return in the result.
</UL>

<P>
<A NAME="IDX1208"></A>
<A NAME="IDX1209"></A>
<A NAME="IDX1210"></A>


<H2><A NAME="Query_Speed" HREF="manual.ja_toc.html#Query_Speed">13.5  データをアクセス・更新するクエリの速度</A></H2>

<P>
最初に、全てのクエリに影響する一つの事柄をのべます：
より複雑な権限の設定を行うと、オーバーヘッドが多くなります。

</P>
<P>
もしあなたがいかなる <CODE>GRANT</CODE> 文も行っていなければ、
<STRONG>MySQL</STRONG> はパーミッションの検査を少ししか最適化しないでしょう。
So if you have a very high
volume it may be worth the time to avoid grants. Otherwise more
permission check results in a larger overhead.

</P>
<P>
もし <STRONG>MySQL</STRONG> 関数のあるものが確実に問題を引き起こしているのならば、
常に <STRONG>MySQL</STRONG> クライアント側は以下のようになります：

</P>

<PRE>
mysql&#62; select benchmark(1000000,1+1);
+------------------------+
| benchmark(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</PRE>

<P>
上の例では <STRONG>MySQL</STRONG> は 1,000,000 <CODE>+</CODE> 式を 0.32 秒で実行できています
(たんなる <CODE>PentiumII 400MHz</CODE> マシンで)。

</P>
<P>
全ての <STRONG>MySQL</STRONG> 関数は最適化されていますが、
いくつかは例外があるかもしれません。
<CODE>benchmark(loop_count,expression)</CODE>はあなたのクエリの
問題を見つけるためのとてもよいツールです。

</P>

<P>
<A NAME="IDX1211"></A>
<A NAME="IDX1212"></A>
<A NAME="IDX1213"></A>


<H3><A NAME="Estimating_performance" HREF="manual.ja_toc.html#Estimating_performance">13.5.1  クエリの性能評価</A></H3>

<P>
ほとんどの場合、ディスク・シークを数えることでだいたいのパフォーマンスを予測できます。
小さなテーブルでは、通常、1回のディスク・シークでレコードを見つけれるでしょう
(インデックスがたぶんキャッシュされるので)。 大きなテーブルでは、
おおよその予測として、(B++ ツリーインデックスを使用している場合)、
<CODE>log(row_count) /
log(index_block_length / 3 * 2 / (index_length + data_pointer_length)) +
1</CODE> シーク、1レコードを見つけるのに必要となるでしょう。

</P>
<P>
<STRONG>MySQL</STRONG> では、インデックス・ブロックは通常 1024 バイトで、
データ・ポインターは通常 4 バイトです。 これは、
インデックス長が 3 (medium integer) 、データが 500,000 レコードあるテーブルでは、 
<CODE>log(500,000)/log(1024/3*2/(3+4)) + 1</CODE> = 4 シークとなります。

</P>
<P>
As the above index would require about 500,000 * 7 * 3/2 = 5.2M,
(assuming that the index buffers are filled to 2/3, which is typical)
you will probably have much of the index in memory and you will probably
only need 1-2 calls to read data from the OS to find the row.

</P>
<P>
書き込み時には、上の場合、新しいインデックスを書き込める場所を
探し出すのに、4 シークかかり、さらに、通常、インデックスを更新し、
レコードを書くのに 2 シーク必要です。

</P>
<P>
Note that the above doesn't mean that your application will slowly
degenerate by N log N!  As long as everything is cached by the OS or SQL
server things will only go marginally slower while the table gets
bigger. After the data gets too big to be cached, things will start to
go much slower until your applications is only bound by disk-seeks
(which increase by N log N). To avoid this, increase the index cache as
the data grows.  「<A HREF="manual.ja_Performance.html#Server_parameters">13.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>
<P>
<A NAME="IDX1214"></A>
<A NAME="IDX1215"></A>

</P>


<H3><A NAME="SELECT_speed" HREF="manual.ja_toc.html#SELECT_speed">13.5.2  <CODE>SELECT</CODE> クエリの速度</A></H3>

<P>
通常、遅い <CODE>SELECT ... WHERE</CODE> を速くするには、
まず最初にインデックスがあるかどうかをチェックします。 「<A HREF="manual.ja_Performance.html#MySQL_indexes">13.4  MySQL はどのようにインデックスを使用するか？</A>」節参照. 
違うテーブルを参照する場合には、普通はインデックスをともなうべきです。
<CODE>EXPLAIN</CODE> コマンドを使用すれば、<CODE>SELECT</CODE> でどのインデックスが
使用されているか確認できます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.29  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.

</P>
<P>
Some general tips:

</P>

<UL>
<LI>

To help <STRONG>MySQL</STRONG> optimize queries better, run <CODE>myisamchk
--analyze</CODE> on a table after it has been loaded with relevant data. This
updates a value for each index part that indicates the average number of
rows that have the same value.  (For unique indexes, this is always 1,
of course.).  <STRONG>MySQL</STRONG> will use this to decide which index to
choose when you connect two tables with 'a non-constant expression'.
You can check the result from the <CODE>analyze</CODE> run by doing <CODE>SHOW
INDEX FROM table_name</CODE> and examining the <CODE>Cardinality</CODE> column.

<LI>

インデックスとデータをインデックス順に従ってソートするには、
<CODE>myisamchk --sort-index --sort-records=1</CODE> を使用します
(もし １番目のインデックス順にソートするなら)。 
If you
have a unique index from which you want to read all records in order
according to that index, this is a good way to make that faster. 
しかし、このソート方法は最適状態では書かれず、また大きなテーブルでは
多くの時間がかかることに注意してください！
</UL>

<P>
<A NAME="IDX1216"></A>
<A NAME="IDX1217"></A>


<H3><A NAME="Where_optimizations" HREF="manual.ja_toc.html#Where_optimizations">13.5.3  MySQL はどのように <CODE>WHERE</CODE> 節を最適化するか？</A></H3>

<P>
<CODE>WHERE</CODE> の最適化は、<CODE>WHERE</CODE> がほとんど <CODE>SELECT</CODE> で使用されるため、
<CODE>SELECT</CODE> に置かれています。 しかし、同じ最適化は
<CODE>DELETE</CODE> や <CODE>UPDATE</CODE> 文でも使用されます。

</P>
<P>
このセクションの最適化の説明はまだ不十分です。
なぜなら、 <STRONG>MySQL</STRONG> はとても多くの最適化を行っており、
それら全てについての説明を書ける時間が、我々はとれません。

</P>
<P>
<STRONG>MySQL</STRONG>による最適化のいくつかを以下に示します:

</P>

<UL>
<LI>

括弧の除去 (全ての不必要な括弧は削除されます):

<PRE>
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&#62; (a AND b AND c) OR (a AND b AND c AND d)
</PRE>

<LI>

定数の保持:

<PRE>
   (a&#60;b AND b=c) AND a=5
-&#62; b&#62;5 AND b=c AND a=5
</PRE>

<LI>

定数条件の除去 (定数保持のために必要とされます):

<PRE>
   (B&#62;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&#62; B=5 OR B=6
</PRE>

<LI>

インデックスに使用される全ての表現は一度だけ評価されます。
<LI>

一つのテーブル上の <CODE>WHERE</CODE> がない <CODE>CONST(*)</CODE> は、テーブルから
直接取り出されます。これはまた同じ条件下での任意の <CODE>NOT NULL</CODE> 表現
のためにも行われます。
<LI>

不当な定数表現は早く検出されます。
<STRONG>MySQL</STRONG> は不可能な  <CODE>SELECT</CODE> 構文を素早く見つけ、0 行を結果として返します。
<LI>

<CODE>GROUP BY</CODE> または group 関数 (<CODE>COUNT()</CODE>, <CODE>MIN()</CODE>...) を使用しない場合は、
<CODE>HAVING</CODE> は <CODE>WHERE</CODE> とマージされます。
<LI>

各サブ結合についての速い <CODE>WHERE</CODE> 評価を得るために、また、可能な限り
早くレコードをスキップするために、各サブ結合についてより簡単な 
<CODE>WHERE</CODE> が構築されます。
<A NAME="IDX1218"></A>
<A NAME="IDX1219"></A>
<LI>

全ての定数テーブルをクエリー中の他のテーブルより先に読みます。
定数テーブルは次です:

<UL>
<LI>

0 または 1 行のテーブル。
<LI>

<CODE>WHERE</CODE> 節で <CODE>UNIQUE</CODE> インデックスや <CODE>PRIMARY KEY</CODE> が使用されたテーブルで、
かつ、全てのインデックスが定数式で使用されていて、
かつ、インデックスのパートが <CODE>NOT NULL</CODE> で定義されているテーブル。
</UL>

以下のテーブルのように定数だけを使用するテーブル:

<PRE>
mysql&#62; SELECT * FROM t WHERE primary_key=1;
mysql&#62; SELECT * FROM t1,t2
           WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
</PRE>

<LI>

テーブルを結合するために最良の結合の組合せを見つけます。全ての可能性を試して 。
<CODE>ORDER BY</CODE> または <CODE>GROUP</CODE> 内の全てのフィールドが同じテーブルの場合は、
このテーブルは結合時に最初に優先されます。
<LI>

<CODE>ORDER BY</CODE> 節と <CODE>GROUP BY</CODE> 節がある場合、または <CODE>ORDER BY</CODE> か <CODE>GROUP BY</CODE> が結合キュー
内の最初のテーブルではない他のテーブルからの項目を含む場合、一時テーブルが生成されます。
<LI>

もし <CODE>SQL_SMALL_RESULT</CODE> を使用するなら, <STRONG>MySQL</STRONG> はメモリー内の一次テーブルを
使用します
<LI>

各テーブルのインデックスはクエリされ、得られる行の 30% 未満の幅しかない最良のインデックスが使用されます。
そのようなインデックスが見つけられない場合、素早いテーブルの走査(quick table scan)が使用されます。
<LI>

同じように、<STRONG>MySQL</STRONG> はデータファイルを等しく調べはしないインデックスから
レコードを読むことが可能です。もし全てのフィールドが数値型のインデックスなら、
インデックスツリーだけがクエリの解決に使用されます。
<LI>

各レコードが出力される前に、<CODE>HAVING</CODE> 節に適合するものをスキップします。
</UL>

<P>
以下はとても速いクエリの例です:

</P>

<PRE>
mysql&#62; SELECT COUNT(*) FROM tbl_name;
mysql&#62; SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;
mysql&#62; SELECT MAX(key_part2) FROM tbl_name
           WHERE key_part_1=constant;
mysql&#62; SELECT ... FROM tbl_name
           ORDER BY key_part1,key_part2,... LIMIT 10;
mysql&#62; SELECT ... FROM tbl_name
           ORDER BY key_part1 DESC,key_part2 DESC,... LIMIT 10;
</PRE>

<P>
以下のクエリはインデックスツリーのみを使用します(インデックス化されているフィールドは
数値型と仮定します)：

</P>

<PRE>
mysql&#62; SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
mysql&#62; SELECT COUNT(*) FROM tbl_name
           WHERE key_part1=val1 AND key_part2=val2;
mysql&#62; SELECT key_part2 FROM tbl_name GROUP BY key_part1;
</PRE>

<P>
以下のクエリは、ソートされた行の検索にインデックスを使用します：

</P>

<PRE>
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1,key_part2,... ;
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1 DESC,key_part2 DESC,... ;
</PRE>

<P>
<A NAME="IDX1220"></A>
<A NAME="IDX1221"></A>


<H3><A NAME="DISTINCT_optimization" HREF="manual.ja_toc.html#DISTINCT_optimization">13.5.4  How MySQL Optimizes <CODE>DISTINCT</CODE></A></H3>

<P>
<CODE>DISTINCT</CODE> is converted to a <CODE>GROUP BY</CODE> on all columns,
<CODE>DISTINCT</CODE> combined with <CODE>ORDER BY</CODE> will in many cases also
need a temporary table.

</P>
<P>
When combining <CODE>LIMIT #</CODE> with <CODE>DISTINCT</CODE>, <STRONG>MySQL</STRONG> will stop
as soon as it finds <CODE>#</CODE> unique rows.

</P>
<P>
If you don't use columns from all used tables, <STRONG>MySQL</STRONG> will stop
the scanning of the not used tables as soon as it has found the first match.

</P>

<PRE>
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
</PRE>

<P>
In the case, assuming t1 is used before t2 (check with <CODE>EXPLAIN</CODE>), then
<STRONG>MySQL</STRONG> will stop reading from t2 (for that particular row in t1)
when the first row in t2 is found.

</P>
<P>
<A NAME="IDX1222"></A>
<A NAME="IDX1223"></A>


<H3><A NAME="LEFT_JOIN_optimization" HREF="manual.ja_toc.html#LEFT_JOIN_optimization">13.5.5  MySQL はどのように <CODE>LEFT JOIN</CODE> と <CODE>RIGHT JOIN</CODE> を最適化するか？</A></H3>

<P>
<STRONG>MySQL</STRONG> の <CODE>A LEFT JOIN B</CODE> は以下のように組みこまれています：

</P>

<UL>
<LI>

The table <CODE>B</CODE> is set to be dependent on table <CODE>A</CODE> and all tables
that <CODE>A</CODE> is dependent on.
<LI>

テーブル <CODE>A</CODE> が <CODE>LEFT JOIN</CODE> 条件中に使用される全てのテーブル
（ただし <CODE>B</CODE> は除く）に依存すると、セットされます。
<LI>

全ての <CODE>LEFT JOIN</CODE> 条件が <CODE>WHERE</CODE> 節に移動されます。
<LI>

All standard join optimizations are done, with the exception that a table is
always read after all tables it is dependent on.  If there is a circular
dependence then <STRONG>MySQL</STRONG> will issue an error.
<LI>

全ての <CODE>WHERE</CODE> 節の最適化が行われます。
<LI>

<CODE>WHERE</CODE> 節にマッチするレコードが <CODE>A</CODE> にあり、
<CODE>LEFT JOIN</CODE> 条件にマッチするレコードが <CODE>B</CODE> にない場合、
全てのフィールドが <CODE>NULL</CODE> にセットされた <CODE>B</CODE> のレコードが
作成されます。 
<LI>

If you use <CODE>LEFT JOIN</CODE> to find rows that don't exist in some
table and you have the following test: <CODE>column_name IS NULL</CODE> in the
<CODE>WHERE</CODE> part, where column_name is a column that is declared as
<CODE>NOT NULL</CODE>, then <STRONG>MySQL</STRONG> will stop searching after more rows
(for a particular key combination) after it has found one row that
matches the <CODE>LEFT JOIN</CODE> condition.
</UL>

<P>
<CODE>RIGHT JOIN</CODE> is implemented analogously as <CODE>LEFT JOIN</CODE>.

</P>
<P>
The table read order forced by <CODE>LEFT JOIN</CODE> and <CODE>STRAIGHT JOIN</CODE>
will help the join optimizer (which calculates in which order tables
should be joined) to do its work much more quickly, as there are fewer
table permutations to check.

</P>
<P>
Note that the above means that if you do a query of type:

</P>

<PRE>
SELECT * FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key) WHERE b.key=d.key
</PRE>

<P>
<STRONG>MySQL</STRONG> will do a full scan on <CODE>b</CODE> as the <CODE>LEFT
JOIN</CODE> will force it to be read before <CODE>d</CODE>.

</P>
<P>
The fix in this case is to change the query to:

</P>

<PRE>
SELECT * FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key) WHERE b.key=d.key
</PRE>

<P>
<A NAME="IDX1224"></A>
<A NAME="IDX1225"></A>


<H3><A NAME="LIMIT_optimization" HREF="manual.ja_toc.html#LIMIT_optimization">13.5.6  MySQL はどのように <CODE>LIMIT</CODE> を最適化するか？</A></H3>

<P>
In some cases <STRONG>MySQL</STRONG> will handle the query differently when you are
using <CODE>LIMIT #</CODE> and not using <CODE>HAVING</CODE>:

</P>

<UL>
<LI>

もし <CODE>LIMIT</CODE> を使用して限定した数だけ select を行うなら、 <STRONG>MySQL</STRONG> は、
ある場合、テーブルを全て走査するよりも、インデックスを使用しようとします。
<LI>

もし <CODE>LIMIT #</CODE> を <CODE>ORDER BY</CODE> と共に使用するなら, <STRONG>MySQL</STRONG> は
最初の <CODE>#</CODE> 行を見つけたらすぐに、全テーブルのソートは行わずに、
ソートを終わらせます。 
<LI>

<CODE>LIMIT #</CODE> を <CODE>DISTINCT</CODE> と共に使用するなら, <STRONG>MySQL</STRONG> は
<CODE>#</CODE> 個の一意なレコードを見つけた時点で終わります。
<LI>

In some cases a <CODE>GROUP BY</CODE> can be resolved by reading the key in order 
(or do a sort on the key) and then calculate summaries until the
key value changes.  In this case <CODE>LIMIT #</CODE> will not calculate any
unnecessary <CODE>GROUP BY</CODE>'s.
<LI>

<STRONG>MySQL</STRONG> は、最初の <CODE>#</CODE> 行をクライアントに送ったあと直に、
クエリを中断します。
<LI>

<CODE>LIMIT 0</CODE> は常に素早く空の結果を返します。
これはクエリのチェックや結果として得られるフィールドの型を得るために利用できます。
<LI>

一時テーブルの大きさは、クエリを解決するためにどれぐらいのスペースがいるかを
計算するのに、<CODE>LIMIT #</CODE> を使用します。
</UL>

<P>
<A NAME="IDX1226"></A>
<A NAME="IDX1227"></A>


<H3><A NAME="Insert_speed" HREF="manual.ja_toc.html#Insert_speed">13.5.7  <CODE>INSERT</CODE> クエリの速度</A></H3>

<P>
レコードを挿入する時間はおおよそ次からなります:

</P>

<UL>
<LI>

接続:                    (3)
<LI>

クエリをサーバへ送信:    (2)
<LI>

クエリの解析:            (2)
<LI>

レコードの挿入:          (1 x size of record)
<LI>

インデックスの挿入:      (1 x number of indexes)
<LI>

クローズ:                (1)
</UL>

<P>
ここで (数字) は比例時間です。これは、テーブルのオープンにかかる初期オーバーヘッ
ド(これは同時に動作する各クエリ毎に1回行なわれます)は考慮されていません。

</P>
<P>
テーブルのサイズはインデックスの挿入を N log N で遅くします (B-tree)。

</P>
<P>
INSERT を速くするいくつかの方法：

</P>

<UL>
<LI>

もし同じクライアントから多くのレコードを同時にインサートするなら、
複数の値が書ける <CODE>INSERT</CODE> 文を使用します。 これは個々に <CODE>INSERT</CODE> 文
を発行する場合に比べて、とても速くなります。
<LI>

もし違うクライアントから多くのレコードを同時にインサートするなら、
 <CODE>INSERT DELAYED</CODE> 文の使用で、より速くなるでしょう。  「<A HREF="manual.ja_Reference.html#INSERT">7.21  <CODE>INSERT</CODE>構文</A>」節参照.
<LI>

<CODE>MyISAM</CODE> では、複数の <CODE>SELECT</CODE> が走っているテーブルに対して、
同時に、レコードを挿入できます。 ただしそのテーブルに対して
レコードの削除がない場合に。
<LI>

テキストファイルからテーブルにデータをいれる場合は、 <CODE>LOAD DATA INFILE</CODE> を
使用します。 これはたくさんの <CODE>INSERT</CODE> 文の発行に比べて通常 20倍 程度
速くなります
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">7.23  <CODE>LOAD DATA INFILE</CODE>構文</A>」節参照.
<LI>

テーブルが多くのインデックスを持っている場合、ある方法で、 <CODE>LOAD DATA INFILE</CODE> の
実行を速くすることが可能です。
以下の手順で行います：


<OL>
<LI>

Optionally create the table with <CODE>CREATE TABLE</CODE>. For example, using
<CODE>mysql</CODE> or Perl-DBI.

<LI>

<CODE>FLUSH TABLES</CODE> の実行。 あるいは <CODE>mysqladmin flush-tables</CODE> 
コマンドの実行。

<LI>

<CODE>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</CODE> の使用。
これは指定されたテーブルから全てのインデックスを削除します。

<LI>

そのテーブルに <CODE>LOAD DATA INFILE</CODE> を使用してデータを入れます. 
これはいかなるインデックスも更新しないでしょうし、そのため、速くもなるでしょう。

<LI>

If you are going to only read the table in the future, run <CODE>myisampack</CODE>
on it to make it smaller.  「<A HREF="manual.ja_Table_types.html#Compressed_format">8.1.2.3  Compressed Table Characteristics</A>」節参照.

<LI>

<CODE>myisamchk -r -q /path/to/db/tbl_name</CODE> でインデックスを再構築. 
これは disk に書き込む前にインデックスをメモリに作成します。
これは多くのディスクシークを避けることが出来るのでとても速くなります。
でき上がったインデックスツリーは、バランスのよいものになります。

<LI>

<CODE>FLUSH TABLES</CODE> の実行。 あるいは <CODE>mysqladmin flush-tables</CODE> 
コマンドの実行。
</OL>

この手順は、将来の MySQL の <CODE>LOAD DATA INFILE</CODE> に組み込むかもしれません。
<LI>

テーブルをロックすることで、挿入を速くすることも可能です：


<PRE>
mysql&#62; LOCK TABLES a WRITE;
mysql&#62; INSERT INTO a VALUES (1,23),(2,34),(4,33);
mysql&#62; INSERT INTO a VALUES (8,26),(6,29);
mysql&#62; UNLOCK TABLES;
</PRE>

主な速度差は、全ての <CODE>INSERT</CODE> 構文でインデックスバッファが一度だけディスクにフ
ラッシュされることです。通常は  <CODE>INSERT</CODE> 構文があるのと同じくらい多くのインデッ
クスバッファフラッシュがあります。単一構文の全てのレコードは、ロックなしで挿入できます。

ロックも複数接続テストの合計時間を低くしますが、いくつかのスレッドの最大
待ち時間は上がります(ロックを待っているから)。
例えば:


<PRE>
thread 1 does 1000 inserts
thread 2, 3, and 4 does 1 insert
thread 5 does 1000 inserts
</PRE>

ロックを使用しない場合、2, 3 そして 4 は 1 と 5 の前に終ります。ロックを
使用する場合、2,3,4 は 1 や 5 の前に終わることはおそらくありませんが、合
計時間は約 40 % 速くなります。

<CODE>INSERT</CODE>, <CODE>UPDATE</CODE> , <CODE>DELETE</CODE> は、 <STRONG>MySQL</STRONG> ではとても速いので、
1 行で約 5 つ以上、値を 挿入・更新 をする操作に対して、
ロックを追加すれば、全般的により良い性能が得られます。
とても多い insert を行なう場合、
他のスレッドにそのロックしたテーブルへのアクセスを与えるために 、
だいたい 1000 レコードごとに一度、<CODE>UNLOCK TABLES</CODE> した後に
 <CODE>LOCK TABLES</CODE> を行います。 これでもまだ良い性能が得られます。

もちろん <CODE>LOAD DATA INFILE</CODE> はとても速いです。
</UL>

<P>
<CODE>LOAD DATA INFILE</CODE> と <CODE>INSERT</CODE> を共に速くするためには、
キーバッファを増やします。  「<A HREF="manual.ja_Performance.html#Server_parameters">13.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>


<H3><A NAME="Update_speed" HREF="manual.ja_toc.html#Update_speed">13.5.8  <CODE>UPDATE</CODE> クエリの速度</A></H3>

<P>
<CODE>UPDATE</CODE> クエリは <CODE>SELECT</CODE> クエリのように最適化されますが、
書き込みのオーバーヘッドが加わります。
書き込み速度は、更新されるデータの大きさ、更新されるインデックス数に
依ります。 変更されないインデックスは更新されません。

</P>
<P>
Also, another way to get fast updates is to delay updates and then do
many updates in a row later. 
一文で多くの更新を行えば、もしテーブルがロックされていれば、
一文で一個づつ更新するよりも、とても速くなります。

</P>
<P>
Note that, with dynamic record format, updating a record to
a longer total length may split the record.  So if you do this often,
it is very important to <CODE>OPTIMIZE TABLE</CODE> sometimes.
 「<A HREF="manual.ja_Reference.html#OPTIMIZE_TABLE">7.11  <CODE>OPTIMIZE TABLE</CODE>構文</A>」節参照.

</P>


<H3><A NAME="Delete_speed" HREF="manual.ja_toc.html#Delete_speed">13.5.9  <CODE>DELETE</CODE> クエリの速度</A></H3>

<P>
If you want to delete all rows in the table, you should use
<CODE>TRUNCATE TABLE table_name</CODE>.  「<A HREF="manual.ja_Reference.html#TRUNCATE">7.18  <CODE>TRUNCATE</CODE> Syntax</A>」節参照.

</P>
<P>
1レコードを削除する時間は、ちょうどインデックスの数に比例します。
より速くレコードを削除したいなら、インデックス・キャッシュを
増やします。  「<A HREF="manual.ja_Performance.html#Server_parameters">13.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>
<P>
テーブル中からレコードの大きな部分を消すよりも、
全てのレコードを消すほうが、とても速いです。

</P>
<P>
<A NAME="IDX1228"></A>
<A NAME="IDX1229"></A>


<H2><A NAME="Tips" HREF="manual.ja_toc.html#Tips">13.6  最適化に関するその他の助言</A></H2>

<P>
Unsorted tips for faster systems:

</P>

<UL>
<LI>

コネクションオーバーヘッドを避けるために、データベースに対して、
逐次コネクションを落とさないように、常に接続を保ちます。
If you can't use persistent connections and you are doing a
lot of new connections to the database, you may want to change the value
of the <CODE>thread_cache_size</CODE> variable.  「<A HREF="manual.ja_Performance.html#Server_parameters">13.2.3  サーバーパラメーターのチューニング</A>」節参照.
<LI>

あなたのクエリがテーブルのインデックスを使用しているか、いつもチェックします。
<STRONG>MySQL</STRONG> では <CODE>EXPLAIN</CODE> コマンドでこれが行えれます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.29  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.
<LI>

たくさん変更されるようなテーブルに対して、複雑な <CODE>SELECT</CODE> クエリを
避けるように試みます。 これはテーブル・ロックの問題を避けるためです。
<LI>

新しい <CODE>MyISAM</CODE> テーブルでは、あるテーブルにレコードが挿入(削除は無しで)
されている最中に、同時に、同じテーブルからデータを読むことが可能です。
これがあなたにとって重要項目であるなら、
レコードの削除の必要のない方法や、多くのレコードを削除した後に <CODE>OPTIMIZE TABLE</CODE> を
実行することを、考慮すべきです。
<LI>

Use <CODE>ALTER TABLE ... ORDER BY expr1,expr2...</CODE> if you mostly
retrieve rows in expr1,expr2.. order.  By using this option after big
changes to the table, you may be able to get higher performance.
<LI>

In some cases it may make sense to introduce a column that is 'hashed'
based on information from other columns. If this column is short and
reasonably unique it may be much faster than a big index on many
columns. In <STRONG>MySQL</STRONG> it's very easy to use this extra column:
<CODE>SELECT * FROM table_name WHERE hash=MD5(concat(col1,col2))
AND col_1='constant' AND col_2='constant'</CODE>
<LI>

多くの変更がなされるテーブルに対しては、全ての <CODE>VARCHAR</CODE> や <CODE>BLOB</CODE> 
フィールドを避けるように試みるべきです。
You will get dynamic row length as soon as you
are using a single <CODE>VARCHAR</CODE> or <CODE>BLOB</CODE> columns.  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL Table types</A>」節参照.
<LI>

通常、あるテーブルを違うテーブルに分けることは、レコードが大きくなる
ために役立ちません。
レコードにアクセスする際、そのレコードの最初のバイトを見つけるための
ディスク・シークが、一番かかります。
After finding
the data most new disks can read the whole row fast enough for most
applications. The only cases where it really matters to split up a table is if
it's a dynamic row size table (see above) that you can change to a fixed
row size, or if you very often need to scan the table and don't need
most of the columns.  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL Table types</A>」節参照.
<LI>

もし、多くのレコードからの情報を元にした計算(あるもののカウントとか)を
しょっちゅう行う必要があるなら、新しいテーブルを用意し、逐次カウンターを
更新した方が多分良いでしょう。
<CODE>UPDATE table set count=count+1 where index_column=constant</CODE> の更新は
とても速いです！

これは、<STRONG>MySQL</STRONG> のようなテーブル・ロッキング
(multiple readers / single writers)をもつデータベースを
使う上で、本当に重要なことです。
This will
also give better performance with most databases as the row locking
manager in this case will have less to do.
<LI>

もしたくさんの大きなテーブルから統計を収集する必要があるなら、
全テーブルを走査する代わりに、サマリーテーブルを使用します。
Maintaing the summarys should be
much faster than trying to do statistics 'live'. It's much faster to
regenerate new summary tables from the logs when things changes
(depending on business decisions) than to have to change the running
application!
<LI>

If possible, one should classify reports as 'live' or 'statistical',
where data needed for statistical reports are only generated based on
summary tables that are generated from the actual data.
<LI>

フィールドにはデフォルト値があるという事を利用して下さい。
値がデフォルトとは違う場合に限り、値を挿入します。
これは <STRONG>MySQL</STRONG> が必要とする分析を少なくし、インサートの速度が向上します。
<LI>

ある場合では、BLOB にデータをパックして保存するのが便利です。
この場合、BLOB に入れた値を パック・アンパック するためのコードを
あなたのアプリケーションに組み込まなくてはなりません。
しかしこれは、多くのアクセスを抑制するでしょう。
これは、静的(固定長)テーブル構造に適しないデータを持っている場合に
実用になります。
<LI>

通常、あなたは全てのデータを冗長の無いように(データベース理論で
第３正規形 , 3rd Normal Form , 3NF と呼ばれる)
しようとするかもしれませんが、しかし、よりスピードを求める場合は、
重複やサマリーテーブルの作成をおそれてはいけません。
<LI>

ストアド・プロシージャ や UDF (ユーザー定義関数) はよりパフォーマンスを得る
ためにはよい方法かもしれません。
In this case you should, however, always have a way
to do this some other (slower) way if you use some database that doesn't
support this.
<LI>

You can always gain something by caching queries/answers in your
application and trying to do many inserts/updates at the same time.  If
your database supports lock tables (like <STRONG>MySQL</STRONG> and Oracle),
this should help to ensure that the index cache is only flushed once
after all updates.
<LI>

データをすぐには書く必要がないとき、<CODE>INSERT /*! DELAYED */</CODE> を使用します。
これは、一回のディスクへの書き込みで、多くのレコードがかかれるので、
速くなります。
<LI>

SELECT がより重要な場合、<CODE>INSERT /*! LOW_PRIORITY */</CODE> を使用します。
<LI>

キューを無視して SELECT を優先的に行いたいときは
<CODE>SELECT /*! HIGH_PRIORITY */</CODE> を使用します。
これは、たとえ誰かが書き込みを待っていたとしても、その SELECT は
実行されます。
<LI>

複数行 <CODE>INSERT</CODE> 文の使用。 これは多くのレコードを一つの SQL コマンドで
挿入することが出来ます。
(多くの SQL サーバーがこれをサポートしています)
<LI>

大きなデータの読み込みには <CODE>LOAD DATA INFILE</CODE> を使用します。
This if
faster than normal inserts and will be even faster when <CODE>myisamchk</CODE>
is integrated in <CODE>mysqld</CODE>.
<LI>

一意の値を作るために、 <CODE>AUTO_INCREMENT</CODE> を使用します。
<LI>

動的テーブルフォーマットの使用時には、フラグメンテーションを避けるために、
<CODE>OPTIMIZE TABLE</CODE> を時々使用します。
 「<A HREF="manual.ja_Reference.html#OPTIMIZE_TABLE">7.11  <CODE>OPTIMIZE TABLE</CODE>構文</A>」節参照.

<LI>

可能ならば <CODE>HEAP</CODE> テーブルをスピードアップのために使用します.  「<A HREF="manual.ja_Table_types.html#Table_types">8  MySQL Table types</A>」節参照.
<LI>

通常の Web サーバーの設定ならば、イメージはファイルに保存すべきです。
データベースには、それらファイルの参照(パスとか)のみを入れます。
この主な理由は、通常の Web サーバーはデータベースよりもコンテンツを
よりよくキャッシュしてくれるからです。 それでファイルを使用するなら、
速いシステムをより簡単に得ることができます。
<LI>

重要でないデータで、よくアクセスされる物は、メモリテーブルにいれます。
(like
information about the last shown banner for users that don't have
cookies)
<LI>

Columns with identical information in different tables should be
declared identical and have identical names. Before Version 3.23 you
got slow joins otherwise.

名前は単純にしてください（customer テーブルでは <CODE>customer_name</CODE> の
かわりに <CODE>name</CODE> を使うとか）。 他の SQL サーバーへの移植を考慮するなら、
名前は 18 文字より短くすべきです。
<LI>

もし本当にハイ・スピードが必要なら、SQL サーバーがサポートしている物とは
違う、ローレベルのデータ保存のインターフェースに注目すべきです。
例えば、 <STRONG>MySQL</STRONG> <CODE>MyISAM</CODE> を直接アクセスすることは、
SQL インターフェースを介してアクセスするよりも、2〜5倍速くなるでしょう。
これを可能にするには、そのデータは、アプリケーションと同じマシン上になくてはならず、
通常、一つのプロセスだけでアクセスされるべきです。
(なぜなら、外部ファイルロックは、とても遅いから)。
上の問題は、<STRONG>MySQL</STRONG> サーバー内の <CODE>MyISAM</CODE> のローレベルのコマンドの
導入で解決できるでしょう。 (これはよりよいパフォーマンスを得ることの出来る、
簡単な方法の一つです)。 By carefully designing the database interface
it should be quite easy to support this types of optimisations.
<LI>

多くの場合、データベースからデータをアクセスする方が(接続を維持していれば)、
テキストファイルからデータをアクセスするよりも速いです。 なぜなら、
データベースはテキストファイルよりもコンパクトになり（数値データの場合）、
このため、ディスクアクセスが少なくなるからです。
また、行や項目を見つけるために、テキストファイルを解析する必要も省けます。
<LI>

複製もスピードアップに使用できるでしょう。  「<A HREF="manual.ja_Replication.html#Replication">11  Replication in MySQL</A>」節参照.
<LI>

<CODE>DELAY_KEY_WRITE=1</CODE> が定義されたテーブルは、インデックスの更新が速くなります。
これはそのインデックス・ファイルが閉じられるまでディスクに記録されないからです。
したがって、なにかが途中で <CODE>mysqld</CODE> をキルしてもテーブルが大丈夫なようにするため、
<CODE>mysqld</CODE> を起動する前には、<CODE>myisamchk</CODE> をそれらのテーブルに対して実行すべきです。
As the key information can always be generated
from the data, you should not lose anything by using <CODE>DELAY_KEY_WRITE</CODE>.
</UL>

<P>
<A NAME="IDX1230"></A>
<A NAME="IDX1231"></A>


<H2><A NAME="Benchmarks" HREF="manual.ja_toc.html#Benchmarks">13.7  Using Your Own Benchmarks</A></H2>

<P>
You should definitely benchmark your application and database to find
out where the bottlenecks are.  By fixing it (or by replacing the
bottleneck with a 'dummy module') you can then easily identify the next
bottleneck (and so on).  Even if the overall performance for your
application is sufficient, you should at least make a plan for each
bottleneck, and decide how to solve it if someday you really need the
extra performance.

</P>
<P>
For an example of portable benchmark programs, look at the <STRONG>MySQL</STRONG>
benchmark suite.  「<A HREF="manual.ja_MySQL_Benchmarks.html#MySQL_Benchmarks">14  <STRONG>MySQL</STRONG> ベンチマークスイート</A>」節参照. You
can take any program from this suite and modify it for your needs. By doing this,
you can try different solutions to your problem and test which is really the
fastest solution for you.

</P>
<P>
It is very common that some problems only occur when the system is very
heavily loaded. We have had many customers who contact us when they
have a (tested) system in production and have encountered load problems. In
every one of these cases so far, it has been problems with basic design
(table scans are NOT good at high load) or OS/Library issues. Most of
this would be a <STRONG>LOT</STRONG> easier to fix if the systems were not
already in production.

</P>
<P>
To avoid problems like this, you should put some effort into benchmarking
your whole application under the worst possible load! You can use Sasha's
recent hack for this -
<a HREF="http://www.mysql.com/Downloads/super-smack/super-smack-1.0.tar.gz">
super-smack</a>.
As the name suggests, it can bring your system down to its knees if you ask it,
so make sure to use it only on your development systems.

</P>
<P>
<A NAME="IDX1232"></A>
<A NAME="IDX1233"></A>
<A NAME="IDX1234"></A>


<H2><A NAME="Design" HREF="manual.ja_toc.html#Design">13.8  Design Choices</A></H2>

<P>
<CODE>MySQL</CODE> は、レコードのデータとインデックスを別のファイルに保存します。
他の多くの(ほとんど全て)データベースでは、同じファイルにデータとインデックスを
混在させて保存します。 我々は、最近のシステムには、<STRONG>MySQL</STRONG> の選択の方が
良いと信じています。

</P>
<P>
Another way to store the row data is to keep the information for each
column in a separate area (examples are SDBM and Focus). This will cause a
performance hit for every query that accesses more than one column. Because
this degenerates so quickly when more than one column is accessed,
we believe that this model is not good for general purpose databases.

</P>
<P>
The more common case is that the index and data are stored together
(like in Oracle/Sybase et al). In this case you will find the row
information at the leaf page of the index. The good thing with this
layout is that it, in many cases, depending on how well the index is
cached, saves a disk read.  The bad things with this layout are:

</P>

<UL>
<LI>

Table scanning is much slower because you have to read through the indexes
to get at the data.
<LI>

You can't use only the index table to retrieve data for a query.
<LI>

You lose a lot of space, as you must duplicate indexes from the nodes
(as you can't store the row in the nodes).
<LI>

Deletes will degenerate the table over time (as indexes in nodes are
usually not updated on delete).
<LI>

It's harder to cache ONLY the index data.
</UL>

<P>
<A NAME="IDX1235"></A>


<H2><A NAME="Design_Limitations" HREF="manual.ja_toc.html#Design_Limitations">13.9  MySQL Design Limitations/Tradeoffs</A></H2>

<P>
Because <STRONG>MySQL</STRONG> uses extremely fast table locking (multiple readers /
single writers) the biggest remaining problem is a mix of a steady stream of
inserts and slow selects on the same table.

</P>
<P>
We belive that for a huge number of systems the extremely fast
performance in other cases make this choice a win. This case is usually
also possible to solve by having multiple copies of the table, but it
takes more effort and hardware.

</P>
<P>
We are also working on some extensions to solve this problem for some
common application niches.

</P>
<P>
<A NAME="IDX1236"></A>
<A NAME="IDX1237"></A>
<A NAME="IDX1238"></A>


<H2><A NAME="Portability" HREF="manual.ja_toc.html#Portability">13.10  Portability</A></H2>

<P>
Because all SQL servers implement different parts of SQL, it takes work to
write portable SQL applications. For very simple selects/inserts it is
very easy, but the more you need the harder it gets. If you want an
application that is fast with many databases it becomes even harder!

</P>
<P>
To make a complex application portable you need to choose a number of
SQL servers that it should work with.

</P>
<P>
You can use the <STRONG>MySQL</STRONG> crash-me program/web-page
<a HREF="http://www.mysql.com/information/crash-me.php">http://www.mysql.com/information/crash-me.php</a> to find functions,
types, and limits you can use with a selection of database
servers. Crash-me now tests far from everything possible, but it
is still comprehensive with about 450 things tested.

</P>
<P>
For example, you shouldn't have column names longer than 18 characters
if you want to be able to use Informix or DB2.

</P>
<P>
Both the <STRONG>MySQL</STRONG> benchmarks and crash-me programs are very
database-independent.  By taking a look at how we have handled this, you
can get a feeling for what you have to do to write your application
database-independent.  The benchmarks themselves can be found in the
<TT>`sql-bench'</TT> directory in the <STRONG>MySQL</STRONG> source
distribution. They are written in Perl with DBI database interface
(which solves the access part of the problem).

</P>
<P>
See <a HREF="http://www.mysql.com/information/benchmarks.html">http://www.mysql.com/information/benchmarks.html</a> for the results
from this benchmark.

</P>
<P>
As you can see in these results, all databases have some weak points. That
is, they have different design compromises that lead to different
behavior.

</P>
<P>
If you strive for database independence, you need to get a good feeling
for each SQL server's bottlenecks. <STRONG>MySQL</STRONG> is VERY fast in
retrieving and updating things, but will have a problem in mixing slow
readers/writers on the same table. Oracle, on the other hand, has a big
problem when you try to access rows that you have recently updated
(until they are flushed to disk). Transaction databases in general are
not very good at generating summary tables from log tables, as in this
case row locking is almost useless.

</P>
<P>
To get your application <EM>really</EM> database-independent, you need to define
an easy extendable interface through which you manipulate your data. As
C++ is available on most systems, it makes sense to use a C++ classes
interface to the databases.

</P>
<P>
If you use some specific feature for some database (like the
<CODE>REPLACE</CODE> command in <STRONG>MySQL</STRONG>), you should code a method for
the other SQL servers to implement the same feature (but slower).  With
<STRONG>MySQL</STRONG> you can use the <CODE>/*!  */</CODE> syntax to add
<STRONG>MySQL</STRONG>-specific keywords to a query.  The code inside
<CODE>/**/</CODE> will be treated as a comment (ignored) by most other SQL
servers.

</P>
<P>
If REAL high performance is more important than exactness, as in some
Web applications, a possibility is to create an application layer that
caches all results to give you even higher performance. By letting
old results 'expire' after a while, you can keep the cache reasonably
fresh.  This is quite nice in case of extremely high load, in which case
you can dynamically increase the cache and set the expire timeout higher
until things get back to normal.

</P>
<P>
In this case the table creation information should contain information
of the initial size of the cache and how often the table should normally
be refreshed.

</P>
<P>
<A NAME="IDX1239"></A>
<A NAME="IDX1240"></A>


<H2><A NAME="Internal_use" HREF="manual.ja_toc.html#Internal_use">13.11  What have we used MySQL for?</A></H2>

<P>
<STRONG>MySQL</STRONG> の初期の開発期には、<STRONG>MySQL</STRONG> は我々のもっとも大口の顧客に合うように
機能が作成されました。 彼らは、いくつかのスウェーデン最大手の小売り業者
のために、倉庫に入れている（商品）データを取り扱います。

</P>
<P>
我々は、すべての店から、全ボーナス・カード取扱高の、その週間まとめを得ます。
そして、その店のオーナにとって有益な情報、その店の広告キャンペーンが
お客にどの程度影響を及ぼすか、を提供することが、我々に求められています。

</P>
<P>
そのデータは、とても大きくて (約700万/月 回の取り扱い)、
我々はその顧客に提供する必要のあるデータを 4〜10年分、持っています。
我々は、カスタマーから、彼らがこのデータからできる新しいレポートに
”即時に”アクセスしたいという、要求を受けました。

</P>
<P>
我々はこれを、全ての月ごとの情報を圧縮した 'transaction' テーブルに
保存することで解決しました。
We have a set of simple macros (script) that
generates summary tables grouped by different criteria (product group,
customer id, store ...) from the transaction tables. 
そのレポートは Web ページで、これは小さな perl スクリプトで動的に
作成されます。 この perl script は Web Page を分析し、SQL 文を
実行し、結果を挿入します。
We would have used PHP or mod_perl instead but they were
not available at that time.

</P>
<P>
画像データのために、我々は簡単なツールを <CODE>C</CODE> でかきました。
これは SQL のクエリの結果を元に(結果にいくつか処理をして) GIF を提供します。
これも動的に perl スクリプト(<CODE>HTML</CODE> ファイルを分析する)から実行されます。

</P>
<P>
In most cases a new report can simply be done by copying an existing
script and modifying the SQL query in it.  In some cases, we will need to
add more fields to an existing summary table or generate a new one, but
this is also quite simple, as we keep all transactions tables on disk.
(Currently we have at least 50G of transactions tables and 200G of other
customer data.)

</P>
<P>
We also let our customers access the summary tables directly with ODBC
so that the advanced users can themselves experiment with the data.

</P>
<P>
我々はこれらを  Sun Ultra SPARCstation (2x200 Mz) で扱っていますが、
なんの問題もありません。
We recently upgraded one of our servers to a 2
CPU 400 Mhz UltraSPARC, and we are now planning to start handling
transactions on the product level, which would mean a ten-fold increase
of data. We think we can keep up with this by just adding more disk to
our systems.

</P>
<P>
We are also experimenting with Intel-Linux to be able to get more CPU
power cheaper.  現在、我々はバイナリ互換のデータベースフォーマットを持っており
(new in Version 3.23) 、我々はこれをアプリケーションのいくつかの部分に使用しはじめる事でしょう。

</P>
<P>
Our initial feelings are that Linux will perform much better on
low-to-medium load and Solaris will perform better when you start to get a
high load because of extreme disk IO, but we don't yet have anything
conclusive about this. After some discussion with a Linux Kernel
developer, this might be a side effect of Linux giving so much resources
to the batch job that the interactive performance gets very low. This
makes the machine feel very slow and unresponsive while big batches are
going. Hopefully this will be better handled in future Linux Kernels.

</P>
<P>
<A NAME="IDX1241"></A>
<A NAME="IDX1242"></A>
<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Fulltext_Search.html">previous</A>, <A HREF="manual.ja_MySQL_Benchmarks.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
