  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 20 July 2001 -->

  <TITLE>MySQL Reference Manual for version 3.23.38. - 21  問題とよくあるエラー</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Common_programs.html">previous</A>, <A HREF="manual.ja_Common_problems.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Problems" HREF="manual.ja_toc.html#Problems">21  問題とよくあるエラー</A></H1>

<P>
This chapter lists some common problems and error messages that users have
run into.  You will learn how to figure out what the problem is, and what
to do to solve it.  You will also find proper solutions to some common
problems.

</P>


<H2><A NAME="What_is_crashing" HREF="manual.ja_toc.html#What_is_crashing">21.1  How to Determine What Is Causing Problems</A></H2>

<P>
When you run into problems, the first thing you should do is to find out
which program / piece of equipment is causing problems:

</P>

<UL>
<LI>

If you have one of the following symptoms, then it is probably a hardware
(like memory, motherboard, CPU, or hard disk) or kernel problem:

<UL>
<LI>

The keyboard doesn't work.  This can normally be checked by pressing
Caps Lock. If the Caps Lock light doesn't change you have to replace
your keyboard.  (Before doing this, you should try to reboot
your computer and check all cables to the keyboard.)
<LI>

The mouse pointer doesn't move.
<LI>

The machine doesn't answer to a remote machine's pings.
<LI>

Different, unrelated programs don't behave correctly.
<LI>

If your system rebooted unexpectedly (a faulty user level program should
NEVER be able to take down your system).
</UL>

In this case you should start by checking all your cables and run some
diagnostic tool to check your hardware!
You should also check if there are any patches, updates, or service
packs for your operating system that could likely solve your problems.
Check also that all your libraries (like glibc) are up to date.

It's always good to use a machine with ECC memory to discover
memory problems early!
<LI>

If your keyboard is locked up, you may be able to fix this by 
logging into your machine from another machine and execute
<CODE>kbd_mode -a</CODE> on it.

<LI>

Please examine your system log file (/var/log/messages or similar) for
reasons for your problems.  If you think the problem is in <STRONG>MySQL</STRONG>
then you should also examine <STRONG>MySQL</STRONG>'s log files.  「<A HREF="manual.ja_Log_files.html#Update_log">23.3  更新ログ</A>」節参照.

<LI>

If you don't think you have hardware problems, you should try to find
out which program is causing problems.

Try using <CODE>top</CODE>, <CODE>ps</CODE>, <CODE>taskmanager</CODE>, or some similar program,
to check which program is taking all CPU or is locking the machine.

<LI>

Check with <CODE>top</CODE>, <CODE>df</CODE>, or a similar program if you are out of
memory, disk space, open files, or some other critical resource.

<LI>

If the problem is some runaway process, you can always try to kill it. If it
doesn't want to die, there is probably a bug in the operating system.
</UL>

<P>
If after you have examined all other possibilities and you have
concluded that it's the <STRONG>MySQL</STRONG> server or a <STRONG>MySQL</STRONG> client
that is causing the problem, it's time to do a bug report for our
mailing list or our support team.  In the bug report, try to give a
very detailed description of how the system is behaving and what you think is
happening. You should also state why you think it's <STRONG>MySQL</STRONG> that
is causing the problems.  Take into consideration all the situations in
this chapter. State any problems exactly how they appear when you
examine your system. Use the 'cut and paste' method for any output
and/or error messages from programs and/or log files!

</P>
<P>
Try to describe in detail which program is not working and all
symptoms you see!  We have in the past received many bug reports that just
state "the system doesn't work".  This doesn't provide us with any
information about what could be the problem.

</P>
<P>
If a program fails, it's always useful to know:

</P>

<UL>
<LI>

Has the program in question made a segmentation fault (core dumped)?
<LI>

Is the program taking the whole CPU? Check with <CODE>top</CODE>. Let the
program run for a while, it may be evaluating something heavy.
<LI>

If it's the <CODE>mysqld</CODE> server that is causing problems, can you
do <CODE>mysqladmin -u root ping</CODE> or <CODE>mysqladmin -u root processlist</CODE>?
<LI>

What does a client program say (try with <CODE>mysql</CODE>, for example)
when you try to connect to the <STRONG>MySQL</STRONG> server?
Does the client jam?  Do you get any output from the program?
</UL>

<P>
When sending a bug report, you should of follow the outlines
described in this manual.  「<A HREF="manual.ja_Questions.html#Asking_questions">2.2  質問またはバグ報告</A>」節参照.

</P>
<P>
<A NAME="IDX1462"></A>


<H3><A NAME="Crashing" HREF="manual.ja_toc.html#Crashing">21.1.1  <STRONG>MySQL</STRONG> がクラッシュする場合に行うこと</A></H3>

<P>
全ての <STRONG>MySQL</STRONG> バージョンはリリースの前に多くのプラットフォームで
テストされます。 これは <STRONG>MySQL</STRONG> にいかなるバグもないということを
意味しますが、発見するのが困難で、わずかなバグがあるかもしれません。
もし問題があった場合、何がシステムをクラッシュしているかを見つけようとする事は、
問題を早く修正するためのより良い機会でもあります。

</P>
<P>
まず最初に, その問題で <CODE>mysqld</CODE> デーモンが死ななければならないかどうかか, また
はその問題がクライアントで処理しなければならないかどうかを調べるべきです。
<CODE>mysqladmin version</CODE> を実行することにより、 <CODE>mysqld</CODE> サーバーが
どれぐらい稼働していたかわかります。 もし <CODE>mysqld</CODE> が死んでいたなら、
を実行することによってあるのかをチェックすることができます. mysqldが死んだなら、
その原因を <TT>`mysql-data-directory/`hostname`.err'</TT> で見つけれるかもしれません。
 「<A HREF="manual.ja_Log_files.html#Error_log">23.1  The Error Log</A>」節参照.

</P>
<P>
Many crashes of <STRONG>MySQL</STRONG> are caused by corrupted index / data
files.  <STRONG>MySQL</STRONG> will update the data on disk, with the
<CODE>write()</CODE> system call, after every SQL statement and before the
client is notified about the result. (This is not true if you are running
with <CODE>delayed_key_writes</CODE>, in which case only the data is written.)
This means that the data is safe even if mysqld crashes, as the OS will
ensure that the not flushed data is written to disk.  You can force
<STRONG>MySQL</STRONG> to sync everything to disk after every SQL command by
starting <CODE>mysqld</CODE> with <CODE>--flush</CODE>.

</P>
<P>
The above means that normally you shouldn't get corrupted tables unless:

</P>

<UL>
<LI>

Someone/something killed <CODE>mysqld</CODE> or the machine in the middle
of an update.
<LI>

You have found a bug in <CODE>mysqld</CODE> that caused it to die in the
middle of an update.
<LI>

Someone is manipulating the data/index files outside of <STRONG>mysqld</STRONG>
without locking the table properly.
<LI>

If you are running many <CODE>mysqld</CODE> servers on the same data on a
system that doesn't support good file system locks (normally handled by
the <CODE>lockd</CODE> daemon ) or if you are running
multiple servers with <CODE>--skip-locking</CODE>
<LI>

You have a crashed index/data file that contains very wrong data that
got mysqld confused.
<LI>

You have found a bug in the data storage code. This isn't that likely,
but it's at least possible.  In this case you can try to change the file
type to another database handler by using <CODE>ALTER TABLE</CODE> on a
repaired copy of the table!
</UL>

<P>
何かがクラッシュする理由を知るのは非常に難しいので、まず、他の人で動くも
のがあなたでクラッシュするのかどうかをチェックしてください。次のことを行っ
てください。

</P>

<UL>
<LI>

<CODE>mysqld</CODE> デーモンを <CODE>mysqladmin shutdown</CODE> で停止し, 全てのテーブルで
<CODE>myisamchk --silent --force */*.MYI</CODE> を実行し、そして <CODE>mysqld</CODE> デーモンを
再起動します.  これはきれいな状態から開始することになります。
 「<A HREF="manual.ja_Maintenance.html#Maintenance">16  Maintaining a MySQL Installation</A>」節参照.

<LI>

<CODE>mysqld --log</CODE> を使用し、ログの情報から特定のクエリがサーバーをキルしているかを
見つけ出してください。 95% のバグは特定のクエリに関係があります！
通常これは、 <STRONG>MySQL</STRONG> が再起動される前の、ログファイルの最後のクエリの一つです。
 「<A HREF="manual.ja_Log_files.html#Query_log">23.2  The Query Log</A>」節参照.
If you can repeatadly kill <STRONG>MySQL</STRONG> with one of the queries, even
when you have checked all tables just before doing the query, then you
have been able to locate the bug and should do a bug report for this!
 「<A HREF="manual.ja_Questions.html#Bug_reports">2.3  バグや問題を報告する方法</A>」節参照.

<LI>

Try to make a test case that we can use to reproduce the problem.
 「<A HREF="manual.ja_Porting.html#Reproducable_test_case">I.1.5  Making a test case when you experience table corruption</A>」節参照.

<LI>

Try running the included mysql-test test and the <STRONG>MySQL</STRONG>
benchmarks.   「<A HREF="manual.ja_MySQL_internals.html#MySQL_test_suite">26.2  MySQL Test Suite</A>」節参照.  They should test <STRONG>MySQL</STRONG>
rather well.  You can also add code that to the benchmarks to simulates
your application!  The benchmarks can be found in the <TT>`bench'</TT>
directory in the source distribution or, for a binary distribution, in
the <TT>`sql-bench'</TT> directory under your <STRONG>MySQL</STRONG> installation
directory.

<LI>

<CODE>fork_test.pl</CODE> と <CODE>fork2_test.pl</CODE> を試します。

<LI>

デバッグ用に <STRONG>MySQL</STRONG> をコンフィグすると、何かが悪くなる場合にエラー
を見つけ出すのがより簡単になります。<CODE>configure</CODE> に 
<CODE>--with-debug</CODE> オプションか <CODE>--with-debug=full</CODE> オプションを
つけて <STRONG>MySQL</STRONG> を再コンフィグし、
再コンパイルしてください。 「<A HREF="manual.ja_Porting.html#Debugging_server">I.1  MySQL server のデバッグ</A>」節参照.

<LI>

デバッグ用に <STRONG>MySQL</STRONG> をコンフィグすると、いくつかのエラーを検出で
きる安全なメモリ割り当てを含めます。これは何が起きているかについての多く
の出力も提供します。

<LI>

あなたの OS の最新のパッチを適用しましたか？

<LI>

<CODE>--skip-locking</CODE> オプションを <CODE>mysqld</CODE> に使用してください。い
くつかのシステム上では、<CODE>lockd</CODE> ロックマネージャは正しく動きません;
<CODE>--skip-locking</CODE> オプションは <CODE>mysqld</CODE> に外部ロッキングを使用
しないように伝えます。(これは同じデータ上で2つの <CODE>mysqld</CODE> サーバを
動すことができず、<CODE>myisamchk</CODE> の使用時に注意しなければいけないことを
意味します。しかし、テストとしてこのオプションを試すことは指示できます。)

<LI>

<CODE>mysqld</CODE> が動いているのに応答がないように見えた時 
<CODE>mysqladmin -u root processlist</CODE> を試しましたか？ 時々 
<CODE>mysqld</CODE> はそう思えても死んでいません。問題は全ての接続が使用中であ
ることか、いくつかの内部ロック問題があることです。<CODE>mysqladmin
processlist</CODE> は通常これらの場合でも接続を作ることができ、現在の接続数と
それらの状態についての有用な情報を提供できます。

<LI>

別のウィンドウで、統計出力のためにコマンド <CODE>mysqladmin -i 5 status</CODE> 
や <CODE>mysqladmin -i 5 -r status</CODE> をクエリ中に行ってください。

<LI>

次を試してください:

<OL>
<LI>

<CODE>gdb</CODE> (または他のデバッガ) から <CODE>mysqld</CODE> を開始してください。

<LI>

あなたのテストスクリプトを実行してください。

<LI>

Print the backtrace and the local variables at the 3 lowest levels. In gdb you
can do this with the following commands when <CODE>mysqld</CODE> has crashed inside
gdb:


<PRE>
backtrace
info local
up
info local
up
info local
</PRE>

With gdb you can also examine which threads exist with <CODE>info
threads</CODE> and switch to a specific thread with <CODE>thread #</CODE>, where
<CODE>#</CODE> is the thread id.
</OL>

<LI>

<STRONG>MySQL</STRONG> にクラッシュまたは間違った振る舞いをさせるあなたのアプリ
ケーションのシミュレートを Perl スクリプトで試みてください。

<LI>

または通常のバグレポートを送ってください。 「<A HREF="manual.ja_Questions.html#Bug_reports">2.3  バグや問題を報告する方法</A>」節参照。しかし通常
よりもさらに詳細にしてください。<STRONG>MySQL</STRONG> は多くの人のために働いて
いるため、クラッシュはあなたのコンピュータだけに存在する何か(例えば、あ
なたの特別なシステムライブラリに関連したエラー)から生じていると思われま
す。
<LI>

もし可変長のレコードを扱うテーブルで問題があった場合、
もし、<CODE>BLOB/TEXT</CODE> フィールドは使用しておらず、<CODE>VARCHAR</CODE> フィールド
だけ使用しているなら、全ての <CODE>VARCHAR</CODE> フィールドを
 <CODE>ALTER TABLE</CODE> で <CODE>CHAR</CODE> に変更してみてください。
これは <STRONG>MySQL</STRONG> に固定長レコードを使用させるようにします。
固定長レコードは少し余分な領域をとりますが、よりエラーに対して
強くなります。

現在の可変長のレコードのコードは <STRONG>MySQL AB</STRONG> で少なくとも３年以上問題なく
使用されています。 しかし可変長のレコードはよりエラーの傾向があり、
上記の事柄を試すことは良いアイデアです！
</UL>

<P>
<A NAME="IDX1463"></A>
<A NAME="IDX1464"></A>
<A NAME="IDX1465"></A>


<H2><A NAME="Link_errors" HREF="manual.ja_toc.html#Link_errors">21.2  Problems When Linking with the MySQL Client Library</A></H2>

<P>
If you are linking your program and you get errors for unreferenced
symbols that start with <CODE>mysql_</CODE>, like the following:

</P>

<PRE>
/tmp/ccFKsdPa.o: In function `main':
/tmp/ccFKsdPa.o(.text+0xb): undefined reference to `mysql_init'
/tmp/ccFKsdPa.o(.text+0x31): undefined reference to `mysql_real_connect'
/tmp/ccFKsdPa.o(.text+0x57): undefined reference to `mysql_real_connect'
/tmp/ccFKsdPa.o(.text+0x69): undefined reference to `mysql_error'
/tmp/ccFKsdPa.o(.text+0x9a): undefined reference to `mysql_close'
</PRE>

<P>
you should be able to solve this by adding <CODE>-Lpath-to-the-mysql-library
-lmysqlclient</CODE> <STRONG>LAST</STRONG> on your link line.

</P>
<P>
If you get <CODE>undefined reference</CODE> errors for the <CODE>uncompress</CODE>
or <CODE>compress</CODE> function, add <CODE>-lgz</CODE> <STRONG>LAST</STRONG> on your link
line and try again!

</P>
<P>
If you get <CODE>undefined reference</CODE> errors for functions that should
exist on your system, like <CODE>connect</CODE>, check the man page for the
function in question, for which libraries you should add to the link
line!

</P>
<P>
If you get <CODE>undefined reference</CODE> errors for functions that don't
exist on your system, like the following:

</P>

<PRE>
mf_format.o(.text+0x201): undefined reference to `__lxstat'
</PRE>

<P>
it usually means that your library is compiled on a system that is not
100 % compatible with yours.  In this case you should download the
latest <STRONG>MySQL</STRONG> source distribution and compile this yourself.
 「<A HREF="manual.ja_Installing.html#Installing_source">4.7  <STRONG>MySQL</STRONG> ソースディストリビューションのインストール</A>」節参照.

</P>
<P>
If you are trying to run a program and you then get errors for
unreferenced symbols that start with <CODE>mysql_</CODE> or that the
<CODE>mysqlclient</CODE> library can't be found, this means that your system
can't find the share <CODE>libmysqlclient.so</CODE> library.

</P>
<P>
The fix for this is to tell your system to search after shared
libraries where the library is located by one of the following methods:

</P>

<UL>
<LI>

Add the path to the directory where you have <CODE>libmysqlclient.so</CODE> the
<CODE>LD_LIBRARY_PATH</CODE> environment variable.
<LI>

Add the path to the directory where you have <CODE>libmysqlclient.so</CODE> the
<CODE>LD_LIBRARY</CODE> environment variable.
<LI>

Copy <CODE>libmysqlclient.so</CODE> to some place that is searched by your system,
like <TT>`/lib'</TT>, and update the shared library information by executing
<CODE>ldconfig</CODE>.
</UL>

<P>
Another way to solve this problem is to link your program statically, with
<CODE>-static</CODE>, or by removing the dynamic <STRONG>MySQL</STRONG> libraries
before linking your code. In the second case you should be
sure that no other programs are using the dynamic libraries!

</P>
<P>
<A NAME="IDX1466"></A>


<H2><A NAME="Common_errors" HREF="manual.ja_toc.html#Common_errors">21.3  <STRONG>MySQL</STRONG>使用時のよくあるいくつかのエラー</A></H2>

<P>
This section lists some errors that users frequently get.  You will find 
descriptions of the errors, and how to solve the problem here.

</P>
<P>
<A NAME="IDX1467"></A>
<A NAME="IDX1468"></A>
<A NAME="IDX1469"></A>


<H3><A NAME="Error_Access_denied" HREF="manual.ja_toc.html#Error_Access_denied">21.3.1  <CODE>Access denied</CODE> Error</A></H3>

<P>
 「<A HREF="manual.ja_Privilege_system.html#Privileges">6.8  特権システムはどのように動くか？</A>」節参照, and especially.  「<A HREF="manual.ja_Privilege_system.html#Access_denied">6.15  何故 <CODE>Access denied</CODE> エラーになるのか</A>」節参照.

</P>


<H3><A NAME="Gone_away" HREF="manual.ja_toc.html#Gone_away">21.3.2  <CODE>MySQL server has gone away</CODE> エラー</A></H3>

<P>
このセクションは <CODE>Lost connection to server
during query</CODE> エラーに関することもカバーします。

</P>
<P>
<CODE>MySQL server has gone away</CODE> エラーのもっとも一般的な理由は、サーバ
がタイムアウトで接続をクローズしたことです。デフォルトでは、何も起きない
場合、サーバは 8 時間後に接続をクローズします。
この時間は mysqld 起動時の <CODE>wait_timeout</CODE> 変数に与えることにより、変更できます。

</P>
<P>
Another common reason to receive the <CODE>MySQL server has gone away</CODE> error
is because you have issued a ``close'' on your <STRONG>MySQL</STRONG> connection
and then tried to run a query on the closed connection.

</P>
<P>
<CODE>mysqladmin version</CODE> を実行することで <STRONG>MySQL</STRONG> が死んでいるかどうか、
また uptime はどれぐらいか、チェックできます。

</P>
<P>
スクリプトの場合は、自動的に再接続するためにクライアントからクエリを再発
行する必要があります。

</P>
<P>
この場合、通常これらのエラーコードを得ます:
(OS 依存です):

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>CR_SERVER_GONE_ERROR</CODE> </TD><TD> クライアントがサーバーに問い合わせを送ることができなかった
</TR NOSAVE>
<TR><TD><CODE>CR_SERVER_LOST</CODE> </TD><TD> クライアントがサーバーに書き込みを行ったときにはエラーは無かったけれども、問い合わせに対して完全に回答が返ってこない
</TR>
</TABLE>

<P>
間違っているか大きすぎるクエリをサーバに送った場合にもこのエラーが発生し
ます。<CODE>mysqld</CODE> が間違ったブロックを得た場合、クライアントの何かが間違った
と見なし、接続をクローズします。大きなクエリが必要な場合、例えば大きな 
<CODE>BLOB</CODE> で働かせる場合は、<CODE>mysqld</CODE> をオプション <CODE>-O max_query_size=#</CODE>
(デフォルト 1M) で起動することでクエリ制限を増加できます。拡張メモリ
は要求によって割り当てられます。そのため、<CODE>mysqld</CODE> は大きなクエリを発行し
た時や大きな結果行を返す必要のある時だけ、多くのメモリを使用します！

</P>



<H3><A NAME="Can_not_connect_to_server" HREF="manual.ja_toc.html#Can_not_connect_to_server">21.3.3  <CODE>Can't connect to [local] MySQL server</CODE> エラー</A></H3>

<P>
UNIX 上の <STRONG>MySQL</STRONG> クライアントは  <CODE>mysqld</CODE> サーバに2つの異なる方法で接続できます:
UNIX ソケット, これはファイルシステム上のファイル(デフォルト 
<TT>`/tmp/mysql.sock'</TT>)を通して接続します。または TCP/IP, これはポート番
号を通して接続します。Unix ソケットは TCP/IP よりも速いですが、サーバと
同じコンピュータから接続する時しか使えません。UNIX ソケットは、ホスト名
を指定しない場合か、特別なホスト名 <CODE>localhost</CODE> を指定した場合に使用され
ます。

</P>
<P>
On Windows you can connect only with TCP/IP if the <CODE>mysqld</CODE> server
is running on Win95/Win98. If it's running on NT, you can also connect
with named pipes.  The name of the named pipe is <STRONG>MySQL</STRONG>.  If you
don't give a hostname when connecting to <CODE>mysqld</CODE>, a <STRONG>MySQL</STRONG> client
will first try to connect to the named pipe, and if this doesn't work it
will connect to the TCP/IP port.  You can force the use of named pipes
on Windows by using <CODE>.</CODE> as the hostname. 

</P>
<P>
(2002) <CODE>Can't connect to ...</CODE> エラーは、通常、<STRONG>MySQL</STRONG> サーバーが
システム上に走っていないか、あなたが、間違ったソケットファイルや
TCP/IP ポートを使用して <CODE>mysqld</CODE> に接続しようとする場合におきます。

</P>
<P>
Start by check 
サーバー上に <CODE>mysqld</CODE> というプロセスが走っているか ( <CODE>ps</CODE> を使用して。 Windows の場合はタスクマネージャでみて)
確認することから開始してください！
 「<A HREF="manual.ja_Installing.html#Starting_server">4.16.2  <STRONG>MySQL</STRONG> サーバー起動時の問題</A>」節参照.

</P>
<P>
<CODE>mysqld</CODE> プロセスが走っているなら、違う接続を試すことでサーバーを
確認することができます（もちろん、ポート番号とソケットのパスはあなたが
セットアップしたものとは違うでしょう）：

</P>

<PRE>
shell&#62; mysqladmin version
shell&#62; mysqladmin variables
shell&#62; mysqladmin -h `hostname` version variables
shell&#62; mysqladmin -h `hostname` --port=3306 version
shell&#62; mysqladmin -h 'ip for your host' version
shell&#62; mysqladmin --socket=/tmp/mysql.sock version
</PRE>

<P>
<CODE>hostname</CODE> コマンドはフォワードクオートでなくバッククオテーションで
囲んでいることに注意してください； これは <CODE>ホスト名</CODE> (カレントのホスト名) 
を <CODE>mysqladmin</CODE> コマンドに与えます。

</P>
<P>
<CODE>Can't connect to local MySQL server</CODE> エラーが起こりうる理由として：

</P>

<UL>
<LI>

<CODE>mysqld</CODE> is not running.
<LI>

MIT-pthreads を使用するシステム上で実行している。
ネイティブスレッドを持たないシステム上で実行している場合 <CODE>mysqld</CODE> は  MIT-pthreads パッケージを使用します。
 「<A HREF="manual.ja_Installing.html#Which_OS">4.2  <STRONG>MySQL</STRONG> がサポートする OS</A>」節参照.
MIT-pthreads スレッドは UNIX ソケットをサポートしません。
そのため、サーバに接続する時は常にホスト名を与える必要があります。
サーバーへの接続をチェックするために、以下を試してください：

<PRE>
shell&#62; mysqladmin -h `hostname` version
</PRE>

<LI>

誰かが <CODE>mysqld</CODE> が使用する UNIX ソケット を削除した (default <TT>`/tmp/mysqld.sock'</TT>).
だれかが <CODE>cron</CODE> で <STRONG>MySQL</STRONG> ソケットを削除しているかもしれません。(例えば <TT>`/tmp'</TT> ディレクトリから古いファイルを削除するようなクローンで)。
いつでも <CODE>mysqladmin version</CODE> を実行して
<CODE>mysqladmin</CODE> が使用するソケットが本当に存在するかをチェックできます。
この場合の修正は、<TT>`mysqld.sock'</TT> を消さないように <CODE>cron</CODE> を変更するか、またはソケットをどこか他の場所に移すことです。

<STRONG>MySQL</STRONG> を ./configure する場合にソケットを指定するには以下のようにします:

<PRE>
shell&#62; ./configure --with-unix-socket-path=/path/to/socket
</PRE>

また、<CODE>safe_mysqld</CODE> を <CODE>--socket=/path/to/socket</CODE> オプションを指定して起動しても構いませんし、
<CODE>MYSQL_UNIX_PORT</CODE> 環境変数をセットして <STRONG>MySQL</STRONG> クライアントを実行してもかまいません。

<LI>

<CODE>--socket=/path/to/socket</CODE> オプションで <CODE>mysqld</CODE> サーバーを起動できます。
もしサーバーのソケットのパスを変えた場合、<STRONG>MySQL</STRONG> クライアントに、新しいパスを教えなければなりません。
この場合、 <CODE>MYSQL_UNIX_PORT</CODE> 環境変数に設定することにより可能です。
ソケットのテストをする場合、以下のようにします：


<PRE>
shell&#62; mysqladmin --socket=/path/to/socket version
</PRE>

<LI>

Linux を使用していてスレッドが一つ死んだとき（コアダンプした）。
この場合、他の <CODE>mysqld</CODE> スレッドをキルしなければなりません。
たとえば、<CODE>mysql_zap</CODE> スクリプトを、新しく <STRONG>MySQL</STRONG> サーバーを
起動する前に実行します。  「<A HREF="manual.ja_Problems.html#Crashing">21.1.1  <STRONG>MySQL</STRONG> がクラッシュする場合に行うこと</A>」節参照.
<LI>

You may not have read and write privilege to either the directory that holds
the socket file or privilege to the socket file itself. In this case you
have to either change the privilege for the directory / file or restart
<CODE>mysqld</CODE> so that it uses a directory that you can access.
</UL>

<P>
もし <CODE>Can't connect to MySQL server on some_hostname</CODE> エラーの場合,
何が問題なのかを見つけるために、以下の手順を踏みます：

</P>

<UL>
<LI>

もし <CODE>telnet your-host-name tcp-ip-port-number</CODE> を実行すると
サーバーがアップするなら、 <CODE>RETURN</CODE> を何回かたたいてください。
もしこのポートで <STRONG>MySQL</STRONG> サーバーが走っているなら、
走っている <STRONG>MySQL</STRONG> サーバーのバージョンナンバーを含んだ
レスポンスが得られるはずです。
もし <CODE>telnet: Unable to connect to remote host: Connection refused</CODE> のような
エラーになったならば、このポートを使用しているサーバーはありません。

<LI>

ローカルのマシンの <CODE>mysqld</CODE> デーモンに接続してみてください。
<CODE>mysqld</CODE> が使用するように指定された TCP/IP ポートをチェックしてください。
（<CODE>mysqladmin variables</CODE> で得られる <CODE>port</CODE> 変数）

<LI>

<CODE>mysqld</CODE> サーバーが <CODE>--skip-networking</CODE> オプションで起動されていないか
確認してください。
</UL>



<H3><A NAME="Blocked_host" HREF="manual.ja_toc.html#Blocked_host">21.3.4  <CODE>Host '...' is blocked</CODE> エラー</A></H3>

<P>
以下のエラーの場合：

</P>

<PRE>
Host 'hostname' is blocked because of many connection errors.
Unblock with 'mysqladmin flush-hosts'
</PRE>

<P>
これは <CODE>mysqld</CODE> が多くの <CODE>'hostname'</CODE> ホストからの接続エラー(<CODE>max_connect_errors</CODE>)
を受けた場合に発生します。
この <CODE>max_connect_errors</CODE> 大量発生後、<CODE>mysqld</CODE> は何か(クラッカーによるサーバーへのアタックなど)が起こったと判断し、このホストからの接続をいっさい拒否するようにします。
これを解除するには、<CODE>mysqladmin flush-hosts</CODE> コマンドを実行します。

</P>
<P>
デフォルトでは、10回の接続エラーが発生した場合に、<CODE>mysqld</CODE> はそのホストを拒否します。
この値は以下のようにして簡単に変更できます：

</P>

<PRE>
shell&#62; safe_mysqld -O max_connect_errors=10000 &#38;
</PRE>

<P>
もしこのエラーがあるホストに対して発生するならば、まず最初にそのホストからの TCP/IP 接続に不具合がないかチェックしてください。
もし TCP/IP 接続が動作していないようなら、 <CODE>max_connect_errors</CODE> 値を増やすことはよくないことです！

</P>


<H3><A NAME="Too_many_connections" HREF="manual.ja_toc.html#Too_many_connections">21.3.5  <CODE>Too many connections</CODE> エラー</A></H3>

<P>
もし <STRONG>MySQL</STRONG> に接続しようとして <CODE>Too many connections</CODE> となった場合、
これは既に <CODE>max_connections</CODE> 分、クライアントから <CODE>mysqld</CODE> サーバーへの
接続が行われています。

</P>
<P>
もしデフォルトの100よりも多い接続を必要とするならば、
<CODE>max_connections</CODE> 変数に多くの値を与えて、<CODE>mysqld</CODE> を
リスタートしなくてはなりません。

</P>
<P>
実際は、<CODE>mysqld</CODE> は (<CODE>max_connections</CODE>+1) 個のクライアントからの接続を許しています。
最後の１個は、 <CODE>process</CODE> 権限をもつユーザーのために取ってあります。
By not giving this privilege to normal
users (they shouldn't need this), an administrator with this privilege
can log in and use <CODE>SHOW PROCESSLIST</CODE> to find out what could be
wrong.  「<A HREF="manual.ja_Reference.html#SHOW">7.28  <CODE>SHOW</CODE> 構文</A>」節参照.

</P>
<P>
The maximum number of connects <STRONG>MySQL</STRONG> is depending on how good
the thread library is on a given platform. Linux or Solaris should be
able to support 500-1000 simultaneous connections, depending on how much
RAM you have and what your clients are doing.

</P>
<P>
<A NAME="IDX1470"></A>


<H3><A NAME="Non-transactional_tables" HREF="manual.ja_toc.html#Non-transactional_tables">21.3.6  <CODE>Some non-transactional changed tables couldn't be rolled back</CODE> Error</A></H3>

<P>
If you get the error/warning: <CODE>Warning: Some non-transactional
changed tables couldn't be rolled back</CODE> when trying to do a
<CODE>ROLLBACK</CODE>, this means that some of the tables you used in the
transaction didn't support transactions.  These non-transactional tables
will not be affected by the <CODE>ROLLBACK</CODE> statement.

</P>
<P>
The most typical case when this happens is when you have tried to create
a table of a type that is not supported by your <CODE>mysqld</CODE> binary.
If <CODE>mysqld</CODE> doesn't support a table type (or if the table type is
disabled by a startup option) , it will instead create the table type
with the table type that is most resembles to the one you requested,
probably <CODE>MyISAM</CODE>.

</P>
<P>
You can check the table type for a table by doing:

</P>
<P>
<CODE>SHOW TABLE STATUS LIKE 'table_name'</CODE>.  「<A HREF="manual.ja_Reference.html#SHOW_TABLE_STATUS">7.28.2  <CODE>SHOW TABLE STATUS</CODE></A>」節参照.

</P>
<P>
You can check the extensions your <CODE>mysqld</CODE> binary supports by doing:

</P>
<P>
<CODE>show variables like 'have_%'</CODE>.  「<A HREF="manual.ja_Reference.html#SHOW_VARIABLES">7.28.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.

</P>


<H3><A NAME="Out_of_memory" HREF="manual.ja_toc.html#Out_of_memory">21.3.7  <CODE>Out of memory</CODE> エラー</A></H3>

<P>
クエリを行って、次のエラーのようなものを得た場合:

</P>

<PRE>
mysql: Out of memory at line 42, 'malloc.c'
mysql: needed 8136 byte (8k), memory in use: 12481367 bytes (12189k)
ERROR 2008: MySQL client ran out of memory
</PRE>

<P>
エラーは <STRONG>MySQL</STRONG> クライアント <CODE>mysql</CODE> に関係することに注意してください。エ
ラーの理由は単純で、クライアントが結果全体を格納するのに十分なメモリを持っ
ていないことです。

</P>
<P>
この問題を解決するにあたり、まず最初にクエリーが正しいか確認してください。
そのクエリーは大量の結果を返すものでしょうか？
もしそうなら、<CODE>mysql --quick</CODE> を使用してください。
これは結果を取り出すために <CODE>mysql_use_result()</CODE> を使用します。
これはクライアントのロード不足を補います(サーバーより多い領域は取れません)。

</P>


<H3><A NAME="Packet_too_large" HREF="manual.ja_toc.html#Packet_too_large">21.3.8  <CODE>Packet too large</CODE> エラー</A></H3>

<P>
<STRONG>MySQL</STRONG> クライアントが <CODE>max_allowed_packet</CODE> よりも大きなブロックを <CODE>mysqld</CODE> サーバーから得た時、<CODE>Packet too large</CODE> エラーを発します。

</P>
<P>
<CODE>mysql</CODE> クライアントを使用する場合、<CODE>mysql --set-variable=max_allowed_packet=8M</CODE>
 でクライアントを開始することで、バッファを大きく設定できます。

</P>
<P>
もし(<CODE>DBI</CODE> のように)最大パケットサイズを指定できないクライアントを使用している場合、
パケットサイズを指定してサーバーを立ち上げ直します。
これは <CODE>mysqld</CODE> のオプションの <CODE>max_allowed_packet</CODE> に大きな値を設定することで行います。
例えば、 <CODE>BLOB</CODE> 型の許容範囲いっぱいのデータをテーブルに入れる場合、
<CODE>--set-variable=max_allowed_packet=16M</CODE> オプションを指定してサーバーを起動する必要があります。

</P>
<P>
<A NAME="IDX1471"></A>
<A NAME="IDX1472"></A>
<A NAME="IDX1473"></A>


<H3><A NAME="Communication_errors" HREF="manual.ja_toc.html#Communication_errors">21.3.9  Communication Errors / Aborted Connection</A></H3>

<P>
If you find errors like the following in your error log.

</P>

<PRE>
010301 14:38:23  Aborted connection 854 to db: 'users' user: 'josh'
</PRE>

<P>
 「<A HREF="manual.ja_Log_files.html#Error_log">23.1  The Error Log</A>」節参照.

</P>
<P>
This means that something of the following has happened:

</P>

<UL>
<LI>

The client program did not call <CODE>mysql_close()</CODE> before exit.
<LI>

The client had been sleeping more than <CODE>wait_timeout</CODE> or
<CODE>interactive_timeout</CODE> without doing any requests.  「<A HREF="manual.ja_Reference.html#SHOW_VARIABLES">7.28.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.
<LI>

The client program ended abruptly in the middle of the transfer.
</UL>

<P>
When the above happens, the server variable <CODE>Aborted_clients</CODE> is
incremented.

</P>
<P>
The server variable <CODE>Aborted_connects</CODE> is incremented when:

</P>

<UL>
<LI>

When a connection packet doesn't contain the right information.
<LI>

When the user didn't have privileges to connect to a database.
<LI>

When a user uses a wrong password.
<LI>

When it takes more than <CODE>connect_timeout</CODE> seconds to get
a connect package.
</UL>

<P>
Note that the above could indicate that someone is trying to break into
your database!

</P>
<P>
 「<A HREF="manual.ja_Reference.html#SHOW_VARIABLES">7.28.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.

</P>
<P>
Other reasons for problems with Aborted clients / Aborted connections.

<UL>
<LI>

Usage of duplex Ethernet protocol, both half and full with
Linux. Many Linux Ethernet drivers have this bug. You should test
for this bug by transferring a huge file via ftp between these two
machines. If a transfer goes in burst-pause-burst-pause ... mode then
you are experiencing a Linux duplex syndrome. The only solution to
this problem is switching of both half and full duplexing on hubs
and switches.
<LI>

Some problem with the thread library that causes interrupts on reads.
<LI>

Badly configured TCP/IP.
<LI>

Faulty Ethernets or hubs or switches, cables ... This can be diagnosed
properly only by replacing hardware.
</UL>

<P>
<A NAME="IDX1474"></A>


<H3><A NAME="Full_table" HREF="manual.ja_toc.html#Full_table">21.3.10  <CODE>The table is full</CODE> エラー</A></H3>

<P>
このエラーは、古い <STRONG>MySQL</STRONG> バージョンにおいて、
メモリ内一時テーブルが <CODE>tmp_table_size</CODE> よりも大きくなっ
た時に発生します。この問題を回避するために、<CODE>mysqld</CODE> のオプション <CODE>-O
tmp_table_size=#</CODE> で増加、または、SQL オプション <CODE>SQL_BIG_TABLES</CODE> 
を問題のクエリの前に使用できます。 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.33  <CODE>SET</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>mysqld</CODE> を <CODE>--big-tables</CODE> オプション指定して起動します。
これは全てのクエリーに対して <CODE>SQL_BIG_TABLES</CODE> を使用するのと同じです。

</P>
<P>
In <STRONG>MySQL</STRONG> Version 3.23, in-memory temporary tables will automatically be
converted to a disk-based <CODE>MyISAM</CODE> table after the table size gets
bigger than <CODE>tmp_table_size</CODE>.

</P>
<P>
<A NAME="IDX1475"></A>


<H3><A NAME="Cannot_create" HREF="manual.ja_toc.html#Cannot_create">21.3.11  <CODE>Can't create/write to file</CODE> Error</A></H3>

<P>
If you get an error for some queries of type:

</P>

<PRE>
Can't create/write to file '\\sqla3fe_0.ism'.
</PRE>

<P>
this means that <STRONG>MySQL</STRONG> can't create a temporary file for the
result set in the given temporary directory. (The above error is a
typical error message on Windows, and the Unix error message is similar.)
The fix is to start mysqld with <CODE>--tmpdir=path</CODE> or to add to your option
file:

</P>

<PRE>
[mysqld]
tmpdir=C:/temp
</PRE>

<P>
assuming that the <TT>`c:\\temp'</TT> directory exists.  「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照.

</P>
<P>
Check also the error code that you get with <CODE>perror</CODE>. One reason
may also be a disk full error;

</P>

<PRE>
shell&#62; perror 28
Error code  28:  No space left on device
</PRE>

<P>
<A NAME="IDX1476"></A>


<H3><A NAME="Commands_out_of_sync" HREF="manual.ja_toc.html#Commands_out_of_sync">21.3.12  <CODE>Commands out of sync</CODE> Error in Client</A></H3>

<P>
<CODE>Commands out of sync; You can't run this command now</CODE> をクライアン
トコード中で得た場合、クライアント関数を間違った順番で呼び出しました！

</P>
<P>
これは例えば、<CODE>mysql_use_result()</CODE> を使用していて、<CODE>mysql_free_result()</CODE>
を行う前に新しいクエリの実行を試みた場合に発生します。これはまた、データ
を返す２つのクエリの実行を、間に <CODE>mysql_use_result()</CODE> や 
<CODE>mysql_store_result()</CODE> 無しで試みた場合にも発生します。

</P>



<H3><A NAME="Ignoring_user" HREF="manual.ja_toc.html#Ignoring_user">21.3.13  <CODE>Ignoring user</CODE> エラー</A></H3>

<P>
以下のエラーの場合：

</P>
<P>
<CODE>Found wrong password for user: 'some_user@some_host'; Ignoring user</CODE>

</P>
<P>
これは <CODE>mysqld</CODE> の開始または 'reload' 時に <CODE>user</CODE> テーブル内に正しいパスワー
ドを持たないエントリを見つけたことを意味します。
これは単にエントリが許可システムに拒否されているだけです。

</P>
<P>
起こり得ることとその解決:

</P>

<UL>
<LI>

新しいバージョンの <CODE>mysqld</CODE> を、古いバージョン用の <CODE>user</CODE> テーブルで走らせているのかもしれません。
<CODE>mysqlshow mysql user</CODE> を行うことによってこれを検証できます。
パスワードフィールドが 16 文字よりも短いかどうかをチェックしてください。
もしそうなら、これを修正するために、<CODE>scripts/add_long_password</CODE> スクリプトを実行してください。

<LI>

ユーザーが古いパスワード(最大8文字) を使用していて、<CODE>mysqld</CODE> を <CODE>--old-protocol</CODE> オプションで起動していないのかもしれません。
新しいパスワードで <CODE>user</CODE> テーブル内のユーザを更新するか、<CODE>--old-protocol</CODE>
付きで <CODE>mysqld</CODE> を再起動してください。

<LI>

<A NAME="IDX1477"></A>
<CODE>user</CODE> テーブルのパスワードを、<CODE>PASSWORD()</CODE> 関数を使用しないで登録したのかもしれません。
この場合、<CODE>user</CODE> テーブルのパスワードを、<CODE>mysql</CODE> を使用して更新します。
<CODE>PASSWORD()</CODE> 関数は以下のようにして使用します：


<PRE>
mysql&#62; update user set password=PASSWORD('your password')
           where user='XXX';
</PRE>

</UL>



<H3><A NAME="Cannot_find_table" HREF="manual.ja_toc.html#Cannot_find_table">21.3.14  <CODE>Table 'xxx' doesn't exist</CODE> Error</A></H3>

<P>
もし <CODE>Table 'xxx' doesn't exist</CODE> か <CODE>Can't find file: 'xxx' (errno: 2)</CODE>
 エラーが出た場合、使用しているデータベースに  <CODE>xxx</CODE> という名前のテーブルが
見付からなかったことを示します

</P>
<P>
データベースとテーブルの保存に、<STRONG>MySQL</STRONG> はディレクトリとファイルを使用し、
データベースとテーブルの名前は<STRONG>ケース依存</STRONG>です!
(Windows ではデータベースとテーブル名はケース非依存です。
クエリ中のテーブルに対する問い合わせは全て、同じケースで書かなくてはなりません！)

</P>
<P>
<CODE>SHOW TABLES</CODE> を使用してデータベースのテーブルを確認できます.  「<A HREF="manual.ja_Reference.html#SHOW">7.28  <CODE>SHOW</CODE> 構文</A>」節参照.

</P>
<P>
<A NAME="IDX1478"></A>


<H3><A NAME="Cannot_initialize_character_set" HREF="manual.ja_toc.html#Cannot_initialize_character_set">21.3.15  <CODE>Can't initialize character set xxx</CODE> error.</A></H3>

<P>
If you get an error like:

</P>

<PRE>
MySQL Connection Failed: Can't initialize character set xxx
</PRE>

<P>
This means one of the following things:

</P>

<UL>
<LI>

The character set is a multi-byte character set and you have not support
for the character set in the client.

In this case you need to recompile the client with
<CODE>--with-charset=xxx</CODE> or with <CODE>--with-extra-charsets=xxx</CODE>.
 「<A HREF="manual.ja_Installing.html#configure_options">4.7.3  典型的な configure オプション</A>」節参照.

All standard <STRONG>MySQL</STRONG> binaries are compiled with
<CODE>--with-extra-character-sets=complex</CODE> which will enable support for
all multi-byte character sets.  「<A HREF="manual.ja_Server.html#Character_sets">10.1.1  データとソートに使用されるキャラクターセット</A>」節参照.

<LI>

The character set is a simple character set which is not compiled into
<CODE>mysqld</CODE> and the character set definition files is not in the place
where the client expect to find them.

In this case you need to:


<UL>
<LI>

Recompile the client with support for the character set.
 「<A HREF="manual.ja_Installing.html#configure_options">4.7.3  典型的な configure オプション</A>」節参照.
<LI>

Specify to the client where the character set definition files are. For many
client you can do this with the
<CODE>--character-sets-dir=path-to-charset-dir</CODE> option.
<LI>

Copy the character definition files to the path where the client expect them
to be.
</UL>

</UL>

<P>
<A NAME="IDX1479"></A>
<A NAME="IDX1480"></A>


<H2><A NAME="Full_disk" HREF="manual.ja_toc.html#Full_disk">21.4  <STRONG>MySQL</STRONG> はフルディスクをどのように扱うか？</A></H2>

<P>
ディスクフルが起きた場合 <STRONG>MySQL</STRONG> は次のことを行います:

</P>

<UL>
<LI>

現在の行を書くのに十分な領域があるかどうかを1分毎に1回チェックします。十
分なディスクがある場合は、何も起きなかったように継続します。
<LI>

6分毎にログファイルにディスクフルを警告するエントリを書き出します。
</UL>

<P>
この問題の場合、以下のようにします：

</P>

<UL>
<LI>

継続するためには、全てのレコードを挿入するのに十分な領域を解放する必要が
あります。
<LI>

スレッドをアボートするためには、<CODE>mysqladmin kill</CODE> をスレッドに送る
必要があります。スレッドは次に(1分)ディスクをチェックした時にアボートし
ます。
<LI>

他のスレッドが ``disk full'' が発生したテーブルで待たされることに注意して
ください。多くの ``locked'' スレッドがある場合、disk full を待つ一つのスレッ
ドを kill することで、他のスレッドの継続を許します。
</UL>

<P>
Exceptions to the above behaveour is when you use <CODE>REPAIR</CODE> or
<CODE>OPTIMIZE</CODE> or when the indexes are created in a batch after an
<CODE>LOAD DATA INFILE</CODE> or after an <CODE>ALTER TABLE</CODE> statement.

</P>
<P>
All of the above commands may use big temporary files that left to
themself would cause big problems for the rest of the system.  If
<STRONG>MySQL</STRONG> gets disk full while doing any of the above operations,
it will remove the big temporary files and mark the table as crashed
(except for <CODE>ALTER TABLE</CODE>, in which the old table will be left
unchanged).

</P>


<H2><A NAME="Multiple_sql_commands" HREF="manual.ja_toc.html#Multiple_sql_commands">21.5  テキストファイルから SQL コマンドを実行</A></H2>

<P>
<CODE>mysql</CODE> クライアントは以下のようにして対話的に使用します：

</P>

<PRE>
shell&#62; mysql database
</PRE>

<P>
しかし SQL コマンドをファイルに書いておき、それを <CODE>mysql</CODE> に読み込ませることができます。
テキストファイル <TT>`text_file'</TT> に実行したいコマンドを書いておき、
以下のようにして <CODE>mysql</CODE> を起動します：

</P>

<PRE>
shell&#62; mysql database &#60; text_file
</PRE>

<P>
テキストファイルの先頭に <CODE>USE db_name</CODE> 構文を書くこともできます。
この場合、データベース名をコマンドラインに与える必要は無く、以下のようにできます：

</P>

<PRE>
shell&#62; mysql &#60; text_file
</PRE>

<P>
 「<A HREF="manual.ja_Tools.html#Programs">15.1  様々な <STRONG>MySQL</STRONG> プログラムの概要</A>」節参照.

</P>



<H2><A NAME="Temporary_files" HREF="manual.ja_toc.html#Temporary_files">21.6  <STRONG>MySQL</STRONG> が一時ファイルを格納する場所</A></H2>

<P>
<STRONG>MySQL</STRONG> は一時ファイルを格納する場所として <CODE>TMPDIR</CODE> 環境変数の値を
使用します。<CODE>TMPDIR</CODE> を設定していなければ、<STRONG>MySQL</STRONG> はシステムのデフォ
ルトを使用します。通常は <TT>`/tmp'</TT> または <TT>`/usr/tmp'</TT> です。<CODE>TMPDIR</CODE> が小さ
すぎる場合、<CODE>safe_mysqld</CODE> を編集して、十分な領域がある他のディレクトリを指
すように <CODE>TMPDIR</CODE> を設定すべきです！
<CODE>--tmpdir</CODE> オプションを <CODE>mysqld</CODE> に与えることで、一時ファイルディレクトリを指定することも可能です。

</P>
<P>
<STRONG>MySQL</STRONG> は全ての一時ファイルを ``隠しファイル'' として生成します。
これは <CODE>mysqld</CODE> が終了した場合に、一時ファイルが削除されないことを確実にし
ます。隠しファイルを使用する '悪い' 側面は、小さすぎる一時ディスクを一杯
にする大きな一時ファイルを見つけられないことです。

</P>
<P>
ソート時 (<CODE>ORDER BY</CODE> または <CODE>GROUP BY</CODE>)、<STRONG>MySQL</STRONG> は通常一つまたは二つ
の一時ファイルを使用します。必要な最大のディスク容量は:

</P>

<PRE>
(length of what is sorted + sizeof(database pointer))
* number of matched rows
* 2
</PRE>

<P>
<CODE>sizeof(database_pointer)</CODE> は通常４ですが、将来本当に大きなテーブル
のために大きくなることもあります。

</P>
<P>
いくつかの <CODE>SELECT</CODE> クエリは一時的な SQL テーブルも生成します。これらは隠
しファイルではなく、<TT>`SQL_*'</TT> という名前です。

</P>
<P>
<CODE>ALTER TABLE</CODE> は一時テーブルをオリジナルテーブルと同じディレクトリ
内に生成します。

</P>

<P>
<A NAME="IDX1481"></A>
<A NAME="IDX1482"></A>


<H2><A NAME="Problems_with_mysql.sock" HREF="manual.ja_toc.html#Problems_with_mysql.sock">21.7  <TT>`/tmp/mysql.sock'</TT> を削除から守る方法</A></H2>

<P>
もし誰かに <STRONG>MySQL</STRONG> のソケットファイル <TT>`/tmp/mysql.sock'</TT> が消されるなら、
ほとんどの UNIX がそうであるように、 <TT>`/tmp'</TT> に <CODE>sticky</CODE> ビットをたてて保護します。
<CODE>root</CODE> でログインして、以下のようにします：

</P>

<PRE>
shell&#62; chmod +t /tmp
</PRE>

<P>
これはファイルのオーナーとスーパーユーザー(<CODE>root</CODE>) のみが、
 <TT>`/tmp'</TT> のファイルを消すことができます。

</P>
<P>
<CODE>sticky</CODE> ビットが立っているか確認するには、 <CODE>ls -ld /tmp</CODE> を行います。
パーミッションの最後のビットが <CODE>t</CODE> ならば、セットされています。

</P>
<P>
<A NAME="IDX1483"></A>
<A NAME="IDX1484"></A>


<H2><A NAME="Changing_MySQL_user" HREF="manual.ja_toc.html#Changing_MySQL_user">21.8  一般ユーザで <STRONG>MySQL</STRONG> を動かす方法</A></H2>

<P>
<CODE>mysqld</CODE> (<STRONG>MySQL</STRONG> サーバ) は誰でも開始し実行することができます。
<CODE>mysqld</CODE> をユーザ <CODE>user_name</CODE> で実行するように変更するためには、次を行なう必要が
あります:

</P>

<OL>
<LI>

サーバーを止めます (use <CODE>mysqladmin shutdown</CODE>).

<LI>

<CODE>user_name</CODE> が読み書きできるように、データベースディレクトリとその中のファイルのパーミッションを変更します。(これは UNIX <CODE>root</CODE> ユーザーで実行する必要があるでしょう)：


<PRE>
shell&#62; chown -R user_name /path/to/mysql/datadir
</PRE>

<STRONG>MySQL</STRONG> データベースディレクトリのディレクトリーやファイルがシンボリックリンクの場合、
これらリンクの先のディレクトリとファイルも変更します。<CODE>chown -R</CODE> はシンボリックリンク先を変更してくれません。

<LI>

ユーザ <CODE>user_name</CODE> でサーバを起動します。または <STRONG>MySQL</STRONG> 3.22 以降を使用する
場合は、<CODE>mysqld</CODE> を UNIX <CODE>root</CODE> で起動し <CODE>--user=user_name</CODE> スイッチを使用します。
<CODE>mysqld</CODE> は、接続を許可する前に、与えられた UNIX user <CODE>user_name</CODE> で実行するように切り替えます。

<LI>

システム再起動時、 <CODE>mysql.server</CODE> を使用して <CODE>mysqld</CODE> を起動する場合、ユーザ 
<CODE>user_name</CODE> への <CODE>su</CODE> を行なうようにまたは <CODE>--user</CODE> スイッチを使用して <CODE>mysqld</CODE> を起動するように <CODE>mysql.server</CODE> を 変更すべきです。
(No changes to <CODE>safe_mysqld</CODE> are necessary.)
</OL>

<P>
この時点で、あなたの <CODE>mysqld</CODE> プロセスは UNIX user <CODE>user_name</CODE> で正常に動作します。

</P>
<P>
一つのことは変わりません。それは権限許可テーブルです。デフォルト 
(パーミッションテーブルインストールスクリプト<CODE>mysql_install_db</CODE>実行後の権限) では、<CODE>mysql</CODE>データベースへのアクセスやデータベースの作成、破棄はユーザ <STRONG>MySQL</STRONG> user <CODE>root</CODE> だけです。
これを変更しないと、それはそのままです。
<CODE>root</CODE> 以外の UNIX userでログインしている時でも、あなたは 
<STRONG>MySQL</STRONG> <CODE>root</CODE> user としてアクセスは可能です - ただプログラムに <CODE>-u root</CODE> をクライアントプログラムにオプション指定するだけです。

</P>
<P>
<STRONG>MySQL</STRONG> に <CODE>root</CODE> としてアクセスするには、
コマンドラインで <CODE>-u root</CODE> を使用するだけでいいことに注意してください。
UNIX <CODE>root</CODE> user や <STRONG>MySQL</STRONG> を走らせている UNIX ユーザーである必要は<EM>ない</EM>ことに注意してください。
<STRONG>MySQL</STRONG> のアクセスパーミッションと<STRONG>MySQL</STRONG> のユーザは、
UNIX ユーザとは完全に別のものです。UNIX ユーザに関係するのは、クライアン
トに <CODE>-u</CODE> オプションを使用しない場合だけです。この場合、クライアントは
<STRONG>MySQL</STRONG> へのログインを、あなたの UNIX ログイン名で試みます。

</P>
<P>
あなたの UNIX マシンそれ自身が安全でない場合は、少なくとも <STRONG>MySQL</STRONG> ア
クセステーブルの <STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザにはパスワードを設定すべきです。
どこかの誰かが <CODE>mysql -u root db_name</CODE> を行ない、彼が望むことの全てを実行できてしまうからです。

</P>

<P>
<A NAME="IDX1485"></A>
<A NAME="IDX1486"></A>
<A NAME="IDX1487"></A>


<H2><A NAME="Resetting_permissions" HREF="manual.ja_toc.html#Resetting_permissions">21.9  忘れたパスワードをリセットする</A></H2>

<P>
もし <STRONG>MySQL</STRONG> の <CODE>root</CODE> ユーザーのパスワードを忘れた場合、
これを以下のようにして入れ直すことが可能です。

</P>

<OL>
<LI>

<CODE>mysqld</CODE> サーバーを <CODE>kill</CODE> で落とす。
(<CODE>kill -9</CODE> ではありません！)
PID 番号は通常 <STRONG>MySQL</STRONG> データディレクトリに <CODE>.pid</CODE> ファイルとして
書かれています：


<PRE>
kill `cat /mysql-data-directory/hostname.pid`
</PRE>

 
これを、 UNIX <CODE>root</CODE> ユーザーか、<STRONG>MySQL</STRONG> サーバーを実行した
ユーザーで行います。
 
<LI>

<CODE>mysqld</CODE> を <CODE>--skip-grant-tables</CODE> オプションで起動。

<LI>

<CODE>mysql -h hostname mysql</CODE> で<CODE>mysqld</CODE> サーバーに接続し、
<CODE>GRANT</CODE> コマンドでパスワードを変更します。  「<A HREF="manual.ja_Reference.html#GRANT">7.35  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照.
<CODE>mysqladmin -h hostname -u user password 'new password'</CODE> 
でも変更可能です。

<LI>

許可テーブルを読み込みます：
<CODE>mysqladmin -h hostname flush-privileges</CODE> か、SQL 文の
<CODE>FLUSH PRIVILEGES</CODE> を実行します。
</OL>

<P>
Note that after you started <CODE>mysqld</CODE> with <CODE>--skip-grant-tables</CODE>,
any usage of <CODE>GRANT</CODE> commands will give you an <CODE>Unknown command</CODE>
error until you have executed <CODE>FLUSH PRIVILEGES</CODE>.

</P>
<P>
<A NAME="IDX1488"></A>
<A NAME="IDX1489"></A>
<A NAME="IDX1490"></A>


<H2><A NAME="File_permissions" HREF="manual.ja_toc.html#File_permissions">21.10  ファイルパーミッションの問題</A></H2>

<P>
ファイルパーミッションの問題がある場合、
例えば、テーブルの生成時に <CODE>mysql</CODE> が次を出力する場合:

</P>

<PRE>
ERROR: Can't find file: 'path/with/filename.frm' (Errcode: 13)
</PRE>

<P>
<A NAME="IDX1491"></A>
<A NAME="IDX1492"></A>
これは <CODE>UMASK</CODE> 環境変数が <CODE>mysqld</CODE> 起動時に間違ってセットされていると考えられます。
デフォルトの umask は <CODE>0660</CODE> です. 
これは以下のようにして <CODE>safe_mysqld</CODE> 立ち上げ時に変更できます:

</P>

<PRE>
shell&#62; UMASK=384  # = 600 in octal
shell&#62; export UMASK
shell&#62; /path/to/safe_mysqld &#38;
</PRE>

<P>
<A NAME="IDX1493"></A>
<A NAME="IDX1494"></A>
By default <STRONG>MySQL</STRONG> will create database and <CODE>RAID</CODE>
directories with permission type 0700.  You can modify this behavior by
setting the <CODE>UMASK_DIR</CODE> variable. If you set this, new
directories are created with the combined <CODE>UMASK</CODE> and
<CODE>UMASK_DIR</CODE>. For example, if you want to give group access to
all new directories, you can do:

</P>

<PRE>
shell&#62; UMASK_DIR=504  # = 770 in octal
shell&#62; export UMASK_DIR
shell&#62; /path/to/safe_mysqld &#38;
</PRE>

<P>
In <STRONG>MySQL</STRONG> Version 3.23.25 and above, <STRONG>MySQL</STRONG> assumes that the
value for <CODE>UMASK</CODE> and <CODE>UMASK_DIR</CODE> is in octal if it starts
with a zero.

</P>
<P>
 「<A HREF="manual.ja_Environment_variables.html#Environment_variables">A  Environment Variables</A>」節参照.

</P>


<H2><A NAME="Not_enough_file_handles" HREF="manual.ja_toc.html#Not_enough_file_handles">21.11  File not found</A></H2>

<P>
<CODE>ERROR '...' not found (Errcode: 23)</CODE>, <CODE>Can't open file: ... (errno: 24)</CODE>
 や <CODE>errcode 23</CODE> <CODE>errno 24</CODE> のエラーを <STRONG>MySQL</STRONG> から得た場合、
これは <STRONG>MySQL</STRONG> に十分なファイル記述子が割り当てられなかったことを意味します。
<CODE>perror #</CODE> はさらに読みやすい形式のエラーメッセージを与えます:

</P>

<PRE>
shell&#62; perror 23
File table overflow
shell&#62; perror 24
Too many open files
</PRE>

<P>
これは <CODE>mysqld</CODE> が多くのファイルを開こうとしたことに起因します。
<CODE>mysqld</CODE> に一度に開くファイル数を多く開かないようしたり、あるいは、
<CODE>mysqld</CODE> が扱えるファイル記述子の数を与えたりできます。

</P>
<P>
<CODE>mysqld</CODE> が一度に開くファイルの数を少なくするには、<CODE>-O table_cache=32</CODE> オプション(デフォルトは64)を <CODE>safe_mysqld</CODE> に与えることで可能です。
また、<CODE>max_connections</CODE> の値(デフォルトは90)を少なくするならば、開くファイル数も少なくできます。

</P>
<P>
<A NAME="IDX1495"></A>
To change the number of file descriptors available to <CODE>mysqld</CODE>, you
can use the option <CODE>--open-files-limit=#</CODE> to <CODE>safe_mysqld</CODE> or
<CODE>-O open-files-limit=#</CODE> to <CODE>mysqld</CODE>.  「<A HREF="manual.ja_Reference.html#SHOW_VARIABLES">7.28.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.
The easiest way to do that is to add the option to your option file.
 「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照.  If you have an old <CODE>mysqld</CODE> version that
doesn't support this, you can edit the <CODE>safe_mysqld</CODE> script.  There
is a commented-out line <CODE>ulimit -n 256</CODE> in the script.  You can
remove the <CODE>'#'</CODE> character to uncomment this line, and change the
number 256 to affect the number of file descriptors available to
<CODE>mysqld</CODE>.

</P>
<P>
<CODE>ulimit</CODE> と <CODE>open-files-limit</CODE> はオペレーティングシステムの
制限内でしかファイル記述子の数を指定できません。
There is also a 'hard' limit that can only be overrided if you
start <CODE>safe_mysqld</CODE> or <CODE>mysqld</CODE> as root (Just remember that
you need to also use the <CODE>--user=..</CODE> option in this case).
もし OS の制限以上にファイル記述子のオープン数を増やしたい場合、
お使いのオペレーティングシステムのドキュメントを見て対処してください。

</P>
<P>
<CODE>tcsh</CODE> を使用している場合は <CODE>ulimit</CODE> は動かないことに注意してください！
<CODE>tcsh</CODE> は現在の制限をあなたが問い合わせても、違った値を報告するでしょう。
この場合、<CODE>safe_mysqld</CODE> は <CODE>sh</CODE> で起動すべきです！

</P>
<P>
<A NAME="IDX1496"></A>
<A NAME="IDX1497"></A>
<A NAME="IDX1498"></A>


<H2><A NAME="Using_DATE" HREF="manual.ja_toc.html#Using_DATE">21.12  <CODE>DATE</CODE> フィールド使用時の問題</A></H2>

<P>
日付 <CODE>DATE</CODE> の形式は <CODE>'YYYY-MM-DD'</CODE> です。ANSI SQL に従って実際には他のは許されま
せん。更新または <CODE>SELECT</CODE> 文中の WHERE 節内ではこの形式を使用すべきです。すなわち:

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE date &#62;= '1997-05-05';
</PRE>

<P>
利便のため <STRONG>MySQL</STRONG> は、日付が数値の文脈で使用されると、日付を自動的に数
値に変換します。これにより、更新と <CODE>TIMESTAMP</CODE>, <CODE>DATE</CODE> または 
<CODE>DATETIME</CODE> フィールドでの <CODE>WHERE</CODE> 時に、わりと自由に日付を指定することができます。
(この記述を許すため、句読記号を日付のセパレーターとして使用します。
例えば、<CODE>'1998-08-15'</CODE> と <CODE>'1998#08#15'</CODE> は同一です.)
もしろんセパレーターのない記述(例：<CODE>'19980815'</CODE>)も日付として変換してくれます。

</P>
<P>
特別な日付 <CODE>'0000-00-00'</CODE> は <CODE>'0000-00-00'</CODE> として格納され取り出されます。
<STRONG>MyODBC</STRONG> を通して <CODE>'0000-00-00'</CODE> 日付を使用する時、<STRONG>MyODBC</STRONG> 2.50.12 以上では自
動的に <CODE>NULL</CODE> に変換されます。ODBC はこの日付の種類を扱えないためです。

</P>
<P>
これは次が動くことを意味します:

</P>

<PRE>
mysql&#62; INSERT INTO tbl_name (idate) VALUES (19970505);
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('19970505');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('97-05-05');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('1997.05.05');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('1997 05 05');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('0000-00-00');

mysql&#62; SELECT idate FROM tbl_name WHERE idate &#62;= '1997-05-05';
mysql&#62; SELECT idate FROM tbl_name WHERE idate &#62;= 19970505;
mysql&#62; SELECT mod(idate,100) FROM tbl_name WHERE idate &#62;= 19970505;
mysql&#62; SELECT idate FROM tbl_name WHERE idate &#62;= '19970505';
</PRE>

<P>
次は動きません:

</P>

<PRE>
mysql&#62; SELECT idate FROM tbl_name WHERE STRCMP(idate,'19970505')=0;
</PRE>

<P>
<CODE>STRCMP()</CODE> は文字列関数で、<CODE>idate</CODE> を文字に変換して、文字比較を行います。
<CODE>'19970505'</CODE> は日付には変換してくれず、日付の比較も行いません。

</P>
<P>
<STRONG>MySQL</STRONG> は日付が正しいかどうかをチェックしないことに注意してくだ
さい。間違った日付(例えば <CODE>'1998-2-31'</CODE>)を格納すると、その間違った日付が格納
されます。日付が全体的に不可能な場合、<CODE>0</CODE> が <CODE>DATE</CODE> フィールドに格納されます。
これは主に速度の問題で、日付のチェックはサーバではなくアプリケーションでと我々
は考えています。

</P>
<P>
<A NAME="IDX1499"></A>
<A NAME="IDX1500"></A>
<A NAME="IDX1501"></A>
<A NAME="IDX1502"></A>


<H2><A NAME="Timezone_problems" HREF="manual.ja_toc.html#Timezone_problems">21.13  Time Zone Problems</A></H2>

<P>
もし <CODE>SELECT NOW()</CODE> があなたのローカル時間ではなく GMT を返すなら、
 <CODE>TZ</CODE> 環境変数をローカルのTimezone に設定しなくてはなりません。
環境変数の設定は、サーバーを実行する前に行われなくてはなりません。
たとえば、<CODE>safe_mysqld</CODE> や <CODE>mysql.server</CODE> スクリプトで
行います。

</P>

<P>
<A NAME="IDX1503"></A>
<A NAME="IDX1504"></A>
<A NAME="IDX1505"></A>
<A NAME="IDX1506"></A>


<H2><A NAME="Case_sensitivity" HREF="manual.ja_toc.html#Case_sensitivity">21.14  検索時のケース依存</A></H2>

<P>
デフォルトでは <STRONG>MySQL</STRONG> フィールドはケース非依存です (しかし、ケース非依
存にならないいくつかの文字セットはありますsuch as <CODE>czech</CODE>)。
これは、<CODE>col_name LIKE 'a%'</CODE>
で検索した場合、<CODE>A</CODE> または <CODE>a</CODE> で始まる全てのフィールドを得ることを
意味します。検索をケース依存にしたいのなら、始まりをチェックするには
<CODE>INDEX(column, "A")=0</CODE> のようなことを、また、文字列全体が同じかどう
かには <CODE>STRCMP(column, "A") = 0</CODE> を使用してください。

</P>
<P>
単純な比較操作 <CODE>&#62;=, &#62;, =, &#60;, &#60;=</CODE>、ソートそしてグループ化は、文字 ``sort value''
上で行われます。同じソート値の文字 (like E, e and 'e)は同じ文字と
して扱われます！

</P>
<P>
<CODE>LIKE</CODE> 比較は各文字の大文字で行われます
(E == e but E &#60;&#62; 'e)

</P>
<P>
<CODE>column</CODE> をいつでもケース依存で扱いたい場合は、それを <CODE>BINARY</CODE> 
として宣言してください。 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">7.7  <CODE>CREATE TABLE</CODE>構文</A>」節参照.

</P>
<P>
big5 エンコーディングと呼ばれる中国語データを使用している場合は、全ての
文字項目を <CODE>BINARY</CODE> にしてください。これは、big5 エンコーディング文
字のソート順が ascii コードが基になっているため、機能します。

</P>

<P>
<A NAME="IDX1507"></A>
<A NAME="IDX1508"></A>


<H2><A NAME="Problems_with_NULL" HREF="manual.ja_toc.html#Problems_with_NULL">21.15  <CODE>NULL</CODE> 値での問題</A></H2>

<P>
SQL の初心者のありがちな混乱は、<CODE>NULL</CODE> 値が空文字列  <CODE>''</CODE> と同じ物だと考えるこ
とです。これは正しくありません！ 例えば、次のステートメントは全く別のも
のです:

</P>

<PRE>
mysql&#62; INSERT INTO my_table (phone) VALUES (NULL);
mysql&#62; INSERT INTO my_table (phone) VALUES ("");
</PRE>

<P>
両方の文とも <CODE>phone</CODE> フィールドに値を挿入していますが、
初めのは <CODE>NULL</CODE> 値を挿入し、二番目のは空文字列を挿入しています。
初めのは ``電話番号を知らない'' と見なされ、二番目のは ``彼女は電話を
持っていない'' と見なされます。

</P>
<P>
SQL では、  <CODE>NULL</CODE> は他の全ての値(たとえ  <CODE>NULL</CODE> でも)と比較した時に、常に偽に
なる値です。 <CODE>NULL</CODE> を含む式は、特に断りがなければ、常に  <CODE>NULL</CODE> 値を生成しま
す。次の項目は全て  <CODE>NULL</CODE> を返します:

</P>

<PRE>
mysql&#62; SELECT NULL,1+NULL,CONCAT('Invisible',NULL);
</PRE>

<P>
<CODE>NULL</CODE> 値がセットされている項目を検索する場合、
 <CODE>=NULL</CODE> テストを行わないでください。
これは <CODE>expr = NULL</CODE> が FALSE なので、なんの行も返しません。
例えば以下の例：

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE phone = NULL;
</PRE>

<P>
<CODE>NULL</CODE> 値を持つフィールドを検索したい場合は、<CODE>IS NULL</CODE> テストを使用しなくてはいけま
せん。次は <CODE>NULL</CODE> 電話番号と空の電話番号を見つける方法を示しています:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE phone IS NULL;
mysql&#62; SELECT * FROM my_table WHERE phone = "";
</PRE>

<P>
<STRONG>MySQL</STRONG> では、他の多くの SQL サーバのように、<CODE>NULL</CODE> 値を持つ
インデックスフィールドを持てません。これらのフィールドは <CODE>NOT NULL</CODE> と宣言しな
くてはいけません。
インデックスフィールドには、<CODE>NULL</CODE> を設定することはできません。

</P>
<P>
<A NAME="IDX1509"></A>
<CODE>LOAD DATA INFILE</CODE> でデータを読み込むときは、空のフィールドは <CODE>''</CODE> で更新されます。
項目を <CODE>NULL</CODE> 値にしたい場合は、テキストファイル中に <CODE>\N</CODE> を使用すべきです。
リテラルとしての <CODE>'NULL'</CODE> 語が、ある状況下で使用されています。
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">7.23  <CODE>LOAD DATA INFILE</CODE>構文</A>」節参照.

</P>
<P>
<CODE>ORDER BY</CODE> 使用時, <CODE>NULL</CODE> 値は最初に提示されます.
<CODE>DESC</CODE> を使用して降順にソートする時、<CODE>NULL</CODE> 値は最後になります。
<CODE>GROUP BY</CODE> 使用時, 全ての <CODE>NULL</CODE> 値は等しいと見なされます。

</P>
<P>
<CODE>NULL</CODE> 処理を手助けするため、次の関数を使用できます:
<CODE>IS NULL</CODE>, <CODE>IS NOT NULL</CODE>, <CODE>IFNULL()</CODE>.

</P>
<P>
<A NAME="IDX1510"></A>
<A NAME="IDX1511"></A>
<A NAME="IDX1512"></A>
<A NAME="IDX1513"></A>
いくつかの項目型では、<CODE>NULL</CODE> 値はハンドルとして扱われます。
もしテーブル内の最初の <CODE>TIMESTAMP</CODE> 項に <CODE>NULL</CODE> を挿入するなら、
現在の日付と時刻が挿入されます。もし <CODE>AUTO_INCREMENT</CODE> 項に<CODE>NULL</CODE> 値を挿入するなら、
次のシーケンス番号が挿入されます。

</P>
<P>
<A NAME="IDX1514"></A>


<H2><A NAME="Problems_with_alias" HREF="manual.ja_toc.html#Problems_with_alias">21.16  <CODE>alias</CODE> の問題</A></H2>

<P>
<CODE>GROUP BY</CODE>, <CODE>ORDER BY</CODE>, <CODE>HAVING</CODE> 節において
項目を参照するに当たりエイリアスが使用できます。
エイリアスは項目としてより良い名称を与えるのに使用されます：

</P>

<PRE>
SELECT SQRT(a*b) as rt FROM table_name GROUP BY rt HAVING rt &#62; 0;
SELECT id,COUNT(*) AS cnt FROM table_name GROUP BY id HAVING cnt &#62; 0;
SELECT id AS "Customer identity" FROM table_name;
</PRE>

<P>
 ANSI SQL が <CODE>WHERE</CODE> 節内でエイリアスを参照することを
許可していないことに注意してください。これは <CODE>WHERE</CODE> が実行される時点で
項目の値がまだ決定されていないからです。例えば、以下のクエリは <STRONG>あやまりです</STRONG>：

</P>

<PRE>
SELECT id,COUNT(*) AS cnt FROM table_name WHERE cnt &#62; 0 GROUP BY id;
</PRE>

<P>
どの行が <CODE>GROUP BY</CODE> に含まれるかを決めるために <CODE>WHERE</CODE> 構文が
実行される一方で、
得られた結果のどの行を使うか確定するために <CODE>HAVING</CODE> が使用されます。

</P>

<P>
<A NAME="IDX1515"></A>
<A NAME="IDX1516"></A>
<A NAME="IDX1517"></A>


<H2><A NAME="Deleting_from_related_tables" HREF="manual.ja_toc.html#Deleting_from_related_tables">21.17  Deleting Rows from Related Tables</A></H2>

<P>
<STRONG>MySQL</STRONG> は現在 sub-select は未サポートで、また
 <CODE>DELETE</CODE> 構文で複数のテーブルを扱う事もサポートしていません。
したがって、２つのテーブルに関連するレコードを消すには、以下のようにして行います：

</P>

<OL>
<LI>

いくつかの <CODE>WHERE</CODE> 条件を使用して、基本となるテーブルから行を <CODE>SELECT</CODE>
<LI>

同じ条件下で、基本となるテーブルに含まれる行を <CODE>DELETE</CODE>
<LI>

<CODE>DELETE FROM related_table WHERE related_column IN (selected_rows)</CODE>.
</OL>

<P>
<CODE>related_column</CODE> のクエリの合計文字数が、1,048,576 (デフォルトは <CODE>max_allowed_packet</CODE> の値) をこえる場合、
それをいくつかに分割して、複数の <CODE>DELETE</CODE> 構文にしなくてはなりません。

</P>
<P>
<CODE>related_column</CODE> がインデックスで、100-1000 の<CODE>related_column</CODE>だけを消す場合、
よりはやく <CODE>DELETE</CODE> できます。
もし <CODE>related_column</CODE> がインデックスでない場合、その速度は <CODE>IN</CODE> 節の引数の数に無関係になります。

</P>

<P>
<A NAME="IDX1518"></A>
<A NAME="IDX1519"></A>


<H2><A NAME="No_matching_rows" HREF="manual.ja_toc.html#No_matching_rows">21.18  Solving problems with no matching rows</A></H2>

<P>
複雑なクエリーを行って、もしなんの結果も返さなければ、
そのクエリーの何が悪いかを見つけるため、以下の手続きを行います：

</P>

<OL>
<LI>

<CODE>EXPLAIN</CODE> を使用してクエリーをテストし、明白な間違いを見つけます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.29  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.

<LI>

<CODE>WHERE</CODE> 節で使用されているフィールドだけを Select してみます

<LI>

結果が返ってくるまで、一つ一つクエリーからテーブルを取り除いていきます。
テーブルが大きい場合、<CODE>LIMIT 10</CODE> をクエリーで使用することは良くありません。

<LI>

行にマッチすべきであろう項を <CODE>SELECT</CODE> してみます。
その場合、select するのは、上記で最後に取り除いたテーブルに対して行います。

<LI>

もし <CODE>FLOAT</CODE> か <CODE>DOUBLE</CODE> 型のものを数字と比較するなら、
 <CODE>=</CODE> は使用しないでください！これはほとんどのコンピュータ言語において、
浮動小数点の値はぴったりの値にならないからです。


<PRE>
mysql&#62; SELECT * FROM table_name WHERE float_column=3.5;
   -&#62;
mysql&#62; SELECT * FROM table_name WHERE float_column between 3.45 and 3.55;
</PRE>

In most cases, changing the <CODE>FLOAT</CODE> to a <CODE>DOUBLE</CODE> will fix this!

<LI>

もしなにも悪いところを見つけることができなかった場合、
小さなテストをつくって <CODE>mysql test &#60; query.sql</CODE> を行ってみてください。
<CODE>mysqldump --quick database tables &#62; query.sql</CODE> でテストファイルを作成できます。
このファイルをエディターで編集し、いくつかのinsert行を(多すぎるなら)消します。
そしてファイルの最後にselect構文を付け足します。

テストを行うには：


<PRE>
shell&#62; mysqladmin create test2
shell&#62; mysql test2 &#60; query.sql
</PRE>

<CODE>mysqlbug</CODE> を使用して <a HREF="mailto:mysql@lists.mysql.com">mysql@lists.mysql.com</a> にテストを投稿してください。
</OL>

<P>
<A NAME="IDX1520"></A>


<H2><A NAME="ALTER_TABLE_problems" HREF="manual.ja_toc.html#ALTER_TABLE_problems">21.19  Problems with <CODE>ALTER TABLE</CODE>.</A></H2>

<P>
もし <CODE>ALTER TABLE</CODE> が以下のようなエラーで死んだ場合：

</P>

<PRE>
Error on rename of './database/name.frm' to './database/B-a.frm' (Errcode: 17)
</PRE>

<P>
これは以前の <CODE>ALTER TABLE</CODE> で <STRONG>MySQL</STRONG> がクラッシュしており、
<TT>`A-something'</TT> か <TT>`B-something'</TT> という名前の、誤った情報を流している
古いテーブルが存在しています。
この場合、<STRONG>MySQL</STRONG> データディレクトリに入り、<CODE>A-</CODE> や <CODE>B-</CODE> で始まる
名前を持つファイルを全て消します。
(消す代わりにどこかに移動しても構いません。)

</P>
<P>
<CODE>ALTER TABLE</CODE> は以下のように動作します:

</P>

<UL>
<LI>変更要求のあった <TT>`A-xxx'</TT> という名前の新しいテーブルを作成。

<LI>元のテーブル内の全ての行を <TT>`A-xxx'</TT> にコピー。

<LI>元のテーブルを <TT>`B-xxx'</TT> に名称変更。

<LI><TT>`A-xxx'</TT> は元のテーブル名に名称変更される。

<LI><TT>`B-xxx'</TT> は消去される。

</UL>

<P>
もし名称変更の際に問題があると、<STRONG>MySQL</STRONG> は変更を取り消すように動きます。
致命的な問題が起きた場合(ありえませんが)、<STRONG>MySQL</STRONG> は元の古いテーブルを
 <TT>`B-xxx'</TT> という名前のままにしておきます。単に名称変更すればデータは戻ります。

</P>
<P>
<A NAME="IDX1521"></A>
<A NAME="IDX1522"></A>
<A NAME="IDX1523"></A>
<A NAME="IDX1524"></A>


<H2><A NAME="Change_column_order" HREF="manual.ja_toc.html#Change_column_order">21.20  How To Change the Order of Columns in a Table</A></H2>

<P>
The whole point of SQL is to abstract the application from the data
storage format.  You should always specify the order in which you wish to
retrieve your data.  For example:

</P>

<PRE>
SELECT col_name1, col_name2, col_name3 FROM tbl_name;
</PRE>

<P>
will return columns in the order <CODE>col_name1</CODE>, <CODE>col_name2</CODE>, <CODE>col_name3</CODE>, whereas:

</P>

<PRE>
SELECT col_name1, col_name3, col_name2 FROM tbl_name;
</PRE>

<P>
will return columns in the order <CODE>col_name1</CODE>, <CODE>col_name3</CODE>, <CODE>col_name2</CODE>.

</P>
<P>
You should <STRONG>NEVER</STRONG>, in an application, use <CODE>SELECT *</CODE> and
retrieve the columns based on their position, because the order in which
columns are returned <STRONG>CANNOT</STRONG> be guaranteed over time. A simple
change to your database may cause your application to fail rather
dramatically.

</P>
<P>
If you want to change the order of columns anyway, you can do it as follows:

</P>

<OL>
<LI>

Create a new table with the columns in the right order.
<LI>

Execute
<CODE>INSERT INTO new_table SELECT fields-in-new_table-order FROM old_table</CODE>.
<LI>

Drop or rename <CODE>old_table</CODE>.
<LI>

<CODE>ALTER TABLE new_table RENAME old_table</CODE>.
</OL>

<P>
 
<A NAME="IDX1525"></A>


<H2><A NAME="Temporary_table_problems" HREF="manual.ja_toc.html#Temporary_table_problems">21.21  TEMPORARY TABLE problems</A></H2>

<P>
The following are a list of the limitations with <CODE>TEMPORARY TABLES</CODE>.

</P>

<UL>
<LI>

A temporary table can only be of type <CODE>HEAP</CODE>, <CODE>ISAM</CODE> or
<CODE>MyISAM</CODE>.
<LI>

You can't use temporary tables more than once in the same query.
For example, the following doesn't work.


<PRE>
select * from temporary_table, temporary_table as t2;
</PRE>

We plan to fix the above in 4.0.
<LI>

You can't use <CODE>RENAME</CODE> on a <CODE>TEMPORARY</CODE> table.
Note that <CODE>ALTER TABLE org_name RENAME new_name</CODE> works!

We plan to fix the above in 4.0.
</UL>

<P>
<A NAME="IDX1526"></A>
<A NAME="IDX1527"></A>
<A NAME="IDX1528"></A>
<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Common_programs.html">previous</A>, <A HREF="manual.ja_Common_problems.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
