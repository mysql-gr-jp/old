  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 20 July 2001 -->

  <TITLE>MySQL Reference Manual for version 3.23.38. - 6  MySQL のユーザー権限はどのように動くか？</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Compatibility.html">previous</A>, <A HREF="manual.ja_Reference.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Privilege_system" HREF="manual.ja_toc.html#Privilege_system">6  MySQL のユーザー権限はどのように動くか？</A></H1>
<P>
<A NAME="IDX373"></A>
<A NAME="IDX374"></A>
<A NAME="IDX375"></A>
<A NAME="IDX376"></A>
<A NAME="IDX377"></A>

</P>
<P>
<STRONG>MySQL</STRONG> は先進的な非標準のセキュリティ/特権システムを持っています。
本章ではどのようにそれが動くかを述べます。

</P>



<H2><A NAME="General_security" HREF="manual.ja_toc.html#General_security">6.1  セキュリティ概要</A></H2>

<P>
よくあるセキュリティの間違いを避けるために、インターネットに接続されたコン
ピュータ上で <STRONG>MySQL</STRONG> を使用する誰もが、このセクションを読むべきです。

</P>
<P>
``セキュリティ'' の議論において、我々は、すべての該当するアタックタイプ
(eavesdropping, altering, playback, Denial of Service) に対して、すべてのサー
バホスト(<STRONG>MySQL</STRONG> サーバだけではなく)の完全な保護の必要性を強調しま
す。We do not cover all aspects of availability and fault tolerance
here.

</P>
<P>
<STRONG>MySQL</STRONG> は、ユーザが実行しようとするすべての接続、クエリ、その他の
オペレーションに対して、アクセス制御リスト(ACLs: Access Control Lists)セキュ
リティを使用します。<STRONG>MySQL</STRONG> クライアントとサーバの間で SSL 暗号化接
続のサポートもいくつかあります。ここで議論されるコンセプトの多くは、
<STRONG>MySQL</STRONG> に特有のものではありません; 同じ一般的なアイデアはほとんど
すべてのアプリケーションに適用します。

</P>
<P>
<STRONG>MySQL</STRONG> 実行時、可能な限りいつでもこれらのガイドラインに従ってくだ
さい:

</P>

<UL>
<LI>

(<STRONG>MySQL</STRONG> ROOT ユーザ以外の)誰にも mysql.user テーブルへのアクセスを
与えないでください！ 暗号化されたパスワードは <STRONG>MySQL</STRONG> の本当のパス
ワードです。もしあなたが誰かのこれを知ることができれば、彼の'ホスト'にアク
セスして、彼として簡単にログインできます。

<LI>

<STRONG>MySQL</STRONG> ACL システムの理解に努めるべきです。
<CODE>GRANT</CODE> と <CODE>REVOKE</CODE> コマンドは <STRONG>MySQL</STRONG> へのアクセスを制限するための物です。
必要以上の権限を誰にも与えないでください。
全てのホストに対して、何か出来るような許可を与えてはいけません。

Checklist:

<UL>
<LI>

<CODE>mysql -u root</CODE> を行ってみます。

パスワードを尋ねられること無しにサーバへの接続ができる場合、問題があります。
どのユーザでも(root でなくても)、<STRONG>MySQL</STRONG> サーバに完全な権限で接続で
きます！ <CODE>root</CODE> パスワードの設定についての項目に特別な注意を払って
<STRONG>MySQL</STRONG> インストール説明を見直してください。

<LI>

<CODE>SHOW GRANTS</CODE> を使用し、だれがなんのアクセスを持つかチェックします。
必要ない権限を、<CODE>REVOKE</CODE> コマンドを使用して削除してください。
</UL>

<LI>

いかなる平文パスワードもデータベースに保存しないようにします。
あなたのコンピュータが妥協される時、新入者はパスワードの完全なリストを得て、
それらを使用できます。代わりに <CODE>MD5()</CODE> や他の one-way hashing 関数を
使用してください。
<LI>

辞書にのっている単語をパスワードに使用してはいけません。 それらを破る
プログラムがあるのです。 ``xfish98'' のようなパスワードは悪い例です。
これよりは ``duag98'' の方がよいでしょう。 これは "fish" を打つ際に、
キーを一つずつずらしたものです。 他の方法としては、 "Mhall" 、これは
"Mary had a little lamb" という文の頭文字を羅列したものです。
これを知っている物には打ちやすいパスワードですが、知らない者にとっては、
類推することが難しいパスワードです。
<LI>

ファイアーウォールを導入します。This protects from at least 50% of all types of
 exploits in any software.
<STRONG>MySQL</STRONG> をファイアーウォールで守られた方に置くか、
DMZ (緩衝地帯, 非武装地帯) に置きます。

Checklist:

<UL>
<LI>

インターネットから <CODE>nmap</CODE> のようなツールを使用して、
あなたのマシンのポートをスキャンしてみます。
<STRONG>MySQL</STRONG> はデフォルトで 3306 番を使用しています。
このポートには、ほとんどの場合、アクセスできないようにすべきです。

<STRONG>MySQL</STRONG> ポートがオープンしているかどうかをチェックする他の簡単な方
法は、いくつかのリモートマシンから <CODE>telnet server_host 3306</CODE> を実行す
ることです。ここで <CODE>server_host</CODE> はあなたの <STRONG>MySQL</STRONG> サーバのホ
スト名です。接続し、いくつかのゴミ文字が得られた場合、ポートはオープンして
います。それをオープンしておく正当な理由が本当にない限り、ファイアーウォー
ルやルータでクローズすべきです。<CODE>telnet</CODE> がハングしたり拒否されたり
する場合、すべて OK です。ポートはブロックされています。
</UL>

<LI>

ユーザーから入力されたデータは信頼しないで下さい。
ユーザーは、Webのフォーム、URL、あるいはあなたのカスタムプログラムから
特定の文字を入れることが可能です。 もしユーザーがフォームに
<CODE>; DROP ALL DATABASES ;</CODE> のような文字を入力しても、
あなたのアプリケーションは安全ですか？
これは極端な例ですが、それらに対して準備しない場合、似たようなテクニックを
使用するハッカーの結果として、大きなセキュリティリークとデータ喪失が発生し
得ます。

数値データのチェックも忘れないでください。よくある間違いは文字列しか保護し
ないことです。時々、人はデータベースが保護される必要のない公に有効なデータ
だけを含んでいるかどうかを考えます。これは間違いです。少なくとも、
denial-of-service タイプのアタックはそのようなデータベースでも実行されます。
このタイプのアタックから保護するもっとも簡単な方法は、数値定数の回りにアポ
ストロフィを使用することです: <CODE>SELECT * FROM table WHERE ID=234</CODE> の代
わりに <CODE>SELECT * FROM table WHERE ID='234'</CODE>。<STRONG>MySQL</STRONG> は自動的
にこの文字列を数値に変換し、そこからすべての非数値シンボルを取り除きます。

チェックリスト:

<UL>
<LI>

すべての Web アプリケーション:

<UL>
<LI>

あなたの WWW の全てのフォームに、<SAMP>`''</SAMP> と <SAMP>`"'</SAMP> を入力することを試みてください。
もしなんらかの <STRONG>MySQL</STRONG> エラーがでたら、あなたのサイトを停止したほうが
よいでしょう。
<LI>

あなたの URL に <CODE>%22</CODE> (<SAMP>`"'</SAMP>), <CODE>%23</CODE> (<SAMP>`#'</SAMP>) , <CODE>%27</CODE> (<SAMP>`''</SAMP>) をつけてみて、動的URLを
いろいろ変更して試してみてください。
<LI>

動的 URL のデータタイプを数値から上述の例の文字を含む文字列に修正してみて
ください。アプリケーションはこれと似たようなアタックに対して安全であるべき
です。
<LI>

数値フィールドに対して、文字、スペース、特殊文字の入力を試みてください。
アプリケーションは、それらを <STRONG>MySQL</STRONG> に送る前に取り除くか、
あるいはエラーを出すべきです。 検査しない値を <STRONG>MySQL</STRONG> に送ることは危険です。
<LI>

<STRONG>MySQL</STRONG> にデータを送る前に、そのサイズをチェックします。
<LI>

あなたのアプリケーションが、管理目的であなたが使用するのと異なるユーザ名を
使用してデータベースに接続することを考慮してください。必要以上のアクセス権
をアプリケーションに与えないで下さい。
</UL>

<LI>

PHP ユーザ:

<UL>
<LI><CODE>addslashes()</CODE> 関数を調べてください。

</UL>

<LI>

<STRONG>MySQL</STRONG> C API ユーザ:

<UL>
<LI><CODE>mysql_escape()</CODE> API コールがあるか調べてください。

</UL>

<LI>

<STRONG>MySQL</STRONG>++ ユーザ:

<UL>
<LI>クエリストリームのために <CODE>escape</CODE> と <CODE>quote</CODE> モディファイヤを調べてください。

</UL>

<LI>

Perl DBI ユーザ:

<UL>
<LI><CODE>quote()</CODE> メソッドを調べてください。 or use placeholders.

</UL>

</UL>

<LI>

生のデータ(暗号化されていないデータ)をインターネット越しに送ってはいけませ
ん。このデータは、その情報をトラップして、どこかで再利用することに興味のあ
る誰にでもアクセス可能です。もし送る必要があるなら、SSL のような暗号化され
た通信を使用すべきです。<STRONG>MySQL</STRONG> はバージョン 3.23.9 から内部 SSL 接
続をサポートします。暗号化された(そして圧縮された)通信のトンネルを生成する
ために、SSH ポートフォワーディングを使用することができます。
<LI>

"tcpdump", "strings" ユーティリティを使うことを学んで下さい.
以下のコマンドで、ほとんどの場合、暗号化されていない
<STRONG>MySQL</STRONG> のデータが見えるでしょう：

<PRE>
shell&#62; tcpdump -l -i eth0 -w - src or dst port 3306 | strings
</PRE>

(この例は Linux のものです。他のシステムでは少し違うでしょう).
警告: データが見えなくても、実際に常に暗号化されているわけではありません。
高いセキュリティが必要なら、セキュリティエキスパートに相談すべきです。
</UL>



<H2><A NAME="Security" HREF="manual.ja_toc.html#Security">6.2  MySQL をクラッカーに対して安全にする方法</A></H2>
<P>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>

</P>
<P>
<STRONG>MySQL</STRONG> サーバーに接続するときは、パスワードを使用すべきです。
パスワードはコネクション間で、べたテキストでは流れません。
しかし、暗号化アルゴリズムはそんなに強力なわけではありません。クライアント
とサーバ間のトラフィックを sniff できれば、いくつかの試みで、賢いアタッカー
はパスワードをクラックできます。クライアントとサーバ間の接続が信頼できない
ネットワークを通るなら、通信を暗号化するために <STRONG>SSH</STRONG> トンネルを使用
すべきです。

</P>
<P>
その他の全ての情報はテキストで転送され、
これは接続を覗くことが出来る人に読まれます。
もしこれを心配するなら、圧縮プロトコル(<STRONG>MySQL</STRONG> バージョン 3.22 以上)を
使用することが出来ます。より安全にしたい場合、
<CODE>ssh</CODE> をインストールすべきです。
オープンソースの ssh クライアントは <a HREF="http://www.openssh.org">http://www.openssh.org</a> に、
商用の ssh クライアントは <a HREF="http://www.ssh.com">http://www.ssh.com</a> に見ることができます。
これを使用すれば、<STRONG>MySQL</STRONG> サーバーと <STRONG>MySQL</STRONG> クライアント
間の TCP/IP コネクションは全て暗号化されます。
 
<STRONG>MySQL</STRONG> システムを安全にするためには、次のことを考えるべきです:

</P>

<UL>
<LI>

全ての <STRONG>MySQL</STRONG> ユーザにパスワードを使用すべきです。
<CODE>other_user</CODE> にパスワードが設定されていない場合、
誰でも <CODE>mysql -u other_user db_name</CODE> として簡単に他の人としてログインでき
ることを覚えてください。これは全てのクライアント／サーバアプリケーション
で一般的な振る舞いです。全てのユーザのパスワードは、
<CODE>mysql_install_db</CODE> スクリプトを実行前に編集することで、または 
<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザだけは次のようにして変更することができます。


<PRE>
shell&#62; mysql -u root mysql
mysql&#62; UPDATE user SET Password=PASSWORD('new_password')
           WHERE user='root';
</PRE>

<LI>

<STRONG>MySQL</STRONG> デーモンを UNIX の <CODE>root</CODE> ユーザーで実行しないでください。
<CODE>FILE</CODE>権限を持つ任意のユーザが <CODE>root</CODE> としてファイル(例えば、
<CODE>~root/.bashrc</CODE>)を生成できるためとても危険です。これを防ぐために、
<CODE>mysqld</CODE> は、<CODE>--user=root</CODE> オプションで直接指定されない限り、 
<CODE>root</CODE> としての実行を拒否します。

<CODE>mysqld</CODE> は任意のユーザで実行できます。
より安全にするため、新しく UNIX ユーザ <CODE>mysql</CODE> を追加することもできます。
<CODE>mysqld</CODE> を 他の Unix ユーザーで起動したとしても、
<STRONG>MySQL</STRONG> の <CODE>user</CODE> テーブルの <CODE>root</CODE> ユーザーの名前を変更する必要はありません。
なぜなら、 <STRONG>MySQL</STRONG> ユーザーの名前は Unix のユーザー名とはなんの関係もないからです。
root ユーザ名を変更する必要はありません。
<CODE>mysqld</CODE> を他の UNIX ユーザで起動するために、<CODE>mysql.server</CODE> 編集してもよいでしょう。
通常、これは <CODE>su</CODE> コマンドで行われます。
より詳しい情報は →  「<A HREF="manual.ja_Problems.html#Changing_MySQL_user">21.8  一般ユーザで <STRONG>MySQL</STRONG> を動かす方法</A>」節.

<LI>

<CODE>mysql.server</CODE> スクリプト内に UNIX <CODE>root</CODE> ユーザーのためにパスワードを
書いた場合、このスクリプトは <CODE>root</CODE> だけが読めるようにしなくては
なりません。

<LI>

データベースディレクトリは <CODE>mysqld</CODE> を実行している UNIX ユーザだけが
読み込み／書き込み可能なことをチェックしてください。

<LI>

UNIX プラットフォームでは、本当に必要でない限り、<CODE>mysqld</CODE> を root で
は実行しないでください。その目的用にユーザ名 <CODE>mysql</CODE> を生成することを
考慮してください。

<LI>

<STRONG>process</STRONG> 権限を全てのユーザに与えないでください。この許可がある人は誰でも
<CODE>mysqladmin processlist</CODE> コマンドで実行されているクエリーの中身を見ることができます。
もし誰かが、<CODE>UPDATE user SET password=PASSWORD('not_secure')</CODE> クエリーを
実行していたとして、それが見えてしまいます。

<CODE>mysqld</CODE> は <STRONG>process</STRONG> 権限を持つユーザに対する特別な接続をリザーブします。
そのため、たとえ全ての通常接続が使われたとしても、<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザだけは、
ログインでき、いろいろチェックできます。

<LI>

<STRONG>file</STRONG> を全てのユーザに与えないでください。ユーザがこの権限を持つ場
合、<CODE>mysqld</CODE> デーモンを実行している Unix ユーザーの権限で
ファイルシステム内のどこにでもファイルを書き込むことができます！
これを少し安全にするために、<CODE>SELECT ... INTO OUTFILE</CODE> で作成される全てのファイルは
全員に読み込み可能で生成され、既存のファイルには上書きできません。

<A NAME="IDX380"></A>
<STRONG>file</STRONG> 権限はサーバーを走らせている UNIX ユーザーがアクセスできる
全てのファイルを読むために使用されかもしれません。
例えば、 <TT>`/etc/passwd'</TT> をテーブルに取り込むために <CODE>LOAD DATA</CODE> が
使用されると、 <CODE>SELECT</CODE> でその内容が読めることになります。

<LI>

あなたの DNS を信用しない場合、権限テーブル内にはホスト名の代わりに IP 
を使用すべきです。<CODE>mysqld</CODE> への <CODE>--secure</CODE> オプションは原理上はホスト名を安
全にします。どんな場合でも、ワイルドカードを含んだホスト名を、許可テーブルに登録する
事は本当に注意深くすべきです！

<LI>

一ユーザからの接続数を制限したい場合は、<CODE>mysqld</CODE> の 
<CODE>max_user_connections</CODE> 変数を設定することで、これを行なうことができま
す。
</UL>



<H2><A NAME="Privileges_options" HREF="manual.ja_toc.html#Privileges_options">6.3  セキュリティに関する <CODE>mysqld</CODE> の起動オプション</A></H2>

<P>
<CODE>mysqld</CODE> への次のオプションはネットワークのセキュリティに影響します:

</P>
<DL COMPACT>

<DT><CODE>--secure</CODE>
<DD>
<CODE>gethostbyname()</CODE> から返される ip がオリジナルのホスト名に戻せるかど
うかをチェックします。これは、外の誰かが他のホストを真似てアクセスを得る
ことを難しくします。このオプションはいくつかの正しいホスト名チェックも追
加します。これは、時にチェックに長い時間がかかるため、<STRONG>MySQL</STRONG> バージョン 3.21
ではデフォルトではオフにされています。<STRONG>MySQL</STRONG> 3.22 ではこのオプションは
デフォルトで有効になっていますが、ホスト名をキャッシュするようになっています。

<DT><CODE>--skip-grant-tables</CODE>
<DD>
特権システムを全く使用しません。これは全員に全てのデータベースへの 
<EM>完全なアクセス</EM> を与えます！
(<CODE>mysqladmin flush-privileges</CODE> か <CODE>mysqladmin reload</CODE> を実行することで、
起動しているサーバーは特権システムを使用するようになります。)

<DT><CODE>--skip-name-resolve</CODE>
<DD>
ホスト名を解析しません。権限テーブル中の全ての <CODE>Host</CODE>フィールドは IP アドレスか
<CODE>localhost</CODE> でなければなりません。

<DT><CODE>--skip-networking</CODE>
<DD>
ネットワーク (TCP/IP) 経由の接続を許可しません。<CODE>mysqld</CODE> への全ての接続は、
UNIX ソケットで行われます。MIT-pthreads は UNIX ソケットをサポートしない
ため、このオプションは MIT-pthreads を使用するシステム上では、うまく動きません。

<DT><CODE>--skip-show-database</CODE>
<DD>
<CODE>SHOW DATABASE</CODE> コマンドは何も返しません。

<DT><CODE>--safe-show-database</CODE>
<DD>
<CODE>SHOW DATABASE</CODE> はユーザがいくつかの権限を持つデータベースだけを返し
ます。
</DL>



<H2><A NAME="What_Privileges" HREF="manual.ja_toc.html#What_Privileges">6.4  特権システムの行うこと</A></H2>
<P>
<A NAME="IDX381"></A>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>

</P>

<P>
<STRONG>MySQL</STRONG> 特権システムの基本機能は、与えられたホストから接続する
ユーザを認証すること、そしてデータベースに対する
 <STRONG>select</STRONG>, <STRONG>insert</STRONG>, <STRONG>update</STRONG>, <STRONG>delete</STRONG> 等の権限を与えることです。

</P>
<P>
拡張機能は匿名ユーザをもつ能力を含み、<CODE>LOAD DATA INFILE</CODE> のような 
<STRONG>MySQL</STRONG> 固有の機能を使用する許可を与えます。

</P>



<H2><A NAME="User_names" HREF="manual.ja_toc.html#User_names">6.5  MySQL ユーザ名とパスワード</A></H2>
<P>
<A NAME="IDX384"></A>
<A NAME="IDX385"></A>

</P>

<P>
<STRONG>MySQL</STRONG> によって使用されるユーザー名とパスワードの使用のされ方と、
UNIX, Windows で使用される方法とは、いくつか異なる点があります。

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> データベースのアクセス認証に使用するユーザー名は、
UNIX のログインユーザやWindowsのユーザー名で行うことはありません(一致していません)。
利便性をはかるため、多くの <STRONG>MySQL</STRONG> クライアントは現在のログインしているユーザ名を
<STRONG>MySQL</STRONG>のユーザー名としてログインを試みます。
しかしこれは <CODE>-u</CODE> か <CODE>--user</CODE> スイッチで変更できます。
これは、全てのユーザに対しパスワードを設定しておかないと、
全くデータベースを安全にできないことを意味します。
もしパスワードを全ユーザーに設定しておかないと、そのユーザー名で認証なしにサーバーに接続できます。

<LI>

<STRONG>MySQL</STRONG> のユーザー名は 16文字まで(英数半角)使用できます。
UNIXはだいたい8文字ですが。(8文字をこえるシステムもある)

<LI>

<STRONG>MySQL</STRONG> ユーザーのパスワードは、UNIX のパスワードと違います。
よって、それらのマシン上で UNIX のログインパスワードと
データベースのパスワードは同じにする必要はありません。

<LI>

<STRONG>MySQL</STRONG> は UNIX のログインパスワードとは全く違う、
独自の暗号化されたパスワードだけを使用します。
<CODE>PASSWORD()</CODE> と <CODE>ENCRYPT()</CODE> 関数の説明を参照 →  「<A HREF="manual.ja_Reference.html#Miscellaneous_functions">7.4.12  その他の関数</A>」節.
注意: パスワードが '暗号化' されて格納されていても、あなたの '暗号化' され
たパスワードを知ることで、<STRONG>MySQL</STRONG> サーバに接続するのには十分です！
</UL>



<H2><A NAME="Connecting" HREF="manual.ja_toc.html#Connecting">6.6  MySQL サーバーに接続</A></H2>
<P>
<A NAME="IDX386"></A>
<A NAME="IDX387"></A>
<A NAME="IDX388"></A>
<A NAME="IDX389"></A>

</P>
<P>
<STRONG>MySQL</STRONG> クライアントプログラムは、共通の決まった引数を持ちます：
接続したいホスト名、接続ユーザー名、そしてパスワードです。
例えば、<CODE>mysql</CODE> コマンドは以下のような引数を持ちます
(オプションの引数は <SAMP>`['</SAMP> と <SAMP>`]'</SAMP> で囲まれている部分です)

</P>

<PRE>
shell&#62; mysql [-h host_name] [-u user_name] [-pyour_pass]
</PRE>

<P>
<CODE>-h</CODE>, <CODE>-u</CODE>, <CODE>-p</CODE> オプションは以下と等価です。
<CODE>--host=host_name</CODE>, <CODE>--user=user_name</CODE>, <CODE>--password=your_pass</CODE>
<CODE>-p</CODE> とパスワードの間にはスペースがないことに注意

</P>
<P>
<STRONG>注意:</STRONG> コマンドラインにパスワードを与えるのは安全ではありません！
システムに入っている如何なるユーザーも <CODE>ps auxww</CODE> のようなコマンドを
使用する事でパスワードを見付ける事ができます
 「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照.

</P>
<P>
<CODE>mysql</CODE> コマンドはコマンドラインに引数がなければ接続にデフォルト値を用います。

</P>

<UL>
<LI>

デフォルトのホスト名は <CODE>localhost</CODE>, ユーザー名は UNIX のログイン名です。

<LI>

(<CODE>-p</CODE> が指定されていなければパスワードは与えられません)
</UL>

<P>
UNIX のログインユーザーが <CODE>joe</CODE> の場合、以下のコマンドは等価です：

</P>

<PRE>
shell&#62; mysql -h localhost -u joe
shell&#62; mysql -h localhost
shell&#62; mysql -u joe
shell&#62; mysql
</PRE>

<P>
他の <STRONG>MySQL</STRONG> クライアントも同じように動作します。

</P>
<P>
UNIX システムでは、ある値をデフォルト値にして接続に使用することができます。
そうすることにそり、毎回毎回コマンドラインに引数を与えなくてすむようになります：

</P>

<UL>
<LI>

<A NAME="IDX390"></A>
自分のホームディレクトリに <TT>`.my.cnf'</TT> を作り、そのファイルの中の
<CODE>[client]</CODE> セクションに接続用のパラメターを記述できます。
その記述は以下のようです：


<PRE>
[client]
host=host_name
user=user_name
password=your_pass
</PRE>

 「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照.

<LI>

<A NAME="IDX391"></A>
<A NAME="IDX392"></A>
<A NAME="IDX393"></A>
<A NAME="IDX394"></A>
<A NAME="IDX395"></A>
<A NAME="IDX396"></A>
接続のパラメターに環境変数を使用することもできます。
ホスト名は <CODE>MYSQL_HOST</CODE> 環境変数を使用します。
<STRONG>MySQL</STRONG> のユーザー名は <CODE>USER</CODE> (これは Windows のみ) に設定された値を使用します。
パスワードは <CODE>MYSQL_PWD</CODE> 環境変数を見ますが、これは危険です。(次の節参照)
 「<A HREF="manual.ja_Environment_variables.html#Environment_variables">A  Environment Variables</A>」節参照.
</UL>



<H3><A NAME="Password_security" HREF="manual.ja_toc.html#Password_security">6.6.1  パスワードを安全にする</A></H3>

<P>
自分のパスワードを他人にさらけ出すのは勧められることではありません。
それぞれの方法に於ける危険度に応じ、以下に示す方法でクライアントプログラムに
あなたのパスワードをあたえて走らせることができます：

</P>

<UL>
<LI>

一般ユーザに <CODE>mysql.user</CODE> テーブルへのアクセスを与えてはいけません。
ユーザの暗号化されたパスワード知ることで、そのユーザとしてログインが可能に
なります。パスワードは、使用される本当のパスワードを見ることができないよう
に、スクランブルされているだけです(同じようなパスワードを他のアプリケーショ
ンでたまたま使用する場合のため)。

<LI>

<CODE>-pyour_pass</CODE> か <CODE>--password=your_pass</CODE> オプションをコマンドラインで使用します。
これは便利ですが安全ではありません。あなたのパスワードは (<CODE>ps</CODE> コマンドのような)
システムの状態を見るコマンドにて見ることができます。
(<STRONG>MySQL</STRONG> クライアントは初期化過程においてコマンドラインの引数をゼロで上書きして
見せないようにしているのですが、瞬間ですが値が見えてしまうのです)

<LI>

<CODE>-p</CODE> あるいは <CODE>--password</CODE> オプションを <CODE>your_pass</CODE> を与えないで使用します。
この場合、クライアントプログラムはターミナルを通じてパスワードの入力を促してきます:
<A NAME="IDX397"></A>
<A NAME="IDX398"></A>


<PRE>
shell&#62; mysql -u user_name -p
Enter password: ********
</PRE>

<SAMP>`*'</SAMP> 文字はパスワードを表しています。

クライアントはあなたの入力したパスワードを <SAMP>`*'</SAMP> 文字で端末に返していますので、
画面をのぞき込まれたとしてもパスワードはわかりません。

これはコマンドラインにパスワードを指定するより安全です。他のユーザーには見えませんから。
しかしこのパスワードを毎回入れる方法は対話式のプログラムを実行する場合だけに使用できる手です。
もし非対話式のスクリプトからクライアントプログラムを起動したい場合、
パスワードを端末から入れる機会がありません。
On some systems, you may even find that the first line of your
script is read and interpreted (incorrectly) as your password!
 
<LI>

<A NAME="IDX399"></A>
設定ファイルにパスワードを書いておくこともできます。
例えば、自分のホームディレクトリーにある <TT>`.my.cnf'</TT> ファイルの <CODE>[client]</CODE>
セクションに、以下のような形で書きます：


<PRE>
[client]
password=your_pass
</PRE>

もし <TT>`.my.cnf'</TT> ファイルにパスワードを書いているなら、ファイルはグループや
その他のユーザーが読み書きできないようにすべきです。ファイルのモードは <CODE>400</CODE>
か <CODE>600</CODE> にします。

 「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照.
<LI>

<CODE>MYSQL_PWD</CODE> 環境変数にパスワードを設定することもできます。しかしこの方法は
きわめて危険であるので、使用すべきではありません。
<CODE>ps</CODE> のあるバージョンでは、実行中のプロセスの環境変数を表示するオプションがあります；
もし <CODE>MYSQL_PWD</CODE> 環境変数にパスワードを設定していると全てべたで見れます。
このバージョンの <CODE>ps</CODE> を持っていないシステムだとしても、プロセスの環境変数を調べる
方法がないとはいえないので、この方法はあまりいい方法ではありません。
 「<A HREF="manual.ja_Environment_variables.html#Environment_variables">A  Environment Variables</A>」節参照.
</UL>

<P>
まとめると、より安全な方法は、
パスワードプロンプトを返すクライアントプログラムを実行するか、
適切なパーミッションをかけた <TT>`.my.cnf'</TT> ファイルにパスワードを書くか
です。

</P>



<H2><A NAME="Privileges_provided" HREF="manual.ja_toc.html#Privileges_provided">6.7  MySQL が提供する権限</A></H2>
<P>
<A NAME="IDX400"></A>

</P>
<P>
権限の設定は <CODE>mysql</CODE> データベースの <CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE>,
 <CODE>tables_priv</CODE>, <CODE>columns_priv</CODE> で行います。
(<CODE>mysql</CODE> はデータベースの名前です)
<STRONG>MySQL</STRONG> サーバーは、サーバーの起動時か
  「<A HREF="manual.ja_Privilege_system.html#Privilege_changes">6.11  いつ権限の変更が反映されるか</A>」節 で説明されている方法により、
これらのテーブルから権限の設定を読み込みます。

</P>
<P>
<STRONG>MySQL</STRONG> が提供する権限の名称は,
本マニュアルでは以下の表の名称を用います。
この表の項目名がそれぞれの許可される権限とその説明に対応しています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Privilege</STRONG> </TD><TD> <STRONG>Column</STRONG> </TD><TD> <STRONG>Context</STRONG>
</TR NOSAVE>
<TR><TD><STRONG>select</STRONG> </TD><TD> <CODE>Select_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>insert</STRONG> </TD><TD> <CODE>Insert_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>update</STRONG> </TD><TD> <CODE>Update_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>delete</STRONG> </TD><TD> <CODE>Delete_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>index</STRONG> </TD><TD> <CODE>Index_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>alter</STRONG> </TD><TD> <CODE>Alter_priv</CODE> </TD><TD> tables
</TR NOSAVE>
<TR><TD><STRONG>create</STRONG> </TD><TD> <CODE>Create_priv</CODE> </TD><TD> databases, tables or indexes
</TR NOSAVE>
<TR><TD><STRONG>drop</STRONG> </TD><TD> <CODE>Drop_priv</CODE> </TD><TD> databases or tables
</TR NOSAVE>
<TR><TD><STRONG>grant</STRONG> </TD><TD> <CODE>Grant_priv</CODE> </TD><TD> databases or tables
</TR NOSAVE>
<TR><TD><STRONG>references</STRONG> </TD><TD> <CODE>References_priv</CODE> </TD><TD> databases or tables
</TR NOSAVE>
<TR><TD><STRONG>reload</STRONG> </TD><TD> <CODE>Reload_priv</CODE> </TD><TD> server administration
</TR NOSAVE>
<TR><TD><STRONG>shutdown</STRONG> </TD><TD> <CODE>Shutdown_priv</CODE> </TD><TD> server administration
</TR NOSAVE>
<TR><TD><STRONG>process</STRONG> </TD><TD> <CODE>Process_priv</CODE> </TD><TD> server administration
</TR NOSAVE>
<TR><TD><STRONG>file</STRONG> </TD><TD> <CODE>File_priv</CODE> </TD><TD> file access on server
</TR>
</TABLE>

<P>
<STRONG>select</STRONG>, <STRONG>insert</STRONG>, <STRONG>update</STRONG>, <STRONG>delete</STRONG> の権限は、
存在しているデータベースのテーブルに対して許可されます。

</P>
<P>
もしテーブルから行を取り出すだけなら、<CODE>SELECT</CODE> 構文を実行するためには
 <STRONG>select</STRONG> 権限だけあればかまいません。
だけでなく、サーバーのどのデータベースにアクセスを許可されていない場合でも、
ある種の <CODE>SELECT</CODE> は実行することができます。
例えば、簡単な計算を <CODE>mysql</CODE> クライアントで行う場合です：

</P>

<PRE>
mysql&#62; SELECT 1+1;
mysql&#62; SELECT PI()*2;
</PRE>

<P>
<STRONG>index</STRONG> 権限はインデックスの作成と破棄(削除)を許可します。

</P>
<P>
<STRONG>alter</STRONG> 権限は <CODE>ALTER TABLE</CODE> の実行を許可します。

</P>
<P>
<STRONG>create</STRONG> と <STRONG>drop</STRONG> 権限は、新しいデータベースやテーブルの作成、
あるいは既に存在するデータベース、テーブルの破棄(削除)を許可します。

</P>
<P>
注意： <CODE>mysql</CODE> データベースに登録されているユーザーに <STRONG>drop</STRONG> 権限を与えると、
そのユーザーは <STRONG>MySQL</STRONG> のアクセス権限が格納されているデータベースを破棄できます！

</P>
<P>
<STRONG>grant</STRONG> 権限は、あなたが他のユーザーに対して自分の権限を持たせる事を許可します。

</P>
<P>
 <STRONG>file</STRONG> の権限を与えると、<CODE>LOAD DATA INFILE</CODE> と <CODE>SELECT ... INTO OUTFILE</CODE> 構文を使用して、サーバーのファイルを読み書きする事ができます。
 <STRONG>MySQL</STRONG> サーバーがが読み書きできるファイルに対して、この権限が与えられたユーザーはファイルを読み書きできます。

</P>
<P>
残りの権限はアドミン操作に関する許可で、<CODE>mysqladmin</CODE> コマンドを使用して実行します。
次の表に <CODE>mysqladmin</CODE> コマンドのどれが、どの権限に対応しているかを示します：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Privilege</STRONG> </TD><TD> <STRONG>Commands permitted to privilege holders</STRONG>
</TR NOSAVE>
<TR><TD><STRONG>reload</STRONG> </TD><TD> <CODE>reload</CODE>, <CODE>refresh</CODE>,
<CODE>flush-privileges</CODE>, <CODE>flush-hosts</CODE>, <CODE>flush-logs</CODE>, <CODE>flush-tables</CODE>
</TR NOSAVE>
<TR><TD><STRONG>shutdown</STRONG> </TD><TD> <CODE>shutdown</CODE>
</TR NOSAVE>
<TR><TD><STRONG>process</STRONG> </TD><TD> <CODE>processlist</CODE>, <CODE>kill</CODE>
</TR>
</TABLE>

<P>
<CODE>reload</CODE> コマンドはサーバーに権限の設定を再読込させるように伝えます。
<CODE>refresh</CODE> コマンドは全てのテーブルをフラッシュし、ログファイルを開き直します。
<CODE>flush-privileges</CODE> は <CODE>reload</CODE> と同義です。
その他の <CODE>flush-*</CODE> コマンドは <CODE>refresh</CODE> の動作とよく似ていますが、
適用範囲を絞っており、ちょっとした場合に有効です。
例えば、ログファイルだけをフラッシュしたい場合、
<CODE>refresh</CODE> を行うよりも <CODE>flush-logs</CODE> がいいです。

</P>
<P>
<CODE>shutdown</CODE> コマンドは、サーバーをシャットダウンします。

</P>
<P>
<CODE>processlist</CODE> コマンドはサーバーが実行しているスレッドの情報を表示します。
 <CODE>kill</CODE> コマンドはサーバーのスレッドをkillします。
自分のスレッドは常に表示、killできますが、他人のスレッドをそうするには <STRONG>process</STRONG> 権限が必要です。 「<A HREF="manual.ja_Reference.html#KILL">7.27  <CODE>KILL</CODE> 構文</A>」節参照.

</P>
<P>
ある権限を欲しがるユーザーだけにその権限を許可するのはよい考えですが、
権限を与えるときには、特定の事項を熟知していなければなりません：

</P>

<UL>
<LI>

<STRONG>grant</STRONG> 権限を許可されたユーザーは、他のユーザーの権限を変える事ができます。
二人のユーザー間で違っている権限と <CODE>grant</CODE> 権限を入れ換えることができます。

<LI>

<STRONG>alter</STRONG> 権限は、テーブル名の変更を行うことにより特権システムを破るために
使用されるかもしれません。

<LI>

<STRONG>file</STRONG> 権限は、サーバー上にある全ての読み込み可能なファイルを
データベースに取り込むことができ、これは <CODE>SELECT</CODE> 文でアクセスできます。
これはサーバに置かれているすべてのデータベースの内容を含みます！

<LI>

<STRONG>shutdown</STRONG> 権限は、他のユーザーに対するサービスを、サーバーを
停止することによって、拒否するようにできます。

<LI>

<STRONG>process</STRONG> 権限は実行されているクエリーをプレーンテキストで見ることに使えます。
パスワードの設定、変更のクエリーも含みます。

<LI>

 <CODE>mysql</CODE> データベースに対しての権限は、パスワードの変更と他の権限の設定を変更時に使用されます。
(パスワードは暗号化されて登録されており、悪意のあるユーザーでも
単純に読むことはできません).
<CODE>mysql.user</CODE> のパスワードフィールドにアクセスできれば、それを使用して 
<STRONG>MySQL</STRONG> サーバに与えられたユーザでログインすることができます。(十分
な権限があれば、同じユーザが別のものにパスワードを置き換えることもできます。
)
</UL>

<P>
以下は <STRONG>MySQL</STRONG> の特権システムで行うものではありません：

</P>

<UL>
<LI>

アクセスを拒否するユーザーを特定して設定することはできません。
完全に一致したユーザーからの接続を拒否できません。

<LI>

データベース内のテーブルの作成、破棄の権限を持つが、
データベースそのものを作成、破棄できる、そのようなユーザーを設定できません。
</UL>



<H2><A NAME="Privileges" HREF="manual.ja_toc.html#Privileges">6.8  特権システムはどのように動くか？</A></H2>
<P>
<A NAME="IDX401"></A>

</P>
<P>
<STRONG>MySQL</STRONG> の特権システムは、全てのユーザーが与えられた許可の範囲内で動く事を保証します。
<STRONG>MySQL</STRONG> サーバーに接続するとき、本人の身元は、<STRONG>接続元のホスト</STRONG> と
 <STRONG>接続に使用するユーザー名</STRONG> によって確認されます。
このシステムは、あなたの身元と<STRONG>あなたが要求することが何か</STRONG> によって、権限を与えます。

</P>
<P>
<STRONG>MySQL</STRONG> はあなたのホスト名とユーザー名の両方をあわせてチェックします。
これはインターネット上に同じ名前のユーザーがどこかにいるかもしれないということからそうしています。
例えば、<CODE>whitehouse.gov</CODE> から接続してきた <CODE>bill</CODE> と、
 <CODE>microsoft.com</CODE> から接続してきた <CODE>bill</CODE> は同一人物である必要はありません。
<STRONG>MySQL</STRONG> はこの違うホストから接続してきた同名のユーザーを以下のようにして扱います：
 <CODE>whitehouse.gov</CODE> から接続した <CODE>bill</CODE> にある許可をあたえ、
それとは違う許可を <CODE>microsoft.com</CODE> から接続してきた <CODE>bill</CODE> に与えます。

</P>
<P>
<STRONG>MySQL</STRONG> のアクセスコントロールは以下の二つからなります：

</P>

<UL>
<LI>

Stage 1: サーバーは接続許可があるかどうかをチェックします。

<LI>

Stage 2: 接続許可後、サーバーはそれぞれのリクエストをチェックします。
あなたが要求してきた事柄を、あなたが実行できるかどうかをチェックします。
例えば、あるデータベースのテーブルの行の取り出しやテーブルの破棄をあなたが命令した場合、
サーバーは、あなたにそのテーブルに対する <STRONG>select</STRONG> 許可があるのか、
データベースに対して <STRONG>drop</STRONG> する許可が与えられているのか、を確認します。
</UL>

<P>
サーバーは <CODE>mysql</CODE> データベースの <CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE> ３つのテーブルから、
この２つのアクセス制限を決定します。
このテーブルのフィールドは以下のようになっています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table name</STRONG> </TD><TD> <CODE>user</CODE> </TD><TD> <CODE>db</CODE> </TD><TD> <CODE>host</CODE>

</TR NOSAVE>
<TR><TD><STRONG>Scope fields</STRONG> </TD><TD> <CODE>Host</CODE> </TD><TD> <CODE>Host</CODE> </TD><TD> <CODE>Host</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>User</CODE> </TD><TD> <CODE>Db</CODE> </TD><TD> <CODE>Db</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Password</CODE> </TD><TD> <CODE>User</CODE> </TD><TD>

</TR NOSAVE>
<TR><TD><STRONG>Privilege fields</STRONG> </TD><TD> <CODE>Select_priv</CODE> </TD><TD> <CODE>Select_priv</CODE> </TD><TD> <CODE>Select_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Insert_priv</CODE> </TD><TD> <CODE>Insert_priv</CODE> </TD><TD> <CODE>Insert_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Update_priv</CODE> </TD><TD> <CODE>Update_priv</CODE> </TD><TD> <CODE>Update_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Delete_priv</CODE> </TD><TD> <CODE>Delete_priv</CODE> </TD><TD> <CODE>Delete_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Index_priv</CODE> </TD><TD> <CODE>Index_priv</CODE> </TD><TD> <CODE>Index_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Alter_priv</CODE> </TD><TD> <CODE>Alter_priv</CODE> </TD><TD> <CODE>Alter_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Create_priv</CODE> </TD><TD> <CODE>Create_priv</CODE> </TD><TD> <CODE>Create_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Drop_priv</CODE> </TD><TD> <CODE>Drop_priv</CODE> </TD><TD> <CODE>Drop_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Grant_priv</CODE> </TD><TD> <CODE>Grant_priv</CODE> </TD><TD> <CODE>Grant_priv</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>References_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Reload_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Shutdown_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Process_priv</CODE> </TD><TD> </TD><TD> 
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>File_priv</CODE> </TD><TD> </TD><TD> 
</TR>
</TABLE>

<P>
　アクセスコントロールの第2段階(要求承認)のために、サーバーはこれら 3 つの
テーブルによって決められた許可を基本としますが、もしテーブルに対する要求で
あるならば、<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルを
さらに調べます。これらのテーブルのフィールドは以下のようになっています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table name</STRONG> </TD><TD> <CODE>tables_priv</CODE> </TD><TD> <CODE>columns_priv</CODE>

</TR NOSAVE>
<TR><TD><STRONG>Scope fields</STRONG> </TD><TD> <CODE>Host</CODE> </TD><TD> <CODE>Host</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Db</CODE> </TD><TD> <CODE>Db</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>User</CODE> </TD><TD> <CODE>User</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Table_name</CODE> </TD><TD> <CODE>Table_name</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> </TD><TD> <CODE>Column_name</CODE>

</TR NOSAVE>
<TR><TD><STRONG>Privilege fields</STRONG> </TD><TD> <CODE>Table_priv</CODE> </TD><TD> <CODE>Type</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Column_priv</CODE> </TD><TD>

</TR NOSAVE>
<TR><TD><STRONG>Other fields</STRONG> </TD><TD> <CODE>Timestamp</CODE> </TD><TD> <CODE>Timestamp</CODE>
</TR NOSAVE>
<TR><TD></TD><TD> <CODE>Grantor</CODE> </TD><TD>
</TR>
</TABLE>

<P>
　テーブルの各フィールドを分類すると、２種類にわかれます：
適用範囲を指定するフィールド(以下　スコープフィールド)と許可を定義するフィールド(以下　権限フィールド)です。

</P>
<P>
　スコープフィールドは、権限テーブルの登録ごとに、その適用範囲を決めます。
例えば、 <CODE>user</CODE> テーブルの <CODE>Host</CODE> と <CODE>User</CODE> に
 <CODE>'thomas.loc.gov'</CODE> と <CODE>'bob'</CODE> が登録されている場合、
サーバーへの接続は ホスト <CODE>thomas.loc.gov</CODE> から来た <CODE>'bob'</CODE> に許可されます。
同様に、<CODE>db</CODE> テーブルの  <CODE>Host</CODE>, <CODE>User</CODE>, <CODE>Db</CODE> に
 <CODE>'thomas.loc.gov'</CODE>, <CODE>'bob'</CODE>, <CODE>'reports'</CODE> が登録されていると、
ホスト <CODE>thomas.loc.gov</CODE> から来た <CODE>bob</CODE> に対し <CODE>reports</CODE>
データベースへの接続が許されます。
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは、
テーブルか、テーブルとフィールドを対にしたスコープフィールドを含みます。

</P>
<P>
<A NAME="IDX402"></A>
　アクセスのチェックは、<CODE>Host</CODE> の値はケース非依存で比較されます。
<CODE>User</CODE>, <CODE>Password</CODE>, <CODE>Db</CODE>, <CODE>Table_name</CODE> の値はケース依存で比較されます。
<CODE>Column_name</CODE> の値は <STRONG>MySQL</STRONG> バージョン 3.22.12 以上ではケース非依存で比較されます。
(バージョン 3.22.11 までは ケース依存です)

</P>
<P>
権限フィールドは、テーブルに登録されることにより有効になった許可をしめし、
これはどの操作が実行できるかを示します。
サーバーは許可テーブルの情報をユーザーの権限を得るためにまとめます。
このユーザーの権限許可を割り出す方法は  「<A HREF="manual.ja_Privilege_system.html#Request_access">6.10  Access control, Stage 2: 要求の承認</A>」節 に述べておきます。

</P>
<P>
スコープフィールドは文字で定義され、デフォルト値は空文字になっています：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Field name</STRONG> </TD><TD> <STRONG>Type</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Host</CODE> </TD><TD> <CODE>CHAR(60)</CODE>
</TR NOSAVE>
<TR><TD><CODE>User</CODE> </TD><TD> <CODE>CHAR(16)</CODE>
</TR NOSAVE>
<TR><TD><CODE>Password</CODE> </TD><TD> <CODE>CHAR(16)</CODE>
</TR NOSAVE>
<TR><TD><CODE>Db</CODE> </TD><TD> <CODE>CHAR(64)</CODE> </TD><TD> (<CODE>CHAR(60)</CODE> for the
<CODE>tables_priv</CODE> and <CODE>columns_priv</CODE> tables)
</TR NOSAVE>
<TR><TD><CODE>Table_name</CODE> </TD><TD> <CODE>CHAR(60)</CODE>
</TR NOSAVE>
<TR><TD><CODE>Column_name</CODE> </TD><TD> <CODE>CHAR(60)</CODE>
</TR>
</TABLE>

<P>
<CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE> テーブルでは、
全ての権限フィールドは <CODE>ENUM('N','Y')</CODE> で定義されます。
この値は <CODE>'N'</CODE> か <CODE>'Y'</CODE> のどちらかで、デフォルト値は <CODE>'N'</CODE> です。

</P>
<P>
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルでは、
権限フィールドは <CODE>SET</CODE> フィールドとして定義されます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table name</STRONG> </TD><TD> <STRONG>Field name</STRONG> </TD><TD> <STRONG>Possible set elements</STRONG>
</TR NOSAVE>
<TR><TD><CODE>tables_priv</CODE> </TD><TD> <CODE>Table_priv</CODE> </TD><TD> <CODE>'Select', 'Insert',
'Update', 'Delete', 'Create', 'Drop', 'Grant', 'References', 'Index', 'Alter'</CODE>
</TR NOSAVE>
<TR><TD><CODE>tables_priv</CODE> </TD><TD> <CODE>Column_priv</CODE> </TD><TD> <CODE>'Select', 'Insert',
'Update', 'References'</CODE>
</TR NOSAVE>
<TR><TD><CODE>columns_priv</CODE> </TD><TD> <CODE>column_priv</CODE> </TD><TD> <CODE>'Select', 'Insert',
'Update', 'References'</CODE>
</TR>
</TABLE>

<P>
サーバーは以下のように許可テーブルを使用します：

</P>

<UL>
<LI>

<CODE>user</CODE> テーブルのスコープフィールドは、接続要求を受け入れるか拒否するかを決定します。
許可された接続について、<CODE>user</CODE> テーブルで与えられたすべての権限は、ユー
ザのグローバル(スーパーユーザ)権限を示します。この権限はサーバ上の 
<STRONG>すべての</STRONG> データベースに適用されます。
(訳注：
例えば、<CODE>user</CODE> テーブル の権限を <CODE>'Y'</CODE> にした場合、
どんなに <CODE>db</CODE> テーブルや <CODE>host</CODE> テーブルで権限を <CODE>'N'</CODE> にしたとしても
権限は <CODE>'Y'</CODE> のままである。
ようは <CODE>user</CODE> テーブルの権限許可 <CODE>'Y'</CODE> が全てに反映されてしまうという事。
<CODE>user</CODE> テーブルには最低限の許可を与えるようにし、
<CODE>db</CODE> テーブルや <CODE>host</CODE> テーブルで、それぞれの権限許可を定義する方が無難。
)

<LI>

<CODE>db</CODE> と <CODE>host</CODE> テーブルは一緒に使用されます：


<UL>
<LI>

<CODE>db</CODE> テーブルのスコープフィールドはどのホストからどのデータベースのアクセスできるかを決定します。
権限フィールドは、どういった操作ができるか定義します。

<LI>

<CODE>host</CODE> テーブルは、<CODE>db</CODE> テーブルの登録をいくつかのホストに与えたい時に、
<CODE>db</CODE> テーブルの拡張として使用されます。
例えば、ネットワーク上の限定したマシンからデータベースを使用したい場合、
<CODE>db</CODE> テーブルの <CODE>Host</CODE> の値は空にしておきます。
そして <CODE>host</CODE> テーブルにそれぞれのホストについての登録を行います。
この機構は、  「<A HREF="manual.ja_Privilege_system.html#Request_access">6.10  Access control, Stage 2: 要求の承認</A>」節 で詳細に述べられています。
</UL>

<LI>

<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは <CODE>db</CODE> テーブルに似ていますが、
それらはより細かく定義できます；
データベースレベルではなく、テーブルとフィールドのレベルで与えます。
</UL>

<P>
管理者権限 (<STRONG>reload</STRONG>, <STRONG>shutdown</STRONG>,など) は <CODE>user</CODE> テーブルにだけ定義するように。
これは、管理者操作はデータベースではなくサーバーへの操作であり、
他の許可テーブルにある必要がないからです。
またこうしておくと、管理者操作の許可は、<CODE>user</CODE> テーブルの定義だけを
見ればわかるようになります。

</P>
<P>
<STRONG>file</STRONG> 操作の権限は <CODE>user</CODE> テーブルにだけ定義するように。
これは管理者操作ではありませんが、アクセスしているデータベースにかかわらず、
サーバー内のファイルを読み書きできるのです。

</P>
<P>
<CODE>mysqld</CODE> サーバーは起動時にこれらのテーブルを読み込みます。
許可テーブルの変更を反映させる方法はこちらを参照のこと →  「<A HREF="manual.ja_Privilege_system.html#Privilege_changes">6.11  いつ権限の変更が反映されるか</A>」節

</P>
<P>
これらのテーブルの登録を変更した場合、思ったとおりの権限状態になっている事を確認することはいいことです。
問題の解決には,  「<A HREF="manual.ja_Privilege_system.html#Access_denied">6.15  何故 <CODE>Access denied</CODE> エラーになるのか</A>」節.  セキュリティに関するアドバイスは
 「<A HREF="manual.ja_Privilege_system.html#Security">6.2  MySQL をクラッカーに対して安全にする方法</A>」節.

</P>
<P>
便利なツールとして <CODE>mysqlaccess</CODE> スクリプト( Yves Carlier 作)が <STRONG>MySQL</STRONG> の配布に含まれています。
<CODE>mysqlaccess</CODE> を  <CODE>--help</CODE> オプションで起動するとヘルプが表示されます。
<CODE>mysqlaccess</CODE> は <CODE>user</CODE>,<CODE>db</CODE> and <CODE>host</CODE> テーブルだけしか
検査しません。テーブルレベルの権限、フィールドレベルの権限は調べません。

</P>



<H2><A NAME="Connection_access" HREF="manual.ja_toc.html#Connection_access">6.9  Access Control, Stage 1: 接続の承認</A></H2>
<P>
<A NAME="IDX403"></A>
<A NAME="IDX404"></A>
<A NAME="IDX405"></A>
<A NAME="IDX406"></A>

</P>
<P>
<STRONG>MySQL</STRONG> サーバーに接続すると、あなたがパスワード認証して接続していようがいまいが、
サーバーはあなたの身元により接続の許可拒否を行います。
もし身元が一致しない場合接続を拒否し、接続許可した場合、サーバーは stage 2 へと進み、要求を待ちます。

</P>
<P>
身元は二つのものに基づいて確認されます：

</P>

<UL>
<LI>

あなたが接続しようとしているホスト

<LI>

あなたの <STRONG>MySQL</STRONG> ユーザー名
</UL>

<P>
身元の確認は <CODE>user</CODE> テーブルのスコープフィールド(<CODE>Host</CODE>, <CODE>User</CODE>, <CODE>Password</CODE>) を使用して行います。
サーバーは <CODE>user</CODE> テーブルの登録に一致しているホスト名とユーザー名に限り接続を許可し、その後、パスワードを要求します。

</P>
<P>
<CODE>user</CODE> テーブルのスコープフィールドの登録は以下のようになります：

</P>

<UL>
<LI>

<CODE>Host</CODE> の値はホスト名か IP アドレスか <CODE>'localhost'</CODE>(ローカルホスト) です。

<LI>

<A NAME="IDX407"></A>
<CODE>Host</CODE> にはワイルドカード文字 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> を使用できます。

<LI>

<CODE>Host</CODE> に <CODE>'%'</CODE> を設定すると、全てのホストにマッチします。

<LI>

空の <CODE>Host</CODE> 値は、権限が <CODE>host</CODE> テーブル内の与えられたホスト名に
適合するエントリと AND されることを意味します。次の章にこれについての詳し
い情報を見つけられます。

<A NAME="IDX408"></A>
<LI>

MySQL バージョン 3.23 では、IPアドレスが記述された <CODE>Host</CODE> 値には、何
ビットがネットワークアドレスに使用されるかを示すネットマスクを記述すること
ができます。例えば:


<PRE>
GRANT ALL PRIVILEGES on db.* to david@'192.58.197.0/255.255.255.0';
</PRE>

これは、次が真になる IP からの接続をすべて許可します:


<PRE>
user_ip &#38; netmask = host_ip.
</PRE>

上記の例では、192.58.197.0〜192.58.197.255 のすべての IP が 
<STRONG>MySQL</STRONG> サーバに接続できます。
 
<LI>

<A NAME="IDX409"></A>
ワイルドカード文字は <CODE>User</CODE> フィールドには設定できませんが、
<CODE>User</CODE> フィールドをブランク(空)にすることはできます。ブランクは全ての名前にマッチします。
これはユーザー名がない状態で接続してきたものに適用され、
クライアントがユーザー名を明記しない限り、匿名ユーザー(名前がブランク)として扱われます。
全てのアクセスのチェックにブランクのユーザー名が使用される事を意味します。(that is, during Stage 2)

<LI>

<CODE>Password</CODE> フィールドは空にできます。その場合、パスワードなして接続できることになります。
</UL>

<P>
<A NAME="IDX410"></A>
非ブランクの <CODE>Password</CODE> 値はパスワードを暗号化したものです。
<STRONG>MySQL</STRONG> はだれもが見れるようにパスワードを平文では保存しません。
接続を試みようとしているユーザーのパスワードも、(<CODE>PASSWORD()</CODE> 関数で)
暗号化されます。
それから、暗号化パスワードは、クライアント／サーバがパスワードが正しいかチェッ
クする時に使用されます(This is done without the encrypted password ever
traveling over the connection)。注意: <STRONG>MySQL</STRONG> では、暗号化パスワー
ドが本当のパスワードです。そのため、それへのアクセスを誰にも与えるべきでは
ありません！ 特に、一般ユーザには<CODE>mysql</CODE> データベース内のテーブルの読
み取り権を与えないでください！

</P>
<P>
以下の表は、接続要求に対して与える、
<CODE>user</CODE> テーブルの <CODE>Host</CODE> と  <CODE>User</CODE> の設定例です：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>Host</CODE> <STRONG>value</STRONG> </TD><TD> <CODE>User</CODE> <STRONG>value</STRONG> </TD><TD> <STRONG>Connections matched by entry</STRONG>
</TR NOSAVE>
<TR><TD><CODE>'thomas.loc.gov'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>thomas.loc.gov</CODE> から接続
</TR NOSAVE>
<TR><TD><CODE>'thomas.loc.gov'</CODE> </TD><TD> <CODE>''</CODE> </TD><TD> <CODE>thomas.loc.gov</CODE> から接続してくる全てのユーザー
</TR NOSAVE>
<TR><TD><CODE>'%'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, 全てのホストから接続
</TR NOSAVE>
<TR><TD><CODE>'%'</CODE> </TD><TD> <CODE>''</CODE> </TD><TD> 全てのホストから接続してくる全ユーザー
</TR NOSAVE>
<TR><TD><CODE>'%.loc.gov'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>loc.gov</CODE> ドメイン内の全てのホストからの接続
</TR NOSAVE>
<TR><TD><CODE>'x.y.%'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>x.y.net</CODE>, <CODE>x.y.com</CODE>,<CODE>x.y.edu</CODE>, などからの接続. (あまり有効な使い方ではないです)
</TR NOSAVE>
<TR><TD><CODE>'144.155.166.177'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, IP address が <CODE>144.155.166.177</CODE> のホストからの接続
</TR NOSAVE>
<TR><TD><CODE>'144.155.166.%'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> <CODE>fred</CODE>, <CODE>144.155.166</CODE> class C subnet 内の全てのホストからの接続
</TR NOSAVE>
<TR><TD><CODE>'144.155.166.0/255.255.255.0'</CODE> </TD><TD> <CODE>'fred'</CODE> </TD><TD> 上の例と同じ
</TR>
</TABLE>

<P>
<CODE>Host</CODE> に IP のワイルドカード(例えば <CODE>'144.155.166.%'</CODE> は
サブネットの全てのホストにマッチ) を使用することができます。
が、この場合、 <CODE>144.155.166.somewhere.com</CODE> というホスト名で
だれかが接続しようとしてくるかもしれません。
このような攻撃に対し、<STRONG>MySQL</STRONG> は数字やドットで始まるホスト名を拒否しています。
もし <CODE>1.2.foo.com</CODE> のような名前のホストを持っている場合、
許可テーブルの <CODE>Host</CODE> には絶対にマッチしません。
IPアドレスのみ、IP のワイルドカードにマッチする事になります。

</P>
<P>
サーバーに来る接続は、<CODE>user</CODE> テーブル内の登録に１つ以上
マッチするかもしれません。
例えば, <CODE>thomas.loc.gov</CODE> の <CODE>fred</CODE> からの接続は、上に示された
登録のうちのいくつかにマッチするでしょう。
サーバーは、複数の登録にマッチした場合、どのようにしてその中から
使用する登録を選ぶのでしょう？
サーバーは起動後に <CODE>user</CODE> テーブルをソートし、並び換えられた順に
登録を検索することにより、この問題を解決します。
最初にマッチした登録が使用されます。

</P>
<P>
<CODE>user</CODE> テーブルが以下のようにソートされていた場合：

</P>

<PRE>
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| %         | root     | ...
| %         | jeffrey  | ...
| localhost | root     | ...
| localhost |          | ...
+-----------+----------+-
</PRE>

<P>
サーバーがこのテーブルを読むと、<CODE>Host</CODE> に値が最も確実に特定できるホストを指定しているエントリを、最初に参照します。
(<CODE>Host</CODE> 項の <CODE>'%'</CODE> は ``すべてのホスト'' を意味し、ホスト名をはっきりと特定しているものではありません)

</P>
<P>
<CODE>Host</CODE> の値が同じエントリがあった場合、もっとも明確に <CODE>User</CODE> の値がユーザーを指定しているエントリを最初に参照します。(<CODE>User</CODE> の値が空の場合、``だれでも'' を意味します)
この結果、<CODE>user</CODE> テーブルは以下のようにソートされます：

</P>

<PRE>
+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| localhost | root     | ...
| localhost |          | ...
| %         | jeffrey  | ...
| %         | root     | ...
+-----------+----------+-
</PRE>

<P>
<A NAME="IDX411"></A>
<A NAME="IDX412"></A>
<A NAME="IDX413"></A>
接続が試みられた場合、サーバーは並び換えられた登録を探し、最初に見つけたものを
使用します。
<CODE>'localhost'</CODE> の <CODE>jeffrey</CODE> からの接続は、まず最初に <CODE>Host</CODE> に <CODE>localhost</CODE> を設定しているエントリにマッチします。
ユーザー名が空のエントリは、ホスト名とユーザー名の両方を指定した接続にもマッチします。
( <CODE>'%'/'jeffrey'</CODE> エントリもマッチします。が、これは最初にはマッチしません。)

</P>
<P>
もう一例。<CODE>user</CODE> が以下の設定と仮定します：

</P>

<PRE>
+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| %              | jeffrey  | ...
| thomas.loc.gov |          | ...
+----------------+----------+-
</PRE>

<P>
これは次のようにソートされます：

</P>

<PRE>
+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| thomas.loc.gov |          | ...
| %              | jeffrey  | ...
+----------------+----------+-
</PRE>

<P>
<CODE>thomas.loc.gov</CODE> の <CODE>jeffrey</CODE> からの接続は、最初のエントリにマッチし、
<CODE>whitehouse.gov</CODE> の <CODE>jeffrey</CODE> からの接続は、二つ目のエントリにマッチします。

</P>
<P>
最初にサーバが,接続のためのマッチを見つけるのを試みるとき,共通の誤解は与えられた
ユーザ名に明らかにそのユーザを命名するすべてのエントリが使用されると思うことです.
これは単に本当ではありません. jeffreyによるthomas.loc.govからの接続が最初に
エントリによってユーザ分野値として‘jeffrey'を含まないいずれのエントリによってる合わ
せられる場合,前の例はこれをユーザ名なしで例示します!

</P>
<P>
よくある考え違いは、ユーザー名を与えた場合、
サーバーが接続にマッチするものを探す際に、
そのユーザーが登録されている全てのルールが、
最初に使用されるだろうと考えることです。これは正しくありません。
前の例でこれを示しましたが、<CODE>thomas.loc.gov</CODE> の <CODE>jeffrey</CODE> からの接続が
最初にマッチするのは、 <CODE>User</CODE> フィールドの値が <CODE>'jeffrey'</CODE> に
なっているエントリではなく、ユーザー名なし(＝だれでも) のエントリの方が
先にマッチします！

</P>
<P>
もしサーバーへの接続がうまく行かない場合、 <CODE>user</CODE> テーブルを表示し、
マニュアルでソートしてみて、どのエントリに最初にマッチするか探してください。

</P>



<H2><A NAME="Request_access" HREF="manual.ja_toc.html#Request_access">6.10  Access control, Stage 2: 要求の承認</A></H2>

<P>
一度接続か確立されると、サーバーはステージ２に移ります。
このステージでは、サーバーはこの接続から来るそれぞれの要求が許可されているかどうかをチェックします。
チェックは実行しようとしている操作のタイプにより行います。
その操作が許可テーブルのどの権限フィールドに当てはまるかを見ます。
これら権限は  <CODE>user</CODE>, <CODE>db</CODE>,<CODE>host</CODE>, <CODE>tables_priv</CODE> か <CODE>columns_priv</CODE> テーブルより導出されます。
許可テーブルは <CODE>GRANT</CODE> コマンドで操作します。
 「<A HREF="manual.ja_Reference.html#GRANT">7.35  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照.
(You may find it helpful to refer to the table shown earlier that lists
the fields present in each of the grant tables; see  「<A HREF="manual.ja_Privilege_system.html#Privileges">6.8  特権システムはどのように動くか？</A>」節.)

</P>
<P>
<CODE>user</CODE> テーブルは全てに対して基本となる権限をユーザーに割り当てます。
たとえカレントのデータベースが許可を与えていなくても、<CODE>user</CODE> テーブルの設定が有効になります。
例えば、<CODE>user</CODE> テーブルで <STRONG>delete</STRONG> を許可した場合、
サーバーにあるどんなデータベースの行も削除できるのです！ 
いうならば、<CODE>user</CODE> テーブルの権限はスーパーユーザーの権限と言ってもいいでしょう。
この権限はスーパーユーザー(サーバーやデーターベース管理者)のみに与えておく事が賢明です。
他のユーザーは、<CODE>user</CODE> テーブルの権限の設定を <CODE>'N'</CODE> のままにしておくべきですし、
また、<CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルを利用して、
データベースを指定した上でユーザーに権限を許可すべきです。

</P>
<P>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>
<A NAME="IDX416"></A>
<CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルは特定のデータベースに対する権限許可を行います。
スコープフィールドの値は次のように記述されます:

</P>

<UL>
<LI>

ワイルドカード文字 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> は <CODE>Db</CODE> テーブルと <CODE>Host</CODE> フィールドだけに使用できます。

<LI>

<CODE>'%'</CODE> <CODE>Host</CODE> 値は ``あらゆるホスト'' を意味します。
<CODE>db</CODE> テーブルの <CODE>Host</CODE> に空を設定すると、``さらに <CODE>host</CODE> テーブルに許可情報を探しにいく''
となります。

<LI>

<CODE>'%'</CODE> か 空値を <CODE>Host</CODE> テーブルに設定すると、それは ``あらゆるホスト'' となります。

<LI>

<CODE>'%'</CODE> か 空値を <CODE>host</CODE> テーブルの <CODE>Db</CODE> フィールドに設定すると、
それは ``あらゆるデータベース'' となります。

<LI>

<CODE>User</CODE> を空値にすると、匿名ユーザーにマッチします。
</UL>

<P>
<A NAME="IDX417"></A>
<A NAME="IDX418"></A>
<A NAME="IDX419"></A>
<A NAME="IDX420"></A>
サーバー起動時に、<CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルはサーバーに読み込まれます。
(<CODE>user</CODE> テーブルもこの時に同時に読まれます)
<CODE>db</CODE> テーブルは <CODE>Host</CODE>, <CODE>Db</CODE>, <CODE>User</CODE> のフィールドでソートされ、
<CODE>host</CODE> テーブルは <CODE>Host</CODE>, <CODE>Db</CODE> フィールドでソートされます。
<CODE>user</CODE> テーブルは、一番特定できるエントリを最初に、一番特定できないものを最後にソートします。
サーバーはソートされたものの中から、最初にマッチしたものを使用します。

</P>
<P>
<A NAME="IDX421"></A>
<A NAME="IDX422"></A>
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは、
特定のテーブルとフィールドに対する権限を許可します。
スコープフィールドの値は、いかにそって記述されます：

</P>

<UL>
<LI>

ワイルドカード文字 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> はどちらかのテーブルの
<CODE>Host</CODE> フィールドに使用できます。

<LI>

どちらかのテーブルの <CODE>Host</CODE> 値を <CODE>'%'</CODE> かブランクにすると、
``any host.'' を意味します。

<LI>

<CODE>Db</CODE>, <CODE>Table_name</CODE>, <CODE>Column_name</CODE> フィールドはどのテーブルにも
ワイルドカードやブランクは使用できません。
</UL>

<P>
<CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> テーブルは
<CODE>Host</CODE>, <CODE>Db</CODE>, <CODE>User</CODE> フィールドで並び換えられます。
これは <CODE>db</CODE> テーブルのソートに似ていますが、 <CODE>Host</CODE> フィールドだけが
ワイルドカードを含むので、ソートはより単純なものになります。

</P>
<P>
この要求の承認は次のようにして行います。
もしアクセス承認を決定する部分のソースコードを理解できるなら、
ちょっと変わったアルゴリズムで承認の決定を行っている事に気づくでしょう。

</P>
<P>
管理者の要求(<STRONG>shutdown</STRONG>, <STRONG>reload</STRONG>, etc.)については、サーバーは
 <CODE>user</CODE> テーブルだけを参照します。(<CODE>user</CODE> テーブルだけが管理者権限のフィールドを持つ)。
エントリに許可登録されている操作は受け入れられ、それ以外は拒否されます。
例えば、<CODE>mysqladmin shutdown</CODE> を実行しようとしても、<CODE>user</CODE> テーブルの <STRONG>shutdown</STRONG> 権限が許されていなければ実行できません。この時、<CODE>db</CODE> と <CODE>host</CODE> テーブルはチェックされません。(これらのテーブルには <CODE>Shutdown_priv</CODE> フィールドが無いからです)

</P>
<P>
データベースへの要求 (<STRONG>insert</STRONG>, <STRONG>update</STRONG>, etc.) において、サーバーはまず最初に、ユーザーのグローバルな権限(スーパーユーザー)を <CODE>user</CODE> の中から探しだします。
もし許可が与えられていれば、アクセスは成功します。

</P>
<P>
<CODE>user</CODE> テーブルのグローバルな権限の設定が不十分であるなら、サーバーはユーザーのデータベースに対する権限を <CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルから決定します：

</P>

<OL>
<LI>

サーバーは <CODE>db</CODE> テーブルの <CODE>Host</CODE>,<CODE>Db</CODE>,<CODE>User</CODE>フィールドを参照します。
<CODE>Host</CODE> と <CODE>User</CODE> フィールドはユーザーの接続時のホスト名と <STRONG>MySQL</STRONG> ユーザー名にマッチします。
<CODE>Db</CODE> フィールドはユーザーがアクセスしたいデータベース名にマッチします。
<CODE>Host</CODE> と <CODE>User</CODE> にマッチするものが無かった場合、アクセスは拒否されます。

<LI>

<CODE>db</CODE> テーブル内の <CODE>Host</CODE> フィールドが空でないエントリにマッチした場合、
ユーザーの指定されているデータベースに対する権限が定義されます。

<LI>

<CODE>Host</CODE> フィールドが空値の <CODE>db</CODE> テーブルのエントリにマッチした場合、
どのホストがそのデータベースへアクセスできるかを <CODE>host</CODE> テーブルから探し出します。
この場合、<CODE>host</CODE> テーブル の <CODE>Host</CODE>, <CODE>Db</CODE> フィールドとマッチするものを探し出します。
<CODE>host</CODE> テーブルにエントリがなかった場合、アクセスは拒否されます。
もしマッチすると、ユーザーの特定データベースに対する権限は、
<CODE>host</CODE> テーブルと <CODE>db</CODE> テーブル両方にまたがった権限から割り出されます。
いうならば両方とも <CODE>'Y'</CODE> である権限。
(この方法を使用すると、まず <CODE>db</CODE> テーブルのエントリに大まかな権限を設定しておき、
それから <CODE>host</CODE> テーブルのエントリを使用して、ホスト情報もとに権限を限定していくという事ができます)
</OL>

<P>
特定データベースに対する権限が <CODE>db</CODE> テーブルと <CODE>host</CODE> テーブルのエントリから決定された後、
サーバーはその割り出された権限に対し、<CODE>user</CODE> テーブルて設定されている権限を加えます。
この結果から得られた権限にマッチした要求は受け入れられます。
そうでなければ、サーバーはユーザーのテーブル、フィールドに対する許可を、
 <CODE>tables_priv</CODE> と <CODE>columns_priv</CODE> 内に探します。
アクセスはこの結果により、許可、拒否されます。

</P>
<P>
先のユーザーの権限が計算される方法の記述は、boolean 表記で示すならば、
以下のようになるでしょう：

</P>

<PRE>
global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
</PRE>

<P>
これは少し分かりにくいかもしれません。もしグローバルの <CODE>user</CODE> エントリ
権限許可が、リクエストされたオペレーションには不十分だと最初に分かった際、
サーバーがこれらの権限を database-, table-, column-固有の権限の
後に、なぜ、追加してしまうのか。
 その理由は、リクエストが1個以上の権限を要求するだろうということです。
例えば、もしあなたが <CODE>INSERT ...  SELECT</CODE> 構文を実行するなら、
あなたには <STRONG>insert</STRONG> と <STRONG>select</STRONG> 許可が必要です。
あなたの権限が、 <CODE>user</CODE> テーブルエントリで一つの権限が許可され、
 <CODE>db</CODE> テーブルで、そのほかの権限が許可されていたとします。
この場合、あなたは、そのリクエストを実行するために、必要な権限を持っています。
しかし、サーバーはどちらのテーブル、それ単体からでは、権限を得ることが出来ません。
権限は、両方のエントリーを合わせなくてはならないのです。

</P>
<P>
<A NAME="IDX423"></A>
<A NAME="IDX424"></A>

</P>
<P>
<CODE>host</CODE> テーブルは ``安全な'' ホストのリストを維持するために使用できます。

</P>
<P>
TcX では、<CODE>host</CODE> テーブルにはローカルネット上の全てのホストが登録されています。
これらのホストは全ての権限が許可されています。

</P>
<P>
逆に <CODE>host</CODE> table で安全<EM>ではない</EM>ホストを指定することもできます。
 <CODE>public.your.domain</CODE> というマシンが安全ではない、公開されている場所にあるとします。
その場合以下のようにして、その公開マシン以外のネットワーク上のホストに対して、アクセスを許可することができます：

</P>

<PRE>
+--------------------+----+-
| Host               | Db | ...
+--------------------+----+-
| public.your.domain | %  | ... (all privileges set to 'N')
| %.your.domain      | %  | ... (all privileges set to 'Y')
+--------------------+----+-
</PRE>

<P>
<A NAME="IDX425"></A>
<A NAME="IDX426"></A>
<A NAME="IDX427"></A>
<A NAME="IDX428"></A>

</P>
<P>
権限のテーブル設定は、あなたの思い通りに許可が得られるのか、
常に(<CODE>mysqlaccess</CODE>等を使用して)チェックすべきです。

</P>



<H2><A NAME="Privilege_changes" HREF="manual.ja_toc.html#Privilege_changes">6.11  いつ権限の変更が反映されるか</A></H2>

<P>
<CODE>mysqld</CODE> の起動時、全ての許可テーブルはメモリーに読み込まれ、
この時点で有効になります。

</P>
<P>
<CODE>GRANT</CODE>, <CODE>REVOKE</CODE>, <CODE>SET PASSWORD</CODE> を使用して許可テーブルを
変更した場合、直にサーバに通知されます。

</P>
<P>
もし手動で許可テーブルを変更した場合(<CODE>INSERT</CODE>, <CODE>UPDATE</CODE> などで)、
<CODE>FLUSH PRIVILEGES</CODE> 構文か <CODE>mysqladmin flush-privileges</CODE> コマンド
か <CODE>mysqladmin reload</CODE> コマンドを実行して、
サーバーに許可テーブルの読み込みを指示しなければなりません。
そうしなければ、サーバーを再起動させるまで、変更は<EM>反映されません</EM>。
権限テーブルを手で変更して、権限のリロードを忘れた場合、変更が何も行なわれ
ないように見えるのがなぜかと不思議に思うでしょう！

</P>
<P>
サーバーが許可テーブルの変更を通知した場合、既に接続している
クライアントは、以下のような影響を受けます：

</P>

<UL>
<LI>

テーブルとフィールドの許可の変更は、次のクライアントの要求から反映されます。

<LI>

データベースに対する許可の変更は次の <CODE>USE db_name</CODE> コマンド以降から
有効になります。

</UL>

<P>
グローバル権限とパスワードの変更は、次のクライアントの接続時から反映されます。

</P>

<P>
<A NAME="IDX429"></A>
<A NAME="IDX430"></A>
<A NAME="IDX431"></A>
<A NAME="IDX432"></A>
<A NAME="IDX433"></A>
<A NAME="IDX434"></A>
<A NAME="IDX435"></A>


<H2><A NAME="Default_privileges" HREF="manual.ja_toc.html#Default_privileges">6.12  MySQL 権限許可の初期設定</A></H2>

<P>
<STRONG>MySQL</STRONG> インストール後、<CODE>scripts/mysql_install_db</CODE> を実行して権限のアクセス許可を初期化します。
 「<A HREF="manual.ja_Installing.html#Quick_install">4.7.1  素早いインストールの概要</A>」節参照.
<CODE>mysql_install_db</CODE> スクリプトは <CODE>mysqld</CODE> サーバーを起動し、
以下のように権限を初期化してテーブルに登録します：

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーはスーパーユーザーとして登録され、
全ての操作ができます。
localhostからしか接続できません。

<STRONG>注意:</STRONG>
<CODE>root</CODE> のパスワードの初期値は空です。
全ての人が <EM>パスワードなしで</EM> <CODE>root</CODE> になれ、全ての権限許可を得ることができます。

<LI>

<A NAME="IDX436"></A>
<CODE>'test'</CODE> あるいは <CODE>'test_'</CODE> で名前がはじまっているデータベースに対して、
匿名ユーザーでもなんでもできるように許可が与えられます。
これは ローカルホストからの全てのユーザーは パスワード無しで接続ができ、
匿名ユーザーとして扱われるということです。

<LI>

その他の要求は拒否されます。例えば、一般ユーザーは <CODE>mysqladmin shutdown</CODE> や <CODE>mysqladmin processlist</CODE> を実行できません。
</UL>

<P>
<STRONG>注意:</STRONG> デフォルトの権限は Windows では違います。
 「<A HREF="manual.ja_Installing.html#Windows_running">4.13.4  Windows 上で <STRONG>MySQL</STRONG> を実行</A>」節参照.

</P>
<P>
初期インストールの状態ではかなりアクセスが解放されているので、
インストール後最初にすることは、<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーにパスワードを設定することです。
以下のようにします(パスワードは <CODE>PASSWORD()</CODE> 関数を使用することをお忘れなく)：

</P>

<PRE>
shell&#62; mysql -u root mysql
mysql&#62; UPDATE user SET Password=PASSWORD('new_password')
           WHERE user='root';
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
<STRONG>MySQL</STRONG> バージョン 3.22 以上では、<CODE>SET PASSWORD</CODE> 構文も使用できます:

</P>

<PRE>
shell&#62; mysql -u root mysql
mysql&#62; SET PASSWORD FOR root=PASSWORD('new_password');
</PRE>

<P>
password をセットする他の方法として、<CODE>mysqladmin</CODE> コマンドも使用できます：

</P>

<PRE>
shell&#62; mysqladmin -u root password new_password
</PRE>

<P>
mysql データベースに書き込み／更新アクセスのあるユーザだけが他のユーザのパ
スワードを変更できます。すべての通常のユーザ(匿名ユーザ以外)は、上記のコマ
ンドか、または <CODE>SET PASSWORD=PASSWORD('new password')</CODE> で、自分のパス
ワードだけを変更できます。

</P>
<P>
もし最初の方法で <CODE>user</CODE> テーブルのパスワードを直接更新したなら、
サーバーに許可テーブルの再読み込みを行わせなければなりません(<CODE>FLUSH PRIVILEGES</CODE> を使用して)。

</P>
<P>
一度 <CODE>root</CODE> のパスワードを設定したなら、<CODE>root</CODE> でサーバーに接続する場合は
常にパスワードを与えなければなりません。

</P>
<P>
追加設定やテストをしているためパスワードを入れたくない場合、
<CODE>root</CODE> パスワードをブランクのままにしておこうと考えるかも知れませんが、
実稼働させる前には必ず設定してください。

</P>
<P>
どのようにデフォルトの権限を設定しているか、<CODE>scripts/mysql_install_db</CODE> 見てみてください。
これは他のユーザーを設定するときに使えるでしょう。

</P>
<P>
もし権限の初期状態を違うものにして初期化したいなら、
<CODE>mysql_install_db</CODE> を実行する前に編集してもよいでしょう。

</P>
<P>
<A NAME="IDX437"></A>
<A NAME="IDX438"></A>
もしテーブルを完全に作り直したいなら、<CODE>mysql</CODE> データベースのディレクトリに存在する
全ての <TT>`*.frm'</TT>, <TT>`*.MYI'</TT>, <TT>`*.MYD'</TT> ファイルを削除します。
(このディレクトリーはデータベースディレクトリーの下に <CODE>mysql</CODE> という名前で存在します。
<CODE>mysqld --help</CODE> とすればデータベースのディレクトリーが表示されます。)
そして好みの許可状態に <CODE>mysql_install_db</CODE> を編集してから実行します。

</P>
<P>
<STRONG>注意:</STRONG> <STRONG>MySQL</STRONG> 3.22.10 以前のバージョンでは, 
<TT>`*.frm'</TT> ファイルを消してはいけません.  もしうっかり消してしまった場合、
<CODE>mysql_install_db</CODE> を実行する前に、 <STRONG>MySQL</STRONG> 配布からコピーしなおさ
なくてはなりません。

</P>

<P>
<A NAME="IDX439"></A>
<A NAME="IDX440"></A>
<A NAME="IDX441"></A>
<A NAME="IDX442"></A>
<A NAME="IDX443"></A>


<H2><A NAME="Adding_users" HREF="manual.ja_toc.html#Adding_users">6.13  新しいユーザ権限を MySQL へ追加</A></H2>

<P>
ユーザーは２つの違った方法で追加できます：
<CODE>GRANT</CODE> 構文を使用して行う方法と、
<STRONG>MySQL</STRONG> の許可テーブルを直接操作する方法とです。
<CODE>GRANT</CODE> 構文の使用をお勧めします。

</P>
<P>
以下の例では、いかにして <CODE>mysql</CODE> クライアントを使用して新規にユーザーを登録するかを示します。
以下の例では、権限は前節で述べたデフォルト値になっているとします。
よって変更を行うためには、あなたは <CODE>mysqld</CODE> が走っているマシン上にログインしていなくてはなりませんし、
かつ、<STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーで接続していなければなりません。
さらに <STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザーには
 <CODE>mysql</CODE> データベースに対して <STRONG>insert</STRONG> 権限を持ち、
<STRONG>reload</STRONG> のアドミニストレーター権限を持っていなければなりません。
もし <CODE>root</CODE> ユーザーのパスワードを変えていたならば、
 <CODE>mysql</CODE> コマンドにパスワード指定を与えなくてはなりません。

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; GRANT ALL PRIVILEGES ON *.* TO monty@localhost
           IDENTIFIED BY 'some_pass' WITH GRANT OPTION;
mysql&#62; GRANT ALL PRIVILEGES ON *.* TO monty@"%"
           IDENTIFIED BY 'some_pass' WITH GRANT OPTION;
mysql&#62; GRANT RELOAD,PROCESS ON *.* TO admin@localhost;
mysql&#62; GRANT USAGE ON *.* TO dummy@localhost;
</PRE>

<P>
これら <CODE>GRANT</CODE> 構文では3つの新しいユーザを作ります:

</P>
<DL COMPACT>

<DT><CODE>monty</CODE>
<DD>
どこからでもサーバーに接続できる完全なスーパーユーザ。
しかし、<STRONG>MySQL</STRONG> を使用する時にはパスワード <CODE>'some_pass'</CODE> を
使用する必要があります。
<CODE>monty@localhost</CODE> と <CODE>monty@"%"</CODE> の両方に <CODE>GRANT</CODE> 構文を
発行しなくてはならない事に注意してください。
もし <CODE>localhost</CODE> からの許可をした登録がないと、<CODE>localhost</CODE> から接続した時、
<CODE>mysql_install_db</CODE> が自動で作成した <CODE>localhost</CODE> への匿名ユーザーが優先されます。
なぜなら、 <CODE>Host</CODE> フィールドの値が(ブランクやワールドカード以外に)明記されており、
許可登録が MySQL 内部でソートされる時に順番が上にソートされるからです。

<DT><CODE>admin</CODE>
<DD>
<CODE>localhost</CODE> からパスワードなしで接続できますが、<CODE>reload</CODE>, <CODE>process</CODE> の使用だけが許されます。
これは、<CODE>mysqladmin reload</CODE>, <CODE>mysqladmin refresh</CODE>, <CODE>mysqladmin flush-*</CODE> そして
 <CODE>mysqladmin processlist</CODE> コマンドの実行がこのユーザーに許可されます。
データベースへのアクセスは許可されていません。
しかしこれは後でテーブル <CODE>GRANT</CODE> 構文を発行すれば、
個々のデータベースへのアクセス権限が設定できます。

<DT><CODE>dummy</CODE>
<DD>
パスワードなしで localhost からのみ、接続できるユーザー。
グローバルな権限は全て <CODE>'N'</CODE> に設定されます。
<CODE>USAGE</CODE> 権限は権限無しユーザーの設定を許可する事になります。
これは、特定データーベースに対しての許可を後から与える事を想定しています。
</DL>

<P>
<A NAME="IDX444"></A>
<A NAME="IDX445"></A>
同じアクセス許可を <CODE>INSERT</CODE> 構文を使用して直接設定できます。
サーバーに許可テーブルの再読み込みを指示します：

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; INSERT INTO user VALUES('localhost','monty',PASSWORD('some_pass'),
                'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO user VALUES('%','monty',PASSWORD('some_pass'),
                'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO user SET Host='localhost',User='admin',
                 Reload_priv='Y', Process_priv='Y';
mysql&#62; INSERT INTO user (Host,User,Password)
                        VALUES('localhost','dummy','');
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
<STRONG>MySQL</STRONG> のバージョンにより、上の <CODE>'Y'</CODE> の数が違う事に注意してください。
(3.22.11 以前のバージョンでは項目数が少なくなります).
<CODE>admin</CODE> ユーザーを登録で使用している <CODE>INSERT</CODE> の拡張は
バージョン 3.22.11 以上で可能です。

</P>
<P>
スーパーユーザーを定義するためには、<CODE>user</CODE> テーブルの許可フィールドを
<CODE>'Y'</CODE> にするだけでかまいません。
<CODE>db</CODE> や <CODE>host</CODE> テーブルに登録は必要無いのです。

</P>
<P>
<CODE>user</CODE> テーブルの許可フィールドは最後の <CODE>INSERT</CODE> 文で(<CODE>dummy</CODE> ユーザーのために)
は設定されていません。これらのフィールドはデフォルト値の <CODE>'N'</CODE> になります。
これは <CODE>GRANT USAGE</CODE> が行うのと同じものです。

</P>
<P>
以下は、<CODE>localhost</CODE>, <CODE>server.domain</CODE>, <CODE>whitehouse.gov</CODE> から接続が可能な
 <CODE>custom</CODE> ユーザーの追加例です。
 <CODE>custom</CODE> ユーザーは <CODE>bankaccount</CODE> データーベースには <CODE>localhost</CODE> からの接続のみを許可され、
<CODE>expenses</CODE> データベースには <CODE>whitehouse.gov</CODE> からのみ接続が許可され、
<CODE>customer</CODE> データベースには全てのホストから接続できます。
<CODE>custom</CODE> ユーザーは、 <CODE>stupid</CODE> というパスワードを全てのホストで使用したいとします。

</P>
<P>
このユーザーの許可を <CODE>GRANT</CODE> 構文で定義するには、以下のようにします：

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON bankaccount.*
           TO custom@localhost
           IDENTIFIED BY 'stupid';
mysql&#62; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON expenses.*
           TO custom@whitehouse.gov
           IDENTIFIED BY 'stupid';
mysql&#62; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON customer.*
           TO custom@'%'
           IDENTIFIED BY 'stupid';
</PRE>

<P>
許可テーブルを直接変更してこのユーザーの権限を設定するにはいかのようにします
(<CODE>FLUSH PRIVILEGES</CODE> を最後に実行している事に注意)：

</P>

<PRE>
shell&#62; mysql --user=root mysql
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('localhost','custom',PASSWORD('stupid'));
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('server.domain','custom',PASSWORD('stupid'));
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('whitehouse.gov','custom',PASSWORD('stupid'));
mysql&#62; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES
       ('localhost','bankaccount','custom','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES
       ('whitehouse.gov','expenses','custom','Y','Y','Y','Y','Y','Y');
mysql&#62; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES('%','customer','custom','Y','Y','Y','Y','Y','Y');
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
最初の３つの <CODE>INSERT</CODE> 文は、 <CODE>custom</CODE> ユーザーがそれぞれのホストから
パスワードつきで接続できるように <CODE>user</CODE> テーブルに追加しています。
しかしここでは権限は１つも与えられていません(権限のデフォルト値は <CODE>'N'</CODE> です)。
次の三つの <CODE>INSERT</CODE> 文は、<CODE>bankaccount</CODE>, <CODE>expenses</CODE>, <CODE>customer</CODE>
 データベースに対する該当ホストからのアクセス許可を <CODE>custom</CODE> ユーザーに与えるように、
<CODE>db</CODE> テーブルに追加しています。
許可テーブルが直接変更された場合、これらをサーバーに反映させるために、許可テーブルの
再読み込みを(<CODE>FLUSH PRIVILEGES</CODE>で) サーバーにつげなければなりません。

</P>
<P>
もし、あるドメインの全てのマシンに接続を許可したい場合、
以下のように <CODE>GRANT</CODE> 構文を発行します：

</P>

<PRE>
mysql&#62; GRANT ...
           ON *.*
           TO myusername@"%.mydomainname.com"
           IDENTIFIED BY 'mypassword';
</PRE>

<P>
許可テーブルを直接変更するには以下のようにします：

</P>

<PRE>
mysql&#62; INSERT INTO user VALUES ('%.mydomainname.com', 'myusername', 
           PASSWORD('mypassword'),...);
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
もちろん、<CODE>xmysqladmin</CODE>, <CODE>mysql_webadmin</CODE>, そして <CODE>xmysql</CODE> を使って
も、権限テーブルへの値の挿入/変更/更新ができます。これらのユーティリティは 
<a HREF="http://www.mysql.com/Downloads/Contrib/">Contrib directory of the <STRONG>MySQL</STRONG>
Website</a>.
に見つけることができます。

</P>

<P>
<A NAME="IDX446"></A>
<A NAME="IDX447"></A>
<A NAME="IDX448"></A>
<A NAME="IDX449"></A>


<H2><A NAME="Passwords" HREF="manual.ja_toc.html#Passwords">6.14  パスワードの設定法</A></H2>

<P>
多くの場合、ユーザ／パスワードを設定するために、<CODE>GRANT</CODE> を使用すべき
です。以下は上級ユーザのためにだけあてはまります。
 「<A HREF="manual.ja_Reference.html#GRANT">7.35  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照.

</P>
<P>
前節の例で述べた、とても重要な基本原則：

</P>
<P>
<CODE>INSERT</CODE> か <CODE>UPDATE</CODE> で空ではないパスワードを設定する場合、
暗号化するために <CODE>PASSWORD()</CODE> 関数を使用しなくてはなりません。
これは <CODE>user</CODE> テーブルはプレーンテキストでなく、暗号化されたパスワードであることを要求しているからです。
この原則を忘れてしまった場合、以下のようにしてパスワードをセットしてしまうかもしれません：

</P>

<PRE>
shell&#62; mysql -u root mysql
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('%','jeffrey','biscuit');
mysql&#62; FLUSH PRIVILEGES;
</PRE>

<P>
これは <CODE>user</CODE> テーブルにプレーンテキストの <CODE>'biscuit'</CODE> をパスワードとして登録してしまいます。
<CODE>jeffrey</CODE> ユーザーでこのパスワードを使用してサーバーに接続しようとすると、
 <CODE>mysql</CODE> クライアントは暗号化したパスワードをサーバーに送ります。
サーバーは暗号化されたパスワード(<CODE>'biscuit'</CODE> では<EM>ありません</EM>) と
 <CODE>user</CODE> テーブルに登録された値(<CODE>'biscuit'</CODE>) を比較します。
その結果、比較は失敗し、サーバーは接続を拒否します：

</P>

<PRE>
shell&#62; mysql -u jeffrey -pbiscuit test
Access denied
</PRE>

<P>
 <CODE>user</CODE> テーブルに登録されるパスワードは暗号化されたものでなくてはなりません。
<CODE>INSERT</CODE> 構文は以下のようにして使用しなくてはなりません：

</P>

<PRE>
mysql&#62; INSERT INTO user (Host,User,Password)
       VALUES('%','jeffrey',PASSWORD('biscuit'));
</PRE>

<P>
<CODE>SET PASSWORD</CODE> 構文を使用する場合は、以下のようにしなくてはなりません：

</P>

<PRE>
mysql&#62; SET PASSWORD FOR jeffrey@"%" = PASSWORD('biscuit');
</PRE>

<P>
もし <CODE>GRANT ... IDENTIFIED BY</CODE> 構文や <CODE>mysqladmin password</CODE> コマンド
でパスワードを設定した場合、<CODE>PASSWORD()</CODE> 関数は必要ありません。
両方とも、パスワードを暗号化してくれますので、
以下のように<CODE>'biscuit'</CODE>と与えます：

</P>

<PRE>
mysql&#62; GRANT USAGE ON *.* TO jeffrey@"%" IDENTIFIED BY 'biscuit';

shell&#62; mysqladmin -u jeffrey password biscuit
</PRE>

<P>
<STRONG>注意</STRONG>： <CODE>PASSWORD()</CODE> がパスワードを暗号化することに注意してください。
この暗号化は UNIX のパスワードで使用されている暗号化と違うことにも留意してください。
UNIX パスワードファイルに記録されている暗号と <CODE>PASSWORD()</CODE> が暗号化した物が同じでも、
同じパスワードであるとは思わないでください。
 「<A HREF="manual.ja_Privilege_system.html#User_names">6.5  MySQL ユーザ名とパスワード</A>」節参照.

</P>


<H2><A NAME="Access_denied" HREF="manual.ja_toc.html#Access_denied">6.15  何故 <CODE>Access denied</CODE> エラーになるのか</A></H2>

<P>
もし、<STRONG>MySQL</STRONG> サーバーに接続しようとして <CODE>Access denied</CODE> エラーに
遭遇してしまったら、以下に記すことが問題の解決のための指標となるでしょう:

</P>

<UL>
<LI>

<STRONG>MySQL</STRONG> をインストールした後に、スクリプト <CODE>mysql_install_db</CODE> を実行して
許可テーブルを初期化しましたか？
していなければ実行してください。 「<A HREF="manual.ja_Privilege_system.html#Default_privileges">6.12  MySQL 権限許可の初期設定</A>」節参照
権限許可のテーブルが初期化されているかを試すには以下のようにします：


<PRE>
shell&#62; mysql -u root test
</PRE>

これは普通はエラーなしで接続できます。
<STRONG>MySQL</STRONG> データベースディレクトリ内に <TT>`user.MYD'</TT> ファイルがあるかどうかでもチェックします。
(普通は <TT>`PATH/var/mysql/user.MYD'</TT> です。ここで <CODE>PATH</CODE> は <STRONG>MySQL</STRONG> をインストールしたディレクトリーパスを示します。)

<LI>

初めてインストールした後は、以下のようにしてサーバーに接続してユーザーとアクセス権を設定しなくてはなりません：


<PRE>
shell&#62; mysql -u root mysql
</PRE>

初期状態では、<STRONG>MySQL</STRONG> に <CODE>root</CODE> ユーザーをパスワードなしで登録しているので、
問題なく接続できるはずです。
しかしこれはセキュリティ上危険な状態なので、
他の <STRONG>MySQL</STRONG> ユーザーを登録している時に、
<CODE>root</CODE> のパスワードを設定しておいてください。

もし <CODE>root</CODE> で接続しようとして以下のエラーが出た場合：


<PRE>
Access denied for user: '@unknown' to database mysql
</PRE>

これは <CODE>user</CODE> テーブルに、 <CODE>User</CODE> フィールド = <CODE>root</CODE> かつ
<CODE>mysqld</CODE> がリゾルブできなかったホスト名で、クライアントが登録されていないからです。
この場合、 <TT>`/etc/hosts'</TT> ファイルあるいは <TT>`\windows\hosts'</TT> ファイルを編集して
ホスト名を追加し、<CODE>--skip-grant-tables</CODE> オプションでサーバーをリスタートします。

<LI>

次のようなエラーが出た場合:


<PRE>
shell&#62; mysqladmin -u root -pxxxx ver
Access denied for user: 'root@localhost' (Using password: YES)
</PRE>

これは間違ったパスワードを使用したことを意味します。 「<A HREF="manual.ja_Privilege_system.html#Passwords">6.14  パスワードの設定法</A>」節参照.

root のパスワードを忘れた場合、<CODE>mysqld</CODE> を 
<CODE>--skip-grant-tables</CODE> で再起動して、パスワードを変更することができま
す。このオプションについての詳細は、マニュアルのこの節の後ろに見つけること
ができます。

パスワードを指定してないのに、上のエラーがでた場合は、<CODE>my.ini</CODE> ファイ
ルに間違ったパスワードがあることを意味します。 「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照. このオ
プションファイルは、次のように <CODE>--no-defaults</CODE> オプションで回避できま
す:


<PRE>
shell&#62; mysqladmin --no-defaults -u root ver
</PRE>

<LI>

<A NAME="IDX450"></A>
もしバージョン 3.22.11 より前の <STRONG>MySQL</STRONG> から
バージョン 3.22.11 以上にバージョンアップしたなら、
<CODE>mysql_fix_privilege_tables</CODE> スクリプトを実行しましたか？
実行していないなら、このエラーになります。
許可テーブルの構造が <STRONG>MySQL</STRONG> バージョン 3.22.11 から変更され、
<CODE>GRANT</CODE> 構文が機能しています。

<LI>

もしあなたの権限がセッションの途中で変更されたように思ったなら、それは
スーパーユーザーが権限を変えたのかも知れません。許可テーブルの再読み込みは
新しいクライアントの接続から反映されますが、すでに接続している場合でも
 「<A HREF="manual.ja_Privilege_system.html#Privilege_changes">6.11  いつ権限の変更が反映されるか</A>」節. に示す条件下では影響を受けます。

<LI>

もしあなたのパスワードが働かないのであれば、
<CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, <CODE>SET PASSWORD</CODE> 構文でパスワードを設定するとき
 <CODE>PASSWORD()</CODE> 関数を使用しなければならないことを思い出してください。
しかし <CODE>PASSWORD()</CODE> 関数は、<CODE>GRANT ... INDENTIFIED BY</CODE> 構文や
<CODE>mysqladmin password</CODE> コマンドでは不要です。
 「<A HREF="manual.ja_Privilege_system.html#Passwords">6.14  パスワードの設定法</A>」節参照.

<LI>

<CODE>localhost</CODE> はローカルのホスト名です。
もしクライアントがホストを指定せずに接続してきた場合、<CODE>localhost</CODE> がデフォルトで使用されます。
しかし、 MIT-pthreads を使用している場合、<CODE>localhost</CODE> への接続は失敗します。
(<CODE>localhost</CODE> への接続は、UNIXソケットを使用しますが、 MIT-pthreads が ソケット接続をサポートしていないためです。)
この問題が起きるシステムでは、サーバー名を指定するために <CODE>--host</CODE> オプションを使用すべきです。
これは TCP/IP 接続を使用して <CODE>mysqld</CODE> サーバーに接続します。
この場合、<CODE>user</CODE> テーブルに、サーバーの実ホスト名を登録しておかなくてはなりません。
(これはクライアントプログラムをサーバーと同じホスト上で動かしている場合真となります)
例えば、<CODE>Using password: NO</CODE> を含むエラーメッセージを得た場合、これは
パスワードなしでログインしようとしたことを意味します。

<LI>

<CODE>mysql -u user_name db_name</CODE> を使用してデータベースに接続しているときに
 <CODE>Access denied</CODE> エラーが発生した場合、<CODE>user</CODE> テーブルの設定違いが考えられます。
<CODE>mysql -u root mysql</CODE> を実行し、以下の SQL 文を試してください：


<PRE>
mysql&#62; SELECT * FROM user;
</PRE>

<CODE>Host</CODE> と <CODE>User</CODE> にあなたのコンピュータ名と <STRONG>MySQL</STRONG> ユーザー名にマッチする登録がなされていなければなりません。

<LI>

<CODE>Access denied</CODE> エラーは、どのユーザーで接続してきたか、どのホストから接続しようとしているか、パスワードを使用しているのかをメッセージに出力します。
通常、エラーになっているホスト名とユーザー名がマッチするエントリが <CODE>user</CODE> テーブルに一つはなければなりません。

<LI>

他のホストから <STRONG>MySQL</STRONG> サーバーに接続を試みた時に以下のエラーが出た場合、
<CODE>user</CODE> テーブルにあなたがアクセスしているホストにマッチする行がありません：


<PRE>
Host ... is not allowed to connect to this MySQL server
</PRE>

<CODE>mysql</CODE> コマンドをサーバーのホスト上で使用して、
<CODE>user</CODE>, <CODE>db</CODE>, <CODE>host</CODE> テーブルに接続しようとしている
ユーザー名／ホスト名 を加えて、<CODE>mysqladmin flush-privileges</CODE> を
実行すれば解決できるでしょう。
もしサーバーが <STRONG>MySQL</STRONG> バージョン 3.22 ではなく、接続しようとしている
ホストの IP もホスト名もわからない場合、
<CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドに <CODE>'%'</CODE> を設定し、
<CODE>mysqld</CODE> を <CODE>--log</CODE> オプションで再起動してください。
そしてクライアントホストから接続すれば、<STRONG>MySQL</STRONG> のログファイルに
そのホストの情報が記録されているはずです。
それがわかれば、先に設定した <CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドの <CODE>'%'</CODE> を
ログに記録されたホスト名に置き換えます。(しかしこれはシステムを危険にさらします)

Linux 上でこのエラーの他の原因は、あなたの使用しているのと異なる glibc バー
ジョンでコンパイルされた、バイナリ <STRONG>MySQL</STRONG> バージョンを使用している
ことを意味します。この場合、あなたの OS/glibc をアップグレードするか、ソー
ス <STRONG>MySQL</STRONG> バージョンをダウンロードしてコンパイルすべきです。ソース 
RPM は、通常コンパイルとインストールは簡単なので、これは大きな問題ではあり
ません。

<LI>

ホスト名で接続しようとしたのに、ホスト名が現れないか、ホスト名が IP でエラー
メッセージが出る場合:


<PRE>
shell&#62; mysqladmin -u root -pxxxx -h some-hostname ver
Access denied for user: 'root' (Using password: YES)
</PRE>

これは <STRONG>MySQL</STRONG> が IP をホスト名に解決しようとした時に何かエラーを得
たことを意味します。この場合、<CODE>mysqladmin flush-hosts</CODE> を実行して、内
部の DNS キャッシュをリセットできます。 「<A HREF="manual.ja_Performance.html#DNS">13.2.10  How MySQL uses DNS</A>」節参照.

いくつかの永久的な解決策は:


<UL>
<LI>

DNS サーバで何が間違っているのかを見つけ出し、それを修正する。
<LI>

<STRONG>MySQL</STRONG> 権限テーブル中に、ホスト名の代わりに IP を記述する。
<LI>

<CODE>--skip-name-resolve</CODE> で mysqld を起動する。
<LI>

<CODE>--skip-host-cache</CODE> で mysqld を起動する。
<LI>

同じマシン上でサーバとクライアントを起動している場合、<CODE>localhost</CODE> に
接続する。
<LI>

<CODE>/etc/hosts</CODE> にクライアントマシン名を置く。
</UL>

<LI>

<CODE>mysql -u root test</CODE> は動いたものの <CODE>mysql -h your_hostname -u root test</CODE> が
 <CODE>Access denied</CODE> を返した場合、
<CODE>user</CODE> テーブルに正しいホスト名が使用されていないと思われます。
<CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドにホスト名を確定できる形で指定していないか、
使用しているシステムのリゾルブが FQDN (or vice-versa) を返しているかだと思われます。
例えば、<CODE>user</CODE> テーブルに <CODE>'tcx'</CODE> ホストの定義があったとして、
DNS が <STRONG>MySQL</STRONG> に <CODE>'tcx.subnet.se'</CODE> をホスト名として返した場合、
これは動きません。
<CODE>user</CODE> テーブルの <CODE>Host</CODE> フィールドの値に、あなたのホストの IP 番号を加えてください。
(<CODE>user</CODE> テーブルの <CODE>Host</CODE> の値にワイルドカードを使用することができます。<CODE>'tcx.%'</CODE> のように。
しかしホスト名の値を <SAMP>`%'</SAMP> 文字で終わらせる設定は、<EM>安全ではなく</EM>、<EM>推奨されません</EM>)

<LI>

もし <CODE>mysql -u user_name test</CODE> が動作し <CODE>mysql -u user_name other_db_name</CODE> が
動作しない場合は、<CODE>db</CODE> テーブルに <CODE>other_db_name</CODE> のエントリが
登録されていません。

<LI>

<CODE>mysql -u user_name db_name</CODE> はザーバー上では動作するが、
<CODE>mysql -u host_name -u user_name db_name</CODE> がクライアントホスト上で動作しない場合、
<CODE>user</CODE> テーブルか <CODE>db</CODE> テーブルにクライアントホストの名前が登録されていません。

<LI>

<CODE>Access denied</CODE> の原因がもし上記に当てはまらない場合は、
<CODE>user</CODE> テーブルから <CODE>Host</CODE> にワイルドカードを使用しているエントリを全て消去してみてください。(<SAMP>`%'</SAMP> や <SAMP>`_'</SAMP> を含む値です)
よくある間違いは、<CODE>localhost</CODE> に対して <CODE>localhost</CODE> と同じマシン上から
の接続を許可すると考えて
<CODE>Host</CODE>=<CODE>'%'</CODE> と <CODE>User</CODE>=<CODE>'some user'</CODE> を登録することです。
これは動きません。なぜなら、デフォルトの権限に
<CODE>Host</CODE>=<CODE>'localhost'</CODE> と <CODE>User</CODE>=<CODE>''</CODE> が含まれているからです。
<CODE>Host</CODE> の値が <CODE>'localhost'</CODE> の場合、これは <CODE>'%'</CODE> よりも
具体的に指定されているので、<CODE>localhost</CODE> からの接続にはこちらの方が
使用されるのです！ 正しい指定の仕方は、二番目の登録として
<CODE>Host</CODE>=<CODE>'localhost'</CODE> と <CODE>User</CODE>=<CODE>'some_user'</CODE> を追加するか、
あるいは、<CODE>Host</CODE>=<CODE>'localhost'</CODE> と <CODE>User</CODE>=<CODE>''</CODE> を削除することです。

<LI>

もし以下のエラーが出た場合
<CODE>db</CODE> か <CODE>host</CODE> テーブルに問題があるのかもしれません。：


<PRE>
Access to database denied
</PRE>

もし <CODE>db</CODE> テーブルに <CODE>Host</CODE> フィールドが空の登録がある場合には、
<CODE>host</CODE> テーブル中に、<CODE>db</CODE> テーブルに登録されている
ホストを明記した物が一つ以上あるかどうかを確認してください。

もし <CODE>SELECT ... INTO OUTFILE</CODE> や <CODE>LOAD DATA INFILE</CODE> SQL 文を
使用している時にこのエラーが出る場合、
<CODE>user</CODE> テーブルのあなたの登録に <STRONG>file</STRONG> 権限が
許可されていないと思われます。

<LI>

<A NAME="IDX451"></A>
<A NAME="IDX452"></A>
<A NAME="IDX453"></A>
クライアントプログラムは接続に際して、
設定ファイルで設定された値か環境変数の値を使用することに注意してください。
もしクライアントプログラムが誤った値を接続に使用しているようなら、
環境変数とホームディレクトリにある <TT>`.my.cnf'</TT> ファイルを確認してください。
もちろんシステムワイドの <STRONG>MySQL</STRONG> 設定ファイルも、パラメターが記述されていないか、
チェックしてみてください。 「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照.
もしクライアントをオプションなしで起動していて <CODE>Access denied</CODE> がでるなら、
オプションファイルに古いパスワードが書かれているか確認してください。
 「<A HREF="manual.ja_Installing.html#Option_files">4.16.5  オプションファイル ( <CODE>my.cnf</CODE> )</A>」節参照.

<LI>

権限テーブルを(<CODE>INSERT</CODE> または <CODE>UPDATE</CODE> ステートメントを使用して
)直接変更する場合、あなたの変更は無視されたように見えます。サーバに権限テー
ブルを再読み込みさせるために、<CODE>FLUSH PRIVILEGES</CODE> ステートメントの発行
か、<CODE>mysqladmin flush-privileges</CODE> コマンドの実行の必要があることを忘
れないでください。そうでないと、あなたの変更は次回のサーバ再起動まで効果が
ありません。<CODE>UPDATE</CODE> コマンドで <CODE>root</CODE> パスワードを設定後、権限
をフラッシュするまでそれを指定する必要がありません。サーバはまだパスワード
を変更したことを知らないからです！

<LI>

Perl, PHP, Python, ODBC プログラムでアクセスの問題があった場合、
<CODE>mysql -u user_name db_name</CODE> または <CODE>mysql -u user_name
-pyour_pass db_name</CODE> でサーバへの接続を試してください。<CODE>mysql</CODE> クライ
アントを使用して接続できれば、アクセス権でなく、あなたのプログラムに問題が
あります。(<CODE>-p</CODE> とパスワードの間に空白がないことに注意してください; 
パスワードを指定するのに、<CODE>--password=your_pass</CODE> 構文も使用できます。
単に <CODE>-p</CODE> オプションを使用すると、<STRONG>MySQL</STRONG> はパスワードの入力を
求めます。)

<LI>

テストのために、<CODE>mysqld</CODE> デーモンを <CODE>--skip-grant-tables</CODE> オプショ
ン付きで開始してください。<STRONG>MySQL</STRONG> 権限テーブルを変更し、あなたの変
更が望む効果があるかどうかのチェックに、<CODE>mysqlaccess</CODE> スクリプトを使
用できます。あなたの変更が満足できた時に、<CODE>mysqladmin
flush-privileges</CODE> を実行し、<CODE>mysqld</CODE> サーバに新しい権限テーブルを使用
して開始するように伝えてください。<STRONG>注意:</STRONG> 権限テーブルのリロードは 
<CODE>--skip-grant-tables</CODE> オプションを上書きします。これは、サーバを落と
して再起動することなしに、権限テーブルの使用を始めるようにサーバに伝えるこ
とができます。

<LI>

もし全て失敗するなら、<CODE>mysqld</CODE> デーモンをデバッグオプションで起動してください。
例えば、<CODE>--debug=d,general,query</CODE>。これはコネクションに試みたホストやユーザーの情報、
また実行したコマンドを表示します。  「<A HREF="manual.ja_Porting.html#Debugging_server">I.1  MySQL server のデバッグ</A>」節参照.

<LI>

もし <STRONG>MySQL</STRONG> の権限許可についてその他の問題が起こり、
メーリング・リストに問題をポストしなくてはいけないと感じれば、
いつも <STRONG>MySQL</STRONG> 許可テーブルのダンプを提供して下さい。
<CODE>mysqldump mysql</CODE> コマンドでダンプできます。
いつものように、 <CODE>mysqlbug</CODE> スクリプトでポストしてください。 「<A HREF="manual.ja_Questions.html#Bug_reports">2.3  バグや問題を報告する方法</A>」節参照. 
ときにはは、 <CODE>mysqldump</CODE> を実行するために、
<CODE>mysqld</CODE> を <CODE>--skip-grant-tables</CODE> オプションで実行しないと
いけないかもしれません。
</UL>

<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Compatibility.html">previous</A>, <A HREF="manual.ja_Reference.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
