  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 20 July 2001 -->

  <TITLE>MySQL Reference Manual for version 3.23.38. - 9  MySQL チュートリアル</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Table_types.html">previous</A>, <A HREF="manual.ja_Server.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Tutorial" HREF="manual.ja_toc.html#Tutorial">9  MySQL チュートリアル</A></H1>

<P>
この章では、 <CODE>mysql</CODE> クライアントプログラムの使用の仕方と
単純なデータベースの作成と使用の仕方を例題としてとり上げます。
<CODE>mysql</CODE> (``terminal monitor'' や ``monitor'' として参照されます)は
<STRONG>MySQL</STRONG> サーバーに接続できる対話モードのプログラムで、
クエリの実行や結果の表示が可能です。
<CODE>mysql</CODE> はバッチモードも可能です： クエリをまずファイルに書いておき、
そしてそのファイルを <CODE>mysql</CODE> に実行させます。
どちらの方法でも <CODE>mysql</CODE> はこの章の説明でカバーされます。

</P>
<P>
<CODE>mysql</CODE> の提供するオプションを見るには、 <CODE>--help</CODE> オプションを
実行します：

</P>

<PRE>
shell&#62; mysql --help
</PRE>

<P>
この章では <CODE>mysql</CODE> が既にあなたのマシンにインストールされているものとし、
また <STRONG>MySQL</STRONG> サーバーに接続可能であるとします。 もしそうでないなら、
あなたの <STRONG>MySQL</STRONG> 管理者に連絡を取ってください。
(もし<EM>あなた自身が</EM>管理者なら、このマニュアルの他のセクションを参照してください。)

</P>
<P>
本章ではデータベース設定の全体のプロセス、データベースの使用について述べます。
もしあなたが既に存在しているデータベースにアクセスする事だけに興味があるなら、
この章のデータベース、テーブルの作成方法の説明を読み飛ばしてもかまいません。

</P>
<P>
この章が本質的にはチュートリアルであるので、多くの詳細は、かならず違う章にあります。
ここに書かれている事柄で、
さらに詳しい情報についてはマニュアルの適切なセクションを調べて下さい。 

</P>
<P>
<A NAME="IDX1056"></A>
<A NAME="IDX1057"></A>
<A NAME="IDX1058"></A>
<A NAME="IDX1059"></A>


<H2><A NAME="Connecting-disconnecting" HREF="manual.ja_toc.html#Connecting-disconnecting">9.1  サーバーへの接続と切断</A></H2>

<P>
サーバーに <CODE>mysql</CODE> コマンドから接続するためには、通常、
<STRONG>MySQL</STRONG> ユーザ名、パスワードを指定する必要があるでしょう。
もしあなたがログインしている以外のマシンの上でサーバーが走っていれば、
あなたは、ホスト名を明示する必要があるでしょう。
まずあなたの管理者に問い合わせて、あなたが使うべき接続のためのパラメーターを見つけ出して下さい。
(すなわち、どのようなホスト、ユーザー名とパスワードを使うべきなのか。)
適切なパラメーターを知っていれば、あなたは、以下のようにして接続できます：

</P>

<PRE>
shell&#62; mysql -h host -u user -p
Enter password: ********
</PRE>

<P>
<CODE>********</CODE> とかかれている部分にはあなたのパスワードを入れます；
<CODE>mysql</CODE> が <CODE>Enter password:</CODE> プロンプトを出したときに。

</P>
<P>
きちんと動けば、いくつかの情報と <CODE>mysql&#62;</CODE> プロンプトが現れます：

</P>

<PRE>
shell&#62; mysql -h host -u user -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 459 to server version: 3.22.20a-log

Type 'help' for help.

mysql&#62;
</PRE>

<P>
このプロンプトは <CODE>mysql</CODE> がコマンド入力を待っている状態を示します。

</P>
<P>
いくつかの <STRONG>MySQL</STRONG> インストレーションでは、ローカルホストで
実行されているサーバーに、ユーザーに``匿名''(名前無し)の接続を許しています。
もしあなたのマシンがこの場合に当てはまるなら、<CODE>mysql</CODE> をオプション無しで
起動すべきです：

</P>

<PRE>
shell&#62; mysql
</PRE>

<P>
接続が成功した後、 <CODE>mysql&#62;</CODE> プロンプトで、<CODE>QUIT</CODE> とタイプすれば
いつでも接続を切ることができます：

</P>

<PRE>
mysql&#62; QUIT
Bye
</PRE>

<P>
Control-D で切断してもかまいません。

</P>
<P>
以下のセクションでのほとんどの例では、あなたがサーバーに接続しているものと
しています。その場合は <CODE>mysql&#62;</CODE> プロンプトによって、それを示しています。

</P>
<P>
<A NAME="IDX1060"></A>
<A NAME="IDX1061"></A>
<A NAME="IDX1062"></A>


<H2><A NAME="Entering_queries" HREF="manual.ja_toc.html#Entering_queries">9.2  クエリの入力</A></H2>

<P>
前のセクションで述べたように、あなたがサーバーとつながっていることを確かめて下さい。
この状態ではまだどんなデータベースも選択していない状態です。しかしそれはかまいません。
ここでは、テーブルの作成やデータの入力、取り出しよりも、
いかにクエリを発行するかに重点を置きます。
このセクションでは、あなた自身を <CODE>mysql</CODE> の動きに慣れさせるために、
あなたがやってみることができるであろう、いくつかのクエリを使用して、
コマンド入力の基本的な原則を述べます。

</P>
<P>
サーバーのバージョン、今日の日付をサーバーに問い合わせる、単純なコマンド
がここにあります。 以下のように <CODE>mysql&#62;</CODE> プロンプトの後に入力し
 RETURN キーを押してみてください：

</P>

<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
+--------------+--------------+
| version()    | CURRENT_DATE |
+--------------+--------------+
| 3.22.20a-log | 1999-03-19   |
+--------------+--------------+
1 row in set (0.01 sec)
mysql&#62;
</PRE>

<P>
このクエリは、<CODE>mysql</CODE> のいくつかの事を説明しています：

</P>

<UL>
<LI>

通常、コマンドは、セミコロンで終わる SQL ステートメントから、構成されます。
(セミコロンが必要とされないいくつかの例外があります。
以前に述べた <CODE>QUIT</CODE> はそのうちの一つです。後で他も出てきます。)

<LI>

コマンドを発行すると、<CODE>mysql</CODE> はそれをサーバーに送り、結果を表示します。
その後、 <CODE>mysql&#62;</CODE> プロンプトを出し、他のコマンドが受け付けれる状態であると
示します。

<LI>

<CODE>mysql</CODE> はクエリの結果を表にして出します。 最初の行は項目のラベル名です。
その下の行に、クエリの結果が続きます。 通常、項目のラベル名はデータベースのテーブルから
あなたが取り出したフィールド名になります。 テーブルのフィールド名以外の式を
あなたが検索したのなら(ちょうど例のように)、<CODE>mysql</CODE> は与えられた式自身を
項目のラベル名として表示します。

<LI>

<CODE>mysql</CODE> は何レコード(rows)返ってきたかを示し、実行にどれくらいの時間が
かかったかも示します。 これはおおざっぱなサーバーのパフォーマンスを示します。
これらの値は wall clock time (CPU や マシンタイムではなく) を使用しており、さらに、
サーバーの負荷、およびネットワーク待ち時間といった要因にも影響されるので、
不正確です。
(この章の他の例題においては ``rows in set'' の行は省きます。)
</UL>

<P>
キーワードは、いかなる大文字小文字でも記述できます。
以下に示すクエリは同じです：

</P>

<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
mysql&#62; select version(), current_date;
mysql&#62; SeLeCt vErSiOn(), current_DATE;
</PRE>

<P>
以下のクエリは、<CODE>mysql</CODE> を簡単な計算機として使用した例です：

</P>

<PRE>
mysql&#62; SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
</PRE>

<P>
今までは見てきたたコマンドは、比較的短い、一行のの文です。
あなたは一行に複数、文を書くことが出来ます。
それぞれの文の終わりにはセミコロンを付けます： 

</P>

<PRE>
mysql&#62; SELECT VERSION(); SELECT NOW();
+--------------+
| version()    |
+--------------+
| 3.22.20a-log |
+--------------+

+---------------------+
| NOW()               |
+---------------------+
| 1999-03-19 00:15:33 |
+---------------------+
</PRE>

<P>
コマンドは一行にかく必要もありません。 複数行にわたる長いコマンドでも問題ありません。
<CODE>mysql</CODE> はセミコロンで、一文の終わりと見なします。 その行の最後を文の最後とは
見なしません。 （いうなれば、<CODE>mysql</CODE> は自由な入力を許し、セミコロンが現れるまでは
それらの入力された行を実行しません）

</P>
<P>
複数行にまたがった文の例です：

</P>

<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; ,
    -&#62; CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| joesmith@localhost | 1999-03-18   |
+--------------------+--------------+
</PRE>

<P>
この例では、複数にまたがるクエリにおいて、最初の行の入力のあと、
いかにプロンプトが <CODE>mysql&#62;</CODE> から <CODE>-&#62;</CODE> に変わるかを示しています。
これは <CODE>mysql</CODE> が、まだ文が終わっておらず、残りの部分の入力を待っている
ことを示します。 The prompt is your friend, because it provides
valuable feedback.  If you use that feedback, you will always be aware of
what <CODE>mysql</CODE> is waiting for.

</P>
<P>
入力中にコマンドの実行を取りやめようと思った場合、
<CODE>\c</CODE> でこれをキャンセルできます：

</P>

<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; \c
mysql&#62;
</PRE>

<P>
Here, too, notice the prompt.  It switches back to <CODE>mysql&#62;</CODE> after you
type <CODE>\c</CODE>, providing feedback to indicate that <CODE>mysql</CODE> is ready
for a new command.

</P>
<P>
The following table shows each of the prompts you may see and summarizes what
they mean about the state that <CODE>mysql</CODE> is in:

</P>
<P>
<A NAME="IDX1063"></A>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Prompt</STRONG> </TD><TD> <STRONG>Meaning</STRONG>
</TR NOSAVE>
<TR><TD><CODE>mysql&#62;</CODE> </TD><TD> 新しいコマンドの待状態
</TR NOSAVE>
<TR><TD><CODE>    -&#62;</CODE> </TD><TD> 複数行にまたがるコマンドの、次の行の入力を待っている状態。
</TR NOSAVE>
<TR><TD><CODE>    '&#62;</CODE> </TD><TD> シングルクオート (<SAMP>`''</SAMP>) で始められた文字の、次の行の入力を待っている状態。
</TR NOSAVE>
<TR><TD><CODE>    "&#62;</CODE> </TD><TD> ダブルクオート (<SAMP>`"'</SAMP>) で始められた文字の、次の行の入力を待っている状態。
</TR>
</TABLE>

</P>
<P>
あなたが文をセミコロンで終わらすことを忘れて実行した場合に、
複数行の入力待ちが起こります。 この場合、 <CODE>mysql</CODE> は
次の入力を待ちます：

</P>

<PRE>
mysql&#62; SELECT USER()
    -&#62;
</PRE>

<P>
If this happens to you (you think you've entered a statement but the only
response is a <CODE>-&#62;</CODE> prompt), most likely <CODE>mysql</CODE> is waiting for the
semicolon.  If you don't notice what the prompt is telling you, you might sit
there for a while before realizing what you need to do.  Enter a semicolon to
complete the statement, and <CODE>mysql</CODE> will execute it:

</P>

<PRE>
mysql&#62; SELECT USER()
    -&#62; ;
+--------------------+
| USER()             |
+--------------------+
| joesmith@localhost |
+--------------------+
</PRE>

<P>
The <CODE>'&#62;</CODE> and <CODE>"&#62;</CODE> prompts occur during string collection.
In <STRONG>MySQL</STRONG>, you can write strings surrounded by either <SAMP>`''</SAMP>
or <SAMP>`"'</SAMP> characters (for example, <CODE>'hello'</CODE> or <CODE>"goodbye"</CODE>),
and <CODE>mysql</CODE> lets you enter strings that span multiple lines.  When you
see a <CODE>'&#62;</CODE> or <CODE>"&#62;</CODE> prompt, it means that you've entered a line
containing a string that begins with a <SAMP>`''</SAMP> or <SAMP>`"'</SAMP> quote character,
but have not yet entered the matching quote that terminates the string.
That's fine if you really are entering a multiple-line string, but how likely
is that?  Not very.  More often, the <CODE>'&#62;</CODE> and <CODE>"&#62;</CODE> prompts indicate
that you've inadvertantly left out a quote character.  For example:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE name = "Smith AND age &#60; 30;
    "&#62;
</PRE>

<P>
If you enter this <CODE>SELECT</CODE> statement, then hit RETURN and wait for the
result, nothing will happen.  Instead of wondering why this
query takes so long, notice the clue provided by the <CODE>"&#62;</CODE> prompt.  It
tells you that <CODE>mysql</CODE> expects to see the rest of an unterminated
string.  (Do you see the error in the statement?  The string <CODE>"Smith</CODE> is
missing the second quote.)

</P>
<P>
At this point, what do you do?  The simplest thing is to cancel the command.
However, you cannot just type <CODE>\c</CODE> in this case, because <CODE>mysql</CODE>
interprets it as part of the string that it is collecting!  Instead, enter
the closing quote character (so <CODE>mysql</CODE> knows you've finished the
string), then type <CODE>\c</CODE>:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE name = "Smith AND age &#60; 30;
    "&#62; "\c
mysql&#62;
</PRE>

<P>
The prompt changes back to <CODE>mysql&#62;</CODE>, indicating that <CODE>mysql</CODE>
is ready for a new command.

</P>
<P>
It's important to know what the <CODE>'&#62;</CODE> and <CODE>"&#62;</CODE> prompts signify,
because if you mistakenly enter an unterminated string, any further lines you
type will appear to be ignored by <CODE>mysql</CODE> -- including a line
containing <CODE>QUIT</CODE>!  This can be quite confusing, especially if you
don't know that you need to supply the terminating quote before you can
cancel the current command.

</P>
<P>
<A NAME="IDX1064"></A>
<A NAME="IDX1065"></A>
<A NAME="IDX1066"></A>


<H2><A NAME="Database_use" HREF="manual.ja_toc.html#Database_use">9.3  Creating and Using a Database</A></H2>

<P>
Now that you know how to enter commands, it's time to access a database.

</P>
<P>
Suppose you have several pets in your home (your menagerie) and you'd
like to keep track of various types of information about them.  You can do so
by creating tables to hold your data and loading them with the desired
information.  Then you can answer different sorts of questions about your
animals by retrieving data from the tables.  This section shows you how to:

</P>

<UL>
<LI>

Create a database
<LI>

Create a table
<LI>

Load data into the table
<LI>

Retrieve data from the table in various ways
<LI>

Use multiple tables
</UL>

<P>
The menagerie database will be simple (deliberately), but it is not difficult
to think of real-world situations in which a similar type of database might
be used.  For example, a database like this could be used by a farmer to keep
track of livestock, or by a veterinarian to keep track of patient records.

</P>
<P>
Use the <CODE>SHOW</CODE> statement to find out what databases currently exist
on the server:

</P>

<PRE>
mysql&#62; SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
</PRE>

<P>
The list of databases is probably different on your machine, but the
<CODE>mysql</CODE> and <CODE>test</CODE> databases are likely to be among them.  The
<CODE>mysql</CODE> database is required because it describes user access
privileges.  The <CODE>test</CODE> database is often provided as a workspace for
users to try things out.

</P>
<P>
If the <CODE>test</CODE> database exists, try to access it:

</P>

<PRE>
mysql&#62; USE test
Database changed
</PRE>

<P>
Note that <CODE>USE</CODE>, like <CODE>QUIT</CODE>, does not require a semicolon.  (You
can terminate such statements with a semicolon if you like; it does no harm.)
The <CODE>USE</CODE> statement is special in another way, too:  it must be given on
a single line.

</P>
<P>
You can use the <CODE>test</CODE> database (if you have access to it) for the
examples that follow, but anything you create in that database can be
removed by anyone else with access to it.  For this reason, you should
probably ask your <STRONG>MySQL</STRONG> administrator for permission to use a
database of your own.  Suppose you want to call yours <CODE>menagerie</CODE>.  The
administrator needs to execute a command like this:

</P>

<PRE>
mysql&#62; GRANT ALL ON menagerie.* TO your_mysql_name;
</PRE>

<P>
where <CODE>your_mysql_name</CODE> is the <STRONG>MySQL</STRONG> user name assigned to
you.

</P>
<P>
<A NAME="IDX1067"></A>
<A NAME="IDX1068"></A>


<H3><A NAME="Creating_database" HREF="manual.ja_toc.html#Creating_database">9.3.1  Creating and Selecting a Database</A></H3>

<P>
If the administrator creates your database for you when setting up your
permissions, you can begin using it.  Otherwise, you need to create it
yourself:

</P>

<PRE>
mysql&#62; CREATE DATABASE menagerie;
</PRE>

<P>
Under Unix, database names are case sensitive (unlike SQL keywords), so you
must always refer to your database as <CODE>menagerie</CODE>, not as
<CODE>Menagerie</CODE>, <CODE>MENAGERIE</CODE>, or some other variant.  This is also true
for table names.  (Under Windows, this restriction does not apply, although
you must refer to databases and tables using the same lettercase throughout a
given query.)

</P>
<P>
Creating a database does not select it for use; you must do that explicitly.
To make <CODE>menagerie</CODE> the current database, use this command:

</P>

<PRE>
mysql&#62; USE menagerie
Database changed
</PRE>

<P>
Your database needs to be created only once, but you must select it for use
each time you begin a <CODE>mysql</CODE> session.  You can do this by issuing a
<CODE>USE</CODE> statement as shown above.  Alternatively, you can select the
database on the command line when you invoke <CODE>mysql</CODE>.  Just specify its
name after any connection parameters that you might need to provide.  For
example:

</P>

<PRE>
shell&#62; mysql -h host -u user -p menagerie
Enter password: ********
</PRE>

<P>
Note that <CODE>menagerie</CODE> is not your password on the command just shown.
If you want to supply your password on the command line after the <CODE>-p</CODE>
option, you must do so with no intervening space (for example, as
<CODE>-pmypassword</CODE>, not as <CODE>-p mypassword</CODE>).  However, putting your
password on the command line is not recommended, because doing so exposes it
to snooping by other users logged in on your machine.

</P>
<P>
<A NAME="IDX1069"></A>
<A NAME="IDX1070"></A>


<H3><A NAME="Creating_tables" HREF="manual.ja_toc.html#Creating_tables">9.3.2  Creating a Table</A></H3>

<P>
Creating the database is the easy part, but at this point it's empty, as
<CODE>SHOW TABLES</CODE> will tell you:

</P>

<PRE>
mysql&#62; SHOW TABLES;
Empty set (0.00 sec)
</PRE>

<P>
The harder part is deciding what the structure of your database should be:
what tables you will need and what columns will be in each of them.

</P>
<P>
You'll want a table that contains a record for each of your pets.  This can
be called the <CODE>pet</CODE> table, and it should contain, as a bare minimum,
each animal's name.  Because the name by itself is not very interesting, the
table should contain other information.  For example, if more than one person
in your family keeps pets, you might want to list each animal's owner.  You
might also want to record some basic descriptive information such as species
and sex.

</P>
<P>
How about age?  That might be of interest, but it's not a good thing to store
in a database.  Age changes as time passes, which means you'd have to update
your records often.  Instead, it's better to store a fixed value such as
date of birth.  Then, whenever you need age, you can calculate it as the
difference between the current date and the birth date.  <STRONG>MySQL</STRONG>
provides functions for doing date arithmetic, so this is not difficult.
Storing birth date rather than age has other advantages, too:

</P>

<UL>
<LI>

You can use the database for tasks such as generating reminders for upcoming
pet birthdays.  (If you think this type of query is somewhat silly, note that
it is the same question you might ask in the context of a business database
to identify clients to whom you'll soon need to send out birthday greetings,
for that computer-assisted personal touch.)

<LI>

You can calculate age in relation to dates other than the current date.  For
example, if you store death date in the database, you can easily calculate
how old a pet was when it died.
</UL>

<P>
You can probably think of other types of information that would be useful in
the <CODE>pet</CODE> table, but the ones identified so far are sufficient for now:
name, owner, species, sex, birth, and death.

</P>
<P>
Use a <CODE>CREATE TABLE</CODE> statement to specify the layout of your table:

</P>

<PRE>
mysql&#62; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    -&#62; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
</PRE>

<P>
<CODE>VARCHAR</CODE> is a good choice for the <CODE>name</CODE>, <CODE>owner</CODE>, and
<CODE>species</CODE> columns because the column values will vary in length.  The
lengths of those columns need not all be the same, and need not be
<CODE>20</CODE>.  You can pick any length from <CODE>1</CODE> to <CODE>255</CODE>, whatever
seems most reasonable to you.  (If you make a poor choice and it turns
out later that you need a longer field, <STRONG>MySQL</STRONG> provides an
<CODE>ALTER TABLE</CODE> statement.)

</P>
<P>
Animal sex can be represented in a variety of ways, for example, <CODE>"m"</CODE>
and <CODE>"f"</CODE>, or perhaps <CODE>"male"</CODE> and <CODE>"female"</CODE>.  It's simplest
to use the single characters <CODE>"m"</CODE> and <CODE>"f"</CODE>.

</P>
<P>
The use of the <CODE>DATE</CODE> data type for the <CODE>birth</CODE> and <CODE>death</CODE>
columns is a fairly obvious choice.

</P>
<P>
Now that you have created a table, <CODE>SHOW TABLES</CODE> should produce some
output:

</P>

<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
</PRE>

<P>
To verify that your table was created the way you expected, use
a <CODE>DESCRIBE</CODE> statement:

</P>

<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P>
You can use <CODE>DESCRIBE</CODE> any time, for example, if you forget the names of
the columns in your table or what types they are.

</P>
<P>
<A NAME="IDX1071"></A>
<A NAME="IDX1072"></A>
<A NAME="IDX1073"></A>


<H3><A NAME="Loading_tables" HREF="manual.ja_toc.html#Loading_tables">9.3.3  Loading Data into a Table</A></H3>

<P>
After creating your table, you need to populate it.  The <CODE>LOAD DATA</CODE> and
<CODE>INSERT</CODE> statements are useful for this.

</P>
<P>
Suppose your pet records can be described as shown below.
(Observe that <STRONG>MySQL</STRONG> expects dates in <CODE>YYYY-MM-DD</CODE> format;
this may be different than what you are used to.)

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>name</STRONG> </TD><TD> <STRONG>owner</STRONG> </TD><TD> <STRONG>species</STRONG> </TD><TD> <STRONG>sex</STRONG> </TD><TD> <STRONG>birth</STRONG> </TD><TD> <STRONG>death</STRONG>
</TR NOSAVE>
<TR><TD>Fluffy </TD><TD> Harold </TD><TD> cat </TD><TD> f </TD><TD> 1993-02-04 </TD><TD>
</TR NOSAVE>
<TR><TD>Claws </TD><TD> Gwen </TD><TD> cat </TD><TD> m </TD><TD> 1994-03-17 </TD><TD>
</TR NOSAVE>
<TR><TD>Buffy </TD><TD> Harold </TD><TD> dog </TD><TD> f </TD><TD> 1989-05-13 </TD><TD>
</TR NOSAVE>
<TR><TD>Fang </TD><TD> Benny </TD><TD> dog </TD><TD> m </TD><TD> 1990-08-27 </TD><TD>
</TR NOSAVE>
<TR><TD>Bowser </TD><TD> Diane </TD><TD> dog </TD><TD> m </TD><TD> 1989-08-31 </TD><TD> 1995-07-29
</TR NOSAVE>
<TR><TD>Chirpy </TD><TD> Gwen </TD><TD> bird </TD><TD> f </TD><TD> 1998-09-11 </TD><TD>
</TR NOSAVE>
<TR><TD>Whistler </TD><TD> Gwen </TD><TD> bird </TD><TD> </TD><TD> 1997-12-09 </TD><TD>
</TR NOSAVE>
<TR><TD>Slim </TD><TD> Benny </TD><TD> snake </TD><TD> m </TD><TD> 1996-04-29 </TD><TD>
</TR>
</TABLE>

<P>
Because you are beginning with an empty table, an easy way to populate it is to
create a text file containing a row for each of your animals, then load the
contents of the file into the table with a single statement.

</P>
<P>
You could create a text file <TT>`pet.txt'</TT> containing one record per line,
with values separated by tabs, and given in the order in which the columns
were listed in the <CODE>CREATE TABLE</CODE> statement.  For missing values (such
as unknown sexes or death dates for animals that are still living), you can
use <CODE>NULL</CODE> values.  To represent these in your text file, use
<CODE>\N</CODE>.  For example, the record for Whistler the bird would look like
this (where the whitespace between values is a single tab character):

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>Whistler</CODE> </TD><TD> <CODE>Gwen</CODE> </TD><TD> <CODE>bird</CODE> </TD><TD> <CODE>\N</CODE> </TD><TD> <CODE>1997-12-09</CODE> </TD><TD> <CODE>\N</CODE>
</TR>
</TABLE>

<P>
To load the text file <TT>`pet.txt'</TT> into the <CODE>pet</CODE> table, use this
command:

</P>

<PRE>
mysql&#62; LOAD DATA LOCAL INFILE "pet.txt" INTO TABLE pet;
</PRE>

<P>
You can specify the column value separator and end of line marker explicitly
in the <CODE>LOAD DATA</CODE> statement if you wish, but the defaults are tab and
linefeed.  These are sufficient for the statement to read the file
<TT>`pet.txt'</TT> properly.

</P>
<P>
When you want to add new records one at a time, the <CODE>INSERT</CODE> statement
is useful.  In its simplest form, you supply values for each column, in the
order in which the columns were listed in the <CODE>CREATE TABLE</CODE> statement.
Suppose Diane gets a new hamster named Puffball.  You could add a new record
using an <CODE>INSERT</CODE> statement like this:

</P>

<PRE>
mysql&#62; INSERT INTO pet
    -&#62; VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
</PRE>

<P>
Note that string and date values are specified as quoted strings here.  Also,
with <CODE>INSERT</CODE>, you can insert <CODE>NULL</CODE> directly to represent a
missing value.  You do not use <CODE>\N</CODE> like you do with <CODE>LOAD DATA</CODE>.

</P>
<P>
From this example, you should be able to see that there would be a lot more
typing involved to load
your records initially using several <CODE>INSERT</CODE> statements rather
than a single <CODE>LOAD DATA</CODE> statement.

</P>
<P>
<A NAME="IDX1074"></A>
<A NAME="IDX1075"></A>
<A NAME="IDX1076"></A>
<A NAME="IDX1077"></A>


<H3><A NAME="Retrieving_data" HREF="manual.ja_toc.html#Retrieving_data">9.3.4  Retrieving Information from a Table</A></H3>

<P>
The <CODE>SELECT</CODE> statement is used to pull information from a table.
The general form of the statement is:

</P>

<PRE>
SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy
</PRE>

<P>
<CODE>what_to_select</CODE> indicates what you want to see.  This can be a list of
columns, or <CODE>*</CODE> to indicate ``all columns.'' <CODE>which_table</CODE>
indicates the table from which you want to retrieve data.  The <CODE>WHERE</CODE>
clause is optional.  If it's present, <CODE>conditions_to_satisfy</CODE> specifies
conditions that rows must satisfy to qualify for retrieval.

</P>


<H4><A NAME="Selecting_all" HREF="manual.ja_toc.html#Selecting_all">9.3.4.1  Selecting All Data</A></H4>

<P>
The simplest form of <CODE>SELECT</CODE> retrieves everything from a table:

</P>

<PRE>
mysql&#62; SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1998-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
</PRE>

<P>
This form of <CODE>SELECT</CODE> is useful if you want to review your entire table,
for instance, after you've just loaded it with your initial dataset.  As it
happens, the output just shown reveals an error in your data file:  Bowser
appears to have been born after he died!  Consulting your original pedigree
papers, you find that the correct birth year is 1989, not 1998.

</P>
<P>
There are are least a couple of ways to fix this:

</P>

<UL>
<LI>

Edit the file <TT>`pet.txt'</TT> to correct the error, then empty the table
and reload it using <CODE>DELETE</CODE> and <CODE>LOAD DATA</CODE>:


<PRE>
mysql&#62; SET AUTOCOMMIT=1;  # Used for quick re-create of the table
mysql&#62; DELETE FROM pet;
mysql&#62; LOAD DATA LOCAL INFILE "pet.txt" INTO TABLE pet;
</PRE>

However, if you do this, you must also re-enter the record for Puffball.

<LI>

Fix only the erroneous record with an <CODE>UPDATE</CODE> statement:


<PRE>
mysql&#62; UPDATE pet SET birth = "1989-08-31" WHERE name = "Bowser";
</PRE>

</UL>

<P>
As shown above, it is easy to retrieve an entire table.  But typically you
don't want to do that, particularly when the table becomes large.  Instead,
you're usually more interested in answering a particular question, in which
case you specify some constraints on the information you want.  Let's look at
some selection queries in terms of questions about your pets that they
answer.

</P>
<P>
<A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>


<H4><A NAME="Selecting_rows" HREF="manual.ja_toc.html#Selecting_rows">9.3.4.2  Selecting Particular Rows</A></H4>

<P>
You can select only particular rows from your table.  For example, if you want
to verify the change that you made to Bowser's birth date, select Bowser's
record like this:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name = "Bowser";
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
</PRE>

<P>
The output confirms that the year is correctly recorded now as 1989, not 1998.

</P>
<P>
String comparisons are normally case insensitive, so you can specify the
name as <CODE>"bowser"</CODE>, <CODE>"BOWSER"</CODE>, etc.  The query result will be
the same.

</P>
<P>
You can specify conditions on any column, not just <CODE>name</CODE>.  For example,
if you want to know which animals were born after 1998, test the <CODE>birth</CODE>
column:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE birth &#62;= "1998-1-1";
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
</PRE>

<P>
You can combine conditions, for example, to locate female dogs:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE species = "dog" AND sex = "f";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
The preceding query uses the <CODE>AND</CODE> logical operator.  There is also an
<CODE>OR</CODE> operator:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE species = "snake" OR species = "bird";
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
</PRE>

<P>
<CODE>AND</CODE> and <CODE>OR</CODE> may be intermixed.  If you do that, it's a good idea
to use parentheses to indicate how conditions should be grouped:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE (species = "cat" AND sex = "m")
    -&#62; OR (species = "dog" AND sex = "f");
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
<A NAME="IDX1080"></A>
<A NAME="IDX1081"></A>


<H4><A NAME="Selecting_columns" HREF="manual.ja_toc.html#Selecting_columns">9.3.4.3  Selecting Particular Columns</A></H4>

<P>
If you don't want to see entire rows from your table, just name the columns
in which you're interested, separated by commas.  For example, if you want to
know when your animals were born, select the <CODE>name</CODE> and <CODE>birth</CODE>
columns:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>
To find out who owns pets, use this query:

</P>

<PRE>
mysql&#62; SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
</PRE>

<P>
<A NAME="IDX1082"></A>
However, notice that the query simply retrieves the <CODE>owner</CODE> field from
each record, and some of them appear more than once.  To minimize the output,
retrieve each unique output record just once by adding the keyword
<CODE>DISTINCT</CODE>:

</P>

<PRE>
mysql&#62; SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
</PRE>

<P>
You can use a <CODE>WHERE</CODE> clause to combine row selection with column
selection.  For example, to get birth dates for dogs and cats only,
use this query:

</P>

<PRE>
mysql&#62; SELECT name, species, birth FROM pet
    -&#62; WHERE species = "dog" OR species = "cat";
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
</PRE>

<P>
<A NAME="IDX1083"></A>
<A NAME="IDX1084"></A>
<A NAME="IDX1085"></A>
<A NAME="IDX1086"></A>


<H4><A NAME="Sorting_rows" HREF="manual.ja_toc.html#Sorting_rows">9.3.4.4  Sorting Rows</A></H4>

<P>
You may have noticed in the preceding examples that the result rows are
displayed in no particular order.  However, it's often easier to examine
query output when the rows are sorted in some meaningful way.  To sort a
result, use an <CODE>ORDER BY</CODE> clause.

</P>
<P>
Here are animal birthdays, sorted by date:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>
To sort in reverse order, add the <CODE>DESC</CODE> (descending) keyword to the
name of the column you are sorting by:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
</PRE>

<P>
You can sort on multiple columns.  For example, to sort by type of
animal, then by birth date within animal type with youngest animals first,
use the following query:

</P>

<PRE>
mysql&#62; SELECT name, species, birth FROM pet ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
</PRE>

<P>
Note that the <CODE>DESC</CODE> keyword applies only to the column name immediately
preceding it (<CODE>birth</CODE>); <CODE>species</CODE> values are still sorted in
ascending order.

</P>
<P>
<A NAME="IDX1087"></A>
<A NAME="IDX1088"></A>
<A NAME="IDX1089"></A>
<A NAME="IDX1090"></A>


<H4><A NAME="Date_calculations" HREF="manual.ja_toc.html#Date_calculations">9.3.4.5  日付の計算</A></H4>

<P>
<STRONG>MySQL</STRONG> はいくつかの日付の計算を行う関数を提供します。
例えば、年の計算や日付の部分を取り出したり。

</P>
<P>
ペットの年齢が何才なのかを知るためには、現在の日付と誕生日との差を計算
します。 このためには、二つの日付を日数に直し、差を取り、そして 365
(年の日数) で割ります：

</P>

<PRE>
mysql&#62; SELECT name, (TO_DAYS(NOW())-TO_DAYS(birth))/365 FROM pet;
+----------+-------------------------------------+
| name     | (TO_DAYS(NOW())-TO_DAYS(birth))/365 |
+----------+-------------------------------------+
| Fluffy   |                                6.15 |
| Claws    |                                5.04 |
| Buffy    |                                9.88 |
| Fang     |                                8.59 |
| Bowser   |                                9.58 |
| Chirpy   |                                0.55 |
| Whistler |                                1.30 |
| Slim     |                                2.92 |
| Puffball |                                0.00 |
+----------+-------------------------------------+
</PRE>

<P>
クエリは動きましたが、改良したいくつかのことがあります。 
第1に、この結果は、もしレコードにいくつかの順番を与えれば、簡単に並び換えが
出来そうなこと。
第2に、年齢欄の見出しは、このままではなんなのか分かりません。

</P>
<P>
最初の問題は <CODE>ORDER BY name</CODE> 節を加えることで name 順で並び換えが出来ます。
二つ目の問題に対しては、違う見出しを出力に現れるように、欄の見出しを
扱います (これを フィールドのエイリアス と呼びます) : 

</P>

<PRE>
mysql&#62; SELECT name, (TO_DAYS(NOW())-TO_DAYS(birth))/365 AS age
    -&#62; FROM pet ORDER BY name;
+----------+------+
| name     | age  |
+----------+------+
| Bowser   | 9.58 |
| Buffy    | 9.88 |
| Chirpy   | 0.55 |
| Claws    | 5.04 |
| Fang     | 8.59 |
| Fluffy   | 6.15 |
| Puffball | 0.00 |
| Slim     | 2.92 |
| Whistler | 1.30 |
+----------+------+
</PRE>

<P>
<CODE>name</CODE> ではなく <CODE>age</CODE> で並び換えるには、 <CODE>ORDER BY</CODE> 節を
以下のように変えます：

</P>

<PRE>
mysql&#62;  SELECT name, (TO_DAYS(NOW())-TO_DAYS(birth))/365 AS age
    -&#62;  FROM pet ORDER BY age;
+----------+------+
| name     | age  |
+----------+------+
| Puffball | 0.00 |
| Chirpy   | 0.55 |
| Whistler | 1.30 |
| Slim     | 2.92 |
| Claws    | 5.04 |
| Fluffy   | 6.15 |
| Fang     | 8.59 |
| Bowser   | 9.58 |
| Buffy    | 9.88 |
+----------+------+
</PRE>

<P>
似たクエリが、既に死んでしまった動物の、死んだ時点の年齢を調べるのにも
使用できます。 どの動物が死んでいるかどうかは、<CODE>death</CODE> 値が <CODE>NULL</CODE> か
どうかで判断します。 これらの値が 非<CODE>NULL</CODE> ならば、 <CODE>death</CODE> と <CODE>birth</CODE>
の差の計算を行います：

</P>

<PRE>
mysql&#62;  SELECT name, birth, death, (TO_DAYS(death)-TO_DAYS(birth))/365 AS age
    -&#62;  FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 | 5.91 |
+--------+------------+------------+------+
</PRE>

<P>
このクエリでは、 <CODE>death != NULL</CODE> ではなく <CODE>death IS NOT NULL</CODE> を
使用します。 なぜなら、 <CODE>NULL</CODE> は特別な値だからです。 これは後で解説します。
 「<A HREF="manual.ja_Tutorial.html#Working_with_NULL">9.3.4.6  <CODE>NULL</CODE> 値の振る舞い</A>」節参照.

</P>
<P>
もしあなたが翌月誕生日の動物を知りたいとします。 この種の計算では、
年と日が関係ありません。  <CODE>birth</CODE> フィールドの月だけを単に
取り出したくなるでしょう。 <STRONG>MySQL</STRONG> は日付の部分を取り出すいくつかの関数を
提供します。 <CODE>YEAR()</CODE>, <CODE>MONTH()</CODE>, <CODE>DAYOFMONTH()</CODE> など。
ここでは <CODE>MONTH()</CODE> がいいでしょう。 これがどのように動くか確かめるには、
<CODE>birth</CODE> と <CODE>MONTH(birth)</CODE> の両方を表示させるクエリを実行してみます：

</P>

<PRE>
mysql&#62; SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
</PRE>

<P>
来月誕生日を迎える動物を見つけるのは簡単です。 現在4月だとします。
すると、5月生まれの動物を探します：

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
</PRE>

<P>
もし現在が12月なら、ちょっと困るかもしれません。 月の数字 (<CODE>12</CODE>) に
1 を足して 13 月生まれの動物を探すわけにはいきません。 かわりに1月生まれの
動物を探します。

</P>
<P>
現在が何月なのかを気にすることなく、動作するクエリを書くことが可能です。
この方法では、あなたは月の数字をクエリに使用することがありません。
<CODE>DATE_ADD()</CODE> 関数は与えた日付からある時間を足すことが可能です。
もし現時点 <CODE>NOW()</CODE> の値に 1ヶ月 足し、 <CODE>MONTH()</CODE> で月の
部分を取り出し、その結果を、誕生月を調べるために使用します：

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MONTH(DATE_ADD(NOW(), INTERVAL 1 MONTH));
</PRE>

<P>
同じことができる別の方法として、剰余関数 を使用した結果に 1 を足す方法があります。
(もし今月が12月なら、剰余関数 (<CODE>MOD</CODE>) を使用した結果は <CODE>0</CODE> になります)：

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MOD(MONTH(NOW()), 12) + 1;
</PRE>

<P>
Note that <CODE>MONTH</CODE> returns a number between 1 and 12. And
<CODE>MOD(something,12)</CODE> returns a number between 0 and 11. So the
addition has to be after the <CODE>MOD()</CODE> otherwise we would go from
November (11) to January (1).

</P>
<P>
<A NAME="IDX1091"></A>
<A NAME="IDX1092"></A>


<H4><A NAME="Working_with_NULL" HREF="manual.ja_toc.html#Working_with_NULL">9.3.4.6  <CODE>NULL</CODE> 値の振る舞い</A></H4>

<P>
あなたがそれに慣れるまでは、<CODE>NULL</CODE> 値には驚くかもしれません。
概念的に、<CODE>NULL</CODE> 値は ``値無し'' か ``未知な値'' を意味し、
他の値よりもいくぶん異なって扱われます。
<CODE>NULL</CODE> の評価の際には、数値の比較演算子 <CODE>=</CODE>, <CODE>&#60;</CODE>, <CODE>!=</CODE> を
使用することは出来ません。 あなた自身これをデモするために、以下のようにしてみてください：

</P>

<PRE>
mysql&#62; SELECT 1 = NULL, 1 != NULL, 1 &#60; NULL, 1 &#62; NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 != NULL | 1 &#60; NULL | 1 &#62; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</PRE>

<P>
確実にこれらの比較からいかなる意味がある結果も受け取りません。
この代わりに、 <CODE>IS NULL</CODE> , <CODE>IS NOT NULL</CODE> 演算子を使用します：

</P>

<PRE>
mysql&#62; SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</PRE>

<P>
<STRONG>MySQL</STRONG> では, 0 や <CODE>NULL</CODE> は false（偽） で、それ以外全てが true（真）です。
The default trueth value from a boolean operation is 1.

</P>
<P>
この <CODE>NULL</CODE> の特別な扱いはなぜなのか。 前のセクションを見てください。
どの動物がもはや生きていないことを決定づけるためには、
<CODE>death != NULL</CODE> ではなく <CODE>death IS NOT NULL</CODE> の使用が
必要とされるのです。

</P>
<P>
<A NAME="IDX1093"></A>
<A NAME="IDX1094"></A>
<A NAME="IDX1095"></A>


<H4><A NAME="Pattern_matching" HREF="manual.ja_toc.html#Pattern_matching">9.3.4.7  パターン・マッチ</A></H4>

<P>
<STRONG>MySQL</STRONG> は標準SQLのパターン・マッチを提供します。
また、拡張された正規表現を基にした形式のパターン・マッチ、
これは <CODE>vi</CODE>, <CODE>grep</CODE> , <CODE>sed</CODE> など UNIX のユーティリティに
使用されている物と似ていますが、これも提供します。

</P>
<P>
SQL パターン・マッチは、 <SAMP>`_'</SAMP> でいかなる１文字とも一致し、
<SAMP>`%'</SAMP> であらゆる0こ以上の文字列に一致します。
<STRONG>MySQL</STRONG> では、デフォルトで SQL パターンはケース非依存です。
いくつか例を以下に示します。 SQLパターンを使用する場合、 <CODE>=</CODE> や
<CODE>!=</CODE> を使用しないように注意してください。 <CODE>LIKE</CODE> か <CODE>NOT LIKE</CODE>
を代わりに使用します。

</P>
<P>
<SAMP>`b'</SAMP> から始まる名前を見つけるには:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "b%";
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</PRE>

<P>
<SAMP>`fy'</SAMP> で終わる名前を見つけるには:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%fy";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>
<SAMP>`w'</SAMP> を含む名前を見つけるには:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%w%";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>
5文字の名前を見つけるには, <SAMP>`_'</SAMP> パターン文字を使用して：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "_____";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
<STRONG>MySQL</STRONG> では他のパターン・マッチの形も提供されます。正規表現の拡張を使用して。
これらのパターン・マッチをテストする際には、<CODE>REGEXP</CODE> と <CODE>NOT REGEXP</CODE>
演算子（あるいは<CODE>RLIKE</CODE>, <CODE>NOT RLIKE</CODE> 演算子。これらは同義です）
を使用します。

</P>
<P>
拡張正規表現のいくつかの特徴：

</P>

<UL>
<LI>

<SAMP>`.'</SAMP> はいかなる一文字とも一致します。

<LI>

<SAMP>`[...]'</SAMP> は、かっこ内にある文字と一致します。
例えば、<SAMP>`[abc]'</SAMP> は <SAMP>`a'</SAMP>, <SAMP>`b'</SAMP> あるいは <SAMP>`c'</SAMP> にマッチします。
文字を範囲指定する場合にはダッシュを使用します。 <SAMP>`[a-z]'</SAMP> はいかなる
小文字のアルファベット文字にも一致し、 <SAMP>`[0-9]'</SAMP> はいかなる数字にも
一致します。

<LI>

<SAMP>`*'</SAMP> は、先に指定されている文字 0 個以上にマッチします。
例えば、<SAMP>`x*'</SAMP> は 文字 <SAMP>`x'</SAMP> がいくつも連続している物にマッチし、
<SAMP>`[0-9]*'</SAMP> はいかなる数値ともマッチし、 <SAMP>`.*'</SAMP> はあらゆる文字列に
一致します。

<LI>

正規表現はケース依存です。 しかし大文字小文字どちらでもマッチさせたい場合、
文字クラスを使用できます。 例えば、 <SAMP>`[aA]'</SAMP> は大文字小文字の <SAMP>`a'</SAMP> に
マッチし、<SAMP>`[a-zA-Z]'</SAMP> は大文字小文字のいかなるアルファベット文字にもマッチします。

<LI>

パターンは、テストされた値の中のどこかにある場合、マッチします。
(SQL patterns match only if they match the entire value.)

<LI>

値のはじめ、あるいは終わりに位置を指定してマッチさせたい場合は、
パターンの初めにマッチさせる場合は <SAMP>`^'</SAMP> を使用し、
パターンの終わりにマッチさせる場合は <SAMP>`$'</SAMP> を使用します。
(これらはアンカーと呼ばれます)
</UL>

<P>
以下は拡張された正規表現がどう動くかの例です。
上に示した <CODE>LIKE</CODE> のクエリは <CODE>REGEXP</CODE> で以下のように書き換えれます：

</P>
<P>
<SAMP>`b'</SAMP> で始まる名前をみつけるには、<SAMP>`^'</SAMP> で名前の頭にマッチさせ、
かつ <SAMP>`[bB]'</SAMP> として、大文字小文字にもマッチさせます：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^b";
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</PRE>

<P>
Prior to <STRONG>MySQL</STRONG> Version 3.23.4, <CODE>REGEXP</CODE> is case sensitive, 
and the previous query will return no rows. To match either lowercase or 
uppercase <SAMP>`b'</SAMP>, use this query instead:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^[bB]";
</PRE>

<P>
From <STRONG>MySQL</STRONG> 3.23.4 on, to force a <CODE>REGEXP</CODE> comparison to
be case sensitive, use the <CODE>BINARY</CODE> keyword to make one of the
strings a binary string. This query will match only lowercase <SAMP>`b'</SAMP>
at the beginning of a name:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP BINARY "^b";
</PRE>

<P>
<SAMP>`fy'</SAMP> で終わる名前を見つけるには、 <SAMP>`$'</SAMP> を使用して名前の
最後にマッチさせます：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "fy$";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>
大文字、小文字の <SAMP>`w'</SAMP> を含む名前を見つけるには：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "w";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>
正規表現はもし値中のどこかにでもあればマッチするため、
SQL パターンのように、パターンの前後にワイルドカードを書く必要はありません。

</P>
<P>
5文字の名前を見つけるには、<SAMP>`^'</SAMP> と <SAMP>`$'</SAMP> を使用して名前の初めと終わりに
マッチさせ、その間に <SAMP>`.'</SAMP> を5個入れます：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.....$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
前のクエリは <SAMP>`{n}'</SAMP> ``<CODE>n</CODE>回繰り返し'' オペレーターで
書換え可能です。

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.{5}$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
<A NAME="IDX1096"></A>
<A NAME="IDX1097"></A>
<A NAME="IDX1098"></A>


<H4><A NAME="Counting_rows" HREF="manual.ja_toc.html#Counting_rows">9.3.4.8  Counting Rows</A></H4>

<P>
Databases are often used to answer the question, ``How often does a certain
type of data occur in a table?''  For example, you might want to know how
many pets you have, or how many pets each owner has, or you might want to
perform various kinds of censuses on your animals.

</P>
<P>
Counting the total number of animals you have is the same question as ``How
many rows are in the <CODE>pet</CODE> table?'' because there is one record per pet.
The <CODE>COUNT()</CODE> function counts the number of non-<CODE>NULL</CODE> results, so
the query to count your animals looks like this:

</P>

<PRE>
mysql&#62; SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
</PRE>

<P>
Earlier, you retrieved the names of the people who owned pets.  You can
use <CODE>COUNT()</CODE> if you want to find out how many pets each owner has:

</P>

<PRE>
mysql&#62; SELECT owner, COUNT(*) FROM pet GROUP BY owner;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
</PRE>

<P>
Note the use of <CODE>GROUP BY</CODE> to group together all records for each
<CODE>owner</CODE>.  Without it, all you get is an error message:

</P>

<PRE>
mysql&#62; SELECT owner, COUNT(owner) FROM pet;
ERROR 1140 at line 1: Mixing of GROUP columns (MIN(),MAX(),COUNT()...)
with no GROUP columns is illegal if there is no GROUP BY clause
</PRE>

<P>
<CODE>COUNT()</CODE> and <CODE>GROUP BY</CODE> are useful for characterizing your
data in various ways.  The following examples show different ways to
perform animal census operations.

</P>
<P>
Number of animals per species:

</P>

<PRE>
mysql&#62; SELECT species, COUNT(*) FROM pet GROUP BY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</PRE>

<P>
Number of animals per sex:

</P>

<PRE>
mysql&#62; SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</PRE>

<P>
(In this output, <CODE>NULL</CODE> indicates sex unknown.)

</P>
<P>
Number of animals per combination of species and sex:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>

<P>
You need not retrieve an entire table when you use <CODE>COUNT()</CODE>.  For
example, the previous query, when performed just on dogs and cats, looks like
this:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE species = "dog" OR species = "cat"
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</PRE>

<P>
Or, if you wanted the number of animals per sex only for known-sex animals:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE sex IS NOT NULL
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>

<P>
<A NAME="IDX1099"></A>


<H4><A NAME="Multiple_tables" HREF="manual.ja_toc.html#Multiple_tables">9.3.4.9  Using More Than one Table</A></H4>

<P>
The <CODE>pet</CODE> table keeps track of which pets you have.  If you want to
record other information about them, such as events in their lives like
visits to the vet or when litters are born, you need another table.  What
should this table look like? It needs:

</P>

<UL>
<LI>

To contain the pet name so you know which animal each event pertains
to.

<LI>

A date so you know when the event occurred.

<LI>

A field to describe the event.

<LI>

An event type field, if you want to be able to categorize events.
</UL>

<P>
Given these considerations, the <CODE>CREATE TABLE</CODE> statement for the
<CODE>event</CODE> table might look like this:

</P>

<PRE>
mysql&#62; CREATE TABLE event (name VARCHAR(20), date DATE,
    -&#62; type VARCHAR(15), remark VARCHAR(255));
</PRE>

<P>
As with the <CODE>pet</CODE> table, it's easiest to load the initial records
by creating a tab-delimited text file containing the information:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>Fluffy </TD><TD> 1995-05-15 </TD><TD> litter </TD><TD> 4 kittens, 3 female, 1 male
</TR NOSAVE>
<TR><TD>Buffy </TD><TD> 1993-06-23 </TD><TD> litter </TD><TD> 5 puppies, 2 female, 3 male
</TR NOSAVE>
<TR><TD>Buffy </TD><TD> 1994-06-19 </TD><TD> litter </TD><TD> 3 puppies, 3 female
</TR NOSAVE>
<TR><TD>Chirpy </TD><TD> 1999-03-21 </TD><TD> vet </TD><TD> needed beak straightened
</TR NOSAVE>
<TR><TD>Slim </TD><TD> 1997-08-03 </TD><TD> vet </TD><TD> broken rib
</TR NOSAVE>
<TR><TD>Bowser </TD><TD> 1991-10-12 </TD><TD> kennel
</TR NOSAVE>
<TR><TD>Fang </TD><TD> 1991-10-12 </TD><TD> kennel
</TR NOSAVE>
<TR><TD>Fang </TD><TD> 1998-08-28 </TD><TD> birthday </TD><TD> Gave him a new chew toy
</TR NOSAVE>
<TR><TD>Claws </TD><TD> 1998-03-17 </TD><TD> birthday </TD><TD> Gave him a new flea collar
</TR NOSAVE>
<TR><TD>Whistler </TD><TD> 1998-12-09 </TD><TD> birthday </TD><TD> First birthday
</TR>
</TABLE>

<P>
Load the records like this:

</P>

<PRE>
mysql&#62; LOAD DATA LOCAL INFILE "event.txt" INTO TABLE event;
</PRE>

<P>
Based on what you've learned from the queries you've run on the <CODE>pet</CODE>
table, you should be able to perform retrievals on the records in the
<CODE>event</CODE> table; the principles are the same.  But when is the
<CODE>event</CODE> table by itself insufficient to answer questions you might ask?

</P>
<P>
Suppose you want to find out the ages of each pet when they had their
litters.  The <CODE>event</CODE> table indicates when this occurred, but to
calculate the age of the mother, you need her birth date.  Because that is
stored in the <CODE>pet</CODE> table, you need both tables for the query:

</P>

<PRE>
mysql&#62; SELECT pet.name, (TO_DAYS(date) - TO_DAYS(birth))/365 AS age, remark
    -&#62; FROM pet, event
    -&#62; WHERE pet.name = event.name AND type = "litter";
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy | 2.27 | 4 kittens, 3 female, 1 male |
| Buffy  | 4.12 | 5 puppies, 2 female, 3 male |
| Buffy  | 5.10 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
</PRE>

<P>
There are several things to note about this query:

</P>

<UL>
<LI>

The <CODE>FROM</CODE> clause lists two tables because the query needs to pull
information from both of them.

<LI>

When combining (joining) information from multiple tables, you need to
specify how records in one table can be matched to records in the other.
This is easy because they both have a <CODE>name</CODE> column.  The query uses
<CODE>WHERE</CODE> clause to match up records in the two tables based on the
<CODE>name</CODE> values.

<LI>

Because the <CODE>name</CODE> column occurs in both tables, you must be specific
about which table you mean when referring to the column.  This is done
by prepending the table name to the column name.
</UL>

<P>
You need not have two different tables to perform a join.  Sometimes it is
useful to join a table to itself, if you want to compare records in a table
to other records in that same table.  For example, to find breeding pairs
among your pets, you can join the <CODE>pet</CODE> table with itself to pair up
males and females of like species:

</P>

<PRE>
mysql&#62; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    -&#62; FROM pet AS p1, pet AS p2
    -&#62; WHERE p1.species = p2.species AND p1.sex = "f" AND p2.sex = "m";
+--------+------+--------+------+---------+
| name   | sex  | name   | sex  | species |
+--------+------+--------+------+---------+
| Fluffy | f    | Claws  | m    | cat     |
| Buffy  | f    | Fang   | m    | dog     |
| Buffy  | f    | Bowser | m    | dog     |
+--------+------+--------+------+---------+
</PRE>

<P>
In this query, we specify aliases for the table name in order
to refer to the columns and keep straight which instance of the table
each column reference is associated with.

</P>
<P>
<A NAME="IDX1100"></A>
<A NAME="IDX1101"></A>
<A NAME="IDX1102"></A>


<H2><A NAME="Getting_information" HREF="manual.ja_toc.html#Getting_information">9.4  データベースとテーブルの情報を得る</A></H2>

<P>
データベースやテーブルの名前が何であったか、あるいはテーブルの構造はどうであったか、
(なんというフィールドがあったのか)忘れてしまった場合。
<STRONG>MySQL</STRONG> ではいくつかのデータベースとテーブルの情報を提供する文を通じて
この問題を処理します。

</P>
<P>
あなたは既に <CODE>SHOW DATABASES</CODE> を知っているはずで, これはサーバーが
管理するデーターベースの一覧を表示します。 現在選択しているデータベースが
何であるかを知るには、<CODE>DATABASE()</CODE> 関数を使用します：

</P>

<PRE>
mysql&#62; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
</PRE>

<P>
もしデータベースをまだ何も選択していなければ、結果はブランクです。

</P>
<P>
データベースに含まれるテーブルを見つけるには(たとえば、あなたがテーブル名を
知らない場合)、このコマンドを使用します：

</P>

<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
</PRE>

<P>
もしテーブルの構造を知りたいなら、<CODE>DESCRIBE</CODE> コマンドが便利です；
これはテーブルのそれぞれのフィールドについての情報を表示します。

</P>

<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P>
<CODE>Field</CODE> はフィールド名を示し、<CODE>Type</CODE> はフィールドのデータ型、
<CODE>Null</CODE> はこのフィールドが <CODE>Null</CODE> 値を含むかを示し、
<CODE>Key</CODE> はこのフィールドがインデックス化されているかを示し、
<CODE>Default</CODE> はフィールドのデフォルトの値を示します。

</P>
<P>
もしテーブルにインデックスを持っているなら、
<CODE>SHOW INDEX FROM tbl_name</CODE> がそれらの情報を示します。

</P>
<P>
<A NAME="IDX1103"></A>
<A NAME="IDX1104"></A>


<H2><A NAME="Examples" HREF="manual.ja_toc.html#Examples">9.5  Examples of Common Queries</A></H2>

<P>
Here are examples of how to solve some common problems with
<STRONG>MySQL</STRONG>.

</P>
<P>
Some of the examples use the table <CODE>shop</CODE> to hold the price of each
article (item number) for certain traders (dealers).  Supposing that each
trader has a single fixed price per article, then (<CODE>item</CODE>,
<CODE>trader</CODE>) is a primary key for the records.

</P>
<P>
Start the command line tool <CODE>mysql</CODE> and select a database:

</P>

<PRE>
mysql your-database-name
</PRE>

<P>
(In most <STRONG>MySQL</STRONG> installations, you can use the database-name 'test').

</P>
<P>
You can create the example table as:

</P>

<PRE>
CREATE TABLE shop (
 article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
 dealer  CHAR(20)                 DEFAULT ''     NOT NULL,
 price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL,
 PRIMARY KEY(article, dealer));

INSERT INTO shop VALUES
(1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),(3,'C',1.69),
(3,'D',1.25),(4,'D',19.95);
</PRE>

<P>
Okay, so the example data is:

</P>

<PRE>
mysql&#62; SELECT * FROM shop;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | A      |  3.45 |
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | B      |  1.45 |
|    0003 | C      |  1.69 |
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>



<H3><A NAME="example-Maximum-column" HREF="manual.ja_toc.html#example-Maximum-column">9.5.1  The Maximum Value for a Column</A></H3>

<P>
``What's the highest item number?''

</P>

<PRE>
SELECT MAX(article) AS article FROM shop

+---------+
| article |
+---------+
|       4 |
+---------+
</PRE>



<H3><A NAME="example-Maximum-row" HREF="manual.ja_toc.html#example-Maximum-row">9.5.2  The Row Holding the Maximum of a Certain Column</A></H3>

<P>
``Find number, dealer, and price of the most expensive article.''

</P>
<P>
In ANSI SQL this is easily done with a sub-query:

</P>

<PRE>
SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop)
</PRE>

<P>
In <STRONG>MySQL</STRONG> (which does not yet have sub-selects), just do it in
two steps:

</P>

<OL>
<LI>

Get the maximum price value from the table with a <CODE>SELECT</CODE> statement.
<LI>

Using this value compile the actual query:

<PRE>
SELECT article, dealer, price
FROM   shop
WHERE  price=19.95
</PRE>

</OL>

<P>
Another solution is to sort all rows descending by price and only
get the first row using the <STRONG>MySQL</STRONG> specific <CODE>LIMIT</CODE> clause:

</P>

<PRE>
SELECT article, dealer, price
FROM   shop
ORDER BY price DESC
LIMIT 1
</PRE>

<P>
<STRONG>NOTE</STRONG>:  If there are several most expensive articles (for example, each 19.95)
the <CODE>LIMIT</CODE> solution shows only one of them!

</P>


<H3><A NAME="example-Maximum-column-group" HREF="manual.ja_toc.html#example-Maximum-column-group">9.5.3  Maximum of Column per Group</A></H3>

<P>
``What's the highest price per article?''

</P>

<PRE>
SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
</PRE>



<H3><A NAME="example-Maximum-column-group-row" HREF="manual.ja_toc.html#example-Maximum-column-group-row">9.5.4  The Rows Holding the Group-wise Maximum of a Certain Field</A></H3>

<P>
``For each article, find the dealer(s) with the most expensive price.''

</P>
<P>
In ANSI SQL, I'd do it with a sub-query like this:

</P>

<PRE>
SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article);
</PRE>

<P>
In <STRONG>MySQL</STRONG> it's best do it in several steps:

</P>

<OL>
<LI>

Get the list of (article,maxprice).
<LI>

For each article get the corresponding rows that have the stored maximum
price.
</OL>

<P>
This can easily be done with a temporary table:

</P>

<PRE>
CREATE TEMPORARY TABLE tmp (
        article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
        price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL);

LOCK TABLES shop read;

INSERT INTO tmp SELECT article, MAX(price) FROM shop GROUP BY article;

SELECT shop.article, dealer, shop.price FROM shop, tmp
WHERE shop.article=tmp.article AND shop.price=tmp.price;

UNLOCK TABLES;

DROP TABLE tmp;
</PRE>

<P>
If you don't use a <CODE>TEMPORARY</CODE> table, you must also lock the 'tmp' table.

</P>
<P>
``Can it be done with a single query?''

</P>
<P>
Yes, but only by using a quite inefficient trick that I call the
``MAX-CONCAT trick'':

</P>

<PRE>
SELECT article,
       SUBSTRING( MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 7) AS dealer,
  0.00+LEFT(      MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 6) AS price
FROM   shop
GROUP BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

<P>
The last example can, of course, be made a bit more efficient by doing the
splitting of the concatenated column in the client.

</P>


<H3><A NAME="example-user-variables" HREF="manual.ja_toc.html#example-user-variables">9.5.5  Using user variables</A></H3>

<P>
You can use <STRONG>MySQL</STRONG> user variables to remember results without
having to store them in a temporary variables in the client.
 「<A HREF="manual.ja_Reference.html#Variables">7.2  ユーザー変数</A>」節参照.

</P>
<P>
For example, to find the articles with the highest and lowest price you
can do:

</P>

<PRE>
select @min_price:=min(price),@max_price:=max(price) from shop;
select * from shop where price=@min_price or price=@max_price;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

<P>
<A NAME="IDX1105"></A>
<A NAME="IDX1106"></A>


<H3><A NAME="example-Foreign_keys" HREF="manual.ja_toc.html#example-Foreign_keys">9.5.6  Using Foreign Keys</A></H3>

<P>
You don't need foreign keys to join 2 tables.

</P>
<P>
The only thing <STRONG>MySQL</STRONG> doesn't do is <CODE>CHECK</CODE> to make sure that
the keys you use really exist in the table(s) you're referencing and it
doesn't automatically delete rows from table with a foreign key
definition. If you use your keys like normal, it'll work just fine:

</P>


<PRE>
CREATE TABLE persons (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name CHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirts (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES persons,
    PRIMARY KEY (id)
);

INSERT INTO persons VALUES (NULL, 'Antonio Paz');

INSERT INTO shirts VALUES
(NULL, 'polo', 'blue', LAST_INSERT_ID()),
(NULL, 'dress', 'white', LAST_INSERT_ID()),
(NULL, 't-shirt', 'blue', LAST_INSERT_ID());

INSERT INTO persons VALUES (NULL, 'Lilliana Angelovska');

INSERT INTO shirts VALUES
(NULL, 'dress', 'orange', LAST_INSERT_ID()),
(NULL, 'polo', 'red', LAST_INSERT_ID()),
(NULL, 'dress', 'blue', LAST_INSERT_ID()),
(NULL, 't-shirt', 'white', LAST_INSERT_ID());

SELECT * FROM persons;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+

SELECT * FROM shirts;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+

SELECT s.* FROM persons p, shirts s
 WHERE p.name LIKE 'Lilliana%'
   AND s.owner = p.id
   AND s.color &#60;&#62; 'white';

+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
</PRE>

<P>
<A NAME="IDX1107"></A>
<A NAME="IDX1108"></A>
<A NAME="IDX1109"></A>


<H3><A NAME="Searching_on_two_keys" HREF="manual.ja_toc.html#Searching_on_two_keys">9.5.7  Searching on Two Keys</A></H3>

<P>
<STRONG>MySQL</STRONG> doesn't yet optimize when you search on two different
keys combined with <CODE>OR</CODE> (Searching on one key with different <CODE>OR</CODE>
parts is optimized quite good):

</P>

<PRE>
SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1'
OR  field2_index = '1'
</PRE>

<P>
The reason is that we haven't yet had time to come up with an efficient
way to handle this in the general case. (The <CODE>AND</CODE> handling is,
in comparison, now completely general and works very well).

</P>
<P>
For the moment you can solve this very efficiently by using a
<CODE>TEMPORARY</CODE> table. This type of optimization is also very good if
you are using very complicated queries where the SQL server does the
optimizations in the wrong order.

</P>

<PRE>
CREATE TEMPORARY TABLE tmp
SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1';
INSERT INTO tmp
SELECT field1_index, field2_index FROM test_table WHERE field2_index = '1';
SELECT * from tmp;
DROP TABLE tmp;
</PRE>

<P>
The above way to solve this query is in effect an <CODE>UNION</CODE> of two queries.

</P>
<P>
<A NAME="IDX1110"></A>
<A NAME="IDX1111"></A>
<A NAME="IDX1112"></A>
<A NAME="IDX1113"></A>
<A NAME="IDX1114"></A>


<H2><A NAME="Batch_mode" HREF="manual.ja_toc.html#Batch_mode">9.6  <CODE>mysql</CODE> のバッチモードでの使用</A></H2>

<P>
前のセクションでは、<CODE>mysql</CODE> を対話モードで使用し、クエリの入力と
結果を表示しました。 <CODE>mysql</CODE> はバッチモードでも実行可能です。
これを行うには、あなたが実行したいコマンドをファイルに書いておき、
そのファイルから入力を読み込むようにして <CODE>mysql</CODE> を実行します：

</P>

<PRE>
shell&#62; mysql &#60; batch-file
</PRE>

<P>
もし接続パラメターを指定する必要がある場合は、以下のようになるでしょう：

</P>

<PRE>
shell&#62; mysql -h host -u user -p &#60; batch-file
Enter password: ********
</PRE>

<P>
この方法で <CODE>mysql</CODE> を使用するとき、あなたはスクリプトファイルを
作成し、それを実行することになるでしょう。

</P>
<P>
なぜスクリプトを使用するのか？ それには以下の理由があります：

</P>

<UL>
<LI>

もし繰り返しクエリを実行する場合(毎日とか毎週とか)、スクリプトを書くことで、
その実行の度にあなたがコマンドをタイプすることを省くことが可能です。

<LI>

もし既にあるクエリに似た新しいクエリを書く場合、それらをコピーし
スクリプトファイルを編集できます。

<LI>

バッチモードはクエリの開発中や複数にまたがるコマンドには役に立ちます。
もしコマンドが間違っていたとしても全てを打ち直す必要がありません。
エラーを修正するためにスクリプトを編集し、再び <CODE>mysql</CODE> に実行させます。

<LI>

もし多くの出力を出すようなクエリの場合、ページャーを使用して出力を見ることが
出来ます。 出力がスクロールして画面から見えなくなるよりいいでしょう：


<PRE>
shell&#62; mysql &#60; batch-file | more
</PRE>

<LI>

あなたはより処理を行うために、結果をファイルに書き出すことが可能です：


<PRE>
shell&#62; mysql &#60; batch-file &#62; mysql.out
</PRE>

<LI>

あなたは、他人へのあなたのスクリプトを配布することができます。これにより、ほかの人たちも
コマンドを実行することができます。 

<LI>

いくつかの状況では、対話モードでは使用に耐えません。 たとえば、クエリを
 <CODE>cron</CODE> ジョブとして実行する場合。 この場合、バッチモードでなければなりません。

<LI>

端末が正しく扱えない文字を <CODE>mysql</CODE> コマンドに渡す場合。
たとえば、EUC-JP, Shift_JIS の漢字文字などは、端末や環境によっては直接入力できない場合もあるでしょう。
</UL>

<P>
<CODE>mysql</CODE> をバッチモードで使用するか、対話モードで使用するかで、
デフォルトの出力形式が変わります。 例えば、 <CODE>SELECT DISTINCT species FROM pet</CODE> の
出力は対話モードでは次のようになります：

</P>

<PRE>
+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
</PRE>

<P>
しかし、バッチモードでは：

</P>

<PRE>
species
bird
cat
dog
hamster
snake
</PRE>

<P>
もしバッチモードでも対話モードのような出力を得たい場合には、<CODE>mysql -t</CODE> とします。
出力中に、実行したコマンドを表示させるならば、<CODE>mysql -vvv</CODE> とします。

</P>
<P>
<A NAME="IDX1115"></A>
<A NAME="IDX1116"></A>


<H2><A NAME="Twin" HREF="manual.ja_toc.html#Twin">9.7  Queries from Twin Project</A></H2>

<P>
At Analytikerna and Lentus, we have been doing the systems and field work
for a big research project. This project is a collaboration between the
Institute of Environmental Medicine at Karolinska Institutet Stockholm
and the Section on Clinical Research in Aging and Psychology at the
University of Southern California.

</P>
<P>
The project involves a screening part where all twins in Sweden older
than 65 years are interviewed by telephone. Twins who meet certain
criteria are passed on to the next stage. In this latter stage, twins who
want to participate are visited by a doctor/nurse team. Some of the
examinations include physical and neuropsychological examination,
laboratory testing, neuroimaging, psychological status assessment, and family
history collection. In addition, data are collected on medical and
environmental risk factors.

</P>
<P>
More information about Twin studies can be found at:

</P>

<PRE>
<A HREF="http://www.imm.ki.se/TWIN/TWINUKW.HTM">http://www.imm.ki.se/TWIN/TWINUKW.HTM</A>
</PRE>

<P>
The latter part of the project is administered with a Web interface
written using Perl and <STRONG>MySQL</STRONG>.

</P>
<P>
Each night all data from the interviews are moved into a <STRONG>MySQL</STRONG>
database.

</P>



<H3><A NAME="Twin_pool" HREF="manual.ja_toc.html#Twin_pool">9.7.1  Find all Non-distributed Twins</A></H3>

<P>
The following query is used to determine who goes into the second part of the
project:

</P>

<PRE>
select
        concat(p1.id, p1.tvab) + 0 as tvid,
        concat(p1.christian_name, " ", p1.surname) as Name,
        p1.postal_code as Code,
        p1.city as City,
        pg.abrev as Area,
        if(td.participation = "Aborted", "A", " ") as A,
        p1.dead as dead1,
        l.event as event1,
        td.suspect as tsuspect1,
        id.suspect as isuspect1,
        td.severe as tsevere1,
        id.severe as isevere1,
        p2.dead as dead2,
        l2.event as event2,
        h2.nurse as nurse2,
        h2.doctor as doctor2,
        td2.suspect as tsuspect2,
        id2.suspect as isuspect2,
        td2.severe as tsevere2,
        id2.severe as isevere2,
        l.finish_date
from
        twin_project as tp
        /* For Twin 1 */
        left join twin_data as td on tp.id = td.id and tp.tvab = td.tvab
        left join informant_data as id on tp.id = id.id and tp.tvab = id.tvab
        left join harmony as h on tp.id = h.id and tp.tvab = h.tvab
        left join lentus as l on tp.id = l.id and tp.tvab = l.tvab
        /* For Twin 2 */
        left join twin_data as td2 on p2.id = td2.id and p2.tvab = td2.tvab
        left join informant_data as id2 on p2.id = id2.id and p2.tvab = id2.tvab
        left join harmony as h2 on p2.id = h2.id and p2.tvab = h2.tvab
        left join lentus as l2 on p2.id = l2.id and p2.tvab = l2.tvab,
        person_data as p1,
        person_data as p2,
        postal_groups as pg
where
        /* p1 gets main twin and p2 gets his/her twin. */
        /* ptvab is a field inverted from tvab */
        p1.id = tp.id and p1.tvab = tp.tvab and
        p2.id = p1.id and p2.ptvab = p1.tvab and
        /* Just the sceening survey */
        tp.survey_no = 5 and
        /* Skip if partner died before 65 but allow emigration (dead=9) */
        (p2.dead = 0 or p2.dead = 9 or
         (p2.dead = 1 and
          (p2.death_date = 0 or
           (((to_days(p2.death_date) - to_days(p2.birthday)) / 365)
            &#62;= 65))))
        and
        (
        /* Twin is suspect */
        (td.future_contact = 'Yes' and td.suspect = 2) or
        /* Twin is suspect - Informant is Blessed */
        (td.future_contact = 'Yes' and td.suspect = 1 and id.suspect = 1) or
        /* No twin - Informant is Blessed */
        (ISNULL(td.suspect) and id.suspect = 1 and id.future_contact = 'Yes') or
        /* Twin broken off - Informant is Blessed */
        (td.participation = 'Aborted'
         and id.suspect = 1 and id.future_contact = 'Yes') or
        /* Twin broken off - No inform - Have partner */
        (td.participation = 'Aborted' and ISNULL(id.suspect) and p2.dead = 0))
        and
        l.event = 'Finished'
        /* Get at area code */
        and substring(p1.postal_code, 1, 2) = pg.code
        /* Not already distributed */
        and (h.nurse is NULL or h.nurse=00 or h.doctor=00)
        /* Has not refused or been aborted */
        and not (h.status = 'Refused' or h.status = 'Aborted'
        or h.status = 'Died' or h.status = 'Other')
order by
        tvid;
</PRE>

<P>
Some explanations:
<DL COMPACT>

<DT><CODE>concat(p1.id, p1.tvab) + 0 as tvid</CODE>
<DD>
We want to sort on the concatenated <CODE>id</CODE> and <CODE>tvab</CODE> in
numerical order. Adding <CODE>0</CODE> to the result causes <STRONG>MySQL</STRONG> to
treat the result as a number.
<DT>column <CODE>id</CODE>
<DD>
This identifies a pair of twins. It is a key in all tables.
<DT>column <CODE>tvab</CODE>
<DD>
This identifies a twin in a pair. It has a value of <CODE>1</CODE> or <CODE>2</CODE>.
<DT>column <CODE>ptvab</CODE>
<DD>
This is an inverse of <CODE>tvab</CODE>. When <CODE>tvab</CODE> is <CODE>1</CODE> this is
<CODE>2</CODE>, and vice versa. It exists to save typing and to make it easier for
<STRONG>MySQL</STRONG> to optimize the query.
</DL>

<P>
This query demonstrates, among other things, how to do lookups on a
table from the same table with a join (<CODE>p1</CODE> and <CODE>p2</CODE>). In the example, this
is used to check whether a twin's partner died before the age of 65. If so,
the row is not returned.

</P>
<P>
All of the above exist in all tables with twin-related information. We
have a key on both <CODE>id,tvab</CODE> (all tables), and <CODE>id,ptvab</CODE>
(<CODE>person_data</CODE>) to make queries faster.

</P>
<P>
On our production machine (A 200MHz UltraSPARC), this query returns
about 150-200 rows and takes less than one second.

</P>
<P>
The current number of records in the tables used above:
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table</STRONG> </TD><TD> <STRONG>Rows</STRONG>
</TR NOSAVE>
<TR><TD><CODE>person_data</CODE> </TD><TD> 71074
</TR NOSAVE>
<TR><TD><CODE>lentus</CODE> </TD><TD> 5291
</TR NOSAVE>
<TR><TD><CODE>twin_project</CODE> </TD><TD> 5286
</TR NOSAVE>
<TR><TD><CODE>twin_data</CODE> </TD><TD> 2012
</TR NOSAVE>
<TR><TD><CODE>informant_data</CODE> </TD><TD> 663
</TR NOSAVE>
<TR><TD><CODE>harmony</CODE> </TD><TD> 381
</TR NOSAVE>
<TR><TD><CODE>postal_groups</CODE> </TD><TD> 100
</TR>
</TABLE>

</P>


<H3><A NAME="Twin_event" HREF="manual.ja_toc.html#Twin_event">9.7.2  Show a Table on Twin Pair Status</A></H3>

<P>
Each interview ends with a status code called <CODE>event</CODE>. The query
shown below is used to display a table over all twin pairs combined by
event. This indicates in how many pairs both twins are finished, in how many
pairs one twin is finished and the other refused, and so on.

</P>

<PRE>
select
        t1.event,
        t2.event,
        count(*)
from
        lentus as t1,
        lentus as t2,
        twin_project as tp
where
        /* We are looking at one pair at a time */
        t1.id = tp.id
        and t1.tvab=tp.tvab
        and t1.id = t2.id
        /* Just the sceening survey */
        and tp.survey_no = 5
        /* This makes each pair only appear once */
        and t1.tvab='1' and t2.tvab='2'
group by
        t1.event, t2.event;

</PRE>

<P>
<A NAME="IDX1117"></A>
<A NAME="IDX1118"></A>
<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Table_types.html">previous</A>, <A HREF="manual.ja_Server.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
