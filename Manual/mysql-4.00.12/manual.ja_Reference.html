  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 4 March 2004 -->

  <TITLE>MySQL Reference Manual for version 4.0.12. - 6  MySQL Language Reference</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=silver TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_MySQL_Optimisation.html">previous</A>, <A HREF="manual.ja_Table_types.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Reference" HREF="manual.ja_toc.html#Reference">6  MySQL Language Reference</A></H1>

<P>
MySQL has a very complex, but intuitive and easy to learn SQL
interface.  This chapter describes the various commands, types, and functions
you will need to know in order to use MySQL efficiently and
effectively.  This chapter also serves as a reference to all functionality
included in MySQL.  In order to use this chapter effectively, you
may find it useful to refer to the various indexes.

</P>



<H2><A NAME="Language_Structure" HREF="manual.ja_toc.html#Language_Structure">6.1  Language Structure</A></H2>



<H3><A NAME="Literals" HREF="manual.ja_toc.html#Literals">6.1.1  文字列と数値をどのように書くか？</A></H3>

<P>
<A NAME="IDX936"></A>
<A NAME="IDX937"></A>
<A NAME="IDX938"></A>
<A NAME="IDX939"></A>
<A NAME="IDX940"></A>

</P>

<P>
この節は MySQL で文字列と数値を記述するさまざまな方法を説明します。
MySQL でのこれらの基本型の取り扱い時に、出会うであろうさまざまな
ニュアンスと ``了解'' もカバーします。

</P>



<H4><A NAME="String_syntax" HREF="manual.ja_toc.html#String_syntax">6.1.1.1  文字列</A></H4>

<P>
文字列は文字の並びです。引用符(<SAMP>`''</SAMP>)または二重引用符(<SAMP>`"'</SAMP>)で括ら
れます(後者は ANSI モードで実行していない場合のみ)。 例：

</P>

<PRE>
'a string'
"another string"
</PRE>

<P>
文字列中では、いくつかのシーケンスは特別な意味を持ちます。これらのシーケ
ンスのそれぞれは<EM>エスケープ文字</EM>として知られるバックスラッシュ
(<SAMP>`\'</SAMP>)で始まります。MySQL は次のエスケープシーケンスを認識
します。

</P>
<DL COMPACT>

<DT><CODE>\0</CODE>
<DD>
<A NAME="IDX941"></A>
 <A NAME="IDX942"></A>
 
ASCII 0 (<CODE>NUL</CODE>) 文字。

<A NAME="IDX943"></A>
<A NAME="IDX944"></A>
<DT><CODE>\'</CODE>
<DD>
引用符(<SAMP>`''</SAMP>)。

<A NAME="IDX945"></A>
<A NAME="IDX946"></A>
<DT><CODE>\"</CODE>
<DD>
二重引用符(<SAMP>`"'</SAMP>)。

<A NAME="IDX947"></A>
<A NAME="IDX948"></A>
<DT><CODE>\b</CODE>
<DD>
バックスペース文字。

<A NAME="IDX949"></A>
<A NAME="IDX950"></A>
<DT><CODE>\n</CODE>
<DD>
改行文字。

<A NAME="IDX951"></A>
<A NAME="IDX952"></A>
<A NAME="IDX953"></A>
<DT><CODE>\r</CODE>
<DD>
リターン文字。

<A NAME="IDX954"></A>
<A NAME="IDX955"></A>
<DT><CODE>\t</CODE>
<DD>
タブ文字。

<A NAME="IDX956"></A>
<A NAME="IDX957"></A>
<DT><CODE>\z</CODE>
<DD>
ASCII(26) (Control-Z)。この文字は、ASCII(26) が Windows では END-OF-FILE 
であるという問題を回避するために、コード化できます。(ASCII(26) は 
<CODE>mysql database &#60; filename</CODE> を使用しようとする場合に問題になります)。

<A NAME="IDX958"></A>
<A NAME="IDX959"></A>
<DT><CODE>\\</CODE>
<DD>
バックスラッシュ(<SAMP>`\'</SAMP>)文字。

<A NAME="IDX960"></A>
<A NAME="IDX961"></A>
<DT><CODE>\%</CODE>
<DD>
<SAMP>`%'</SAMP> 文字。これは <SAMP>`%'</SAMP> がワイルドカード文字として解釈される文脈
で、<SAMP>`%'</SAMP> そのものを検索するために使用されます。
 「<A HREF="manual.ja_Reference.html#String_comparison_functions">6.3.2.1  String Comparison Functions</A>」節参照.

<A NAME="IDX962"></A>
<A NAME="IDX963"></A>
<DT><CODE>\_</CODE>
<DD>
<CODE>_</CODE> 文字。これは <SAMP>`_'</SAMP> がワイルドカード文字として解釈される文脈
で、<CODE>_</CODE> そのものを検索するために使用されます。
 「<A HREF="manual.ja_Reference.html#String_comparison_functions">6.3.2.1  String Comparison Functions</A>」節参照.
</DL>

<P>
いくつかの文字列文脈で <SAMP>`\%'</SAMP> または <SAMP>`\_'</SAMP> を使用すると、これらは文
字列 <SAMP>`%'</SAMP> と <SAMP>`_'</SAMP> ではなく、<SAMP>`\%'</SAMP> と <SAMP>`\_'</SAMP> を返します。

</P>
<P>
<A NAME="IDX964"></A>
文字列中に引用符を含める方法はいくつかあります:

</P>

<UL>
<LI>

<SAMP>`''</SAMP> で括られる文字列中の <SAMP>`''</SAMP> は <SAMP>`'''</SAMP> として書くことができ
ます。

<LI>

<SAMP>`"'</SAMP> で括られる文字列中の <SAMP>`"'</SAMP> は <SAMP>`""'</SAMP> として書くことができ
ます。

<LI>

引用符の前にエスケープ文字 (<SAMP>`\'</SAMP>) を置くことができます。

<LI>

<SAMP>`"'</SAMP> で括られた文字列中の <SAMP>`''</SAMP> は特別扱いの必要はなく、二重にし
たり、エスケープする必要はありません。同じように、<SAMP>`''</SAMP> で括られた文
字列中の <SAMP>`"'</SAMP> は特別扱いの必要はありません。
</UL>

<P>
次の <CODE>SELECT</CODE> ステートメントは、クォートとエスケープがどのように働
くかを示します:

</P>

<PRE>
mysql&#62; SELECT 'hello', '"hello"', '""hello""', 'hel''lo', '\'hello';
+-------+---------+-----------+--------+--------+
| hello | "hello" | ""hello"" | hel'lo | 'hello |
+-------+---------+-----------+--------+--------+

mysql&#62; SELECT "hello", "'hello'", "''hello''", "hel""lo", "\"hello";
+-------+---------+-----------+--------+--------+
| hello | 'hello' | ''hello'' | hel"lo | "hello |
+-------+---------+-----------+--------+--------+

mysql&#62; SELECT "This\nIs\nFour\nlines";
+--------------------+
| This
Is
Four
lines |
+--------------------+
</PRE>

<P>
<A NAME="IDX965"></A>

</P>
<P>
バイナリデータを <CODE>BLOB</CODE> フィールドに挿入したい場合、次の文字をエスケープ
シーケンスで表す必要があります:
<DL COMPACT>

<DT><CODE>NUL</CODE>
<DD>
ASCII 0。<SAMP>`\0'</SAMP> (バックスラッシュと ASCII <SAMP>`0'</SAMP> 文字) に置き換える
べきです。
<DT><CODE>\</CODE>
<DD>
ASCII 92, バックスラッシュ。<SAMP>`\\'</SAMP> と表記してください。
<DT><CODE>'</CODE>
<DD>
ASCII 39, 引用符。<SAMP>`\''</SAMP> と表記してください。
<DT><CODE>"</CODE>
<DD>
ASCII 34, 二重引用符。<SAMP>`\"'</SAMP> と表記してください。
</DL>

<P>
<A NAME="IDX966"></A>
<A NAME="IDX967"></A>
<A NAME="IDX968"></A>
<A NAME="IDX969"></A>
C コードを書く場合、<CODE>INSERT</CODE> 節で文字をエスケープするために、C API 
関数 <CODE>mysql_real_escape_string()</CODE> を使用できます。 「<A HREF="manual.ja_Clients.html#C_API_function_overview">8.4.2  C API 関数概要</A>」節参照.  Perl では、<CODE>DBI</CODE> パッケージの <CODE>quote</CODE> メソッドを使
用して、特殊文字を適当なエスケープシーケンスに変換できます。 「<A HREF="manual.ja_Clients.html#Perl_DBI_Class">8.2.2  The <CODE>DBI</CODE> Interface</A>」節参照.

</P>
<P>
上記の特殊文字のどれかを含む可能性のある全ての文字列について、エスケープ
関数を使用すべきです！

</P>
<P>
Alternatively, many MySQL APIs provide some sort of placeholder capability
that allows you to insert special markers into a query string, and then bind
data values to them when you issue the query.  In this case, the API takes
case of escaping special characters in the values for you automatically.

</P>



<H4><A NAME="Number_syntax" HREF="manual.ja_toc.html#Number_syntax">6.1.1.2  数値</A></H4>

<P>
<A NAME="IDX970"></A>
<A NAME="IDX971"></A>
<A NAME="IDX972"></A>
<A NAME="IDX973"></A>
<A NAME="IDX974"></A>

</P>
<P>
整数は数字の並びで表現されます。
浮動小数点は <SAMP>`.'</SAMP> で小数を分割します。
どちらの型も負数を表すために <SAMP>`-'</SAMP> を前につけます。

</P>
<P>
正当な数値の例:

</P>

<PRE>
1221
0
-32
</PRE>

<P>
有効な浮動小数点の例：

</P>

<PRE>
294.42
-32032.6809e+10
148.00
</PRE>

<P>
整数が浮動小数点の文脈で使用されるかもしれません； この場合、浮動小数点に
変換されます。

</P>



<H4><A NAME="Hexadecimal_values" HREF="manual.ja_toc.html#Hexadecimal_values">6.1.1.3  16進法の値</A></H4>

<P>
<A NAME="IDX975"></A>

</P>
<P>
MySQL は16進法の値をサポートします。
数値の文脈では、これらは整数(64ビット精度)のように振る舞います。
文字列の文脈では、hexの桁のそれぞれのペアが文字に変換された
バイナリー文字のように振る舞います。

</P>

<PRE>
mysql&#62; SELECT x'4D7953514C';
         -&#62; MySQL
mysql&#62; SELECT 0xa+0;
       -&#62; 10
mysql&#62; select 0x5061756c;
       -&#62; Paul
</PRE>

<P>
The <CODE>x'hexstring'</CODE> syntax (new in 4.0) is based on ANSI SQL and the
<CODE>0x</CODE> syntax is based on ODBC.
16進数表記は、ODBC において BLOB の値を与えるためにしばしば使用されます。
You can convert a string or a number to hexadecimal with the <CODE>HEX()</CODE>
function.

</P>



<H4><A NAME="NULL_values" HREF="manual.ja_toc.html#NULL_values">6.1.1.4  <CODE>NULL</CODE> 値</A></H4>

<P>
<A NAME="IDX976"></A>

</P>
<P>
<CODE>NULL</CODE> は ``no data'' を意味し、数値型の <CODE>0</CODE> や文字列型の空文
字列とは異なることに注意してください。
 「<A HREF="manual.ja_Problems.html#Problems_with_NULL">A.5.3  <CODE>NULL</CODE> 値での問題</A>」節参照.

</P>
<P>
テキストファイルの読み込みや書き出し時に、<CODE>NULL</CODE> は <CODE>\N</CODE> で
表現されます。 (<CODE>LOAD DATA INFILE</CODE>, <CODE>SELECT ... INTO OUTFILE</CODE>).
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.9  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.

</P>



<H3><A NAME="Legal_names" HREF="manual.ja_toc.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A></H3>

<P>
<A NAME="IDX977"></A>
<A NAME="IDX978"></A>
<A NAME="IDX979"></A>
<A NAME="IDX980"></A>
<A NAME="IDX981"></A>
<A NAME="IDX982"></A>
<A NAME="IDX983"></A>

</P>

<P>
データベース名、テーブル名、インデックス名、フィールド名、エイリアス名は
MySQL では全て同じ規則に基づきます:

</P>
<P>
<A NAME="IDX984"></A>
<A NAME="IDX985"></A>
<A NAME="IDX986"></A>
<A NAME="IDX987"></A>
注意: 規則は MySQL 3.23.6 で変更されました。それは識別子(データベー
ス名、テーブル名、フィールド名)の <SAMP>``'</SAMP> でのクォートを導入した時です
(ANSI モードで実行する場合は、<CODE>"</CODE> も識別子をクォートするために働きま
す)。

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>識別子</STRONG> </TD><TD> <STRONG>最大長</STRONG> </TD><TD> <STRONG>許される文字</STRONG>
</TR NOSAVE>
<TR><TD>データベース </TD><TD> 64 </TD><TD> ディレクトリ名として許されるすべての文字。<CODE>/</CODE>, <SAMP>`\'</SAMP>, <SAMP>`.'</SAMP> を除く。
</TR NOSAVE>
<TR><TD>テーブル </TD><TD> 64 </TD><TD> ファイル名として許されるすべての文字。<CODE>/</CODE> と <CODE>.</CODE> を除く。
</TR NOSAVE>
<TR><TD>フィールド </TD><TD> 64 </TD><TD> すべての文字
</TR NOSAVE>
<TR><TD>エイリアス </TD><TD> 255 </TD><TD> すべての文字
</TR>
</TABLE>

<P>
注意: 上記に加え、識別子内には ASCII(0) と ASCII(255) を持てません。

</P>
<P>
注意: 識別子が制限された単語であったり特殊文字を含む場合は、それを使用する
時には常に <CODE>`</CODE> (バッククォート) でクォートする必要があります:

</P>

<PRE>
mysql&#62; SELECT * FROM `select` WHERE `select`.id &#62; 100;
</PRE>

<P>
 「<A HREF="manual.ja_Reference.html#Reserved_words">6.1.7  Is MySQL Picky About Reserved Words?</A>」節参照.

</P>
<P>
MySQL 3.23.6 より前のバージョンでは、名前の規則は次に従います:

</P>

<UL>
<LI>

名前は、現在の文字セットのアルファベットと数字文字から成り、<SAMP>`_'</SAMP> と 
<SAMP>`$'</SAMP> も含みます。デフォルト文字セットは ISO-8859-1 Latin1 ですが、
これは <CODE>mysqld</CODE> に <CODE>--default-character-set</CODE> オプションを
与えることで変更できます. (3.23.14 以上の場合のみ。
それ以前のバージョンでは MySQL 再コンパイルが必要)
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_sets">4.6.1  データとソートに使用されるキャラクター・セット</A>」節参照.

<LI>

名前は、名前として正しい任意の文字で始めることができます。特に、名前は数
字で始めることができます(これは他の多くのシステムと異なります！)。しかし、
数字<EM>だけ</EM>の名前にする事はできません。

<LI>

名前の中に <SAMP>`.'</SAMP> 文字を使用することはできません。フィールドを参照できるよう
に形式を拡張するために使用されるためです(後述)。
</UL>

<P>
<CODE>1e</CODE> のような名前は使用しないことを勧めます。<CODE>1e+1</CODE> のような式が
あいまいだからです。これは、式 <CODE>1e + 1</CODE> として、または数値 
<CODE>1e+1</CODE> として解釈されます。

</P>
<P>
MySQL では次の形式のいずれかを使用してフィールドを参照できます:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドの参照方法</STRONG> </TD><TD> <STRONG>意味</STRONG>
</TR NOSAVE>
<TR><TD><CODE>col_name</CODE> </TD><TD> クエリ中で使用されるテーブル内に存在している <CODE>col_name</CODE> という名前のフィールド
</TR NOSAVE>
<TR><TD><CODE>tbl_name.col_name</CODE> </TD><TD> 現在のデータベースのテーブル <CODE>tbl_name</CODE> 内のフィールド <CODE>col_name</CODE>
</TR NOSAVE>
<TR><TD><CODE>db_name.tbl_name.col_name</CODE> </TD><TD> データベース <CODE>db_name</CODE>
のテーブル <CODE>tbl_name</CODE> 内のフィールド <CODE>col_name</CODE>。この形式は
バージョン 3.22 以降で有効です。
</TR NOSAVE>
<TR><TD>
<CODE>`column_name`</CODE> </TD><TD> キーワードであったり特殊文字を含むフィールド。
</TR>
</TABLE>

<P>
参照が曖昧でないならば、ステートメント中のフィールド参照の前に <CODE>tbl_name</CODE> 
または <CODE>db_name.tbl_name</CODE> を記述する必要はありません。例えば、テー
ブル <CODE>t1</CODE> と <CODE>t2</CODE> がそれぞれフィールド <CODE>c</CODE> を含み、<CODE>t1</CODE> と 
<CODE>t2</CODE> の両方を使用する <CODE>SELECT</CODE> ステートメントで <CODE>c</CODE> を取
り出すとします。この場合、<CODE>c</CODE> はステートメントで使用されるテーブル
間で唯一でないので曖昧です。そのため、<CODE>t1.c</CODE> または <CODE>t2.c</CODE> と
記述するこよによりどちらのテーブルを意味するかを示す必要があります。同様
に、データベース <CODE>db1</CODE> のテーブル <CODE>t</CODE> とデータベース 
<CODE>db2</CODE> のテーブル <CODE>t</CODE> から取り出す場合、これらのテーブル中の項
目は、<CODE>db1.t.col_name</CODE> と <CODE>db2.t.col_name</CODE> として参照する必要
があります。

</P>
<P>
<A NAME="IDX988"></A>
<A NAME="IDX989"></A>
構文 <CODE>.tbl_name</CODE> は現在のデータベース内のテーブル <CODE>tbl_name</CODE> 
を意味します。この構文はいくつかの ODBC が <SAMP>`.'</SAMP> 文字をテーブル名の前
に置くために許されています。

</P>



<H3><A NAME="Name_case_sensitivity" HREF="manual.ja_toc.html#Name_case_sensitivity">6.1.3  名前のケース依存性</A></H3>

<P>
<A NAME="IDX990"></A>
<A NAME="IDX991"></A>
<A NAME="IDX992"></A>
<A NAME="IDX993"></A>
<A NAME="IDX994"></A>
<A NAME="IDX995"></A>

</P>
<P>
MySQL では、データベースとテーブルは、ディレクトリと
そのディレクトリ中のファイルに対応します。そのため、下で動作するオペレー
ティングシステムのケース依存性は、データベースとテーブル名のケース依存性を決定します。
データベース名とテーブル名は UNIX ではケース依存で、Windows ではケース非依
存です。One prominent
exception here is Mac OS X, when the default HFS+ file system is being used.
However Mac OS X also supports UFS volumes, those are case sensitive on Mac
OS X just like they are on any Unix.
 「<A HREF="manual.ja_Introduction.html#Extensions_to_ANSI">1.7.3  MySQL の ANSI SQL92 に対する拡張</A>」節参照.

</P>
<P>
<STRONG>注意</STRONG>: Windows ではデータベース名とファイル名はケース非依存ですが、
同じクエリ内で、データベースやテーブルを異なるケースを使用して参照すべき
ではありません。
以下のクエリは動きません。なぜなら <CODE>my_table</CODE> と <CODE>MY_TABLE</CODE> の両方を
参照しているからです：

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE MY_TABLE.col=1;
</PRE>

<P>
フィールド名とフィールドの別名は全ての場合でケース非依存です。

</P>
<P>
テーブルの別名はケース依存です。
以下のクエリは動きません。なぜなら <CODE>a</CODE> と <CODE>A</CODE> のエイリアスを両方
参照しているからです：

</P>

<PRE>
mysql&#62; SELECT col_name FROM tbl_name AS a
    -&#62;                 WHERE a.col_name = 1 OR A.col_name = 2;
</PRE>

<P>
テーブル名に使用されたケースを覚えておくことに問題があるなら、常にデータベー
スとテーブルに小文字の名前をつけるというような、一貫した慣習を採用してくだ
さい。

</P>
<P>
この問題を回避する一つの方法は、<CODE>mysqld</CODE> を <CODE>-O
lower_case_table_names=1</CODE> をつけて起動することです。デフォルトではこのオプ
ションは Windows では 1 で UNIX では 0 です。

</P>
<P>
<CODE>lower_case_table_names</CODE> が 1 の場合、MySQL はディスク上のす
べてのテーブル名を小文字に変換して検索します。
(From version 4.0.2, this option also applies to database names.)
注意: このオプションを変更し
た場合、<CODE>mysqld</CODE> を起動する前に、最初に古いテーブル名を小文字に変換す
ることが必要です。

</P>
<P>
If you move <CODE>MyISAM</CODE> files from a Windows to a Unix disk, you may
in some cases need to use the <TT>`mysql_fix_extensions'</TT> tool to fix-up
the case of the file extensions in each specified database directory
(lowercase <TT>`.frm'</TT>, uppercase <TT>`.MYI'</TT> and <TT>`.MYD'</TT>).
<TT>`mysql_fix_extensions'</TT> can be found in the <TT>`scripts'</TT> subdirectory.

</P>



<H3><A NAME="Variables" HREF="manual.ja_toc.html#Variables">6.1.4  ユーザー変数</A></H3>

<P>
<A NAME="IDX996"></A>
<A NAME="IDX997"></A>
<A NAME="IDX998"></A>

</P>
<P>
MySQL は、<CODE>@variablename</CODE> 構文で接続固有の変数をサポー
トします。変数名は現在の文字セットのアルファベットと数字、それに 
<SAMP>`_'</SAMP>、<SAMP>`$'</SAMP>、<SAMP>`.'</SAMP> 文字からなります。デフォルト文字セットは 
ISO-8859-1 Latin1 です。
これは <CODE>mysqld</CODE> に <CODE>--default-character-set</CODE> オプションを
与えることで変更できます. (3.23.14 以上の場合のみ。
それ以前のバージョンでは MySQL 再コンパイルが必要)
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Character_sets">4.6.1  データとソートに使用されるキャラクター・セット</A>」節参照.

</P>
<P>
変数は初期化する必要はありません。デフォルトでは <CODE>NULL</CODE> であり、整数
値、実数値、文字列値を格納できます。すべてのスレッド変数は、スレッドが終了
すると自動的に解放されます。

</P>
<P>
<CODE>SET</CODE> 構文で変数を設定できます:

</P>

<PRE>
SET @variable= { integer expression | real expression | string expression }
[,@variable= ...].
</PRE>

<P>
<CODE>SET</CODE> 構文で、式中で変数を設定することも可能です。
However, in this case the assignment operator is <CODE>:=</CODE> rather than
<CODE>=</CODE>, because <CODE>=</CODE> is reserved for comparisons in non-<CODE>SET</CODE>
statements:

</P>

<PRE>
mysql&#62; SELECT @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;
+----------------------+------+------+------+
| @t1:=(@t2:=1)+@t3:=4 | @t1  | @t2  | @t3  |
+----------------------+------+------+------+
|                    5 |    5 |    1 |    4 |
+----------------------+------+------+------+
</PRE>

<P>
(我々は <CODE>:=</CODE> 構文を使用する必要がありました。<CODE>=</CODE> は比較のために
予約されていたからです。)

</P>
<P>
ユーザー変数は式が許される場所で使用できます。注意: これは現在、
<CODE>SELECT</CODE> ステートメントの <CODE>LIMIT</CODE> 節、<CODE>LOAD DATA</CODE> ステート
メントの <CODE>IGNORE number LINES</CODE> 節のように、数値が明示的に要求される文
脈での使用を含みません。

</P>
<P>
<STRONG>注意</STRONG>: <CODE>SELECT</CODE> ステートメントでは、それぞれの式はクライアン
トに送られた時にだけ評価されます。これは、<CODE>SELECT</CODE> 部で設定された変数
を必要とする式を参照する <CODE>HAVING</CODE>, <CODE>GROUP BY</CODE>, <CODE>ORDER BY</CODE> 
節ができないことを意味します。例えば、次のステートメントは期待通りには動作
しません:

</P>

<PRE>
mysql&#62; SELECT (@aa:=id) AS a, (@aa+3) AS b FROM table_name HAVING b=5;
</PRE>

<P>
この理由は、<CODE>@aa</CODE> が現在のレコードの値ではなく、前に受け取ったレコー
ドの <CODE>id</CODE> の値になるからです。

</P>
<P>
The rule is to never assign <STRONG>and</STRONG> use the same variable in the same
statement.

</P>


<H3><A NAME="System_Variables" HREF="manual.ja_toc.html#System_Variables">6.1.5  System Variables</A></H3>

<P>
<A NAME="IDX999"></A>
<A NAME="IDX1000"></A>

</P>
<P>
Starting from MySQL 4.0.3 we provide better access to a lot of system
and connection variables. One can change most of them without having to take
down the server.

</P>
<P>
There are two kind of system variables: Thread-specific (or
connection-specific)
variables that are unique to the current connection and global variables
that are used to configure global events.
Global variables also are used to set up the initial values of the
corresponding thread-specific variables for new connections.

</P>
<P>
When <CODE>mysqld</CODE> starts, all global variables are initialised from command
line arguments and option files.  You can change the value with the
<CODE>SET GLOBAL</CODE> command. When a new thread is created, the thread-specific
variables are initialised from the global variables and they
will not change even if you issue a new <CODE>SET GLOBAL</CODE> command.

</P>
<P>
To set the value for a <CODE>GLOBAL</CODE> variable, you should use one
of the following syntaxes:
(Here we use <CODE>sort_buffer_size</CODE> as an example variable)

</P>

<PRE>
SET GLOBAL sort_buffer_size=value;
SET @@global.sort_buffer_size=value;
</PRE>

<P>
To set the value for a <CODE>SESSION</CODE> variable, you can use one of the
following syntaxes:

</P>

<PRE>
SET SESSION sort_buffer_size=value;
SET @@session.sort_buffer_size=value;
SET sort_buffer_size=value;
</PRE>

<P>
If you don't specify <CODE>GLOBAL</CODE> or <CODE>SESSION</CODE> then <CODE>SESSION</CODE>
is used.  「<A HREF="manual.ja_MySQL_Optimisation.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>LOCAL</CODE> is a synonym for <CODE>SESSION</CODE>.

</P>
<P>
To retrieve the value for a <CODE>GLOBAL</CODE> variable you can use one of the
following commands:

</P>

<PRE>
SELECT @@global.sort_buffer_size;
SHOW GLOBAL VARIABLES like 'sort_buffer_size';
</PRE>

<P>
To retrieve the value for a <CODE>SESSION</CODE> variable you can use one of the
following commands:

</P>

<PRE>
SELECT @@session.sort_buffer_size;
SHOW SESSION VARIABLES like 'sort_buffer_size';
</PRE>

<P>
When you <STRONG>retrieve</STRONG> a variable value with the
<CODE>@@variable_name</CODE> syntax and you don't specify <CODE>GLOBAL</CODE> or
<CODE>SESSION</CODE> then MySQL will return the thread-specific
(<CODE>SESSION</CODE>) value if it exists.  If not, MySQL will return the
global value.

</P>
<P>
The reason for requiring <CODE>GLOBAL</CODE> for setting <CODE>GLOBAL</CODE> only
variables but not for retrieving them is to ensure that we don't later
run into problems if we later would introduce a thread-specific variable
with the same name or remove a thread-specific variable.  In this case,
you could accidentally change the state for the server as a whole, rather than
just for your own connection.

</P>
<P>
The following is a full list of all variables that you change and retrieve
and if you can use <CODE>GLOBAL</CODE> or <CODE>SESSION</CODE> with them.

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Variable name</STRONG> </TD><TD> <STRONG>Value type</STRONG> </TD><TD> <STRONG>Type</STRONG>
</TR NOSAVE>
<TR><TD>autocommit </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>big_tables </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>binlog_cache_size </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>bulk_insert_buffer_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>concurrent_insert </TD><TD> bool </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>connect_timeout </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>convert_character_set </TD><TD> string </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>delay_key_write </TD><TD> OFF | ON | ALL </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>delayed_insert_limit </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>delayed_insert_timeout </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>delayed_queue_size </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>error_count </TD><TD> num </TD><TD> LOCAL
</TR NOSAVE>
<TR><TD>flush </TD><TD> bool </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>flush_time </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>foreign_key_checks </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>identity </TD><TD> num </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>insert_id </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>interactive_timeout </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>join_buffer_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>key_buffer_size </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>last_insert_id </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>local_infile </TD><TD> bool </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>log_warnings </TD><TD> bool </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>long_query_time </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>low_priority_updates </TD><TD> bool </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>max_allowed_packet </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>max_binlog_cache_size </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>max_binlog_size </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>max_connect_errors </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>max_connections </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>max_error_count </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>max_delayed_threads </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>max_heap_table_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>max_join_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>max_sort_length </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>max_tmp_tables </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>max_user_connections </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>max_write_lock_count </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>myisam_max_extra_sort_file_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>myisam_max_sort_file_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>myisam_sort_buffer_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>net_buffer_length </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>net_read_timeout </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>net_retry_count </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>net_write_timeout </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>query_cache_limit </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>query_cache_size </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>query_cache_type </TD><TD> enum </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>read_buffer_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>read_rnd_buffer_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>rpl_recovery_rank </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>safe_show_database </TD><TD> bool </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>server_id </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>slave_compressed_protocol </TD><TD> bool </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>slave_net_timeout </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>slow_launch_time </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>sort_buffer_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>sql_auto_is_null </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_big_selects </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_big_tables </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_buffer_result </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_log_binlog </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_log_off </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_log_update </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_low_priority_updates </TD><TD> bool </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>sql_max_join_size </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>sql_quote_show_create </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_safe_updates </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_select_limit </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>sql_slave_skip_counter </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>sql_warnings </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>table_cache </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>table_type </TD><TD> enum </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>thread_cache_size </TD><TD> num </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>timestamp </TD><TD> bool </TD><TD> SESSION
</TR NOSAVE>
<TR><TD>tmp_table_size </TD><TD> enum </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>tx_isolation </TD><TD> enum </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>version </TD><TD> string </TD><TD> GLOBAL
</TR NOSAVE>
<TR><TD>wait_timeout </TD><TD> num </TD><TD> GLOBAL | SESSION
</TR NOSAVE>
<TR><TD>warning_count </TD><TD> num </TD><TD> LOCAL
</TR NOSAVE>
<TR><TD>unique_checks </TD><TD> bool </TD><TD> SESSION
</TR>
</TABLE>

<P>
Variables that are marked with <CODE>num</CODE> can be given a numerical
value. Variables that are marked with <CODE>bool</CODE> can be set to 0, 1,
<CODE>ON</CODE> or <CODE>OFF</CODE>. Variables that are of type <CODE>enum</CODE> should
normally be set to one of the available values for the variable, but can
also be set to the number that correspond to the enum value. (The first
enum value is 0).

</P>
<P>
Here is a description of some of the variables:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Variable</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD>identity </TD><TD> Alias for last_insert_id (Sybase compatiblity)
</TR NOSAVE>
<TR><TD>sql_low_priority_updates </TD><TD> Alias for low_priority_updates
</TR NOSAVE>
<TR><TD>sql_max_join_size </TD><TD> Alias for max_join_size
</TR NOSAVE>
<TR><TD>delay_key_write_for_all_tables </TD><TD> If this and delay_key_write are set, then all new MyISAM tables that are opened will use delayed key writes.
</TR NOSAVE>
<TR><TD>version </TD><TD> Alias for VERSION() (Sybase (?) compatability)
</TR>
</TABLE>

<P>
A description of the other variable definitions can be found in the
startup options section, the description of <CODE>SHOW VARIABLES</CODE> and in
the <CODE>SET</CODE> section.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Command-line_options">4.1.1  <CODE>mysqld</CODE> コマンド行オプション</A>」節参照.   「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.  「<A HREF="manual.ja_MySQL_Optimisation.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節参照.

</P>



<H3><A NAME="Comments" HREF="manual.ja_toc.html#Comments">6.1.6  コメント 構文</A></H3>

<P>
<A NAME="IDX1001"></A>

</P>
<P>
<A NAME="IDX1002"></A>

</P>
<P>
MySQL は <CODE># 行末まで</CODE> , <CODE>-- 行末まで</CODE> そして <CODE>/* 
行中または複数行 */</CODE> コメント書式をサポートします:

</P>

<PRE>
mysql&#62; SELECT 1+1;     # このコメントは行末まで続く
mysql&#62; SELECT 1+1;     -- このコメントは行末まで続く
mysql&#62; SELECT 1 /* これは行中コメント */ + 1;
mysql&#62; SELECT 1+
/*
これは
複数行コメント
*/
1;
</PRE>

<P>
<CODE>--</CODE> コメントスタイルは <CODE>--</CODE> の後ろに最低一つのスペースが
必要であることに注意！

</P>
<P>
サーバーはコメント構文を理解しますが、 <CODE>mysql</CODE> クライアントが
 <CODE>/* ... */</CODE> コメントを分析するにはいくつか制限があります：

</P>

<UL>
<LI>

シングルクウォートとダブルクオート文字は引用文字列のトークンの開始を
示します。たとえコメントの中であっても。
もしコメントの中でクオートが二つ目のクオートにマッチしなかった場合、
パーサーはコメントが終了していないと認識します。
<CODE>mysql</CODE> を対話モードで実行している場合、
プロンプトが <CODE>mysql&#62;</CODE> から <CODE>'&#62;</CODE> か <CODE>"&#62;</CODE> に変わります。

<LI>

セミコロンは SQL 構文の終了を示し、これに続く文字は次の構文の開始と
なります。
</UL>

<P>
これらの制限は <CODE>mysql</CODE> を対話モードで実行している場合と、
<CODE>mysql</CODE> にファイルを読み込ませている場合 ( <CODE>mysql &#60; some-file</CODE> ) の
両方で現れます。

</P>
<P>
MySQL は ANSI SQL コメントの <SAMP>`--'</SAMP> をサポートしません。
 「<A HREF="manual.ja_Introduction.html#ANSI_diff_comments">1.7.4.7  コメント開始としての <SAMP>`--'</SAMP></A>」節参照.

</P>



<H3><A NAME="Reserved_words" HREF="manual.ja_toc.html#Reserved_words">6.1.7  Is MySQL Picky About Reserved Words?</A></H3>

<P>
<A NAME="IDX1003"></A>
<A NAME="IDX1004"></A>

</P>
<P>
共通の問題は、フィールドの名前を、 <CODE>TIMESTAMP</CODE> とか <CODE>GROUP</CODE> とかの
 MySQL に埋め込まれているデータ型や関数名と同名にして、
テーブルを作った場合に起こります。
このようなことは行えます(例えば <CODE>ABS</CODE> はフィールド名にできます)。
しかし、関数として使用する場合、
この名前がフィールド名として使用されているなら、
関数名と <SAMP>`('</SAMP> の間の空白は許されません。

</P>
<P>
以下の語は MySQL に予約されています。
これらのほとんどは、 ANSI SQL92 によって、
テーブル、フィールド名としての使用は禁止されています。(例えば <CODE>GROUP</CODE>)。
またいくつかの語は MySQL が必要とし、 <CODE>yacc</CODE> パーサーで
使用しているので予約されています。

</P>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Word</STRONG>
 </TD><TD> <STRONG>Word</STRONG>
 </TD><TD> <STRONG>Word</STRONG>
</TR NOSAVE>
<TR><TD><CODE>ADD</CODE>
 </TD><TD> <CODE>ALL</CODE>
 </TD><TD> <CODE>ALTER</CODE>
</TR NOSAVE>
<TR><TD><CODE>ANALYZE</CODE>
 </TD><TD> <CODE>AND</CODE>
 </TD><TD> <CODE>AS</CODE>
</TR NOSAVE>
<TR><TD><CODE>ASC</CODE>
 </TD><TD> <CODE>AUTO_INCREMENT</CODE>
 </TD><TD> <CODE>BDB</CODE>
</TR NOSAVE>
<TR><TD><CODE>BEFORE</CODE>
 </TD><TD> <CODE>BERKELEYDB</CODE>
 </TD><TD> <CODE>BETWEEN</CODE>
</TR NOSAVE>
<TR><TD><CODE>BIGINT</CODE>
 </TD><TD> <CODE>BINARY</CODE>
 </TD><TD> <CODE>BLOB</CODE>
</TR NOSAVE>
<TR><TD><CODE>BOTH</CODE>
 </TD><TD> <CODE>BTREE</CODE>
 </TD><TD> <CODE>BY</CODE>
</TR NOSAVE>
<TR><TD><CODE>CASCADE</CODE>
 </TD><TD> <CODE>CASE</CODE>
 </TD><TD> <CODE>CHANGE</CODE>
</TR NOSAVE>
<TR><TD><CODE>CHAR</CODE>
 </TD><TD> <CODE>CHARACTER</CODE>
 </TD><TD> <CODE>CHECK</CODE>
</TR NOSAVE>
<TR><TD><CODE>COLLATE</CODE>
 </TD><TD> <CODE>COLUMN</CODE>
 </TD><TD> <CODE>COLUMNS</CODE>
</TR NOSAVE>
<TR><TD><CODE>CONSTRAINT</CODE>
 </TD><TD> <CODE>CREATE</CODE>
 </TD><TD> <CODE>CROSS</CODE>
</TR NOSAVE>
<TR><TD><CODE>CURRENT_DATE</CODE>
 </TD><TD> <CODE>CURRENT_TIME</CODE>
 </TD><TD> <CODE>CURRENT_TIMESTAMP</CODE>
</TR NOSAVE>
<TR><TD><CODE>DATABASE</CODE>
 </TD><TD> <CODE>DATABASES</CODE>
 </TD><TD> <CODE>DAY_HOUR</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY_MINUTE</CODE>
 </TD><TD> <CODE>DAY_SECOND</CODE>
 </TD><TD> <CODE>DEC</CODE>
</TR NOSAVE>
<TR><TD><CODE>DECIMAL</CODE>
 </TD><TD> <CODE>DEFAULT</CODE>
 </TD><TD> <CODE>DELAYED</CODE>
</TR NOSAVE>
<TR><TD><CODE>DELETE</CODE>
 </TD><TD> <CODE>DESC</CODE>
 </TD><TD> <CODE>DESCRIBE</CODE>
</TR NOSAVE>
<TR><TD><CODE>DISTINCT</CODE>
 </TD><TD> <CODE>DISTINCTROW</CODE>
 </TD><TD> <CODE>DIV</CODE>
</TR NOSAVE>
<TR><TD><CODE>DOUBLE</CODE>
 </TD><TD> <CODE>DROP</CODE>
 </TD><TD> <CODE>ELSE</CODE>
</TR NOSAVE>
<TR><TD><CODE>ENCLOSED</CODE>
 </TD><TD> <CODE>ERRORS</CODE>
 </TD><TD> <CODE>ESCAPED</CODE>
</TR NOSAVE>
<TR><TD><CODE>EXISTS</CODE>
 </TD><TD> <CODE>EXPLAIN</CODE>
 </TD><TD> <CODE>FALSE</CODE>
</TR NOSAVE>
<TR><TD><CODE>FIELDS</CODE>
 </TD><TD> <CODE>FLOAT</CODE>
 </TD><TD> <CODE>FOR</CODE>
</TR NOSAVE>
<TR><TD><CODE>FORCE</CODE>
 </TD><TD> <CODE>FOREIGN</CODE>
 </TD><TD> <CODE>FROM</CODE>
</TR NOSAVE>
<TR><TD><CODE>FULLTEXT</CODE>
 </TD><TD> <CODE>FUNCTION</CODE>
 </TD><TD> <CODE>GRANT</CODE>
</TR NOSAVE>
<TR><TD><CODE>GROUP</CODE>
 </TD><TD> <CODE>HASH</CODE>
 </TD><TD> <CODE>HAVING</CODE>
</TR NOSAVE>
<TR><TD><CODE>HIGH_PRIORITY</CODE>
 </TD><TD> <CODE>HOUR_MINUTE</CODE>
 </TD><TD> <CODE>HOUR_SECOND</CODE>
</TR NOSAVE>
<TR><TD><CODE>IF</CODE>
 </TD><TD> <CODE>IGNORE</CODE>
 </TD><TD> <CODE>IN</CODE>
</TR NOSAVE>
<TR><TD><CODE>INDEX</CODE>
 </TD><TD> <CODE>INFILE</CODE>
 </TD><TD> <CODE>INNER</CODE>
</TR NOSAVE>
<TR><TD><CODE>INNODB</CODE>
 </TD><TD> <CODE>INSERT</CODE>
 </TD><TD> <CODE>INT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INTEGER</CODE>
 </TD><TD> <CODE>INTERVAL</CODE>
 </TD><TD> <CODE>INTO</CODE>
</TR NOSAVE>
<TR><TD><CODE>IS</CODE>
 </TD><TD> <CODE>JOIN</CODE>
 </TD><TD> <CODE>KEY</CODE>
</TR NOSAVE>
<TR><TD><CODE>KEYS</CODE>
 </TD><TD> <CODE>KILL</CODE>
 </TD><TD> <CODE>LEADING</CODE>
</TR NOSAVE>
<TR><TD><CODE>LEFT</CODE>
 </TD><TD> <CODE>LIKE</CODE>
 </TD><TD> <CODE>LIMIT</CODE>
</TR NOSAVE>
<TR><TD><CODE>LINES</CODE>
 </TD><TD> <CODE>LOAD</CODE>
 </TD><TD> <CODE>LOCALTIME</CODE>
</TR NOSAVE>
<TR><TD><CODE>LOCALTIMESTAMP</CODE>
 </TD><TD> <CODE>LOCK</CODE>
 </TD><TD> <CODE>LONG</CODE>
</TR NOSAVE>
<TR><TD><CODE>LONGBLOB</CODE>
 </TD><TD> <CODE>LONGTEXT</CODE>
 </TD><TD> <CODE>LOW_PRIORITY</CODE>
</TR NOSAVE>
<TR><TD><CODE>MASTER_SERVER_ID</CODE>
 </TD><TD> <CODE>MATCH</CODE>
 </TD><TD> <CODE>MEDIUMBLOB</CODE>
</TR NOSAVE>
<TR><TD><CODE>MEDIUMINT</CODE>
 </TD><TD> <CODE>MEDIUMTEXT</CODE>
 </TD><TD> <CODE>MIDDLEINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>MINUTE_SECOND</CODE>
 </TD><TD> <CODE>MOD</CODE>
 </TD><TD> <CODE>MRG_MYISAM</CODE>
</TR NOSAVE>
<TR><TD><CODE>NATURAL</CODE>
 </TD><TD> <CODE>NOT</CODE>
 </TD><TD> <CODE>NULL</CODE>
</TR NOSAVE>
<TR><TD><CODE>NUMERIC</CODE>
 </TD><TD> <CODE>ON</CODE>
 </TD><TD> <CODE>OPTIMIZE</CODE>
</TR NOSAVE>
<TR><TD><CODE>OPTION</CODE>
 </TD><TD> <CODE>OPTIONALLY</CODE>
 </TD><TD> <CODE>OR</CODE>
</TR NOSAVE>
<TR><TD><CODE>ORDER</CODE>
 </TD><TD> <CODE>OUTER</CODE>
 </TD><TD> <CODE>OUTFILE</CODE>
</TR NOSAVE>
<TR><TD><CODE>PRECISION</CODE>
 </TD><TD> <CODE>PRIMARY</CODE>
 </TD><TD> <CODE>PRIVILEGES</CODE>
</TR NOSAVE>
<TR><TD><CODE>PROCEDURE</CODE>
 </TD><TD> <CODE>PURGE</CODE>
 </TD><TD> <CODE>READ</CODE>
</TR NOSAVE>
<TR><TD><CODE>REAL</CODE>
 </TD><TD> <CODE>REFERENCES</CODE>
 </TD><TD> <CODE>REGEXP</CODE>
</TR NOSAVE>
<TR><TD><CODE>RENAME</CODE>
 </TD><TD> <CODE>REPLACE</CODE>
 </TD><TD> <CODE>REQUIRE</CODE>
</TR NOSAVE>
<TR><TD><CODE>RESTRICT</CODE>
 </TD><TD> <CODE>RETURNS</CODE>
 </TD><TD> <CODE>REVOKE</CODE>
</TR NOSAVE>
<TR><TD><CODE>RIGHT</CODE>
 </TD><TD> <CODE>RLIKE</CODE>
 </TD><TD> <CODE>RTREE</CODE>
</TR NOSAVE>
<TR><TD><CODE>SELECT</CODE>
 </TD><TD> <CODE>SET</CODE>
 </TD><TD> <CODE>SHOW</CODE>
</TR NOSAVE>
<TR><TD><CODE>SMALLINT</CODE>
 </TD><TD> <CODE>SOME</CODE>
 </TD><TD> <CODE>SONAME</CODE>
</TR NOSAVE>
<TR><TD><CODE>SPATIAL</CODE>
 </TD><TD> <CODE>SQL_BIG_RESULT</CODE>
 </TD><TD> <CODE>SQL_CALC_FOUND_ROWS</CODE>
</TR NOSAVE>
<TR><TD><CODE>SQL_SMALL_RESULT</CODE>
 </TD><TD> <CODE>SSL</CODE>
 </TD><TD> <CODE>STARTING</CODE>
</TR NOSAVE>
<TR><TD><CODE>STRAIGHT_JOIN</CODE>
 </TD><TD> <CODE>STRIPED</CODE>
 </TD><TD> <CODE>TABLE</CODE>
</TR NOSAVE>
<TR><TD><CODE>TABLES</CODE>
 </TD><TD> <CODE>TERMINATED</CODE>
 </TD><TD> <CODE>THEN</CODE>
</TR NOSAVE>
<TR><TD><CODE>TINYBLOB</CODE>
 </TD><TD> <CODE>TINYINT</CODE>
 </TD><TD> <CODE>TINYTEXT</CODE>
</TR NOSAVE>
<TR><TD><CODE>TO</CODE>
 </TD><TD> <CODE>TRAILING</CODE>
 </TD><TD> <CODE>TRUE</CODE>
</TR NOSAVE>
<TR><TD><CODE>TYPES</CODE>
 </TD><TD> <CODE>UNION</CODE>
 </TD><TD> <CODE>UNIQUE</CODE>
</TR NOSAVE>
<TR><TD><CODE>UNLOCK</CODE>
 </TD><TD> <CODE>UNSIGNED</CODE>
 </TD><TD> <CODE>UPDATE</CODE>
</TR NOSAVE>
<TR><TD><CODE>USAGE</CODE>
 </TD><TD> <CODE>USE</CODE>
 </TD><TD> <CODE>USER_RESOURCES</CODE>
</TR NOSAVE>
<TR><TD><CODE>USING</CODE>
 </TD><TD> <CODE>VALUES</CODE>
 </TD><TD> <CODE>VARBINARY</CODE>
</TR NOSAVE>
<TR><TD><CODE>VARCHAR</CODE>
 </TD><TD> <CODE>VARCHARACTER</CODE>
 </TD><TD> <CODE>VARYING</CODE>
</TR NOSAVE>
<TR><TD><CODE>WARNINGS</CODE>
 </TD><TD> <CODE>WHEN</CODE>
 </TD><TD> <CODE>WHERE</CODE>
</TR NOSAVE>
<TR><TD><CODE>WITH</CODE>
 </TD><TD> <CODE>WRITE</CODE>
 </TD><TD> <CODE>XOR</CODE>
</TR NOSAVE>
<TR><TD><CODE>YEAR_MONTH</CODE>
 </TD><TD> <CODE>ZEROFILL</CODE>
 </TD><TD> </TR>
</TABLE>

<P>
The following symbols (from the table above) are disallowed by ANSI SQL
but allowed by MySQL as column/table names. This is because some
of these names are very natural names and a lot of people have already
used them.

</P>

<UL>
<LI><CODE>ACTION</CODE>

<LI><CODE>BIT</CODE>

<LI><CODE>DATE</CODE>

<LI><CODE>ENUM</CODE>

<LI><CODE>NO</CODE>

<LI><CODE>TEXT</CODE>

<LI><CODE>TIME</CODE>

<LI><CODE>TIMESTAMP</CODE>

</UL>



<H2><A NAME="Column_types" HREF="manual.ja_toc.html#Column_types">6.2  フィールド型</A></H2>

<P>
<A NAME="IDX1005"></A>
<A NAME="IDX1006"></A>

</P>
<P>
MySQLは多くのフィールド型をサポートしており、それらは３つのカテゴリに
グループ化されます: 数値型、日付及び時間型、そして文字列(文字)型。
この章ではまず、利用できる型の概要から始まり、それから各カテゴリの各フィールド
型の所要記憶容量の要約と、型の属性についてのより詳細な情報を提供します。
概要は意図的に簡潔にまとめています。値として指定できる書式のようなフィールド
型固有の付加情報は、詳細の説明部にて調べて下さい。

</P>
<P>
MySQLでサポートされるフィールド型は以下に示す通りです。
後に続く文字の意味は説明のために使われます:

</P>
<P>
<A NAME="IDX1007"></A>
<A NAME="IDX1008"></A>
<A NAME="IDX1009"></A>
<A NAME="IDX1010"></A>
<A NAME="IDX1011"></A>
<A NAME="IDX1012"></A>
<DL COMPACT>

<DT><CODE>M</CODE>
<DD>
最大表示サイズを意味します。最大の表示桁数は 255.

<DT><CODE>D</CODE>
<DD>
浮動小数点数型に適用され、小数点以下の桁数を表します。
最大の値は 30 ですが、これは <CODE>M</CODE>-2 より大きくなってはいけません。
</DL>

<P>
中カッコ(<SAMP>`['</SAMP>及び<SAMP>`]'</SAMP>)は型定義の一部であり、それがオプションであることを
表します。

</P>
<P>
<A NAME="IDX1013"></A>

</P>

<P>
もしあるフィールドに <CODE>ZEROFILL</CODE> を指定した場合、
 MySQL は自動で <CODE>UNSIGNED</CODE> 属性をそのフィールドに
追加します。

</P>
<P>
<STRONG>Warning</STRONG>: you should be aware that when you use subtraction
between integer values where one is of type <CODE>UNSIGNED</CODE>, the result
will be unsigned!  「<A HREF="manual.ja_Reference.html#Cast_Functions">6.3.5  Cast Functions</A>」節参照.

</P>
<DL COMPACT>

<DT><CODE>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
<A NAME="IDX1014"></A>
 

とても小さい整数。符号つきの範囲は <CODE>-128</CODE>〜<CODE>127</CODE>。符号なしの範囲は
<CODE>0</CODE>〜<CODE>255</CODE>。

<A NAME="IDX1015"></A>
<A NAME="IDX1016"></A>
<DT><CODE>BIT</CODE>
<DD>
<DT><CODE>BOOL</CODE>
<DD>
These are synonyms for <CODE>TINYINT(1)</CODE>.

<A NAME="IDX1017"></A>
<DT><CODE>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
小さい整数。符号つきの範囲は <CODE>-32768</CODE>〜<CODE>32767</CODE>。
符号なしの範囲は <CODE>0</CODE>〜<CODE>65535</CODE>。

<A NAME="IDX1018"></A>
<DT><CODE>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
中間の整数。符号ありの範囲は <CODE>-8388608</CODE>〜<CODE>8388607</CODE>。
符号なしの範囲は <CODE>0</CODE>〜<CODE>16777215</CODE>

<A NAME="IDX1019"></A>
<DT><CODE>INT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
通常の整数。符号ありの範囲は <CODE>-2147483648</CODE>〜<CODE>2147483647</CODE>。符号なしの範
囲は <CODE>0</CODE>〜<CODE>4294967295</CODE>

<A NAME="IDX1020"></A>
<DT><CODE>INTEGER[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
これは、<CODE>INT</CODE>の同義語です。

<A NAME="IDX1021"></A>
<DT><CODE>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
大きい整数。
符号ありの範囲は <CODE>-9223372036854775808</CODE>〜<CODE>9223372036854775807</CODE>。
符号なしの範囲は <CODE>0</CODE>〜<CODE>18446744073709551615</CODE>。

<CODE>BIGINT</CODE> フィールドについて意識すべきことのいくつか:


<UL>
<LI>

<A NAME="IDX1022"></A>
全ての演算は符合付き <CODE>BIGINT</CODE> または <CODE>DOUBLE</CODE> で行われるため、
符合無しの <CODE>9223372036854775807</CODE> (63 bits) よりも大きな整数を
ビット関数以外で使用すべきではありません！
それを行なうと、結果の最後の桁のいくつかは不正になるでしょう
<CODE>BIGINT</CODE> を <CODE>DOUBLE</CODE> に変換する時の丸めエラーのためです。

MySQL 4.0 can handle <CODE>BIGINT</CODE> in the following cases:

<UL>
<LI>

Use integers to store big unsigned values in a <CODE>BIGINT</CODE> column.
<LI>

In <CODE>MIN(big_int_column)</CODE> and <CODE>MAX(big_int_column)</CODE>.
<LI>

When using operators (<CODE>+</CODE>, <CODE>-</CODE>, <CODE>*</CODE>, etc.) where
both operands are integers.
</UL>

<LI>

文字列として格納することで <CODE>BIGINT</CODE> フィールドの正確な整数値を常に格
納することができます。この場合、double 表現を介在しません。

<LI>

<CODE>-</CODE>、<CODE>+</CODE>及び<CODE>*</CODE>は、両方の引数が<CODE>INTEGER</CODE>値の時、
<CODE>BIGINT</CODE>演算を使うことに注意して下さい！ これは、２つの大きな整数の
かけ算を行なう(又は整数を返す関数の結果が大きな整数である)時、
結果が<CODE>9223372036854775807</CODE>よりも大きい場合に予期しない結果を
受け取ることがあるということを意味しています。
</UL>

<A NAME="IDX1023"></A>
<A NAME="IDX1024"></A>
<A NAME="IDX1025"></A>
<DT><CODE>FLOAT(precision) [UNSIGNED] [ZEROFILL]</CODE>
<DD>
浮動小数点数。Version 4.0 未満では符号なしにはできません。単精度浮動小数点数では 
<CODE>precision</CODE> が <CODE>&#60;=24</CODE> で、倍精度浮動小数点数では 25〜53 の間です。
これらの型は次で述べる<CODE>FLOAT</CODE>や<CODE>DOUBLE</CODE>型に似ています。
<CODE>FLOAT(X)</CODE>は、<CODE>FLOAT</CODE>及び<CODE>DOUBLE</CODE>型に一致する同じ範囲を持っていま
すが、
表示サイズや小数点以下桁数が定義されません。

MySQL バージョン 3.23 では、これは正しい浮動小数点です。前の 
MySQL バージョンでは, <CODE>FLOAT(precision)</CODE> は常に小数部は2桁で
した。

注意: <CODE>FLOAT</CODE> の使用は、MySQL での全ての演算が double 精度で行
なわれるため、いくつかの予期しない問題が起こり得ます。
 「<A HREF="manual.ja_Problems.html#No_matching_rows">A.5.6  Solving Problems with No Matching Rows</A>」節参照.

<A NAME="IDX1026"></A>
<A NAME="IDX1027"></A>
この構文は ODBC 互換です。

<A NAME="IDX1028"></A>
<A NAME="IDX1029"></A>
<DT><CODE>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
小さい浮動小数点数。Version 4.0 未満では符号なしにはできません。
範囲は <CODE>-3.402823466E+38</CODE>〜<CODE>-1.175494351E-38</CODE>、 <CODE>0</CODE>、
<CODE>1.175494351E-38</CODE>〜<CODE>3.402823466E+38</CODE>です。
Version 4.0 以上では、If
<CODE>UNSIGNED</CODE> is specified, negative values are disallowed.
<CODE>M</CODE> は表示幅で <CODE>D</CODE> は小数部桁数です。引数が無いか引数が24以下の <CODE>FLOAT</CODE> 
は単精度浮動小数点数を意味します。

<A NAME="IDX1030"></A>
<A NAME="IDX1031"></A>
<DT><CODE>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
通常の浮動小数点数。Version 4.0 未満では符号なしにはできません。
範囲は <CODE>-1.7976931348623157E+308</CODE>〜<CODE>-2.2250738585072014E-308</CODE>
、 <CODE>0</CODE>、<CODE>2.2250738585072014E-308</CODE>〜<CODE>1.7976931348623157E+308</CODE>です。
Version 4.0 以上では、If
<CODE>UNSIGNED</CODE> is specified, negative values are disallowed.
<CODE>M</CODE> は表示幅で <CODE>D</CODE> は小数部桁数です。引数が無いか <CODE>DOUBLE</CODE> か、
25 &#60;= <CODE>X</CODE> &#60;= 53 である <CODE>FLOAT(X)</CODE> は倍精度浮動小数点数を意味します。

<A NAME="IDX1032"></A>
<A NAME="IDX1033"></A>
<DT><CODE>DOUBLE PRECISION[(M,D)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
<DT><CODE>REAL[(M,D)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
これらは<CODE>DOUBLE</CODE>の同義語です。

<A NAME="IDX1034"></A>
<DT><CODE>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
パック無し浮動小数点数。Version 4.0 未満では符号なしにはできません。<CODE>CHAR</CODE>フィールドのように振
舞います。`パック無し'は、数値が文字列として格納されることを意味し、数値のそれぞ
れの桁、小数点、及び負数での<SAMP>`-'</SAMP>符号に１文字使用します。
<CODE>D</CODE>が0の時、値は小数点や小数部を持ちません。<CODE>DECIMAL</CODE>値の最大範囲は
<CODE>DOUBLE</CODE>と同じですが、実際の範囲は<CODE>DECIMAL</CODE>フィールドに与えられた<CODE>M</CODE>
及び<CODE>D</CODE>の選択に強制されます。
Version 4.0 以上では、If <CODE>UNSIGNED</CODE> is specified, negative values are disallowed.

<CODE>D</CODE> を省略した場合は 0 に設定されます。<CODE>M</CODE> を省略した場合は 
10 に設定されます。

MySQL 3.22 以下では、 <CODE>M</CODE> 引数は符号や小数点を含みます。 

<A NAME="IDX1035"></A>
<A NAME="IDX1036"></A>
<DT><CODE>DEC[(M[,D])] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
<DT><CODE>NUMERIC[(M[,D])] [UNSIGNED] [ZEROFILL]</CODE>
<DD>
<CODE>DECIMAL</CODE>と同じ。

<A NAME="IDX1037"></A>
<DT><CODE>DATE</CODE>
<DD>
日付。サポートされる範囲は<CODE>'1000-01-01'</CODE>から<CODE>'9999-12-31'</CODE>まで。
MySQL は<CODE>'YYYY-MM-DD'</CODE>の書式で<CODE>DATE</CODE>値を表示しますが、<CODE>DATE</CODE>
フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。
 「<A HREF="manual.ja_Reference.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A>」節参照.

<A NAME="IDX1038"></A>
<DT><CODE>DATETIME</CODE>
<DD>
日付と時刻の組み合わせ。サポートされる範囲は<CODE>'1000-01-01 00:00:00'</CODE>〜
<CODE>'9999-12-31 23:59:59'</CODE>です。MySQLは<CODE>DATETIME</CODE>値を
<CODE>'YYYY-MM-DD HH:MM:SS'</CODE>という書式で表示しますが、<CODE>DATETIME</CODE>フィールド
への値の割当ては、文字列もしくは数値のいずれかの使用が許されます。
 「<A HREF="manual.ja_Reference.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A>」節参照.

<A NAME="IDX1039"></A>
<DT><CODE>TIMESTAMP[(M)]</CODE>
<DD>
タイムスタンプ。範囲は<CODE>'1970-01-01 00:00:00'</CODE>〜<CODE>2037</CODE>年末までです。
MySQL は<CODE>TIMESTAMP</CODE>値を<CODE>YYYYMMDDHHMMSS</CODE>、<CODE>YYMMDDHHMMSS</CODE>、
<CODE>YYYYMMDD</CODE>又は<CODE>YYMMDD</CODE>という書式で表示し、それは<CODE>M</CODE>に<CODE>14</CODE>(もし
くは誤ってそれ以上の値を指定した時)、<CODE>12</CODE>、<CODE>8</CODE>又は<CODE>6</CODE>のいずれが指
定されたかに依存します。しかしながら<CODE>TIMESTAMP</CODE>フィールドへの値の割当ては、
文字列もしくは数値のいずれかの使用が許されます。
<CODE>TIMESTAMP</CODE>フィールドは、最後に操作された時刻を自動的に設定するので、
<CODE>INSERT</CODE>や<CODE>UPDATE</CODE>操作の時刻を記録するのに役立ちます。
<CODE>NULL</CODE>値を与えることによっても、現在時刻を設定できます。
 「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節参照.

<CODE>TIMESTAMP</CODE> は常に 4 バイトで格納されます。<CODE>M</CODE> 引数は
<CODE>TIMESTAMP</CODE> フィールドがどのように表示されるかだけに影響します。

注意: X が 8 または 14 である <CODE>TIMESTAMP(X)</CODE> フィールドは数値として報
告されます。他の <CODE>TIMESTAMP(X)</CODE> フィールドは文字列として報告されます。
これは、これらの型を持ったテーブルを確実にダンプとリストアできるようにする
ためです！
 「<A HREF="manual.ja_Reference.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A>」節参照.

<A NAME="IDX1040"></A>
<DT><CODE>TIME</CODE>
<DD>
時間。範囲は<CODE>'-838:59:59'</CODE>〜<CODE>'838:59:59'</CODE>です。
MySQL は<CODE>TIME</CODE>値を<CODE>'HH:MM:SS'</CODE>という書式で表示しますが、<CODE>TIME</CODE>
フィールドへの値の割当ては、文字列もしくは数値のいずれかの使用が許されます。
 「<A HREF="manual.ja_Reference.html#TIME">6.2.2.3  <CODE>TIME</CODE> 型</A>」節参照.

<A NAME="IDX1041"></A>
<DT><CODE>YEAR[(2|4)]</CODE>
<DD>
年。2桁または4桁形式(デフォルトは4桁)。許される値は、4桁形式では 
<CODE>1901</CODE>〜<CODE>2155</CODE>, <CODE>0000</CODE> で、2桁形式(70〜69)では 1970〜2069 
です。MySQL は <CODE>YEAR</CODE> 値を <CODE>YYYY</CODE> 形式で表示しますが、
<CODE>YEAR</CODE> フィールドへの値の割り当ては文字列と数字のどちらでも使用できま
す。(<CODE>YEAR</CODE> は MySQL バージョン 3.22 以上での新しい型です。)
 「<A HREF="manual.ja_Reference.html#YEAR">6.2.2.4  <CODE>YEAR</CODE> 型</A>」節参照.

<A NAME="IDX1042"></A>
<A NAME="IDX1043"></A>
<A NAME="IDX1044"></A>
<A NAME="IDX1045"></A>
<DT><CODE>[NATIONAL] CHAR(M) [BINARY]</CODE>
<DD>
固定長文字列で、格納時には必ず指定された長さまで右側に空白を埋めます。
<CODE>M</CODE>の範囲は 0 から 255 文字です。
(MySQL Version 3.23 までは 1 から 255 です。)
後続の空白は値の取り出し時に削除され
ます。<CODE>BINARY</CODE> キーワードが与えられない場合、<CODE>CHAR</CODE> 値のソートと
比較は、デフォルト文字セットに従ってケース非依存の方法で行なわれます。

<CODE>NATIONAL CHAR</CODE> (短い形式は <CODE>NCHAR</CODE>) は、ANSI SQL で、CHAR フィー
ルドがデフォルト文字セットを使用することを定義する方法です。これは 
MySQL ではデフォルトです。

<CODE>CHAR</CODE> は <CODE>CHARACTER</CODE> の略記です。

MySQL は <CODE>CHAR(0)</CODE> 型のフィールドの生成を許します。これは主
に、実際にはもう値が使われていないフィールドが存在することに依存しているよ
うないくつかの古いアプリケーションに対応する必要がある時に便利です。２つの
値だけを取ることができるフィールドを必要とする時にもとても良いことです:
<CODE>NOT NULL</CODE> として定義されていない <CODE>CHAR(0)</CODE> は1ビットだけを占有
し、２つの値だけを取ることができます: <CODE>NULL</CODE> または <CODE>""</CODE>。
 「<A HREF="manual.ja_Reference.html#CHAR">6.2.3.1  <CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型</A>」節参照.

<DT><CODE>CHAR</CODE>
<DD>
This is a synonym for <CODE>CHAR(1)</CODE>.

<A NAME="IDX1046"></A>
<A NAME="IDX1047"></A>
<A NAME="IDX1048"></A>
<DT><CODE>[NATIONAL] VARCHAR(M) [BINARY]</CODE>
<DD>
可変長文字列。  注意:
後続の空白は格納時に削除されます(これは ANSI SQL 仕様と異なります)。
<CODE>M</CODE>の範囲は 0 から 255 文字です。
(MySQL Version 4.0.2 未満では 1 から 255 です)
<CODE>BINARY</CODE> キーワードが与えられない場合、ソートと比較はケースに依存しません。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

<CODE>VARCHAR</CODE> は <CODE>CHARACTER VARYING</CODE> の略記です。
 「<A HREF="manual.ja_Reference.html#CHAR">6.2.3.1  <CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型</A>」節参照.

<A NAME="IDX1049"></A>
<A NAME="IDX1050"></A>
<DT><CODE>TINYBLOB</CODE>
<DD>
<DT><CODE>TINYTEXT</CODE>
<DD>
最大長 255 (2^8 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.  「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<A NAME="IDX1051"></A>
<A NAME="IDX1052"></A>
<DT><CODE>BLOB</CODE>
<DD>
<DT><CODE>TEXT</CODE>
<DD>
最大長 65535 (2^16 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.  「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<A NAME="IDX1053"></A>
<A NAME="IDX1054"></A>
<DT><CODE>MEDIUMBLOB</CODE>
<DD>
<DT><CODE>MEDIUMTEXT</CODE>
<DD>
最大長 16777215 (2^24 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.  「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<A NAME="IDX1055"></A>
<A NAME="IDX1056"></A>
<DT><CODE>LONGBLOB</CODE>
<DD>
<DT><CODE>LONGTEXT</CODE>
<DD>
最大長 4294967295 (2^32 - 1) 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照。注意: サーバ／クライアントプロトコルと 
MyISAM テーブルは、通信パケット単位 / テーブルレコードで、現在 16M の制限
があるため、この型の範囲全体はまだ使用できません。 「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照。

<A NAME="IDX1057"></A>
<DT><CODE>ENUM('value1','value2',...)</CODE>
<DD>
列挙。
対象となる文字列は、値を一つだけ持ち、値リスト<CODE>'value1', 'value2',...</CODE>(又は
<CODE>NULL</CODE>)から選ばれます。<CODE>ENUM</CODE>は最大65535個の固有値を持つことができます
。  「<A HREF="manual.ja_Reference.html#ENUM">6.2.3.3  <CODE>ENUM</CODE> 型</A>」節参照.

<A NAME="IDX1058"></A>
<DT><CODE>SET('value1','value2',...)</CODE>
<DD>
組。
対象となる文字列は0以上の値を持ち、それぞれ値リスト<CODE>'value1', 'value2',...</CODE>
から選ばれなければなりません。
<CODE>SET</CODE>は、最大 64個の要素を持つことができます。 「<A HREF="manual.ja_Reference.html#SET">6.2.3.4  <CODE>SET</CODE> 型</A>」節参照.
</DL>



<H3><A NAME="Numeric_types" HREF="manual.ja_toc.html#Numeric_types">6.2.1  数値型</A></H3>

<P>
MySQL は ANSI/ISO SQL92 数値型をすべてサポートします。これらの型
は正確な数値データ型(<CODE>NUMERIC</CODE>, <CODE>DECIMAL</CODE>, <CODE>INTEGER</CODE>,
<CODE>SMALLINT</CODE>)、近似数値型(<CODE>FLOAT</CODE>, <CODE>REAL</CODE>, <CODE>DOUBLE
PRECISION</CODE>)を含みます。キーワード <CODE>INT</CODE> は <CODE>INTEGER</CODE> の同義語で、
<CODE>DEC</CODE>は <CODE>DECIMAL</CODE> の同義語です。

</P>
<P>
MySQL では <CODE>NUMERIC</CODE> と <CODE>DECIMAL</CODE> 型は、SQL92 標準で許
されているように同じ型として実装されています。これらは正確な精度を維持する
ことが重要な値(例えば金銭データ)に使用されます。これらの型の一つのフィール
ドを宣言する時、精度と大きさが指定できます(通常はそうします); 例えば:

</P>

<PRE>
    salary DECIMAL(5,2)
</PRE>

<P>
この例では、<CODE>5</CODE> (<CODE>precisoin</CODE>) は値を格納する重要な数値の桁数を表
します。そして <CODE>2</CODE> (<CODE>scale</CODE>) は小数点に続いて格納される桁数を表
します。従って、この場合 <CODE>salary</CODE> フィールドに格納することができる値
の範囲は、<CODE>-99.99</CODE> から <CODE>99.99</CODE> です。
(MySQL can actually store numbers up to <CODE>999.99</CODE> in this column
because it doesn't have to store the sign for positive numbers)

</P>
<P>
ANSI/ISO SQL92 
では、構文 <CODE>DECIMAL(p)</CODE> は <CODE>DECIMAL(p,0)</CODE> と等しいです。同様に、
構文 <CODE>DECIMAL</CODE> は <CODE>DECIMAL(p,0)</CODE> と等しいです。ここで <CODE>p</CODE> 
の値の決定は実装に許されてます。<CODE>DECIMAL</CODE>/<CODE>NUMERIC</CODE> データ型のこ
れらの異なる形式は、MySQL は現在サポートしていません。この型の主
な利益は精度と大きさの両方を明示的に制御する機能から引き出されるので、これ
は通常深刻な問題ではありません。

</P>
<P>
<CODE>DECIMAL</CODE> と <CODE>NUMERIC</CODE> 値は、値の小数の精度を維持するため、バイ
ナリ浮動小数点数としてではなく、文字列として格納されます。1文字は値のそれ
ぞれの桁(<CODE>scale</CODE> &#62; 0 の場合)と <SAMP>`-'</SAMP> 記号(負数の場合)に使用されま
す。<CODE>scale</CODE> が 0 の場合、<CODE>DECIMAL</CODE> と <CODE>NUMERIC</CODE> 値は小数点
と小数部を含みません。

</P>
<P>
<CODE>DECIMAL</CODE> と <CODE>NUMERIC</CODE> 値の最大範囲は <CODE>DOUBLE</CODE> と同じです。
しかし <CODE>DECIMAL</CODE> や <CODE>NUMERIC</CODE> フィールドに与えられる実際の範囲は
フィールドに与えられた <CODE>precision</CODE> と <CODE>scale</CODE> によって強制されま
す。このフィールドに、指定された <CODE>scale</CODE> で許されるよりも多い桁の小数
部を持つ数値が割り当てられた場合、値はその <CODE>scale</CODE> に丸められます。
<CODE>DECIMAL</CODE> や <CODE>NUMERIC</CODE> フィールドに、指定された(またはデフォルト
の) <CODE>precision</CODE> と <CODE>scale</CODE> で示された範囲を超えた大きさの値を割
り当てた時、MySQL はその範囲の対応する最大値を表す値を格納します。

</P>
<P>
ANSI/ISO SQL92 標準に対する拡張として、上の表にリストしたように、
MySQL は整数型 <CODE>TINYINT</CODE>, <CODE>MEDIUMINT</CODE>, <CODE>BIGINT</CODE> も
サポートします。MySQL によってサポートされる他の拡張として、オプ
ションで、型の基本キーワードに続けて括弧内に指定する整数値の表示幅(例えば 
<CODE>INT(4)</CODE>)があります。このオプションの幅指定は、フィールドに指定された
幅よりも少ない幅の値の表示の左側を埋めるために使用されます。しかしフィール
ドに格納することができる値の範囲や、フィールドに指定された幅を超える幅の値
について表示される桁数は制約されません。オプションの拡張属性 
<CODE>ZEROFILL</CODE> を指定して使用された場合、デフォルトの埋められる空白は 0 
で置き換えられます。例えば、<CODE>INT(5) ZEROFILL</CODE> として宣言されたフィー
ルドでは、値 <CODE>4</CODE> は <CODE>0004</CODE> として取り出されます。注意: 整数フィー
ルド内に表示幅よりも大きい値を格納する場合、MySQL が複雑な join 
のために一時テーブルを生成する時に、問題を体験するでしょう。この場合 
MySQL はデータがオリジナルのフィールド幅に合っていることを信用す
るためです。

</P>
<P>
すべての整数型はオプションの(非標準)属性 <CODE>UNSIGNED</CODE> を持つことができ
ます。符合無しの値はフィールド内に正の数だけを許可したくて、フィールドに対
して少し大きい数値の範囲が必要な時に使用できます。

</P>
<P>
As of MySQL 4.0.2, floating-point types also can be <CODE>UNSIGNED</CODE>.
As with integer types, this attribute prevents negative values from
being stored in the column.  Unlike the integer types, the upper range
of column values remains the same.

</P>
<P>
<CODE>FLOAT</CODE> 型は近似数データ型を表すために使用されます。ANSI/ISO SQL92 標
準は、<CODE>FLOAT</CODE> キーワードに続く括弧中にオプションの精度(指数の範囲では
ない)の指定を許しています。MySQL 実装はこのオプションの精度指定も
サポートしています。キーワード <CODE>FLOAT</CODE> が精度の指定無しでフィールド型
として使用された時は、MySQL は値を格納するために4バイトを使用しま
す。<CODE>FLOAT</CODE> キーワードに続く括弧中に2つの数値を与える構文もサポートさ
れます。このオプションでの、最初の数値は値に必要な容量をバイトで表します。
2番目の数値は、格納、表示される小数部の桁数を指定します(<CODE>DECIMAL</CODE> と 
<CODE>NUMERIC</CODE> と同様)。MySQL がフィールドに指定されたよりも大き
い小数部の桁数を持つ数値をこのフィールドに格納する時、値の格納時に余計な桁
を取り除くように値が丸められます。

</P>
<P>
<CODE>REAL</CODE> と <CODE>DOUBLE PRECISION</CODE> 型は精度指定を許しません。
ANSI/ISO SQL92 標準に対する拡張として、MySQL は <CODE>DOUBLE</CODE> を 
<CODE>DOUBLE PRECISION</CODE> 型の同義語として認識します。<CODE>REAL</CODE> の精度は 
<CODE>DOUBLE PRECISION</CODE> の指定よりも小さいことを要求する標準と異なり、
MySQL はどちらも8バイトの倍精度小数点の値として実装しています
(非"ANSI モード"で実行した場合)。移植性を最大にするためには、近似数値
データ値の格納を要求するコードは、精度や小数部桁数の指定無しの 
<CODE>FLOAT</CODE> か <CODE>DOUBLE PRECISION</CODE> を使用すべきです。

</P>
<P>
フィールドの型の値の許容範囲を超えた数値を代入しようとすると、MySQL は
その値を許容範囲いっぱいに切り詰め、その結果を代わりに代入します。

</P>
<P>
例えば、 <CODE>INT</CODE> フィールドの範囲は <CODE>-2147483648</CODE> から <CODE>2147483647</CODE>
 です。
もし <CODE>-9999999999</CODE> を <CODE>INT</CODE> フィールドに挿入しようとすると、値は範囲の
最低値に修正され、 <CODE>-2147483648</CODE> が代わりに代入されます。同様に、
<CODE>9999999999</CODE> の場合、 <CODE>2147483647</CODE> が代わりに代入されます。

</P>
<P>
そして、<CODE>INT</CODE> フィールドが符号無しの場合、フィールドの範囲の大きさは
同じですが、限界値は <CODE>0</CODE> と<CODE>4294967296</CODE> になります。
もし <CODE>-9999999999</CODE> と <CODE>9999999999</CODE> を代入しようとすると、
値は <CODE>0</CODE> と <CODE>4294967296</CODE> として代入されます。

</P>
<P>
<CODE>ALTER TABLE</CODE>, <CODE>LOAD DATA INFILE</CODE>, <CODE>UPDATE</CODE> または
 multi-row <CODE>INSERT</CODE> 時、これらの変換は `警告' として得られます。

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Type</STRONG> </TD><TD> <STRONG>Bytes</STRONG> </TD><TD> <STRONG>From</STRONG> </TD><TD> <STRONG>To</STRONG>
</TR NOSAVE>
<TR><TD><CODE>TINYINT</CODE> </TD><TD> 1 </TD><TD> -128 </TD><TD> 127
</TR NOSAVE>
<TR><TD><CODE>SMALLINT</CODE> </TD><TD> 2 </TD><TD> -32768 </TD><TD> 32767
</TR NOSAVE>
<TR><TD><CODE>MEDIUMINT</CODE> </TD><TD> 3 </TD><TD> -8388608 </TD><TD> 8388607
</TR NOSAVE>
<TR><TD><CODE>INT</CODE> </TD><TD> 4 </TD><TD> -2147483648 </TD><TD> 2147483647
</TR NOSAVE>
<TR><TD><CODE>BIGINT</CODE> </TD><TD> 8 </TD><TD> -9223372036854775808 </TD><TD> 9223372036854775807
</TR>
</TABLE>



<H3><A NAME="Date_and_time_types" HREF="manual.ja_toc.html#Date_and_time_types">6.2.2  日付と時間の型</A></H3>

<P>
<A NAME="IDX1059"></A>
<A NAME="IDX1060"></A>

</P>

<P>
日付と時間の型は <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE>,
<CODE>TIME</CODE>, <CODE>YEAR</CODE> です.  これらはそれぞれ値に適正な範囲があり、
``zero'' はあなたが間違った値を指定した場合に用いられます。注意: MySQL は
確実に '厳密でない' 正しい日付の値、例えば <CODE>1999-11-31</CODE> を格納するこ
とができます。この理由は、日付をチェックする処理の責任はアプリケーションに
あり、SQL サーバにはないと考えているからです。日付を'速く'チェックするため
に、MySQL は月が 0〜12 の範囲であるかと日が 0〜31 の範囲であるか
だけをチェックします。上述の範囲は、MySQL が <CODE>DATE</CODE> または 
<CODE>DATETIME</CODE> フィールドに、日または月日が 0 である日付を格納できるため
に定義されています。これは、正確な日付を知らない誕生日を登録する必要がある
アプリケーションに非常に有用です。この場合、<CODE>1999-00-00</CODE> や 
<CODE>1999-01-00</CODE> のような日付を単純に登録できます(もちろん、このような日
付を <CODE>DATE_SUB()</CODE> や <CODE>DATE_ADD</CODE> のような関数で使用して、正しい値
が返ることは期待できません)。

</P>
<P>
これは、日付と時間型で作業する場合に、一般的に考慮しなければならないことです:

</P>

<UL>
<LI>

MySQLは、標準形式で与えられた日付や時間から値を抽出しますが、与えられた
多様な形式の値(例えば、指定された値を日付や時間型に割り当てたり、比較したり)を解
釈しようと試みます。
それでも、次節で述べる形式だけがサポートされます。
それは、正当な値が与えられることを期待し、他の形式の値を使用されるような事態が起
こると、どのような結果となるか予想できません。

<LI>

MySQL はいくつかの形式に値を変えてくれますが、
常に年の部分と日にちの部分は左から与えられていると期待しています。
日付は 年-月-日 の順(例えば、<CODE>'98-09-04'</CODE>)でなくてはなりません。
月-日-年 や 日-月-年 の様などこでも使われているような形であってはなりません。
(例えば、<CODE>'09-04-98'</CODE>や<CODE>'04-09-98'</CODE>).

<LI>

MySQL は、もし数値の文脈で日付と時間の型が使用されると、
自動的に日付と時間を数値に直します。逆も行います。

<LI>

MySQL が範囲外の誤った値を日付と時間型として受け取った場合
(このセクションの最初をみてください)、その値は ``ゼロ'' に変換されます。
(例外は、範囲外の<CODE>TIME</CODE>値が適切な<CODE>TIME</CODE>の範囲の限界値に切り詰められる
ことです。)
以下に、それぞれの型の `ゼロ' の形式を示します：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>`ゼロ'値</STRONG>
</TR NOSAVE>
<TR><TD><CODE>DATETIME</CODE> </TD><TD> <CODE>'0000-00-00 00:00:00'</CODE>
</TR NOSAVE>
<TR><TD><CODE>DATE</CODE> </TD><TD> <CODE>'0000-00-00'</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP</CODE> </TD><TD> <CODE>00000000000000</CODE> (長さは表示サイズに依存し
ます)
</TR NOSAVE>
<TR><TD><CODE>TIME</CODE> </TD><TD> <CODE>'00:00:00'</CODE>
</TR NOSAVE>
<TR><TD><CODE>YEAR</CODE> </TD><TD> <CODE>0000</CODE>
</TR>
</TABLE>

<LI>

`ゼロ'値は特別ですが、表に示された値を明示的に使用して、格納したり参照したりでき
ます。
この値は、 <CODE>'0'</CODE> 又は <CODE>0</CODE> を使用することにより、より簡潔に書くこともで
きます。

<LI>

<STRONG>MyODBC</STRONG> 内で使用されている `ゼロ' の日付と時間は、
<STRONG>MyODBC</STRONG> 2.50.12 以上では自動的に <CODE>NULL</CODE> に変換されます。
これは ODBC がこれらの値を扱えないからです。
</UL>



<H4><A NAME="Y2K_issues" HREF="manual.ja_toc.html#Y2K_issues">6.2.2.1  西暦２０００年問題とデータ型</A></H4>

<P>
<A NAME="IDX1061"></A>
<A NAME="IDX1062"></A>

</P>
<P>
MySQL 自体は2000年問題に対して安全です( 「<A HREF="manual.ja_Introduction.html#Year_2000_compliance">1.2.5  2000 年対応</A>」節参照)が、
 MySQL に提示される入力値に関してはそうではありません。2桁の
年の入力は何世紀なのかわからないので全て曖昧です。このような値は MySQL
が内部で年に4桁を使っていることから4桁の形式に変換されてしまいます。

</P>
<P>
 MySQL は曖昧な日付を <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 
および <CODE>YEAR</CODE> 型に関して、以下の
ルールに従って解釈します。

</P>

<UL>
<LI>

<CODE>00-69</CODE> の範囲の年は <CODE>2000-2069</CODE> に変換。

<LI>

<CODE>70-99</CODE> の範囲の年は <CODE>1970-1999</CODE> に変換。
</UL>

<P>
これらのルールはデータが何を意味しているかに対して妥当な推定を与えるに
過ぎないことに注意してください。この MySQL 発見的手法が正しい値を生成し
ない場合は曖昧でない4桁の年を含む入力を与えるべきです。

</P>
<P>
<CODE>ORDER BY</CODE> は2桁の <CODE>YEAR/DATE/DATETIME</CODE> 型を正しくソートされます。

</P>
<P>
注意: <CODE>MIN()</CODE> と <CODE>MAX()</CODE> のようないくつかの関数は <CODE>TIMESTAMP/DATE</CODE>
を数値に変換します。これは年が2桁のタイムスタンプはこれらの関数で正しく動作しな
いことを意味します。この場合の修復は、<CODE>TIMESTAMP/DATE</CODE> を4桁の年の形
式に変換するか、<CODE>MIN(DATE_ADD(timestamp,INTERVAL 0 DAYS))</CODE> のような何
かを使用することです。

</P>



<H4><A NAME="DATETIME" HREF="manual.ja_toc.html#DATETIME">6.2.2.2  <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 型</A></H4>

<P>
<A NAME="IDX1063"></A>
<A NAME="IDX1064"></A>
<A NAME="IDX1065"></A>

</P>
<P>
<CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE>型はお互いに関連しています。このセ
クションではそれらの特徴と、それぞれがどう同じでどう違うかを示します。

</P>
<P>
<CODE>DATETIME</CODE> 型は日付と時刻の情報を含む値が必要な場合に使います。MySQL は
<CODE>DATETIME</CODE> 値を <CODE>'YYYY-MM-DD HH:MM:SS'</CODE> のフォーマットで取り出し、
表示します。
サポートされる範囲は <CODE>'1000-01-01 00:00:00'</CODE> から <CODE>'9999-12-31 23:59:59'</CODE> です。
(「サポートされる」とはさらに過去の値でも動くかも知れませんが保証の限りではない
という意味です)

</P>
<P>
<CODE>DATE</CODE> 型は時刻の部分なしで日付の値のみが必要な場合に使います。MySQL は
 <CODE>DATE</CODE> 値を<CODE>'YYYY-MM-DD'</CODE> のフォーマットで取り出し、表示します。サポ
ートされる範囲は <CODE>'1000-01-01'</CODE> から <CODE>'9999-12-31'</CODE> です。

</P>
<P>
<CODE>TIMESTAMP</CODE> タイプは <CODE>INSERT</CODE> や <CODE>UPDATE</CODE> 操作に自動的に
現在の日付と時刻をマークする場合に提供される型です。
もし複数の <CODE>TIMESTAMP</CODE> フィールドがある場合には最初
の一つだけが自動的に更新されます。

</P>
<P>
最初の <CODE>TIMESTAMP</CODE> フィールドの自動更新は以下のいずれかの条件で起こります：

</P>

<UL>
<LI>

そのフィールドが明示的に <CODE>INSERT</CODE> または <CODE>LOAD DATA INFILE</CODE> 文で指定さ
れていないとき。
<LI>

そのフィールドが明示的に <CODE>UPDATE</CODE> 文で指定されず、かつ、他のフィールドの値
が変わった場合。
(もともとフィールドに入っていた値と同じ値に更新しようとする <CODE>UPDATE</CODE> 文は
<CODE>TIMESTAMP</CODE> フィールドを更新しないことに注意。なぜならあるフィールドを現在
と同じ値に変えようとしても MySQL は効率のためにそれを無視するからです。)
<LI>

明示的に <CODE>TIMESTAMP</CODE> フィールドを <CODE>NULL</CODE> にした場合。
</UL>

<P>
最初以外の <CODE>TIMESTAMP</CODE> フィールドも現在の日付と時刻にすることができます。そ
れらのフィールドを<CODE>NULL</CODE> または <CODE>NOW()</CODE> にすることです。

</P>
<P>
どの <CODE>TIMESTAMP</CODE> フィールドも明示的に望む値をセットすることで現在の日時でな
い値にすることができます。それは最初の <CODE>TIMESTAMP</CODE> フィールドについても同じ
です。この特性は例えば <CODE>TIMESTAMP</CODE> フィールドをあるレコードが生成された時の
日時にし、その後その行が更新されても変化しないようにしたいというようなときに使え
ます。

</P>

<UL>
<LI>

MySQL にレコードが生成されたときにそのフィールドをセットさせる。これで
現在日時に初期化される。

<LI>

以降の他のフィールドに対する更新時に <CODE>TIMESTAMP</CODE> フィールドをそれ自体が今持
っている値に明示的に更新する。
</UL>

<P>
一方、この手法は <CODE>DATATIME</CODE> フィールドを行生成時に <CODE>NOW()</CODE> で初期化し
、以降の更新時に
それをほうっておくのと同じように簡単であるとわかるでしょう。

</P>
<P>
<CODE>TIMESTAMP</CODE> の値は <CODE>1970</CODE> 年の最初から <CODE>2037</CODE> 年のどこかの時点ま
での範囲で有効で、
1秒の時間分解能を持ちます。値は数値として表示されます。

</P>
<P>
MySQL が <CODE>TIMESTAMP</CODE> 値を取り出したり表示するのに使うフォーマット
は以下の表
に示すようにその表示サイズに依存します。「目一杯の」 <CODE>TIMESTAMP</CODE> フォーマッ
トは14桁ですが、 <CODE>TIMESTAMP</CODE> フィールドはより短い表示サイズで生成することも
できます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールド型</STRONG> </TD><TD> <STRONG>表示フォーマット</STRONG>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(14)</CODE> </TD><TD> <CODE>YYYYMMDDHHMMSS</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(12)</CODE> </TD><TD> <CODE>YYMMDDHHMMSS</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(10)</CODE> </TD><TD> <CODE>YYMMDDHHMM</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(8)</CODE> </TD><TD> <CODE>YYYYMMDD</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(6)</CODE> </TD><TD> <CODE>YYMMDD</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(4)</CODE> </TD><TD> <CODE>YYMM</CODE>
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP(2)</CODE> </TD><TD> <CODE>YY</CODE>
</TR>
</TABLE>

<P>
全ての <CODE>TIMESTAMP</CODE> フィールドは表示サイズに関係なく同じ格納サイズを持ちます。
もっとも一般的な表示サイズは 6 , 8 , 12 および 14 です。表示サイズはテーブル生成
時に任意の値に指定できますが、 0 および 14 以上の値は強制的に 14 になります。1
から 13 までの奇数のサイズは強制的に一つ大きい偶数になります。

</P>
<P>
<CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 値は以下の共通フォーマットセット
のいずれかを使って指定できます：

</P>

<UL>
<LI>

文字列で <CODE>'YYYY-MM-DD HH:MM:SS'</CODE> か <CODE>'YY-MM-DD HH:MM:SS'</CODE> の形式。
"柔軟な"書き方を許しています -- 日付や時刻の区切り文字として、いかなる句読記号
も使用できます。例えば、<CODE>'98-12-31 11:30:45'</CODE>, <CODE>'98.12.31 11+30+45'</CODE>,
<CODE>'98/12/31 11*30*45'</CODE>, <CODE>'98@12@31 11^30^45'</CODE> は等価です。

<LI>

文字列で <CODE>'YYYY-MM-DD'</CODE> か <CODE>'YY-MM-DD'</CODE> の形式。
これも"柔軟な"書き方ができます。
例えば, <CODE>'98-12-31'</CODE>,<CODE>'98.12.31'</CODE>, <CODE>'98/12/31'</CODE>,
 <CODE>'98@12@31'</CODE> は
等価です。

<LI>

文字列 <CODE>'YYYYMMDDHHMMSS'</CODE> または <CODE>'YYMMDDHHMMSS'</CODE> フォーマット。
「緩やかな」文法が認められていて、句読記号は日付、時刻部分の区切り
として使えます。例えば <CODE>'98-12-31 11:30:45'</CODE>,  <CODE>'98.12.31 11+30+45'</CODE>,
 <CODE>'98/12/31 11*:30*:45'</CODE>,  <CODE>'98@12@31 11^30^45'</CODE> は全て等価です。

<LI>

文字列 <CODE>'YYYY-MM-DD'</CODE> または <CODE>'YY-MM-DD'</CODE> フォーマット。
これも「緩やかな」文法が認められています。例えば <CODE>'98-12-31'</CODE>,
<CODE>'98.12.31'</CODE>,  <CODE>'98/12/31'</CODE>, <CODE>'98@12@31'</CODE>は全て等価です。

<LI>

区切り文字なしの文字列 <CODE>'YYYYMMDDHHMMSS'</CODE> または <CODE>'YYMMDDHHMMSS'</CODE> フォ
ーマットで日時として意味のあるもの。
例えば <CODE>'19970523091528'</CODE> および <CODE>'970523091528'</CODE> は
<CODE>'1997-05-23 09:15:28'</CODE> と解釈されます。しかし <CODE>'971122129015'</CODE> は無効で
(時と分の部分がおかしい)、 <CODE>'0000-00-00 00:00:00'</CODE> になります。

<LI>

区切り文字なしの文字列 <CODE>'YYYYMMDD'</CODE> または <CODE>'YYMMDD'</CODE> フォーマットで、
日付として意味のあるもの。
例えば <CODE>'19970523'</CODE> および <CODE>'970523'</CODE> は <CODE>'1997-05-23'</CODE> と解釈
されます。
しかし <CODE>'971332'</CODE> は無効で(月と日の部分がおかしい)、 <CODE>'0000-00-00'</CODE> 
になります。

<LI>

 <CODE>YYYYMMDDHHMMSS</CODE> または <CODE>YYMMDDHHMMSS</CODE> のフォーマットの数値で、日時と
して意味のあるもの。例えば <CODE>19830905132800</CODE> および <CODE>830905132800</CODE> は
 <CODE>'1983-09-05 13:28:00'</CODE> と解釈されます。

<LI>

 <CODE>YYYYMMDD</CODE> または <CODE>YYMDD</CODE> のフォーマットの数値で日付として意味のある
もの。
例えば <CODE>19830905</CODE> および <CODE>830905</CODE> は <CODE>'1983-09-05'</CODE> として解釈さ
れます。

<LI>

 <CODE>NOW()</CODE> や <CODE>CURRENT_DATE</CODE> のように
 <CODE>DATETIME</CODE> , <CODE>DATE</CODE> , <CODE>TIMESTAMP</CODE> のコンテキストで
アクセス可能な値を返す関数の結果。
</UL>

<P>
無効な <CODE>DATETIME</CODE> , <CODE>DATE</CODE> , <CODE>TIMESTAMP</CODE> の値は適切な「ゼロ」値に
変換されます(<CODE>'0000-00-00 00:00:00'</CODE> , <CODE>'0000-00-00'</CODE> または <CODE>00000000000000</CODE> )。

</P>
<P>
日時の部分に区切りを持つ文字列で指定される値で、月、日の値が10未満の場
合は2桁で指定しなくてもかまいません。 <CODE>'1979-6-9'</CODE> は <CODE>'1979-06-09'</CODE> 
と等価です。同様に時刻の部分に区切りを持つ文字列で指定される値で、時、分、秒が
 <CODE>10</CODE> 未満の場合は2桁で指定しなくてもかまいません。
 <CODE>'1979-10-30 1:2:3'</CODE> は <CODE>'1979-10-30 01:02:03'</CODE> と等価です。

</P>
<P>
数値でしていされる値は 6, 8, 12 または 14 桁である必要があります。もしその数
値が 8 または 14 桁の長さの時はそれぞれ <CODE>YYYYMMDD</CODE> および
<CODE>YYYYMMDDHHMMSS</CODE> フォーマットで、最初の 4 桁で年が与えられるものと仮定
されます。もしその数値が 6または12桁の長さの時は <CODE>YYMMDD</CODE> および
<CODE>YYMMDDHHMMSS</CODE> フォーマットで最初の2桁で年が与えられるものと仮定されます。
これら以外の長さの数値はあとに <CODE>0</CODE> が追加されてこれらのうちのもっとも近い
長さのものと解釈されます。

</P>
<P>
<A NAME="IDX1066"></A>
<A NAME="IDX1067"></A>
区切りなしの文字列で与えられる値はそれ自身の長さを使って解釈されます。
もし文字列が8または14文字ならば年は最初の4文字で与えられると仮定されま
す。そうでなければ最初の2文字で与えられると仮定されます。文字列は左か
ら右に年、月、日、時、分、秒と文字列中に表現されている分だけ順に解釈さ
れます。つまり6文字以下の文字列は使ってはいけないということです。例え
ば1999年3月を指定するつもりで <CODE>'9903'</CODE> を指定した場合、MySQL は「ゼロ」日付
をテーブルに挿入します。これは年と月の部分は <CODE>99</CODE> と <CODE>03</CODE> ですが日の部
分が欠けている(ゼロ)ために値が有効な日付でないために起こります。

</P>
<P>
<CODE>TIMESTAMP</CODE> フィールドは有効な値を、表示サイズに関係なく指定された値を最高
精度の時間分解能で格納します。このことはいくつかの意味合いを持ちます。

</P>
<P>
年の値が二桁で指定された場合、世紀の部分がないので曖昧な値となります。
MySQL は二桁の年の値を以下に示す規則にそって変換します：

</P>

<UL>
<LI>

列の型がTIMESTAMP(4)であってもTIMESTAMP(2)であっても常に年月日を指定
すること。そうでなければ値は無効で0が格納されます。

<LI>

もし短い形式の <CODE>TIMESTAMP</CODE> を <CODE>ALTER TABLE</CODE> を使って拡張しようとした場
合、拡張前には「隠れていた」情報が現れます。

<LI>

同様に <CODE>TIMESTAMP</CODE> フィールドを縮めた場合も、値が表示された時により少ない情
報しか現れないという点を除いて、情報は失われません。

<LI>

 <CODE>TIMESTAMP</CODE> 値は最高精度の時間分解能で格納されますが、内部的に格納され
た値を直接操作できる関数は <CODE>UNIX_TIMESTAMP()</CODE> のみです。他の関数はフォーマ
ットされて取り出された値について操作します。つまり、 <CODE>HOUR()</CODE> や
<CODE>SECOND()</CODE> などの関数は <CODE>TIMESTAMP</CODE> 値の対応する部分がフォーマットされた
値で含まれないと使うことができません。例えば <CODE>TIMESTAMP</CODE> 列の <CODE>HH</CODE> の部分は
表示サイズが少なくとも10以上ないと表示されないので、それより短い <CODE>TIMESTAMP</CODE> 値
に <CODE>HOUR()</CODE> の操作を行っても無意味な値しか得られません。
</UL>

<P>
ある日付型を他の日付型のオブジェクトに拡張して指定することができます。
しかしそれは値の変化や情報の欠落を起こす可能性があります。

</P>

<UL>
<LI>

<CODE>DATE</CODE> の値を <CODE>DATETIME</CODE> か <CODE>TIMESTAMP</CODE> の物に与えた場合、
時刻の部分は <CODE>'00:00:00'</CODE> になります。これは <CODE>DATE</CODE> 値が
時刻の情報を持っていないからです。

<LI>

<CODE>DATETIME</CODE> か <CODE>TIMESTAMP</CODE> の値を <CODE>DATE</CODE> の物に与えた場合、
時刻の部分は削られます。これは <CODE>DATE</CODE> 値が
時刻の情報を持っていないからです。

<LI>

 <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE> 値は同じフォーマットのセットを使
って表現できますが、どの型も同じ値の範囲を持っているわけではないことを覚えておい
てください。例えば <CODE>TIMESTAMP</CODE> 値は <CODE>1970</CODE> 年より前や <CODE>2037</CODE> 年よ
り後の値にはできません。つまり <CODE>'1968-01-01'</CODE> という値は <CODE>DATETIME</CODE> や
<CODE>DATE</CODE> の値としては有効ですが <CODE>TIMESTAMP</CODE> の値としては無効で、
そのようなオブジェクトを指定した場合は <CODE>0</CODE> に変換されます。
</UL>

<P>
<A NAME="IDX1068"></A>
<A NAME="IDX1069"></A>
日付の値を指定するときの落とし穴に注意してください

</P>

<UL>
<LI>

文字列として指定される値の柔軟なフォーマットに騙されないよう。例え
ば <CODE>'10:11:12'</CODE> は <SAMP>`':''</SAMP> を区切り文字とする時刻のように見えますが、日
付のコンテキストで使われるとこれは <CODE>'2010-11-12'</CODE> と解釈されます。
<CODE>'10:45:15'</CODE> は <CODE>'45'</CODE> が有効な月ではないので <CODE>'0000-00-00'</CODE> に
変換されます。

<LI>

The MySQL server only performs basic checking on the validity of a date:
days <CODE>00-31</CODE>, months <CODE>00-12</CODE>, years <CODE>1000-9999</CODE>.
Any date not within this range will revert to <CODE>0000-00-00</CODE>.
Please note that this still allows you to store invalid dates such as
<CODE>2002-04-31</CODE>. It allows web applications to store data from a form
without further checking. To ensure a date is valid, perform a check in
your application.

<LI>

2桁で表される年は世紀の部分が不明なので曖昧です。 MySQL は以下のルール
で2桁の年を解釈します。


<UL>
<LI>

<CODE>00-69</CODE> の範囲にある年の値は <CODE>2000-2069</CODE> 年とする。

<LI>

<CODE>70-99</CODE> の範囲にある年の値は <CODE>1970-1999</CODE> 年とする。
</UL>

</UL>



<H4><A NAME="TIME" HREF="manual.ja_toc.html#TIME">6.2.2.3  <CODE>TIME</CODE> 型</A></H4>

<P>
<A NAME="IDX1070"></A>

</P>
<P>
MySQL は <CODE>TIME</CODE> の値を <CODE>'HH:MM:SS'</CODE>
 (時の部分が大きい場合は <CODE>'HHH:MM:SS'</CODE>)
というフォーマットで扱い、また表示します。
(時の部分が大きい場合は <CODE>'HHH:MM:SS'</CODE>)。
<CODE>TIME</CODE> 値の範囲は <CODE>'-838:59:59'</CODE> から <CODE>'838:59:59'</CODE> の範囲です。
時の部分がこんなに大きいのは、<CODE>TIME</CODE> 型は一日すなわち24時間以内
の時刻を表現するのに用いられるだけではなく経過時間や二つの事象の間隔
(どちらも２４時間を越えたり、負の数になる場合もあります)を表現すること
もあるからです。

</P>
<P>
<CODE>TIME</CODE> 値は様々なフォーマットで指定可能です：

</P>

<UL>
<LI>

文字列で <CODE>'D HH:MM:SS.fraction'</CODE> というフォーマット。
(MySQLはまだこの fraction を time フィールドに保存できません)。
以下の ``柔軟な'' 文法が使用できます：

<CODE>HH:MM:SS.fraction</CODE>, <CODE>HH:MM:SS</CODE>, <CODE>HH:MM</CODE>, <CODE>D HH:MM:SS</CODE>,
<CODE>D HH:MM</CODE>, <CODE>D HH</CODE> または <CODE>SS</CODE>。
ここで、<CODE>D</CODE> は 0〜33 の間の日です。

<LI>

文字列で <CODE>'HHMMSS'</CODE> というように区切りのないフォーマットで時刻として有効
なもの。例えば <CODE>'101112'</CODE> は <CODE>'10:11:12'</CODE> と解釈されますが <CODE>'1097
12'</CODE> は無効で(分の部分が無意味) <CODE>'00:00:00'</CODE> になります。

<LI>

数値で <CODE>HHMMSS</CODE> のフォーマットで時刻として有効なもの。
例えば <CODE>101112</CODE> は <CODE>'10:11:12'</CODE> と解釈されます。
次の別の形式も解釈できます: <CODE>SS</CODE>, <CODE>MMSS</CODE>,<CODE>HHMMSS</CODE>,
<CODE>HHMMSS.fraction</CODE>。注意: MySQL はまだ fraction 部を保存でき
ません。

<LI>

例えば <CODE>CURRENT_TIME</CODE> のように <CODE>TIME</CODE> のコンテキストで受け付けられる値
を返す関数の結果。
</UL>

<P>
文字列で時刻の各部の区切りを含む <CODE>TIME</CODE> の値については、時、分、秒が
<CODE>10</CODE> 以下の場合、２桁の数字を指定する必要はありません。<CODE>'8:3:2'</CODE> は
<CODE>'08:03:02'</CODE> と同じです。

</P>
<P>
「短い」 <CODE>TIME</CODE> 値を <CODE>TIME</CODE> フィールドとして指定する場合は要注意です。
コロンなしでは、MySQL はその値のもっとも右端の桁は秒を表すと仮定して解
釈します。
(MySQL は <CODE>TIME</CODE> の値を一日のうちの時刻としてより経過時間として
解釈します)。例えば <CODE>'11:12'</CODE>,<CODE>'1112'</CODE>, <CODE>1112</CODE> が
<CODE>'11:12:00'</CODE> (11時12分)を表しているつもりでいても、
MySQL はこれらを <CODE>'00:11:12'</CODE> (11分12秒)として解釈します。
同様に <CODE>'12'</CODE> および <CODE>12</CODE> は <CODE>'00:00:12'</CODE> と解釈します。

</P>
<P>
<CODE>TIME</CODE> の範囲外にある値で値以外は正しいものは範囲の端の値の適当な方にクリッ
プされます。例えば <CODE>'-850:00:00'</CODE> および <CODE>'850:00:00'</CODE> は
それぞれ <CODE>'-838:59:59'</CODE> および <CODE>'838:59:59'</CODE> になります。

</P>
<P>
無効な <CODE>TIME</CODE> 値は <CODE>'00:00:00'</CODE> に変換されます。
ここで <CODE>'00:00:00'</CODE> 自体は有効な <CODE>TIME</CODE> 値なので、
テーブル内に保存された'00:00:00'という値からそれがもとも
と <CODE>'00:00:00'</CODE> と指定された値なのか無効なために変換された結果なのかを区
別する方法はないことに注意してください。

</P>



<H4><A NAME="YEAR" HREF="manual.ja_toc.html#YEAR">6.2.2.4  <CODE>YEAR</CODE> 型</A></H4>

<P>
<A NAME="IDX1071"></A>

</P>
<P>
<CODE>YEAR</CODE> 型は年を表現するのに使われる1バイトの値です。

</P>
<P>
MySQL は <CODE>YEAR</CODE> の値を <CODE>YYYY</CODE> というフォーマットで扱い、
また表示します。範囲は <CODE>1901</CODE> から <CODE>2155</CODE> です。

</P>
<P>
<CODE>YEAR</CODE> 型は様々なフォーマットで指定可能です：

</P>

<UL>
<LI>

<CODE>'1901'</CODE> から <CODE>'2155'</CODE> の範囲にある4桁の文字列

<LI>

<CODE>1901</CODE> から <CODE>2155</CODE> の範囲にある4桁の数値。

<LI>

<CODE>'00'</CODE> から <CODE>'99'</CODE> の範囲にある2桁の文字列。
<CODE>'00'</CODE> から <CODE>'69'</CODE> までおよび <CODE>'70'</CODE> から
<CODE>'99'</CODE> までの範囲はそれぞれ <CODE>2000</CODE> から <CODE>2069</CODE> まで
および <CODE>1970</CODE> から <CODE>1999</CODE> までの範囲の
YEAR型に変換されます。

<LI>

<CODE>1</CODE> から <CODE>99</CODE> の範囲にある2桁の数値。<CODE>1</CODE> から <CODE>69</CODE> まで
および <CODE>70</CODE> から <CODE>99</CODE> までの範囲は
それぞれ <CODE>2001</CODE> から <CODE>2069</CODE> までおよび <CODE>1970</CODE> から <CODE>1999</CODE> まで
の範囲の <CODE>YEAR</CODE> 型に変換されます。
2桁の数値の場合は2桁の文字列の場合と若干異なっている点に注意してください。
なぜなら0を数値として指定し、それを2000年として解釈させることができないからです。
その場合は文字列で <CODE>'0'</CODE> または <CODE>'00'</CODE> を<EM>指定しなければ
なりません</EM>。そうでなければ数値0は無効なYEAR値を示す <CODE>0000</CODE> に変換されます。

<LI>

例えば <CODE>NOW()</CODE> のように <CODE>YEAR</CODE> コンテキストで受け入れられる値を返す関
数の結果。
</UL>

<P>
無効な <CODE>YEAR</CODE> 値は <CODE>0000</CODE> に変換されます。

</P>



<H3><A NAME="String_types" HREF="manual.ja_toc.html#String_types">6.2.3  文字列型</A></H3>

<P>
<A NAME="IDX1072"></A>
<A NAME="IDX1073"></A>

</P>
<P>
<A NAME="IDX1074"></A>
<A NAME="IDX1075"></A>

</P>

<P>
文字列型は<CODE>CHAR</CODE>, <CODE>VARCHAR</CODE>, <CODE>BLOB</CODE>, <CODE>TEXT</CODE>,
<CODE>ENUM</CODE>, <CODE>SET</CODE> です。このセクションは、それらの型がどのように動作
するかと、要求されるサイズと、クエリ内での使用方法を説明します。

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Type</STRONG> </TD><TD> <STRONG>Max.size</STRONG> </TD><TD> <STRONG>Bytes</STRONG>
</TR NOSAVE>
<TR><TD><CODE>TINYTEXT</CODE>   or <CODE>TINYBLOB</CODE> </TD><TD> 2^8-1 </TD><TD> 255
</TR NOSAVE>
<TR><TD><CODE>TEXT</CODE>       or <CODE>BLOB</CODE> </TD><TD> 2^16-1 (64K-1) </TD><TD> 65535
</TR NOSAVE>
<TR><TD><CODE>MEDIUMTEXT</CODE> or <CODE>MEDIUMBLOB</CODE> </TD><TD> 2^24-1 (16M-1) </TD><TD> 16777215
</TR NOSAVE>
<TR><TD><CODE>LONGBLOB</CODE> </TD><TD> 2^32-1 (4G-1) </TD><TD> 4294967295
</TR>
</TABLE>



<H4><A NAME="CHAR" HREF="manual.ja_toc.html#CHAR">6.2.3.1  <CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型</A></H4>

<P>
<CODE>CHAR</CODE> 型と <CODE>VARCHAR</CODE> 型はよく似ていますが格納、取り出しの手順に違いが
あります。

</P>
<P>
<CODE>CHAR</CODE> フィールドの長さはテーブルを生成するときに宣言した長さに固定されます。
長さは 1 から 255 までの値を取ります。<CODE>CHAR</CODE> が格納されるときには指定された
長さになるように右側に空白が詰められます。<CODE>CHAR</CODE> の値が取り出された場合には
右側(後続)の空白は取り除かれます。

</P>
<P>
<CODE>VARCHAR</CODE> フィールドの値は可変長文字列です。
<CODE>VARCHAR</CODE> フィールドは <CODE>CHAR</CODE> フィールド
と同じく 1 から 255 までの長さに宣言できます。
(MySQL バージョン 3.23 では, <CODE>CHAR</CODE> の長さは 0 から 255 まで許され
ています.)
しかし <CODE>CHAR</CODE> 型と異なり <CODE>VARCHAR</CODE> 型の値は必要な文字数の分に
長さを記録する1 バイトを足した領域に格納されます。値には桁合わせのための空白はつ
けられません。後続の空白は値の格納時に取り除かれます。(この空白の除去は ANSI
SQL仕様とは違っています。)

</P>
<P>
もし <CODE>CHAR</CODE> または <CODE>VARCHAR</CODE> フィールドに、フィールドの最大長を
越える長さの値を与えた場合は、適合するように切り詰められます。

</P>
<P>
以下の表はこれらの二つのフィールド型の違いを、<CODE>CHAR(4)</CODE> および <CODE>VARCHA
R(4)</CODE> に様々な文字列値を格納した結果を示すことで表しています。

</P>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>値</STRONG> </TD><TD> <CODE>CHAR(4)</CODE> </TD><TD> <STRONG>必要な格納域</STRONG> </TD><TD> @code
{VARCHAR(4)} </TD><TD> <STRONG>必要な格納域</STRONG>
</TR NOSAVE>
<TR><TD><CODE>''</CODE> </TD><TD> <CODE>'    '</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>''</CODE> </TD><TD> 1 バイト
</TR NOSAVE>
<TR><TD><CODE>'ab'</CODE> </TD><TD> <CODE>'ab  '</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>'ab'</CODE> </TD><TD> 3 バイト
</TR NOSAVE>
<TR><TD><CODE>'abcd'</CODE> </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 5 バイト
</TR NOSAVE>
<TR><TD><CODE>'abcdefgh'</CODE> </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 4 バイト </TD><TD> <CODE>'abcd'</CODE> </TD><TD> 5 バイト
</TR>
</TABLE>

<P>
<CODE>CHAR(4)</CODE> フィールドの後続の空白は取り出し時にとりのぞかれるので、CHAR(4)お
よび
<CODE>VARCHAR(4)</CODE> から取り出される値はどの場合でも同じです。

</P>
<P>
<CODE>CHAR</CODE> および <CODE>VARCHAR</CODE> フィールドの値はテーブルの生成時に <CODE>BINARY</CODE> 属性が
つけられない限り、大文字と小文字を区別しないでソート・比較されます。<CODE>BINARY</CODE> 属性は
その列の値が大文字、小文字を区別して、MySQLサーバを実行しているマシンのASCII順に
ソート・比較されることを意味します。
<CODE>BINARY</CODE> はフィールドがどのように格納されるか、どのように取り出される
かには影響しません。

</P>
<P>
<CODE>BINARY</CODE> 属性は「固定的」です。つまり、もし <CODE>BINARY</CODE> であると指定された
フィールドが式の中にあると式全体が <CODE>BINARY</CODE> の値として比較されるのです。

</P>
<P>
MySQL はテーブル生成時に何も断らずに<CODE>CHAR</CODE> または <CODE>VARCHAR</CODE> 
型のフィールドを変更する事があります。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

</P>



<H4><A NAME="BLOB" HREF="manual.ja_toc.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A></H4>

<P>
<A NAME="IDX1076"></A>
<A NAME="IDX1077"></A>

</P>
<P>
<CODE>BLOB</CODE> は大きなバイナリ型のオブジェクトで、可変長のデータを保持できます。
4 つの <CODE>BLOB</CODE> 型、すなわち <CODE>TINYBLOB</CODE>, <CODE>BLOB</CODE>,
<CODE>MEDIUMBLOB</CODE> と <CODE>LONGBLOB</CODE> は保持できるデータの最大長が違うだけです。
 「<A HREF="manual.ja_Reference.html#Storage_requirements">6.2.6  各フィールド型の所要容量</A>」節参照.

</P>
<P>
4 つの <CODE>TEXT</CODE> 型、すなわち <CODE>TINYTEXT</CODE>, <CODE>TEXT</CODE>, <CODE>MEDIUMTEXT</CODE>
と <CODE>LONGTEXT</CODE> は 4 つの <CODE>BLOB</CODE> 型に対応し、同じ最大長と
格納条件を持っています。 <CODE>TEXT</CODE> と <CODE>BLOB</CODE> の違いは、
<CODE>TEXT</CODE> はケースに依存しないでソートと比較され、
<CODE>BLOB</CODE> はケースに依存して(文字コードで)比較されることだけです。
いうならば、<CODE>TEXT</CODE> は、ケースに依存しない <CODE>BLOB</CODE> です。

</P>
<P>
もし <CODE>BLOB</CODE> や <CODE>TEXT</CODE> フィールドにそれらの最大長以上の値が与えられた
場合、その値はきっちり収まるように切り落とされます。

</P>
<P>
ほとんどの点で、<CODE>TEXT</CODE> フィールドを <CODE>VARCHAR</CODE> の大きい物と見なすことが
出来ます。
同様に、<CODE>BLOB</CODE> フィールドは <CODE>VARCHAR BINARY</CODE> フィールドの大きくなった
物です。
違いは、

</P>

<UL>
<LI>

MySQL バージョン 3.23.2 以上では、<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 項に
インデックスを持つことが出来ます。それ以前のバージョンでは
インデックスをもつことが出来ません。

<LI>

<CODE>VARCHAR</CODE> フィールドで行っているようには、<CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィー
ルドの値の後ろについている連続した空白文字は切り落とされません。

<LI>

<A NAME="IDX1078"></A>
<A NAME="IDX1079"></A>
<A NAME="IDX1080"></A>
<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 項は <CODE>DEFAULT</CODE> 値を持つことが出来ません。
</UL>

<P>
<CODE>MyODBC</CODE> は <CODE>BLOB</CODE> を <CODE>LONGVARBINARY</CODE> として、 
<CODE>TEXT</CODE> を <CODE>LONGVARCHAR</CODE> として定義します。

</P>
<P>
<CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィールドは極端に長いので、それらを使用する際には、
いくつかの困った事にでくわすかもしれません：

</P>

<UL>
<LI>

もし <CODE>GROUP BY</CODE> か <CODE>ORDER BY</CODE> を <CODE>BLOB</CODE> フィールドや <CODE>TEXT</CODE> 
フィールドで使用したいなら、フィールドの値を固定長のものに変換しなくてはなりま
せん。標準的な方法は、 <CODE>SUBSTRING</CODE> 関数を使用することです。
たとえば：


<PRE>
mysql&#62; SELECT comment FROM tbl_name,SUBSTRING(comment,20) AS substr
    -&#62;                 ORDER BY substr;
</PRE>

もしこれをしない場合、フィールドの最初の <CODE>max_sort_length</CODE> バイトが
ソート時に使用されます。 <CODE>max_sort_length</CODE> のデフォルト値は 1024; 
この値は <CODE>mysqld</CODE> サーバー起動時に <CODE>-O</CODE> オプションを使用することで
変更できます。
フィールドの位置を指定することによってか、エイリアスを使用することによって、
 <CODE>BLOB</CODE> や <CODE>TEXT</CODE> の値で group 化できます。


<PRE>
mysql&#62; SELECT id,SUBSTRING(blob_col,1,100) FROM tbl_name GROUP BY 2;
mysql&#62; SELECT id,SUBSTRING(blob_col,1,100) AS b FROM tbl_name GROUP BY b;
</PRE>

<LI>

<CODE>BLOB</CODE> または <CODE>TEXT</CODE> オブジェクトの最大長はその型により決定されますが、
あなたがクライアントとサーバの間で実際に送ることができるは最大長は、
利用可能なメモリ量とコミュニケーションバッファのサイズによって決定されます。
メッセージバッファサイズを変えることができますが、その場合、サーバーとクライアン
ト、両方共に変更しなければなりません。 「<A HREF="manual.ja_MySQL_Optimisation.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.
</UL>

<P>
それぞれの <CODE>BLOB</CODE>, <CODE>TEXT</CODE> フィールドは、一意のアロケートされたオブジェ
クトによって、内部では表されることに注意してください.。
これはテーブルが開かれるときに一度だけアロケートされる他のフィールドとは対照的で
す。

</P>



<H4><A NAME="ENUM" HREF="manual.ja_toc.html#ENUM">6.2.3.3  <CODE>ENUM</CODE> 型</A></H4>

<P>
<A NAME="IDX1081"></A>

</P>
<P>
<CODE>ENUM</CODE> はストリングオブジェクトで、
その値は、通常、テーブル作成時のフィールド定義で列挙された値の中から選ばれます。

</P>
<P>
値はある状況下では 空文字 (<CODE>""</CODE>) か <CODE>NULL</CODE> を取ることがあります：

</P>

<UL>
<LI>

もし <CODE>ENUM</CODE> に無効な値 (列挙されている値の中に含まれない文字) を
代入した場合、 そのエラーになる文字の代わりに空文字が挿入されます。

<LI>

もし <CODE>ENUM</CODE> が <CODE>NULL</CODE> と定義された場合, <CODE>NULL</CODE> はそのフィールドで
許可される値となり、デフォルト値が <CODE>NULL</CODE> になります。
 もし <CODE>ENUM</CODE> が <CODE>NOT NULL</CODE> と定義されたならば、 デフォルト値は、
列挙リストの最初の値になります。
</UL>

<P>
列挙されたそれぞれの値はインデックスを持ちます：

</P>

<UL>
<LI>

列挙リストの要素は 1 から付番されます。

<LI>

空文字エラーのインデックス値は 0 。
 これは不正な <CODE>ENUM</CODE> 値が与えられているレコードを見つけるために
以下のような <CODE>SELECT</CODE> 構文が使用できることを意味します：


<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE enum_col=0;
</PRE>

<LI>

<CODE>NULL</CODE> のインデックス値は <CODE>NULL</CODE>.
</UL>

<P>
たとえば、フィールドが <CODE>ENUM("one", "two", "three")</CODE> と定義されたなら、
以下に示す値をとります。 それぞれのインデックス値も示します。

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>値</STRONG> </TD><TD> <STRONG>インデックス</STRONG>
</TR NOSAVE>
<TR><TD><CODE>NULL</CODE> </TD><TD> <CODE>NULL</CODE>
</TR NOSAVE>
<TR><TD><CODE>""</CODE> </TD><TD> 0
</TR NOSAVE>
<TR><TD><CODE>"one"</CODE> </TD><TD> 1
</TR NOSAVE>
<TR><TD><CODE>"two"</CODE> </TD><TD> 2
</TR NOSAVE>
<TR><TD><CODE>"three"</CODE> </TD><TD> 3
</TR>
</TABLE>

<P>
列挙は最大 65535 個の要素まで可能です。

</P>
<P>
Starting from 3.23.51 trailing spaces are automatically deleted from
<CODE>ENUM</CODE> values when the table is created.

</P>
<P>
<CODE>ENUM</CODE> フィールドに値を与える場合は大文字小文字は無関係です。
しかし、後でフィールドから検索される値は、大文字小文字をもちます。
これはテーブル作成時に与えられたリストの値です。

</P>
<P>
もし <CODE>ENUM</CODE> を数値の文脈で検索した場合、そのメンバーを前から数えた
時の順番が数値で返ってきます。
たとえば、<CODE>ENUM</CODE> フィールドから次のようにして数値を取り出すことができ
ます:

</P>

<PRE>
mysql&#62; SELECT enum_col+0 FROM tbl_name;
</PRE>

<P>
もし <CODE>ENUM</CODE> に数値を代入しようとした場合、その数値の位置にある
メンバーが代入されます。
(しかし、これは <CODE>LOAD DATA</CODE> では働きません。これはすべての入力を文字
列として扱います。)
It's not advisable to store numbers in an <CODE>ENUM</CODE> string because
it will make things confusing.

</P>
<P>
<CODE>ENUM</CODE> 値は列挙メンバがフィールド指定にリストされた順に従ってソートさ
れます。(つまり、<CODE>ENUM</CODE> 値はインデックス値に従ってソートされます。)
例えば、<CODE>ENUM("a", "b")</CODE> ならば <CODE>"a"</CODE> が <CODE>"b"</CODE> の前にソートされ、
<CODE>ENUM("b", "a")</CODE> ならば <CODE>"b"</CODE> が <CODE>"a"</CODE> の前にソートされます。
空文字列は空ではない文字の前にソートされ、
<CODE>NULL</CODE> は他の列挙の前に並びます。
To prevent unexpected results, specify the <CODE>ENUM</CODE> list in alphabetical
order. You can also use <CODE>GROUP BY CONCAT(col)</CODE> to make sure the column
is sorted alphabetically rather than by index number.

</P>
<P>
<CODE>ENUM</CODE> フィールドで指定可能な値のリストを全て取りたいならば、
次のようにします：
<CODE>SHOW COLUMNS FROM table_name LIKE enum_column_name</CODE>
そして二番目のフィールドの <CODE>ENUM</CODE> 定義を分析します。

</P>



<H4><A NAME="SET" HREF="manual.ja_toc.html#SET">6.2.3.4  <CODE>SET</CODE> 型</A></H4>

<P>
<CODE>SET</CODE> は文字型オブジェクトでゼロかそれ以上を値持ちます。
テーブル作成時には、それぞれの値はリストから選ばれるべきです。
<CODE>SET</CODE> 型のフィールドの値は、コンマ(<SAMP>`,'</SAMP>)
区切りで並べられた複数のメンバーで構成されています。 
これは、 <CODE>SET</CODE> メンバーの値中にコンマを含むことが出来ない、
ということです。

</P>
<P>
例えば、
<CODE>SET("one", "two") NOT NULL</CODE> と指定されたフィールドは以下の値をとります：

</P>

<PRE>
""
"one"
"two"
"one,two"
</PRE>

<P>
<CODE>SET</CODE> は最大 64 個の異なったメンバーがもてます。

</P>
<P>
Starting from 3.23.51 trailing spaces are automatically deleted from
<CODE>SET</CODE> values when the table is created.

</P>
<P>
MySQL は <CODE>SET</CODE> の値を数値として代入します。代入された
値の最下位のビットが最初のメンバーに対応します。もし <CODE>SET</CODE> 値を
数値の文脈で検索した場合、検索される値はフィールドの値に対応します。
たとえば、<CODE>SET</CODE> フィールドから次のようにして数値を取り出すことができ
ます:

</P>

<PRE>
mysql&#62; SELECT set_col+0 FROM tbl_name;
</PRE>

<P>
もし数値が <CODE>SET</CODE> フィールドに代入された場合、
二進数で表される数値のビットによって、メンバーが決定されます。
<CODE>SET("a","b","c","d")</CODE> とフィールドが定義されたとします。
メンバーは以下の２進数の値を持ちます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>SET</CODE> <STRONG>member</STRONG> </TD><TD> <STRONG>10進数</STRONG> </TD><TD> <STRONG>２進数値</STRONG>
</TR NOSAVE>
<TR><TD><CODE>a</CODE> </TD><TD> <CODE>1</CODE> </TD><TD> <CODE>0001</CODE>
</TR NOSAVE>
<TR><TD><CODE>b</CODE> </TD><TD> <CODE>2</CODE> </TD><TD> <CODE>0010</CODE>
</TR NOSAVE>
<TR><TD><CODE>c</CODE> </TD><TD> <CODE>4</CODE> </TD><TD> <CODE>0100</CODE>
</TR NOSAVE>
<TR><TD><CODE>d</CODE> </TD><TD> <CODE>8</CODE> </TD><TD> <CODE>1000</CODE>
</TR>
</TABLE>

<P>
もしこのフィールドに <CODE>9</CODE> を与えた場合、これは２進数で <CODE>1001</CODE> ですから、
1 番目と 4 番目の <CODE>SET</CODE> メンバーである <CODE>"a"</CODE> と <CODE>"d"</CODE> が
選択され、結果、 <CODE>"a,d"</CODE> となります。

</P>
<P>
1つ以上の <CODE>SET</CODE> 要素を含む値においては,あなたが値を挿入するとき,要素がどん
な
順序で記載されているのかは重要ではありません. また,何回要素が与えられたのかは
重要ではありません. 後で値が検索されるとき, 値の中のそれぞれの要素は
ただ一回だけ表れます。そのとき、テーブル作成時に与えられた順に要素は並びます。
例えば、フィールドが <CODE>SET("a","b","c","d")</CODE> と設定されていたなら、
<CODE>"a,d"</CODE>, <CODE>"d,a"</CODE>, <CODE>"d,a,a,d,d"</CODE> は検索されると <CODE>"a,d"</CODE> と
なります。

</P>
<P>
If you set a <CODE>SET</CODE> column to an unsupported value, the value will
be ignored.

</P>
<P>
<CODE>SET</CODE> 値は数値として代入されます。
<CODE>NULL</CODE> 値は非 <CODE>NULL</CODE> <CODE>SET</CODE> 値の前にソートされます。

</P>
<P>
通常、<CODE>LIKE</CODE> か <CODE>FIND_IN_SET()</CODE> を使用して <CODE>SET</CODE> フィールド
の <CODE>SELECT</CODE> を行います：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE set_col LIKE '%value%';
mysql&#62; SELECT * FROM tbl_name WHERE FIND_IN_SET('value',set_col)&#62;0;
</PRE>

<P>
しかし、以下も動作します：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE set_col = 'val1,val2';
mysql&#62; SELECT * FROM tbl_name WHERE set_col &#38; 1;
</PRE>

<P>
最初の文は完全一致するものを探します。
二つ目は第一番目のメンバーを含む値を探します。

</P>
<P>
もし <CODE>SET</CODE> フィールドで設定可能なすべてのメンバーを知りたい場合：
 <CODE>SHOW COLUMNS FROM table_name LIKE set_column_name</CODE> とし、
２番目にあらわされる <CODE>SET</CODE> 定義を分析します。

</P>



<H3><A NAME="Choosing_types" HREF="manual.ja_toc.html#Choosing_types">6.2.4  正しいフィールド型の選択</A></H3>

<P>
<A NAME="IDX1082"></A>
<A NAME="IDX1083"></A>

</P>
<P>
もっとも効率よく格納するには、全てにおいて一番正確な型を使用することです。
例えば、<CODE>1</CODE>-<CODE>99999</CODE> の整数
には、<CODE>MEDIUMINT UNSIGNED</CODE> が最良の型です。

</P>
<P>
良くある問題は、貨幣の値の正確な表現です。MySQL では 
<CODE>DECIMAL</CODE> 型を使用すべきです。これは文字列として格納し、正確さのロ
スは発生しません。正確さが重要でない場合は <CODE>DOUBLE</CODE> 型でも十分良い
です。

</P>
<P>
高精度のため、常に <CODE>BITINT</CODE> に格納される固定小数点型に変換できます。
これは、全ての計算を整数で行なうようにし、結果だけを浮動小数点に変換して
戻します。

</P>



<H3><A NAME="Other-vendor_column_types" HREF="manual.ja_toc.html#Other-vendor_column_types">6.2.5  他のデータベースエンジンのフィールド型の使用</A></H3>

<P>
<A NAME="IDX1084"></A>
<A NAME="IDX1085"></A>
<A NAME="IDX1086"></A>

</P>
<P>
ほかのベンダーからSQLを簡単に書けれるように、 MySQL は以下の表に
しめすフィールド型をサポートします。これらは、テーブルの定義を、
他のデータベースエンジンから MySQL に簡単に移行させてくれます：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Other vendor type</STRONG> </TD><TD> <STRONG>MySQL type</STRONG>
</TR NOSAVE>
<TR><TD><CODE>BINARY(NUM)</CODE> </TD><TD> <CODE>CHAR(NUM) BINARY</CODE>
</TR NOSAVE>
<TR><TD><CODE>CHAR VARYING(NUM)</CODE> </TD><TD> <CODE>VARCHAR(NUM)</CODE>
</TR NOSAVE>
<TR><TD><CODE>FLOAT4</CODE> </TD><TD> <CODE>FLOAT</CODE>
</TR NOSAVE>
<TR><TD><CODE>FLOAT8</CODE> </TD><TD> <CODE>DOUBLE</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT1</CODE> </TD><TD> <CODE>TINYINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT2</CODE> </TD><TD> <CODE>SMALLINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT3</CODE> </TD><TD> <CODE>MEDIUMINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT4</CODE> </TD><TD> <CODE>INT</CODE>
</TR NOSAVE>
<TR><TD><CODE>INT8</CODE> </TD><TD> <CODE>BIGINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>LONG VARBINARY</CODE> </TD><TD> <CODE>MEDIUMBLOB</CODE>
</TR NOSAVE>
<TR><TD><CODE>LONG VARCHAR</CODE> </TD><TD> <CODE>MEDIUMTEXT</CODE>
</TR NOSAVE>
<TR><TD><CODE>MIDDLEINT</CODE> </TD><TD> <CODE>MEDIUMINT</CODE>
</TR NOSAVE>
<TR><TD><CODE>VARBINARY(NUM)</CODE> </TD><TD> <CODE>VARCHAR(NUM) BINARY</CODE>
</TR>
</TABLE>

<P>
もし他のベンダーの型を使用してテーブルを作ろうとすると、
テーブル作成時のフィールドの型のマッピングが発生し、
<CODE>DESCRIBE tbl_name</CODE> 構文を発行します。
そして MySQL は、使用された型と等価な MySQL の型を用いて
テーブルを構成したことを告げます。

</P>



<H3><A NAME="Storage_requirements" HREF="manual.ja_toc.html#Storage_requirements">6.2.6  各フィールド型の所要容量</A></H3>

<P>
<A NAME="IDX1087"></A>
<A NAME="IDX1088"></A>

</P>
<P>
MySQLがサポートする各フィールドタイプ毎の所要容量を、カテゴリ別に以下に
記述します。

</P>
<P>
<A NAME="IDX1089"></A>
<A NAME="IDX1090"></A>

</P>

<H4>6.2.6.1  数値タイプの保存容量</H4>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>所要容量</STRONG>
</TR NOSAVE>
<TR><TD><CODE>TINYINT</CODE> </TD><TD> 1 byte
</TR NOSAVE>
<TR><TD><CODE>SMALLINT</CODE> </TD><TD> 2 bytes
</TR NOSAVE>
<TR><TD><CODE>MEDIUMINT</CODE> </TD><TD> 3 bytes
</TR NOSAVE>
<TR><TD><CODE>INT</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>INTEGER</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>BIGINT</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>FLOAT(X)</CODE> </TD><TD> X &#60;= 24 の場合 4、25 &#60;= X &#60;= 53 の場合 8
</TR NOSAVE>
<TR><TD><CODE>FLOAT</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>DOUBLE</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>DOUBLE PRECISION</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>REAL</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>DECIMAL(M,D)</CODE> </TD><TD> D &#62; 0 の場合 <CODE>M+2</CODE>, D = 0 の場合 <CODE>M+1</CODE> bytes (<CODE>M &#60; D</CODE> の場合 <CODE>D</CODE>+2)
</TR NOSAVE>
<TR><TD><CODE>NUMERIC(M,D)</CODE> </TD><TD> D &#62; 0 の場合 <CODE>M+2</CODE>, D = 0 の場合 <CODE>M+1</CODE> bytes (<CODE>M &#60; D</CODE> の場合 <CODE>D</CODE>+2)
</TR>
</TABLE>

<P>
<A NAME="IDX1091"></A>
<A NAME="IDX1092"></A>
<A NAME="IDX1093"></A>
<A NAME="IDX1094"></A>

</P>

<H4>6.2.6.2  日付と時間タイプの保存容量</H4>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>所要容量</STRONG>
</TR NOSAVE>
<TR><TD><CODE>DATE</CODE> </TD><TD> 3 bytes
</TR NOSAVE>
<TR><TD><CODE>DATETIME</CODE> </TD><TD> 8 bytes
</TR NOSAVE>
<TR><TD><CODE>TIMESTAMP</CODE> </TD><TD> 4 bytes
</TR NOSAVE>
<TR><TD><CODE>TIME</CODE> </TD><TD> 3 bytes
</TR NOSAVE>
<TR><TD><CODE>YEAR</CODE> </TD><TD> 1 byte
</TR>
</TABLE>


<H4>6.2.6.3  文字列タイプの保存容量</H4>

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>フィールドタイプ</STRONG> </TD><TD> <STRONG>所要容量</STRONG>
</TR NOSAVE>
<TR><TD><CODE>CHAR(M)</CODE> </TD><TD> <CODE>M</CODE> bytes, <CODE>1 &#60;= M &#60;= 255</CODE>
</TR NOSAVE>
<TR><TD><CODE>VARCHAR(M)</CODE> </TD><TD> <CODE>L</CODE>+1 bytes, where <CODE>L &#60;= M</CODE> and <CODE>1 &#60;= M &#60;= 255</CODE>
</TR NOSAVE>
<TR><TD><CODE>TINYBLOB</CODE>, <CODE>TINYTEXT</CODE> </TD><TD> <CODE>L</CODE>+1 bytes,where <CODE>L</CODE> &#60; 2^8
</TR NOSAVE>
<TR><TD><CODE>BLOB</CODE>, <CODE>TEXT</CODE> </TD><TD> <CODE>L</CODE>+2 bytes,where <CODE>L</CODE> &#60; 2^16
</TR NOSAVE>
<TR><TD><CODE>MEDIUMBLOB</CODE>, <CODE>MEDIUMTEXT</CODE> </TD><TD> <CODE>L</CODE>+3 bytes,where <CODE>L</CODE> &#60; 2^24
</TR NOSAVE>
<TR><TD><CODE>LONGBLOB</CODE>, <CODE>LONGTEXT</CODE> </TD><TD> <CODE>L</CODE>+4 bytes,where <CODE>L</CODE> &#60; 2^32
</TR NOSAVE>
<TR><TD><CODE>ENUM('value1','value2',...)</CODE> </TD><TD> 1 or 2 bytes, 列挙値の数に依存 (最大値は 65535 )
</TR NOSAVE>
<TR><TD><CODE>SET('value1','value2',...)</CODE> </TD><TD> 1, 2, 3, 4 or 8 bytes, 要素の数に依存 (最大要素 64 )
</TR>
</TABLE>

<P>
<A NAME="IDX1095"></A>
<A NAME="IDX1096"></A>
<A NAME="IDX1097"></A>
<CODE>VARCHAR</CODE>、<CODE>BLOB</CODE>、及び<CODE>TEXT</CODE>型は可変長型であり、所要容量は、フィ
ールドのとり得る最大サイズというよりはむしろフィールド値の実際の長さに依存します
(前の表で<CODE>L</CODE>と表しました)。
例えば、<CODE>VARCHAR(10)</CODE>フィールドは、最大10文字分の長さの文字列を保持すること
が出来ます。実際の所要容量は、文字列の長さ(<CODE>L</CODE>)と、その長さを記録するための
１バイトを加えます。文字列<CODE>'abcd'</CODE>においては、<CODE>L</CODE>は４で、所要容量は５
バイトです。

</P>
<P>
<CODE>BLOB</CODE>と<CODE>TEXT</CODE>型は、フィールド値の長さを記録するのに、１、２、３、又は
４バイト必要とし、型のとり得る最大の長さに依存します。 「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

</P>
<P>
テーブルが可変長フィールド型を含む場合、そのレコードフォーマットもまた可変長とな
るでしょう。
テーブルが作成された時、MySQLは確かな条件の下、フィールドを可変長タイプ
から固定長タイプへ変更し、副作用を起こすことに注意して下さい。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

</P>
<P>
<A NAME="IDX1098"></A>
<CODE>ENUM</CODE>オブジェクトのサイズは、異なる列挙値の数によって決められます。
列挙する数が255以内では、１バイトが使用されます。
列挙する数が65535以内では、２バイトが使用されます。 「<A HREF="manual.ja_Reference.html#ENUM">6.2.3.3  <CODE>ENUM</CODE> 型</A>」節参照.

</P>
<P>
<A NAME="IDX1099"></A>
<CODE>SET</CODE>オブジェクトのサイズは、異なる要素の数によって決められます。
組のサイズを<CODE>N</CODE>とすると、オブジェクトは<CODE>(N+7)/8</CODE>バイトを占有し、
１、２、３、４又は８バイトに切上げられます。
１つの<CODE>SET</CODE>は、最大６４要素を持つことができます。 「<A HREF="manual.ja_Reference.html#SET">6.2.3.4  <CODE>SET</CODE> 型</A>」節参照.

</P>



<H2><A NAME="Functions" HREF="manual.ja_toc.html#Functions">6.3  <CODE>SELECT</CODE> と <CODE>WHERE</CODE> 節で使用する関数</A></H2>

<P>
<A NAME="IDX1100"></A>

</P>
<P>
SQL ステートメント中の <CODE>select_expression</CODE> または 
<CODE>where_definition</CODE> は後述の関数を使用した任意の式からなります。

</P>
<P>
演算と関数を式の中で呼ぶ時、本ドキュメントに示しているもの以外の、
<CODE>NULL</CODE> を含む式は常に <CODE>NULL</CODE> 値を生成します

</P>
<P>
<STRONG>注意</STRONG>: 関数名とそれに続く語句の間には、空白はありません。
これは関数の呼び出しと、関数と同名のテーブル(かフィールド)の参照を、
 MySQL パーサが区別するのを助けます。

</P>
<P>
<CODE>mysqld</CODE> に <CODE>--ansi</CODE> をつけて起動するか、
<CODE>CLIENT_IGNORE_SPACE</CODE> を <CODE>mysql_connect()</CODE> に使用すれば、
MySQL が関数名の後の空白を許すようになりますが、その場合、すべて
の関数名が予約語になります。 「<A HREF="manual.ja_Introduction.html#ANSI_mode">1.7.2  MySQLをANSIモードで実行する</A>」節参照。

</P>
<P>
次の例では、<CODE>mysql</CODE> プログラムの出力は短くなっています。つまり:

</P>

<PRE>
mysql&#62; SELECT MOD(29,9);
1 rows in set (0.00 sec)

+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+
</PRE>

<P>
これは次に変換されています:

</P>

<PRE>
mysql&#62; SELECT MOD(29,9);
        -&#62; 2
</PRE>



<H3><A NAME="Non-typed_Operators" HREF="manual.ja_toc.html#Non-typed_Operators">6.3.1  Non-Type-Specific Operators and Functions</A></H3>

<P>
<A NAME="IDX1101"></A>
The maximum size of a row in a <CODE>MyISAM</CODE> table is 65534 bytes. Each 
<CODE>BLOB</CODE> and <CODE>TEXT</CODE> column accounts for only 5-9 bytes 
towards this size.

</P>


<H4><A NAME="Parentheses" HREF="manual.ja_toc.html#Parentheses">6.3.1.1  Parentheses</A></H4>

<P>
<A NAME="IDX1102"></A>
<A NAME="IDX1103"></A>

</P>
<P>
<A NAME="IDX1104"></A>
<A NAME="IDX1105"></A>

</P>

<PRE>
( ... )
</PRE>

<P>
Use parentheses to force the order of evaluation in an expression.  For
example:

</P>

<PRE>
mysql&#62; SELECT 1+2*3;
        -&#62; 7
mysql&#62; SELECT (1+2)*3;
        -&#62; 9
</PRE>



<H4><A NAME="Comparison_Operators" HREF="manual.ja_toc.html#Comparison_Operators">6.3.1.2  比較演算子</A></H4>

<P>
<A NAME="IDX1106"></A>

</P>
<P>
<A NAME="IDX1107"></A>
<A NAME="IDX1108"></A>

</P>
<P>
<CODE>1</CODE> (TRUE), <CODE>0</CODE> (FALSE) または <CODE>NULL</CODE> を返します。
これらの関数は数値と文字列の両方で働きます。
必要ならば、文字は自動的に数字に変換され、数字は文字に変換されます。
(Perlがおこなっているみたいに)

</P>
<P>
MySQL は以下の規則で比較を行います：

</P>

<UL>
<LI>

どちらかまたは両方の引数が <CODE>NULL</CODE> の場合は、比較結果は <CODE>NULL</CODE> 
です。<CODE>&#60;=&#62;</CODE> 演算子を除きます。

<LI>

比較操作の両方の引数が文字列の場合、文字列として比較されます。

<LI>

両方の引数が整数の場合、整数として比較されます。

<LI>

16進数の値は、もし数値と比較されないのであれば、文字列として扱われます。

<LI>

<A NAME="IDX1109"></A>
<A NAME="IDX1110"></A>
引数の一方が <CODE>TIMESTAMP</CODE> または <CODE>DATETIME</CODE> フィールドで、他の引数が
定数の場合は、定数は比較前に timestamp に変換されます。これはより ODBC 
フレンドリにするためです。

<LI>

他の場合は全て浮動小数点(real)として比較されます。
</UL>

<P>
文字列の比較は、ケースに依存せず、標準のキャラクターセットに従って
行われます。(ISO-8859-1 Latin1 がデフォルトです。これは English です)

</P>
<P>
以下は、比較のために文字が数値へ変換されている例です：

</P>

<PRE>
mysql&#62; SELECT 1 &#62; '6x';
         -&#62; 0
mysql&#62; SELECT 7 &#62; '6x';
         -&#62; 1
mysql&#62; SELECT 0 &#62; 'x6';
         -&#62; 0
mysql&#62; SELECT 0 = 'x6';
         -&#62; 1
</PRE>

<DL COMPACT>

<DT><CODE>=</CODE>
<DD>
<A NAME="IDX1111"></A>
 <A NAME="IDX1112"></A>
 
等しい:

<PRE>
mysql&#62; SELECT 1 = 0;
        -&#62; 0
mysql&#62; SELECT '0' = 0;
        -&#62; 1
mysql&#62; SELECT '0.0' = 0;
        -&#62; 1
mysql&#62; SELECT '0.01' = 0;
        -&#62; 0
mysql&#62; SELECT '.01' = 0.01;
        -&#62; 1
</PRE>

<A NAME="IDX1113"></A>
<A NAME="IDX1114"></A>
<A NAME="IDX1115"></A>
<A NAME="IDX1116"></A>
<DT><CODE>&#60;&#62;</CODE>
<DD>
<DT><CODE>!=</CODE>
<DD>
等しくない:

<PRE>
mysql&#62; SELECT '.01' &#60;&#62; '0.01';
        -&#62; 1
mysql&#62; SELECT .01 &#60;&#62; '0.01';
        -&#62; 0
mysql&#62; SELECT 'zapp' &#60;&#62; 'zappp';
        -&#62; 1
</PRE>

<A NAME="IDX1117"></A>
<A NAME="IDX1118"></A>
<DT><CODE>&#60;=</CODE>
<DD>
より小さいか等しい:

<PRE>
mysql&#62; SELECT 0.1 &#60;= 2;
        -&#62; 1
</PRE>

<A NAME="IDX1119"></A>
<A NAME="IDX1120"></A>
<DT><CODE>&#60;</CODE>
<DD>
より小さい:

<PRE>
mysql&#62; SELECT 2 &#60; 2;
        -&#62; 0
</PRE>

<A NAME="IDX1121"></A>
<A NAME="IDX1122"></A>
<DT><CODE>&#62;=</CODE>
<DD>
より大きいか等しい:

<PRE>
mysql&#62; SELECT 2 &#62;= 2;
        -&#62; 1
</PRE>

<A NAME="IDX1123"></A>
<A NAME="IDX1124"></A>
<DT><CODE>&#62;</CODE>
<DD>
より大きい:

<PRE>
mysql&#62; SELECT 2 &#62; 2;
        -&#62; 0
</PRE>

<A NAME="IDX1125"></A>
<A NAME="IDX1126"></A>
<DT><CODE>&#60;=&#62;</CODE>
<DD>
等しい(NULL 安全):

<PRE>
mysql&#62; SELECT 1 &#60;=&#62; 1, NULL &#60;=&#62; NULL, 1 &#60;=&#62; NULL;
        -&#62; 1 1 0
</PRE>

<A NAME="IDX1127"></A>
<A NAME="IDX1128"></A>
<A NAME="IDX1129"></A>
<DT><CODE>IS NULL</CODE>
<DD>
<DT><CODE>IS NOT NULL</CODE>
<DD>
値が <CODE>NULL</CODE> とであるかどうかのテスト:

<PRE>
mysql&#62; SELECT 1 IS NULL, 0 IS NULL, NULL IS NULL;
        -&#62; 0 0 1
mysql&#62; SELECT 1 IS NOT NULL, 0 IS NOT NULL, NULL IS NOT NULL;
        -&#62; 1 1 0
</PRE>

<A NAME="IDX1130"></A>
<A NAME="IDX1131"></A>
To be able to work good with other programs, MySQL supports the following
extra features when using <CODE>IS NULL</CODE>:


<UL>
<LI>

You can find the last inserted row with:


<PRE>
SELECT * FROM tbl_name WHERE auto_col IS NULL
</PRE>

This can be disabled by setting <CODE>SQL_AUTO_IS_NULL=0</CODE>.  「<A HREF="manual.ja_MySQL_Optimisation.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節参照.
<LI>

For <CODE>NOT NULL</CODE> <CODE>DATE</CODE> and <CODE>DATETIME</CODE> columns you can find
the special date <CODE>0000-00-00</CODE> by using:


<PRE>
SELECT * FROM tbl_name WHERE date_column IS NULL
</PRE>

This is needed to get some ODBC applications to work (as ODBC doesn't
support a <CODE>0000-00-00</CODE> date)
</UL>

<A NAME="IDX1132"></A>
<DT><CODE>expr BETWEEN min AND max</CODE>
<DD>
もし <CODE>expr</CODE> が <CODE>min</CODE> 以上、 <CODE>max</CODE> 以下なら <CODE>1</CODE>を返します。
そうでないなら <CODE>0</CODE> を返します。
これは 全ての引数が同じ型ならば、<CODE>(min &#60;= expr AND expr &#60;= max)</CODE> と同じです。
Otherwise type conversion takes place, according to the rules
above, but applied to all the three arguments. <STRONG>Note</STRONG> that before
4.0.5 arguments were converted to the type of <CODE>expr</CODE> instead.


<PRE>
mysql&#62; SELECT 1 BETWEEN 2 AND 3;
        -&#62; 0
mysql&#62; SELECT 'b' BETWEEN 'a' AND 'c';
        -&#62; 1
mysql&#62; SELECT 2 BETWEEN 2 AND '3';
        -&#62; 1
mysql&#62; SELECT 2 BETWEEN 2 AND 'x-3';
        -&#62; 0
</PRE>

<A NAME="IDX1133"></A>
<DT><CODE>expr NOT BETWEEN min AND max</CODE>
<DD>
Same as <CODE>NOT (expr BETWEEN min AND max)</CODE>.

<A NAME="IDX1134"></A>
<DT><CODE>expr IN (value,...)</CODE>
<DD>
もし <CODE>expr</CODE> が <CODE>IN</CODE> リストにある値のどれかならば、<CODE>1</CODE> を返します
。
そうでなければ <CODE>0</CODE> を返します。
もし全ての値が定数なら、すべての値が <CODE>expr</CODE> の型に従って評価され、
ソートされます。この検索にはバイナリサーチが使用されます。
これは <CODE>IN</CODE> リストに定数を与えた場合、<CODE>IN</CODE> が速くなることを意味します。
もし <CODE>expr</CODE> がケース依存の文字式なら、ケース依存のやり方で比較されます。


<PRE>
mysql&#62; SELECT 2 IN (0,3,5,'wefwf');
        -&#62; 0
mysql&#62; SELECT 'wefwf' IN (0,3,5,'wefwf');
        -&#62; 1
</PRE>

From 4.1 (in line with the SQL-99 standard), <CODE>IN</CODE> returns <CODE>NULL</CODE> 
not only if the expression on the left hand side is <CODE>NULL</CODE>, but also if
no match is found in the list and one of the expressions in the list is 
<CODE>NULL</CODE>.

<A NAME="IDX1135"></A>
<DT><CODE>expr NOT IN (value,...)</CODE>
<DD>
<CODE>NOT (expr IN (value,...))</CODE> と同じ。

<A NAME="IDX1136"></A>
<DT><CODE>ISNULL(expr)</CODE>
<DD>
<CODE>expr</CODE> が <CODE>NULL</CODE> なら <CODE>1</CODE> を、そうでなければ <CODE>0</CODE> を返します

<PRE>
mysql&#62; SELECT ISNULL(1+1);
        -&#62; 0
mysql&#62; SELECT ISNULL(1/0);
        -&#62; 1
</PRE>

<CODE>NULL</CODE> の値を <CODE>=</CODE> を使用して比較した場合は常に偽(false) となることに
注意してください！

<A NAME="IDX1137"></A>
<A NAME="IDX1138"></A>
<DT><CODE>COALESCE(list)</CODE>
<DD>
list 中の、最初に現れた 非-<CODE>NULL</CODE> 要素を返します。


<PRE>
mysql&#62; SELECT COALESCE(NULL,1);
        -&#62; 1
mysql&#62; SELECT COALESCE(NULL,NULL,NULL);
        -&#62; NULL
</PRE>

<A NAME="IDX1139"></A>
<DT><CODE>INTERVAL(N,N1,N2,N3,...)</CODE>
<DD>
もし <CODE>N</CODE> &#60; <CODE>N1</CODE> なら <CODE>0</CODE> を返します。
もし <CODE>N</CODE> &#60; <CODE>N2</CODE> なら <CODE>1</CODE> を返します。
全ての引数は整数として扱われます。
これは <CODE>N1</CODE> &#60; <CODE>N2</CODE> &#60; <CODE>N3</CODE> &#60; <CODE>...</CODE> &#60; <CODE>Nn</CODE>を正しく動作さ
せるために
必要なことです。これはバイナリ検索が使用されます(速いです)


<PRE>
mysql&#62; SELECT INTERVAL(23, 1, 15, 17, 30, 44, 200);
        -&#62; 3
mysql&#62; SELECT INTERVAL(10, 1, 10, 100, 1000);
        -&#62; 2
mysql&#62; SELECT INTERVAL(22, 23, 30, 44, 200);
        -&#62; 0
</PRE>

</DL>

<P>
If you are comparing case-insensitive strings with any of the standard
operators (<CODE>=</CODE>, <CODE>&#60;&#62;</CODE>..., but not <CODE>LIKE</CODE>) trailing whitespace 
(spaces, tabs and newlines) will be ignored.

</P>

<PRE>
mysql&#62; SELECT "a" ="A \n";
        -&#62; 1
</PRE>



<H4><A NAME="Logical_Operators" HREF="manual.ja_toc.html#Logical_Operators">6.3.1.3  論理演算</A></H4>

<P>
<A NAME="IDX1140"></A>
<A NAME="IDX1141"></A>

</P>
<P>
全ての論理関数は <CODE>1</CODE> (TRUE) か <CODE>0</CODE> (FALSE) か <CODE>NULL</CODE> を返します。
(unknown は多くの場合 FALSE と同じです)：

</P>
<DL COMPACT>

<DT><CODE>NOT</CODE>
<DD>
<A NAME="IDX1142"></A>
 <A NAME="IDX1143"></A>
 
<DT><CODE>!</CODE>
<DD>
論理否定。引数が <CODE>0</CODE> なら <CODE>1</CODE> を返し、そうでなければ <CODE>0</CODE> を返しま
す。
例外: <CODE>NOT NULL</CODE> は <CODE>NULL</CODE> を返します:

<PRE>
mysql&#62; SELECT NOT 1;
        -&#62; 0
mysql&#62; SELECT NOT NULL;
        -&#62; NULL
mysql&#62; SELECT ! (1+1);
        -&#62; 0
mysql&#62; SELECT ! 1+1;
        -&#62; 1
</PRE>

最後の例は <CODE>1</CODE> を返します。なぜなら、式の評価が
 <CODE>(!1)+1</CODE> と同じだからです。

<A NAME="IDX1144"></A>
<A NAME="IDX1145"></A>
<DT><CODE>AND</CODE>
<DD>
<DT><CODE>&#38;&</CODE>
<DD>
論理積。
全ての引数が 非<CODE>0</CODE> または 非<CODE>NULL</CODE> であれば <CODE>1</CODE> を返します。
引数のどれかが <CODE>0</CODE> ならば <CODE>0</CODE> を返します。
それ以外は <CODE>NULL</CODE> を返します。

<PRE>
mysql&#62; SELECT 1 &#38;& 1;
        -&#62; 1
mysql&#62; SELECT 1 &#38;& 0;
        -&#62; 0
mysql&#62; SELECT 1 &#38;& NULL;
        -&#62; NULL
mysql&#62; SELECT 0 &#38;& NULL;
        -&#62; 0
mysql&#62; SELECT NULL &#38;& 0;
        -&#62; 0
</PRE>

Please note that MySQL versions prior to 4.0.5 stop evaluation when
a <CODE>NULL</CODE> is encountered, rather than continuing the process to
check for possible <CODE>0</CODE>s. This means that in these versions,
<CODE>SELECT (NULL AND 0)</CODE> returns <CODE>NULL</CODE> instead of <CODE>0</CODE>.
In 4.0.5 the code has been re-engineered so that the result will
always be as prescribed by ANSI while still using the optimisation
wherever possible.

<A NAME="IDX1146"></A>
<A NAME="IDX1147"></A>
<DT><CODE>OR</CODE>
<DD>
<DT><CODE>||</CODE>
<DD>
論理和。
Evaluates to <CODE>1</CODE> if any operand is non-zero,
to <CODE>NULL</CODE> if any operand is <CODE>NULL</CODE>,
otherwise <CODE>0</CODE> is returned.

<PRE>
mysql&#62; SELECT 1 || 1;
        -&#62; 1
mysql&#62; SELECT 1 || 0;
        -&#62; 1
mysql&#62; SELECT 0 || 0;
        -&#62; 0
mysql&#62; SELECT 0 || NULL;
        -&#62; NULL
mysql&#62; SELECT 1 || NULL;
        -&#62; 1
</PRE>

<A NAME="IDX1148"></A>
<DT><CODE>XOR</CODE>
<DD>
Logical XOR. 
Returns <CODE>NULL</CODE> if either operand is <CODE>NULL</CODE>.
For non-<CODE>NULL</CODE> operands, evaluates to <CODE>1</CODE> if an odd number
of operands is non-zero,
otherwise <CODE>0</CODE> is returned.

<PRE>
mysql&#62; SELECT 1 XOR 1;
        -&#62; 0
mysql&#62; SELECT 1 XOR 0;
        -&#62; 1
mysql&#62; SELECT 1 XOR NULL;
        -&#62; NULL
mysql&#62; SELECT 1 XOR 1 XOR 1;
        -&#62; 1
</PRE>

<CODE>a XOR b</CODE> is mathematically equal to
<CODE>(a AND (NOT b)) OR ((NOT a) and b)</CODE>.

<CODE>XOR</CODE> was added in version 4.0.2.
</DL>



<H4><A NAME="Control_flow_functions" HREF="manual.ja_toc.html#Control_flow_functions">6.3.1.4  フロー制御関数</A></H4>

<P>
<A NAME="IDX1149"></A>
<A NAME="IDX1150"></A>

</P>
<DL COMPACT>

<DT><CODE>IFNULL(expr1,expr2)</CODE>
<DD>
<A NAME="IDX1151"></A>
 <A NAME="IDX1152"></A>
 
<CODE>expr1</CODE> が <CODE>NULL</CODE> でない場合は <CODE>expr1</CODE> を、そうでなければ 
<CODE>expr2</CODE> を返します。
<CODE>IFNULL()</CODE> はどの文脈で使用されたかにより数値か文字を返します:

<PRE>
mysql&#62; SELECT IFNULL(1,0);
        -&#62; 1
mysql&#62; SELECT IFNULL(NULL,10);
        -&#62; 10
mysql&#62; SELECT IFNULL(1/0,10);
        -&#62; 10
mysql&#62; SELECT IFNULL(1/0,'yes');
        -&#62; 'yes'
</PRE>

In 4.0.6 and above the default result value of
<CODE>IFNULL(expr1,expr2)</CODE> is the more 'general' of the two expressions,
in the order <CODE>STRING</CODE>, <CODE>REAL</CODE> or <CODE>INTEGER</CODE>.The difference
to earlier MySQL versions are mostly notable when you create a table
based on expressions or MySQL has to internally store a value from
<CODE>IFNULL()</CODE> in a temporary table.


<PRE>
CREATE TABLE foo SELECT IFNULL(1,"test") as test;
</PRE>

In MySQL 4.0.6 the type for column 'test' is <CODE>CHAR(4)</CODE> while in
earlier versions you would get <CODE>BIGINT</CODE>.

<A NAME="IDX1153"></A>
<DT><CODE>NULLIF(expr1,expr2)</CODE>
<DD>
<CODE>expr1 = expr2</CODE> が真なら、<CODE>NULL</CODE> を返し、そうでなければ 
<CODE>expr1</CODE> を返します。
これは <CODE>CASE WHEN x = y THEN NULL ELSE x END</CODE> と同じです:

<PRE>
mysql&#62; SELECT NULLIF(1,1);
        -&#62; NULL
mysql&#62; SELECT NULLIF(1,2);
        -&#62; 1
</PRE>

注意: 引数が等しくない場合、<CODE>expr1</CODE> は MySQL 内部では2回評価されます。

<A NAME="IDX1154"></A>
<DT><CODE>IF(expr1,expr2,expr3)</CODE>
<DD>
<CODE>expr1</CODE> が真 (<CODE>expr1 &#60;&#62; 0</CODE> and <CODE>expr1 &#60;&#62; NULL</CODE>) の場合
 <CODE>expr2</CODE> を返し、そうでなければ <CODE>expr3</CODE> を返します。
<CODE>IF()</CODE> はどの文脈で使用されたかにより数値か文字を返します:


<PRE>
mysql&#62; SELECT IF(1&#62;2,2,3);
        -&#62; 3
mysql&#62; SELECT IF(1&#60;2,'yes','no');
        -&#62; 'yes'
mysql&#62; SELECT IF(STRCMP('test','test1'),'no','yes');
        -&#62; 'no'
</PRE>

If <CODE>expr2</CODE> or <CODE>expr3</CODE> is explicitely <CODE>NULL</CODE> then the
result type of the <CODE>IF()</CODE> function is the type of the not
<CODE>NULL</CODE> column. (This behaviour is new in MySQL 4.0.3).

<CODE>expr1</CODE> は <CODE>INTEGER</CODE> として評価されます。これは浮動小数点を使用する
場合、比較演算も使用すべきであることを意味します:


<PRE>
mysql&#62; SELECT IF(0.1,1,0);
        -&#62; 0
mysql&#62; SELECT IF(0.1&#60;&#62;0,1,0);
        -&#62; 1
</PRE>

上の最初の例では、 <CODE>IF(0.1)</CODE> は <CODE>0</CODE> を返します。なぜなら <CODE>0.1</CODE> は
整数値として変換され <CODE>IF(0)</CODE> になり、それをもとにしたテスト結果が
返るからです。 これはあなたの期待に添わないかもしれません。
 二番目の場合、 比較は、元の浮動小数点値が非ゼロかどうかテストします。
比較結果は整数として使用されます。

<CODE>IF()</CODE> のデフォルトの戻り値型(一時テーブルに格納される時に問題となり
ます)は MySQL バージョン 3.23 では次のように計算されます:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Expression</STRONG> </TD><TD> <STRONG>Return value</STRONG>
</TR NOSAVE>
<TR><TD>expr2 または expr3 が文字列を返す </TD><TD> 文字列
</TR NOSAVE>
<TR><TD>expr2 または expr3 が浮動小数点値を返す </TD><TD> 浮動小数点
</TR NOSAVE>
<TR><TD>expr2 または expr3 が整数を返す </TD><TD> 整数
</TR>
</TABLE>

If expr2 and expr3 are strings, then the result is case-insensitive if
both strings are case-insensitive. (Starting from 3.23.51)

<A NAME="IDX1155"></A>
<DT><CODE>CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ...] [ELSE result] END</CODE>
<DD>
<DT><CODE>CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END</CODE>
<DD>
最初の式は <CODE>value=compare-value</CODE> ならば <CODE>result</CODE> を返します。
二つ目の式では、最初の条件[condition] が真ならば、 <CODE>result</CODE> を返します。
もしマッチする result の値がなければ、 <CODE>ELSE</CODE> 以下の result が返ります。
もし <CODE>ELSE</CODE> 部分がなければ、 <CODE>NULL</CODE> が返ります:


<PRE>
mysql&#62; SELECT CASE 1 WHEN 1 THEN "one"
           WHEN 2 THEN "two" ELSE "more" END;
       -&#62; "one"
mysql&#62; SELECT CASE WHEN 1&#62;0 THEN "true" ELSE "false" END;
       -&#62; "true"
mysql&#62; SELECT CASE BINARY "B" WHEN "a" THEN 1 WHEN "b" THEN 2 END;
       -&#62; NULL
</PRE>

</DL>

<P>
戻り値の型(<CODE>INTEGER</CODE>, <CODE>DOUBLE</CODE>, <CODE>STRING</CODE>)は最初に返される値
(最初の <CODE>THEN</CODE> の後の式)の型と同じです。

</P>



<H3><A NAME="String_functions" HREF="manual.ja_toc.html#String_functions">6.3.2  文字列関数</A></H3>

<P>
<A NAME="IDX1156"></A>
<A NAME="IDX1157"></A>

</P>
<P>
サーバー側のパラメター <CODE>max_allowed_packet</CODE> よりも結果の長さが大きい場合、
文字列関数は <CODE>NULL</CODE> を返します。  「<A HREF="manual.ja_MySQL_Optimisation.html#Server_parameters">5.5.2  サーバーパラメーターのチューニング</A>」節参照.

</P>
<P>
文字の位置を扱う関数においては、一番最初の位置は数字の 1 です。

</P>
<DL COMPACT>

<DT><CODE>ASCII(str)</CODE>
<DD>
<A NAME="IDX1158"></A>
 
<CODE>str</CODE> の左端の文字の ASCII コード値を返します。
<CODE>str</CODE> が空文字の場合は <CODE>0</CODE> を返します。
<CODE>str</CODE> が <CODE>NULL</CODE> の場合は <CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; SELECT ASCII('2');
        -&#62; 50
mysql&#62; SELECT ASCII(2);
        -&#62; 50
mysql&#62; SELECT ASCII('dx');
        -&#62; 100
</PRE>

See also the <CODE>ORD()</CODE> function.

<A NAME="IDX1159"></A>
<DT><CODE>ORD(str)</CODE>
<DD>
文字列 str の左端の文字がマルチバイト文字の場合、文字のASCII コード値を次
の形式で返すことにより、マルチバイト文字のコードを返します:
<CODE>((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...]</CODE>.
左端の文字がマルチバイト文字でない場合は、<CODE>ASCII()</CODE> 関数と同じ値を返
します:


<PRE>
mysql&#62; SELECT ORD('2');
        -&#62; 50
</PRE>

<A NAME="IDX1160"></A>
<DT><CODE>CONV(N,from_base,to_base)</CODE>
<DD>
数字を、進数の違う数字に変換します。
数 <CODE>N</CODE> を <CODE>from_base</CODE> 進数から <CODE>to_base</CODE> 進数に
変換した場合の、文字表現を返します。
もし引数が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します。
引数 <CODE>N</CODE> は整数として解釈されますが、整数か文字列で指定します。
最小の進数は <CODE>2</CODE> で、最大は <CODE>36</CODE> です。
<CODE>to_base</CODE> が負数なら、<CODE>N</CODE> は符号付きの数になります。
<CODE>CONV</CODE> は 64-bit 精度で動作します:


<PRE>
mysql&#62; SELECT CONV("a",16,2);
        -&#62; '1010'
mysql&#62; SELECT CONV("6E",18,8);
        -&#62; '172'
mysql&#62; SELECT CONV(-17,10,-18);
        -&#62; '-H'
mysql&#62; SELECT CONV(10+"10"+'10'+0xa,10,10);
        -&#62; '40'
</PRE>

<A NAME="IDX1161"></A>
<DT><CODE>BIN(N)</CODE>
<DD>
<CODE>N</CODE> を二進数にした値を返します。<CODE>N</CODE> は longlong 数値です。
これは <CODE>CONV(N,10,2)</CODE> と同じです。
<CODE>N</CODE> が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; SELECT BIN(12);
        -&#62; '1100'
</PRE>

<A NAME="IDX1162"></A>
<DT><CODE>OCT(N)</CODE>
<DD>
<CODE>N</CODE> の8進数値を表す文字列を返します。<CODE>N</CODE> は longlong 数値です。
これは <CODE>CONV(N,10,8)</CODE> と同じです。<CODE>N</CODE> が <CODE>NULL</CODE> の場合は 
<CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; SELECT OCT(12);
        -&#62; '14'
</PRE>

<A NAME="IDX1163"></A>
<DT><CODE>HEX(N_or_S)</CODE>
<DD>
If N_OR_S is a number, returns a string representation of the hexadecimal
value of <CODE>N</CODE>, ここで <CODE>N</CODE> は 
longlong(<CODE>BIGINT</CODE>) 数値です。これは <CODE>CONV(N,10,16)</CODE> と同じです。

If N_OR_S is a string, returns a hexadecimal string of N_OR_S where each
character in N_OR_S is converted to 2 hexadecimal digits. This is the
invers of the <CODE>0xff</CODE> strings.


<PRE>
mysql&#62; SELECT HEX(255);
        -&#62; 'FF'
mysql&#62; SELECT HEX("abc");
        -&#62; 616263
mysql&#62; SELECT 0x616263;
        -&#62; "abc"
</PRE>

<A NAME="IDX1164"></A>
<DT><CODE>CHAR(N,...)</CODE>
<DD>
引数の ASCII コード値によって与えられた文字からなる文字列を返します。
<CODE>NULL</CODE> は飛ばされます:


<PRE>
mysql&#62; SELECT CHAR(77,121,83,81,'76');
        -&#62; 'MySQL'
mysql&#62; SELECT CHAR(77,77.3,'77.3');
        -&#62; 'MMM'
</PRE>

<A NAME="IDX1165"></A>
<DT><CODE>CONCAT(str1,str2,...)</CODE>
<DD>
引数を結合した結果を返します。引数が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します.
2個以上の引数を必要とします。
数値の引数は等価の文字列形式に変換されます:


<PRE>
mysql&#62; SELECT CONCAT('My', 'S', 'QL');
        -&#62; 'MySQL'
mysql&#62; SELECT CONCAT('My', NULL, 'QL');
        -&#62; NULL
mysql&#62; SELECT CONCAT(14.3);
        -&#62; '14.3'
</PRE>

<A NAME="IDX1166"></A>
<DT><CODE>CONCAT_WS(separator, str1, str2,...)</CODE>
<DD>
<CODE>CONCAT_WS()</CODE> は区切り文字つき CONCAT (CONCAT With Separator) を意味
し、<CODE>CONCAT()</CODE> の特殊な形式です。最初の引数は、残りの引数の区切り文字
です。区切り文字は残りの引数と同じような文字列です。区切り文字が 
<CODE>NULL</CODE> の場合、結果は <CODE>NULL</CODE> になります。関数は区切り文字より後
の <CODE>NULL</CODE> と空文字列を飛ばします。区切り文字は結合される文字列の間に
追加されます:


<PRE>
mysql&#62; SELECT CONCAT_WS(",","First name","Second name","Last Name");
       -&#62; 'First name,Second name,Last Name'
mysql&#62; SELECT CONCAT_WS(",","First name",NULL,"Last Name");
       -&#62; 'First name,Last Name'
</PRE>

<A NAME="IDX1167"></A>
<A NAME="IDX1168"></A>
<A NAME="IDX1169"></A>
<A NAME="IDX1170"></A>
<DT><CODE>LENGTH(str)</CODE>
<DD>
<DT><CODE>OCTET_LENGTH(str)</CODE>
<DD>
<DT><CODE>CHAR_LENGTH(str)</CODE>
<DD>
<DT><CODE>CHARACTER_LENGTH(str)</CODE>
<DD>
文字列 <CODE>str</CODE> の長さ:


<PRE>
mysql&#62; SELECT LENGTH('text');
        -&#62; 4
mysql&#62; SELECT OCTET_LENGTH('text');
        -&#62; 4
</PRE>

注意: <CODE>CHAR_LENGTH()</CODE> と <CODE>CHARACTER_LENGTH()</CODE>
については、マルチバイト文字は一度だけしかカウントされません。

<A NAME="IDX1171"></A>
<DT><CODE>BIT_LENGTH(str)</CODE>
<DD>
Returns the length of the string <CODE>str</CODE> in bits:


<PRE>
mysql&#62; SELECT BIT_LENGTH('text');
        -&#62; 32
</PRE>

<A NAME="IDX1172"></A>
<A NAME="IDX1173"></A>
<DT><CODE>LOCATE(substr,str)</CODE>
<DD>
<DT><CODE>POSITION(substr IN str)</CODE>
<DD>
<CODE>str</CODE> 内にある <CODE>substr</CODE> 文字列の位置を返します。最初の位置は 1 です。
<CODE>str</CODE> 内に <CODE>substr</CODE> がない時は <CODE>0</CODE> を返します:


<PRE>
mysql&#62; SELECT LOCATE('bar', 'foobarbar');
        -&#62; 4
mysql&#62; SELECT LOCATE('xbar', 'foobar');
        -&#62; 0
</PRE>

この関数はマルチバイトでも安全です。
In MySQL 3.23 this function is case
sensitive, while in 4.0 it's only case-sensitive if either argument is
a binary string.

<A NAME="IDX1174"></A>
<DT><CODE>LOCATE(substr,str,pos)</CODE>
<DD>
文字列 <CODE>str</CODE> 中に最初に顕れた <CODE>substr</CODE> 文字の位置を返します。
<CODE>pos</CODE> は検索を開始する位置です。
<CODE>str</CODE> に <CODE>substr</CODE> がなければ <CODE>0</CODE> を返します:


<PRE>
mysql&#62; SELECT LOCATE('bar', 'foobarbar',5);
        -&#62; 7
</PRE>

この関数はマルチバイトでも安全です。
In MySQL 3.23 this function is case
sensitive, while in 4.0 it's only case-sensitive if either argument is
a binary string.

<A NAME="IDX1175"></A>
<DT><CODE>INSTR(str,substr)</CODE>
<DD>
文字列 <CODE>str</CODE> 内の最初の文字列 <CODE>substr</CODE> の位置を返します。
これは引数が入れ替わっていることをのぞいて、
2つの引数を与えた <CODE>LOCATE</CODE> と同じです:


<PRE>
mysql&#62; SELECT INSTR('foobarbar', 'bar');
        -&#62; 4
mysql&#62; SELECT INSTR('xbar', 'foobar');
        -&#62; 0
</PRE>

この関数はマルチバイトでも安全です。
In MySQL 3.23 this function is case
sensitive, while in 4.0 it's only case-sensitive if either argument is
a binary string.

<A NAME="IDX1176"></A>
<DT><CODE>LPAD(str,len,padstr)</CODE>
<DD>
<CODE>str</CODE> の長さが <CODE>len</CODE> になるまで文字列 <CODE>str</CODE> の始めに <CODE>padstr</CODE> を埋めます。
<CODE>str</CODE> が <CODE>len</CODE> よりも長い場合は、<CODE>len</CODE> 文字に短くされます。


<PRE>
mysql&#62; SELECT LPAD('hi',4,'??');
        -&#62; '??hi'
</PRE>

<A NAME="IDX1177"></A>
<DT><CODE>RPAD(str,len,padstr)</CODE>
<DD>
<CODE>str</CODE> の長さが <CODE>len</CODE> になるまで文字列 <CODE>str</CODE> の終わりに <CODE>padstr</CODE> を埋めます。
<CODE>str</CODE> が <CODE>len</CODE> よりも長い場合は、<CODE>len</CODE> 文字に短くされます。


<PRE>
mysql&#62; SELECT RPAD('hi',5,'?');
        -&#62; 'hi???'
</PRE>

<A NAME="IDX1178"></A>
<DT><CODE>LEFT(str,len)</CODE>
<DD>
文字列 <CODE>str</CODE> の最初から <CODE>len</CODE> 個の文字を得ます:


<PRE>
mysql&#62; SELECT LEFT('foobarbar', 5);
        -&#62; 'fooba'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1179"></A>
<DT><CODE>RIGHT(str,len)</CODE>
<DD>
文字列 <CODE>str</CODE> の最後から <CODE>len</CODE> 個の文字を得ます:


<PRE>
mysql&#62; SELECT RIGHT('foobarbar', 4);
        -&#62; 'rbar'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1180"></A>
<A NAME="IDX1181"></A>
<DT><CODE>SUBSTRING(str,pos,len)</CODE>
<DD>
<DT><CODE>SUBSTRING(str FROM pos FOR len)</CODE>
<DD>
<DT><CODE>MID(str,pos,len)</CODE>
<DD>
<CODE>str</CODE> の <CODE>pos</CODE> 位置から <CODE>len</CODE> 文字数分の文字列を返します。
<CODE>FROM</CODE> の違いは ANSI SQL 92 構文です:


<PRE>
mysql&#62; SELECT SUBSTRING('Quadratically',5,6);
        -&#62; 'ratica'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1182"></A>
<DT><CODE>SUBSTRING(str,pos)</CODE>
<DD>
<DT><CODE>SUBSTRING(str FROM pos)</CODE>
<DD>
文字列 <CODE>str</CODE> の 位置 <CODE>pos</CODE> 以降の文字を返します:


<PRE>
mysql&#62; SELECT SUBSTRING('Quadratically',5);
        -&#62; 'ratically'
mysql&#62; SELECT SUBSTRING('foobarbar' FROM 4);
        -&#62; 'barbar'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1183"></A>
<DT><CODE>SUBSTRING_INDEX(str,delim,count)</CODE>
<DD>
<CODE>str</CODE> から、区切り文字 <CODE>delim</CODE> が <CODE>count</CODE> 個現れた位置から前の
文字列を返します。<CODE>count</CODE> が正の場合は文字列は左から検索され、
<CODE>count</CODE> が負の場合は文字列は右から検索されます:


<PRE>
mysql&#62; SELECT SUBSTRING_INDEX('www.mysql.com', '.', 2);
        -&#62; 'www.mysql'
mysql&#62; SELECT SUBSTRING_INDEX('www.mysql.com', '.', -2);
        -&#62; 'mysql.com'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1184"></A>
<DT><CODE>LTRIM(str)</CODE>
<DD>
文字列 <CODE>str</CODE> の最初から空白文字を削除します:


<PRE>
mysql&#62; SELECT LTRIM('  barbar');
        -&#62; 'barbar'
</PRE>

<A NAME="IDX1185"></A>
<DT><CODE>RTRIM(str)</CODE>
<DD>
文字列 <CODE>str</CODE> の最後から空白文字を削除します:


<PRE>
mysql&#62; SELECT RTRIM('barbar   ');
        -&#62; 'barbar'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1186"></A>
<DT><CODE>TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str)</CODE>
<DD>
全ての <CODE>remstr</CODE> プレフィックスまたはサフィックスを  <CODE>str</CODE> から削除した
文字列を返します。<CODE>BOTH</CODE>, <CODE>LEADING</CODE> そして <CODE>TRAILING</CODE> が
使用されない場合、<CODE>BOTH</CODE> が適用されます。<CODE>remstr</CODE> が与えられないと、
空白が削除されます:


<PRE>
mysql&#62; SELECT TRIM('  bar   ');
        -&#62; 'bar'
mysql&#62; SELECT TRIM(LEADING 'x' FROM 'xxxbarxxx');
        -&#62; 'barxxx'
mysql&#62; SELECT TRIM(BOTH 'x' FROM 'xxxbarxxx');
        -&#62; 'bar'
mysql&#62; SELECT TRIM(TRAILING 'xyz' FROM 'barxxyz');
        -&#62; 'barx'
</PRE>

This function is multi-byte safe.  In MySQL 3.23 this function is case
insensitive, while in 4.0 it's only case insensitive if either argument is
a binary string.

<A NAME="IDX1187"></A>
<DT><CODE>SOUNDEX(str)</CODE>
<DD>
<CODE>str</CODE> からの soundex 文字列を返します。発音が``大体同じ''２つの文字列
は同じ soundex 文字列を持ちます。``標準の'' soundex 文字列は4文字長ですが、
<CODE>SOUNDEX()</CODE> 関数は任意の長さの文字列を返します。<CODE>SUBSTRING()</CODE> を
結果に使用して、``標準の'' soundex 文字列を得ることができます。与えられた
文字列中の非アルファベット文字は無視されます。A-Z の半以外のすべての国際的
なアルファベット文字は母音とみなされます:


<PRE>
mysql&#62; SELECT SOUNDEX('Hello');
        -&#62; 'H400'
mysql&#62; SELECT SOUNDEX('Quadratically');
        -&#62; 'Q36324'
</PRE>

<A NAME="IDX1188"></A>
<DT><CODE>SPACE(N)</CODE>
<DD>
<CODE>N</CODE> 個の空白文字を返します:


<PRE>
mysql&#62; SELECT SPACE(6);
        -&#62; '      '
</PRE>

<A NAME="IDX1189"></A>
<DT><CODE>REPLACE(str,from_str,to_str)</CODE>
<DD>
文字列 <CODE>str</CODE> 内の全ての文字列 <CODE>from_str</CODE> を <CODE>to_str</CODE> に
置き換えます:


<PRE>
mysql&#62; SELECT REPLACE('www.mysql.com', 'w', 'Ww');
        -&#62; 'WwWwWw.mysql.com'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1190"></A>
<DT><CODE>REPEAT(str,count)</CODE>
<DD>
<CODE>str</CODE> を <CODE>count</CODE> 回繰り返します。<CODE>count &#60;= 0</CODE> の場合は
空の文字列を返します。<CODE>str</CODE> または <CODE>count</CODE> が <CODE>NULL</CODE> 
または、<CODE>LENGTH(str)*count &#62; max_allowed_packet</CODE> の場合は 
<CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; SELECT REPEAT('MySQL', 3);
        -&#62; 'MySQLMySQLMySQL'
</PRE>

<A NAME="IDX1191"></A>
<DT><CODE>REVERSE(str)</CODE>
<DD>
文字列 <CODE>str</CODE> を反転します:


<PRE>
mysql&#62; SELECT REVERSE('abc');
        -&#62; 'cba'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1192"></A>
<DT><CODE>INSERT(str,pos,len,newstr)</CODE>
<DD>
<CODE>str</CODE> 中の <CODE>pos</CODE> 位置から <CODE>len</CODE> 長の文字列を 
<CODE>newstr</CODE> で置き換えます。<CODE>str</CODE> 内の最初の位置は1です:


<PRE>
mysql&#62; SELECT INSERT('Quadratic', 3, 4, 'What');
        -&#62; 'QuWhattic'
</PRE>

この関数はマルチバイトでも安全です。

<A NAME="IDX1193"></A>
<DT><CODE>ELT(N,str1,str2,str3,...)</CODE>
<DD>
<CODE>N</CODE> = <CODE>1</CODE> なら <CODE>str1</CODE> を、<CODE>N</CODE> = <CODE>2</CODE> なら <CODE>str2</CODE> を
返します。
<CODE>N</CODE> が <CODE>1</CODE> より小さい場合、または引数の数より大きい場合は <CODE>NULL</CODE> 
が返されます。
<CODE>ELT()</CODE> は <CODE>FIELD()</CODE> の逆です:


<PRE>
mysql&#62; SELECT ELT(1, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'ej'
mysql&#62; SELECT ELT(4, 'ej', 'Heja', 'hej', 'foo');
        -&#62; 'foo'
</PRE>

<A NAME="IDX1194"></A>
<DT><CODE>FIELD(str,str1,str2,str3,...)</CODE>
<DD>
<CODE>str1</CODE>, <CODE>str2</CODE>, <CODE>str3</CODE>, <CODE>...</CODE> リスト内の <CODE>str</CODE> のインデ
ックスを
返します。<CODE>str</CODE> が見つからなければ <CODE>0</CODE> を返します。
<CODE>FIELD()</CODE> は <CODE>ELT()</CODE> の逆です:


<PRE>
mysql&#62; SELECT FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 2
mysql&#62; SELECT FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo');
        -&#62; 0
</PRE>

<A NAME="IDX1195"></A>
<DT><CODE>FIND_IN_SET(str,strlist)</CODE>
<DD>
<CODE>str</CODE> が <CODE>strlist</CODE> 中にあれば、値 <CODE>1</CODE> から <CODE>N</CODE> を返します。
<CODE>strlist</CODE> は、それぞれの異なる値が ',' で分割された文字列です。最初の
引数が定数文字列で２番目が <CODE>SET</CODE> 型のフィールドの場合<CODE>FIND_IN_SET</CODE> は
ビット演算を使用して最適化されます！
<CODE>strlist</CODE> が空文字なら <CODE>0</CODE> を返します。
どちらかの引数が <CODE>NULL</CODE> なら <CODE>NULL</CODE> を返します.
この関数は最初の引数が  ',' を含んだ場合、うまく動かないでしょう:


<PRE>
mysql&#62; SELECT FIND_IN_SET('b','a,b,c,d');
        -&#62; 2
</PRE>

<A NAME="IDX1196"></A>
<DT><CODE>MAKE_SET(bits,str1,str2,...)</CODE>
<DD>
<CODE>bits</CODE> に指定されたビットに対応する文字列のセットを返します。
(文字列が複数の場合、 <SAMP>`,'</SAMP> で区切られます) 
<CODE>str1</CODE> が ビット 0 に対応し、<CODE>str2</CODE> が ビット 1 に対応し、
<CODE>str3</CODE> が ビット 2 に対応し... となります。
<CODE>str1</CODE>, <CODE>str2</CODE>, <CODE>...</CODE> 中に含まれている <CODE>NULL</CODE> 文字は
結果には追加されません:


<PRE>
mysql&#62; SELECT MAKE_SET(1,'a','b','c');
        -&#62; 'a'
mysql&#62; SELECT MAKE_SET(1 | 4,'hello','nice','world');
        -&#62; 'hello,world'
mysql&#62; SELECT MAKE_SET(0,'a','b','c');
        -&#62; ''
</PRE>

<A NAME="IDX1197"></A>
<DT><CODE>EXPORT_SET(bits,on,off,[separator,[number_of_bits]])</CODE>
<DD>
'bits' に与えられた数値に対し、
全てのセットされているビットを 'on' で指定された文字で表し、
リセットされているビットを 'off' で指定された文字で表した文字列を返します。
それぞれの文字は 'separator' (デフォルト',') で示された文字で区切られ、
'number_of_bits' (default 64) に与えられた桁数だけのビットを表示します:


<PRE>
mysql&#62; SELECT EXPORT_SET(5,'Y','N',',',4)
        -&#62; Y,N,Y,N
</PRE>

<A NAME="IDX1198"></A>
<A NAME="IDX1199"></A>
<DT><CODE>LCASE(str)</CODE>
<DD>
<DT><CODE>LOWER(str)</CODE>
<DD>
<CODE>str</CODE> を現在のキャラクターセットマッピング
 (デフォルト ISO-8859-1 Latin1) にしたがって小文字に変換します:


<PRE>
mysql&#62; SELECT LCASE('QUADRATICALLY');
        -&#62; 'quadratically'
</PRE>

This function is multi-byte safe.  In MySQL 3.23 this function is case
insensitive, while in 4.0 it's only case insensitive if either argument is
a binary string.

<A NAME="IDX1200"></A>
<A NAME="IDX1201"></A>
<DT><CODE>UCASE(str)</CODE>
<DD>
<DT><CODE>UPPER(str)</CODE>
<DD>
<CODE>str</CODE> を現在のキャラクターセットマッピング
 (デフォルト ISO-8859-1 Latin1) にしたがって大文字に変換します:


<PRE>
mysql&#62; SELECT UCASE('Hej');
        -&#62; 'HEJ'
</PRE>

This function is multi-byte safe.  In MySQL 3.23 this function is case
insensitive, while in 4.0 it's only case insensitive if either argument is
a binary string.

<A NAME="IDX1202"></A>
<A NAME="IDX1203"></A>
<DT><CODE>LOAD_FILE(file_name)</CODE>
<DD>
ファイルを読み込み、ファイルの中身を文字として返します。 ファイルは
サーバー上になくてはならず、ファイルをフルパスで指定しなければなりません。
そして、 <CODE>FILE</CODE> 権限がなければなりません。 ファイルは全員に
読み込み可能でなければならず、そして、 <CODE>max_allowed_packet</CODE> より
小さいサイズでなければなりません。

このうちどれかの理由で、もしファイルが存在しないか読み込めない場合、
この関数は <CODE>NULL</CODE> を返します:


<PRE>
mysql&#62; UPDATE tbl_name
           SET blob_column=LOAD_FILE("/tmp/picture")
           WHERE id=1;
</PRE>

<STRONG>MySQL 3.23</STRONG> を使用していない場合、あなたのアプリケーション内部でファ
イルを読み込んで、ファイル情報でデータベースを更新するための 
<CODE>INSERT</CODE> ステートメントを生成する必要があります。これを行なう一つの方
法は、MySQL++ ライブラリを使用する場合、
<a HREF="http://www.mysql.com/documentation/mysql++/mysql++-examples.html">http://www.mysql.com/documentation/mysql++/mysql++-examples.html</a> で
見つけられます。

<A NAME="IDX1204"></A>
<DT><CODE>QUOTE(str)</CODE>
<DD>
Quotes a string to produce a result that can be used as a properly-escaped
data value in a SQL statement.  The string is returned surrounded by single
quotes and with each instance of single quote (<SAMP>`''</SAMP>), backslash (<SAMP>`\'</SAMP>),
ASCII NUL, and Control-Z preceded by a backslash.  If the argument is
<CODE>NULL</CODE>, the return value is the word ``NULL'' without surrounding
single quotes.


<PRE>
mysql&#62; SELECT QUOTE("Don't");
        -&#62; 'Don\'t!'
mysql&#62; SELECT QUOTE(NULL);
        -&#62; NULL
</PRE>

</DL>



<H4><A NAME="String_comparison_functions" HREF="manual.ja_toc.html#String_comparison_functions">6.3.2.1  String Comparison Functions</A></H4>

<P>
<A NAME="IDX1205"></A>
<A NAME="IDX1206"></A>

</P>

<P>
MySQL は必要とあらば数値を文字列に変換します。
逆も同様に行います：

</P>

<PRE>
mysql&#62; SELECT 1+"1";
        -&#62; 2
mysql&#62; SELECT CONCAT(2,' test');
        -&#62; '2 test'
</PRE>

<P>
明示的に数値を文字列に変換したければ、<CODE>CONCAT()</CODE> に引数として渡して下
さい。

</P>
<P>
文字列関数は引数としてバイナリ文字列が与えられると、結果の文字列もバイナリ
文字列になります。文字列に変換された数値はバイナリ文字列とみなされます。こ
れは比較にだけ影響します。

</P>
<P>
<A NAME="IDX1207"></A>
<A NAME="IDX1208"></A>

</P>
<P>
通常、比較される表現がケース依存でない場合、比較はケース非依存で行われます。

</P>
<DL COMPACT>

<DT><CODE>expr LIKE pat [ESCAPE 'escape-char']</CODE>
<DD>
<A NAME="IDX1209"></A>
 
SQL の簡単な正規表現比較です。<CODE>1</CODE> (TRUE) または <CODE>0</CODE> (FALSE) を返します
。
<CODE>LIKE</CODE> には2つのワイルドカードがあります:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Char</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>%</CODE> </TD><TD> 任意の数の文字(0文字も含む)に適合します。
</TR NOSAVE>
<TR><TD><CODE>_</CODE> </TD><TD> 厳密に1つの文字に適合します。
</TR>
</TABLE>


<PRE>
mysql&#62; SELECT 'David!' LIKE 'David_';
        -&#62; 1
mysql&#62; SELECT 'David!' LIKE '%D%v%';
        -&#62; 1
</PRE>

ワイルドカード文字のテストをするためには、エスケープ文字より先行しておこなって
ください。
<CODE>ESCAPE</CODE> を指定しない場合は、文字 <SAMP>`\'</SAMP> が使われます:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>String</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>\%</CODE> </TD><TD> 1つの <CODE>%</CODE> に適合します。
</TR NOSAVE>
<TR><TD><CODE>\_</CODE> </TD><TD> 1つの <CODE>_</CODE> に適合します。
</TR>
</TABLE>


<PRE>
mysql&#62; SELECT 'David!' LIKE 'David\_';
        -&#62; 0
mysql&#62; SELECT 'David_' LIKE 'David\_';
        -&#62; 1
</PRE>

違うエスケープ文字を指定するには、 <CODE>ESCAPE</CODE> 節を使用します:


<PRE>
mysql&#62; SELECT 'David_' LIKE 'David|_' ESCAPE '|';
        -&#62; 1
</PRE>

次の２つのステートメントは、オペランドの一つがバイナリ文字列でなければ、文
字列比較がケース非依存であることを示しています:


<PRE>
mysql&#62; SELECT 'abc' LIKE 'ABC';
        -&#62; 1
mysql&#62; SELECT 'abc' LIKE BINARY 'ABC';
        -&#62; 0
</PRE>

<CODE>LIKE</CODE> は数値表現でも許されます！
(これは MySQL の、ANSI SQL <CODE>LIKE</CODE> に対する拡張です)

注意： MySQL は文字列中に C のエスケープ文字を使用しているので(e.g.,
<SAMP>`\n'</SAMP>),  <CODE>LIKE</CODE> の指定文字列として使用するには <SAMP>`\'</SAMP> を
二倍しなくてはなりません。 例えば、 <SAMP>`\n'</SAMP> を探すには、<SAMP>`\\n'</SAMP> と
記述します。 <SAMP>`\'</SAMP> を探すには、  <SAMP>`\\\\'</SAMP> (バックスラッシュは、
一つはパーサーに取り除かれ、パターンマッチが行われる際にもうひとつ
取り除かれ、一致を探すために残った一つのバックスラッシュが使用されます)

<A NAME="IDX1210"></A>
<DT><CODE>expr NOT LIKE pat [ESCAPE 'escape-char']</CODE>
<DD>
<CODE>NOT (expr LIKE pat [ESCAPE 'escape-char'])</CODE> と同じ

<A NAME="IDX1211"></A>
<DT><CODE>expr SOUNDS LIKE expr</CODE>
<DD>
Same as <CODE>SOUNDEX(expr)=SOUNDEX(expr)</CODE> (available only in version 4.1 or later). 

<A NAME="IDX1212"></A>
<A NAME="IDX1213"></A>
<A NAME="IDX1214"></A>
<A NAME="IDX1215"></A>
<DT><CODE>expr REGEXP pat</CODE>
<DD>
<DT><CODE>expr RLIKE pat</CODE>
<DD>
パターン <CODE>pat</CODE> に対し、文字式 <CODE>expr</CODE> のパターンマッチを行います。
パターン <CODE>pat</CODE> は正規表現の拡張が使用できます。 「<A HREF="manual.ja_Regexp.html#Regexp">G  MySQL の正規表現</A>」節参照.
もし <CODE>expr</CODE> が <CODE>pat</CODE> にマッチするなら <CODE>1</CODE> を返し、
でなければ <CODE>0</CODE> を返します。
<CODE>RLIKE</CODE> は <CODE>REGEXP</CODE> と同義で、<CODE>mSQL</CODE> 互換を提供します。
注意: MySQL は C エスケープ構文を文字中に使用しており(<CODE>\n</CODE>)、
 <CODE>REGEXP</CODE> 中で使用される <CODE>'\'</CODE> 文字はすべて、二重に書かなければ
なりません。
MySQL 3.23.4 <CODE>REGEXP</CODE> は、普通の文字 (not binary) はケース非依存で
す:


<PRE>
mysql&#62; SELECT 'Monty!' REGEXP 'm%y%%';
        -&#62; 0
mysql&#62; SELECT 'Monty!' REGEXP '.*';
        -&#62; 1
mysql&#62; SELECT 'new*\n*line' REGEXP 'new\\*.\\*line';
        -&#62; 1
mysql&#62; SELECT "a" REGEXP "A", "a" REGEXP BINARY "A";
        -&#62; 1  0
mysql&#62; SELECT "a" REGEXP "^[a-d]";
        -&#62; 1
</PRE>

<CODE>REGEXP</CODE> and <CODE>RLIKE</CODE> は、文字の型を決定する場合、
カレントのキャラクターセットを使用します。
(ISO-8859-1 Latin1 がデフォルト)

<A NAME="IDX1216"></A>
<DT><CODE>expr NOT REGEXP pat</CODE>
<DD>
<DT><CODE>expr NOT RLIKE pat</CODE>
<DD>
<CODE>NOT (expr REGEXP pat)</CODE> と同じ.

<A NAME="IDX1217"></A>
<DT><CODE>STRCMP(expr1,expr2)</CODE>
<DD>
<CODE>STRCMP()</CODE>
文字列が同じなら <CODE>0</CODE> を返します。そうでなければ、最初の引数がソート順で小
さければ <CODE>-1</CODE> を返します。そうでなければ <CODE>1</CODE> を返します:


<PRE>
mysql&#62; SELECT STRCMP('text', 'text2');
        -&#62; -1
mysql&#62; SELECT STRCMP('text2', 'text');
        -&#62; 1
mysql&#62; SELECT STRCMP('text', 'text');
        -&#62; 0
</PRE>

<A NAME="IDX1218"></A>
<DT><CODE>MATCH (col1,col2,...) AGAINST (expr)</CODE>
<DD>
<CODE>MATCH ... AGAINST()</CODE> は全文検索に使用され、妥当性を返します。フィー
ルド <CODE>(col1,col2,...)</CODE> 内のテキストとクエリ <CODE>expr</CODE> との間の類似
点を評価します。妥当性は正の浮動小数点数です。妥当性 0 は類似点なしを意味
します。<CODE>MATCH ... AGAINST()</CODE> が動作するためには、最初に 
<STRONG>FULLTEXT</STRONG> インデックスが作成する必要があります。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照。
<CODE>MATCH ... AGAINST()</CODE> は MySQL 3.23.23 以上のバージョンで有
効です。
<CODE>IN BOOLEAN MODE</CODE> extension was added in version 4.0.1. 
詳細と使用例は
 「<A HREF="manual.ja_Reference.html#Fulltext_Search">6.8  MySQL Full-text Search</A>」節.
</DL>



<H4><A NAME="Case_Sensitivity_Operators" HREF="manual.ja_toc.html#Case_Sensitivity_Operators">6.3.2.2  Case-Sensitivity</A></H4>

<P>
<A NAME="IDX1219"></A>

</P>
<P>
<A NAME="IDX1220"></A>
<A NAME="IDX1221"></A>

</P>
<DL COMPACT>

<DT><CODE><CODE>BINARY</CODE></CODE>
<DD>
<A NAME="IDX1222"></A>
 
<CODE>BINARY</CODE> 演算子は、これ以降に続く文字をバイナリにキャストします。
これはたとえフィールドが <CODE>BINARY</CODE> や <CODE>BLOB</CODE> 定義でなくても、
ケース依存でフィールドを比較することが出来る簡単な方法です:

<PRE>
mysql&#62; SELECT "a" = "A";
        -&#62; 1
mysql&#62; SELECT BINARY "a" = "A";
        -&#62; 0
</PRE>

<CODE>BINARY string</CODE> is a shorthand for <CODE>CAST(string AS BINARY)</CODE>.
 「<A HREF="manual.ja_Reference.html#Cast_Functions">6.3.5  Cast Functions</A>」節参照.
<CODE>BINARY</CODE> は MySQL 3.23.0 で登場しました。

注意: いくつかの文脈では、インデックスされたフィールドを <CODE>BINARY</CODE> に
キャストした時、MySQL はインデックスを効率よく使用できません。
</DL>

<P>
BLOB をケース非依存で比較したい場合、比較を行なう前に BLOB を常に大文字に
変換します:

</P>

<PRE>
SELECT 'A' LIKE UPPER(blob_col) FROM table_name;
</PRE>

<P>
より柔軟に文字列を比較するために、我々は間もなく異なる文字セット間のキャス
トを導入する予定です。

</P>



<H3><A NAME="Numeric_Functions" HREF="manual.ja_toc.html#Numeric_Functions">6.3.3  Numeric Functions</A></H3>



<H4><A NAME="Arithmetic_functions" HREF="manual.ja_toc.html#Arithmetic_functions">6.3.3.1  算術演算</A></H4>

<P>
<A NAME="IDX1223"></A>
普通の算術演算が有効です。
<CODE>-</CODE>, <CODE>+</CODE>, <CODE>*</CODE> は、二つの引数が正数ならば
 <CODE>BIGINT</CODE> (64bit精度) で計算されることに注意してください！
If one of the argument is an unsigned integer, and the other argument
is also an integer, the result will be an unsigned integer.
 「<A HREF="manual.ja_Reference.html#Cast_Functions">6.3.5  Cast Functions</A>」節参照.

</P>
<P>
<A NAME="IDX1224"></A>
<A NAME="IDX1225"></A>
<DL COMPACT>

<DT><CODE>+</CODE>
<DD>
<A NAME="IDX1226"></A>
 <A NAME="IDX1227"></A>
 
足し算:

<PRE>
mysql&#62; SELECT 3+5;
        -&#62; 8
</PRE>

<A NAME="IDX1228"></A>
<A NAME="IDX1229"></A>
<DT><CODE>-</CODE>
<DD>
引き算:

<PRE>
mysql&#62; SELECT 3-5;
        -&#62; -2
</PRE>

<A NAME="IDX1230"></A>
<A NAME="IDX1231"></A>
<DT><CODE>*</CODE>
<DD>
掛け算:

<PRE>
mysql&#62; SELECT 3*5;
        -&#62; 15
mysql&#62; SELECT 18014398509481984*18014398509481984.0;
        -&#62; 324518553658426726783156020576256.0
mysql&#62; SELECT 18014398509481984*18014398509481984;
        -&#62; 0
</PRE>

最後の式の結果は不当です。なぜなら結果は <CODE>BIGINT</CODE> の 64 ビットを超えた整数だからです。

<A NAME="IDX1232"></A>
<A NAME="IDX1233"></A>
<DT><CODE>/</CODE>
<DD>
割り算:

<PRE>
mysql&#62; SELECT 3/5;
        -&#62; 0.60
</PRE>

0 で割った場合、<CODE>NULL</CODE> になります。


<PRE>
mysql&#62; SELECT 102/(1-1);
        -&#62; NULL
</PRE>

演算結果が整数になる場合にだけ、 <CODE>BIGINT</CODE> を用いて割り算は計算されます。
</DL>



<H4><A NAME="Mathematical_functions" HREF="manual.ja_toc.html#Mathematical_functions">6.3.3.2  数学関数</A></H4>
<P>
すべての数学関数はエラーの場合 <CODE>NULL</CODE> を返します。

</P>
<P>
<A NAME="IDX1234"></A>
<A NAME="IDX1235"></A>

</P>
<DL COMPACT>

<DT><CODE>-</CODE>
<DD>
<A NAME="IDX1236"></A>
 <A NAME="IDX1237"></A>
 <A NAME="IDX1238"></A>
 
符号。引数の符号を変更します:

<PRE>
mysql&#62; SELECT - 2;
        -&#62; -2
</PRE>

このオペレーターが <CODE>BIGINT</CODE> とともに使用された場合、
返り値は <CODE>BIGINT</CODE> であることに注意してください!  これは <CODE>-2^63</CODE> の値を
持つかもしれない整数を、 <CODE>-</CODE> で使用してはならないことを意味します！

<A NAME="IDX1239"></A>
<DT><CODE>ABS(X)</CODE>
<DD>
Returns the absolute value of <CODE>X</CODE>:

<PRE>
mysql&#62; SELECT ABS(2);
        -&#62; 2
mysql&#62; SELECT ABS(-32);
        -&#62; 32
</PRE>

この関数は <CODE>BIGINT</CODE> 値とともに使用されると安全です。

<A NAME="IDX1240"></A>
<DT><CODE>SIGN(X)</CODE>
<DD>
<CODE>X</CODE> が負数、ゼロ、整数によって、 <CODE>-1</CODE>, <CODE>0</CODE> or <CODE>1</CODE> を
返します:

<PRE>
mysql&#62; SELECT SIGN(-32);
        -&#62; -1
mysql&#62; SELECT SIGN(0);
        -&#62; 0
mysql&#62; SELECT SIGN(234);
        -&#62; 1
</PRE>

<A NAME="IDX1241"></A>
<A NAME="IDX1242"></A>
<A NAME="IDX1243"></A>
<DT><CODE>MOD(N,M)</CODE>
<DD>
<DT><CODE>%</CODE>
<DD>
剰余 ( C の <CODE>%</CODE> 演算子のような ).
<CODE>N</CODE> を <CODE>M</CODE> で割ったときの余りが返ります:

<PRE>
mysql&#62; SELECT MOD(234, 10);
        -&#62; 4
mysql&#62; SELECT 253 % 7;
        -&#62; 1
mysql&#62; SELECT MOD(29,9);
        -&#62; 2
</PRE>

この関数は <CODE>BIGINT</CODE> 値でも安全に使用できます。

<A NAME="IDX1244"></A>
<DT><CODE>FLOOR(X)</CODE>
<DD>
<CODE>X</CODE> より大きくならない整数のうち、最大の整数値を返します:

<PRE>
mysql&#62; SELECT FLOOR(1.23);
        -&#62; 1
mysql&#62; SELECT FLOOR(-1.23);
        -&#62; -2
</PRE>

返り値は <CODE>BIGINT</CODE> に変換されていることに注意!

<A NAME="IDX1245"></A>
<DT><CODE>CEILING(X)</CODE>
<DD>
<CODE>X</CODE> より小さくならない整数のうち、最小の整数値を返します.

<PRE>
mysql&#62; SELECT CEILING(1.23);
        -&#62; 2
mysql&#62; SELECT CEILING(-1.23);
        -&#62; -1
</PRE>

返り値は <CODE>BIGINT</CODE> に変換されていることに注意!

<A NAME="IDX1246"></A>
<DT><CODE>ROUND(X)</CODE>
<DD>
<CODE>X</CODE> を整数に丸めた値(四捨五入)を返します:

<PRE>
mysql&#62; SELECT ROUND(-1.23);
        -&#62; -1
mysql&#62; SELECT ROUND(-1.58);
        -&#62; -2
mysql&#62; SELECT ROUND(1.58);
        -&#62; 2
</PRE>

引数が２つの整数間の半分時の <CODE>ROUND()</CODE> の振る舞いは、C ライブラリの実
装に依存します。いくつかは、近い偶数値、常に上、常に下、または常に０方向に
丸めます。丸めの種類の一つを必要とする場合は、<CODE>TRUNCATE()</CODE> または 
<CODE>FLOOR()</CODE> のようなはっきりと定義された関数を代わりに使用すべきです。

<A NAME="IDX1247"></A>
<DT><CODE>ROUND(X,D)</CODE>
<DD>
<CODE>X</CODE> を <CODE>D</CODE> で指定した少数桁に丸めた値(四捨五入)を返します。
もし <CODE>D</CODE> が <CODE>0</CODE> なら, 結果は小数点無しになるか
少数部分になるでしょう:


<PRE>
mysql&#62; SELECT ROUND(1.298, 1);
        -&#62; 1.3
mysql&#62; SELECT ROUND(1.298, 0);
        -&#62; 1
</PRE>

<A NAME="IDX1248"></A>
<DT><CODE>EXP(X)</CODE>
<DD>
指数関数 : <CODE>e</CODE> (自然対数の底) の <CODE>X</CODE> 乗:

<PRE>
mysql&#62; SELECT EXP(2);
        -&#62; 7.389056
mysql&#62; SELECT EXP(-2);
        -&#62; 0.135335
</PRE>

<A NAME="IDX1249"></A>
<DT><CODE>LN(X)</CODE>
<DD>
Returns the natural logarithm of <CODE>X</CODE>:

<PRE>
mysql&#62; SELECT LN(2);
        -&#62; 0.693147
mysql&#62; SELECT LN(-2);
        -&#62; NULL
</PRE>

This function was added in MySQL version 4.0.3.
It is synonymous with <CODE>LOG(X)</CODE> in MySQL.

<A NAME="IDX1250"></A>
<DT><CODE>LOG(X)</CODE>
<DD>
<DT><CODE>LOG(B,X)</CODE>
<DD>
自然対数 <CODE>X</CODE>:
If called with one parameter, this function returns the natural logarithm
of <CODE>X</CODE>:

<PRE>
mysql&#62; SELECT LOG(2);
        -&#62; 0.693147
mysql&#62; SELECT LOG(-2);
        -&#62; NULL
</PRE>

任意の底 <CODE>B</CODE> に対する <CODE>X</CODE> の対数を得たければ、公式 
<CODE>LOG(X)/LOG(B)</CODE> を使用してください。

If called with two parameters, this function returns the logarithm of
<CODE>X</CODE> for an arbitary base <CODE>B</CODE>:

<PRE>
mysql&#62; SELECT LOG(2,65536);
        -&#62; 16.000000
mysql&#62; SELECT LOG(1,100);
        -&#62; NULL
</PRE>

The arbitrary base option was added in MySQL version 4.0.3.
<CODE>LOG(B,X)</CODE> is equivalent to <CODE>LOG(X)/LOG(B)</CODE>.

<A NAME="IDX1251"></A>
<DT><CODE>LOG2(X)</CODE>
<DD>
Returns the base-2 logarithm of <CODE>X</CODE>:

<PRE>
mysql&#62; SELECT LOG2(65536);
        -&#62; 16.000000
mysql&#62; SELECT LOG2(-100);
        -&#62; NULL
</PRE>

<CODE>LOG2()</CODE> is useful for finding out how many bits a number would
require for storage.
This function was added in MySQL version 4.0.3.
In earlier versions, you can use <CODE>LOG(X)/LOG(2)</CODE> instead.
  
<A NAME="IDX1252"></A>
<DT><CODE>LOG10(X)</CODE>
<DD>
常用対数(10を底とした対数) <CODE>X</CODE>:

<PRE>
mysql&#62; SELECT LOG10(2);
        -&#62; 0.301030
mysql&#62; SELECT LOG10(100);
        -&#62; 2.000000
mysql&#62; SELECT LOG10(-100);
        -&#62; NULL
</PRE>

<A NAME="IDX1253"></A>
<A NAME="IDX1254"></A>
<DT><CODE>POW(X,Y)</CODE>
<DD>
<DT><CODE>POWER(X,Y)</CODE>
<DD>
<CODE>X</CODE> の <CODE>Y</CODE> 乗:

<PRE>
mysql&#62; SELECT POW(2,2);
        -&#62; 4.000000
mysql&#62; SELECT POW(2,-2);
        -&#62; 0.250000
</PRE>

<A NAME="IDX1255"></A>
<DT><CODE>SQRT(X)</CODE>
<DD>
<CODE>X</CODE> の非負の平方根を返します:

<PRE>
mysql&#62; SELECT SQRT(4);
        -&#62; 2.000000
mysql&#62; SELECT SQRT(20);
        -&#62; 4.472136
</PRE>

<A NAME="IDX1256"></A>
<DT><CODE>PI()</CODE>
<DD>
π の値を返します。デフォルトの表示桁数は 5 ですが、MySQL 内部で
は π に完全な倍精度を使用します。

<PRE>
mysql&#62; SELECT PI();
        -&#62; 3.141593
mysql&#62; SELECT PI()+0.000000000000000000;
        -&#62; 3.141592653589793116
</PRE>

<A NAME="IDX1257"></A>
<DT><CODE>COS(X)</CODE>
<DD>
コサイン <CODE>X</CODE>。<CODE>X</CODE> はラジアン:

<PRE>
mysql&#62; SELECT COS(PI());
        -&#62; -1.000000
</PRE>

<A NAME="IDX1258"></A>
<DT><CODE>SIN(X)</CODE>
<DD>
サイン <CODE>X</CODE>。<CODE>X</CODE> はラジアン:

<PRE>
mysql&#62; SELECT SIN(PI());
        -&#62; 0.000000
</PRE>

<A NAME="IDX1259"></A>
<DT><CODE>TAN(X)</CODE>
<DD>
タンジェント <CODE>X</CODE>。<CODE>X</CODE> はラジアン:

<PRE>
mysql&#62; SELECT TAN(PI()+1);
        -&#62; 1.557408
</PRE>

<A NAME="IDX1260"></A>
<DT><CODE>ACOS(X)</CODE>
<DD>
<CODE>X</CODE> のアークコサインを返します。これはコサインが <CODE>X</CODE> である値で
す。<CODE>X</CODE> が <CODE>-1</CODE> から <CODE>1</CODE> の範囲にない場合は <CODE>NULL</CODE> を
返します:

<PRE>
mysql&#62; SELECT ACOS(1);
        -&#62; 0.000000
mysql&#62; SELECT ACOS(1.0001);
        -&#62; NULL
mysql&#62; SELECT ACOS(0);
        -&#62; 1.570796
</PRE>

<A NAME="IDX1261"></A>
<DT><CODE>ASIN(X)</CODE>
<DD>
<CODE>X</CODE> のアークサインを返します。これはサインが <CODE>X</CODE> である値です。
<CODE>X</CODE> が <CODE>-1</CODE> から <CODE>1</CODE> の範囲にない場合は <CODE>NULL</CODE> を返し
ます:

<PRE>
mysql&#62; SELECT ASIN(0.2);
        -&#62; 0.201358
mysql&#62; SELECT ASIN('foo');
        -&#62; 0.000000
</PRE>

<A NAME="IDX1262"></A>
<DT><CODE>ATAN(X)</CODE>
<DD>
<CODE>X</CODE> のアークタンジェントを返します。これはタンジェントが <CODE>X</CODE> で
ある値です:

<PRE>
mysql&#62; SELECT ATAN(2);
        -&#62; 1.107149
mysql&#62; SELECT ATAN(-2);
        -&#62; -1.107149
</PRE>

<A NAME="IDX1263"></A>
<DT><CODE>ATAN(Y,X)</CODE>
<DD>
<DT><CODE>ATAN2(Y,X)</CODE>
<DD>
２つの変数 <CODE>X</CODE> と <CODE>Y</CODE> のアークタンジェントを返します。両方の引数
の符号が結果の象限を決定するために使用されることを除いて、<CODE>Y / X</CODE> の
アークタンジェントの計算と同様です:

<PRE>
mysql&#62; SELECT ATAN(-2,2);
        -&#62; -0.785398
mysql&#62; SELECT ATAN2(PI(),0);
        -&#62; 1.570796
</PRE>

<A NAME="IDX1264"></A>
<DT><CODE>COT(X)</CODE>
<DD>
<CODE>X</CODE> のコタンジェントを返します:

<PRE>
mysql&#62; SELECT COT(12);
        -&#62; -1.57267341
mysql&#62; SELECT COT(0);
        -&#62; NULL
</PRE>

<A NAME="IDX1265"></A>
<DT><CODE>RAND()</CODE>
<DD>
<DT><CODE>RAND(N)</CODE>
<DD>
<CODE>0</CODE> から <CODE>1.0</CODE> 間のランダムな浮動小数点数値を返します。
もし <CODE>N</CODE> に整数を与えた場合、シードとしてこの値が使用されます:

<PRE>
mysql&#62; SELECT RAND();
        -&#62; 0.9233482386203
mysql&#62; SELECT RAND(20);
        -&#62; 0.15888261251047
mysql&#62; SELECT RAND(20);
        -&#62; 0.15888261251047
mysql&#62; SELECT RAND();
        -&#62; 0.63553050033332
mysql&#62; SELECT RAND();
        -&#62; 0.70100469486881
</PRE>

<CODE>RAND()</CODE> 値を持つフィールドは <CODE>ORDER BY</CODE> 節で使用できません。
<CODE>ORDER BY</CODE> はフィールドを複数回評価するためです。

しかし MySQL バージョン 3.23 では, 次が可能です:
<CODE>SELECT * FROM table_name ORDER BY RAND()</CODE>

これは <CODE>SELECT * FROM table1,table2 WHERE a=b AND c&#60;d ORDER BY
RAND() LIMIT 1000</CODE> のセットからランダムなサンプルを得るのに便利です。

注意: <CODE>WHERE</CODE> 節の <CODE>RAND()</CODE> は <CODE>WHERE</CODE> が実行する度に再評価
されます。

<CODE>RAND()</CODE> is not meant to be a perfect random generator, but instead a
fast way to generate ad hoc random numbers that will be portable between
platforms for the same MySQL version.

<A NAME="IDX1266"></A>
<DT><CODE>LEAST(X,Y,...)</CODE>
<DD>
二つ以上の引数を取り、引数中、最小の値を返します。
引数は以下の規則に従って比較されます：


<UL>
<LI>

値が <CODE>INTEGER</CODE> を使用しているなら、あるいは、全ての引数が
整数値ならば、整数として比較します。

<LI>

値が <CODE>REAL</CODE> として使用されているか、全ての引数が実数ならば、
実数として比較します。

<LI>

いかなる引数もケース依存の文字ならば、引数はケース依存文字として比較されます。

<LI>

そのほかの場合、引数はケース非依存文字として比較されます:
</UL>


<PRE>
mysql&#62; SELECT LEAST(2,0);
        -&#62; 0
mysql&#62; SELECT LEAST(34.0,3.0,5.0,767.0);
        -&#62; 3.0
mysql&#62; SELECT LEAST("B","A","C");
        -&#62; "A"
</PRE>

バージョン 3.22.5 以前の MySQL では、<CODE>MIN()</CODE> を <CODE>LEAST</CODE> の代
わりに使用できます。

<A NAME="IDX1267"></A>
<DT><CODE>GREATEST(X,Y,...)</CODE>
<DD>
二つ以上の引数を取り、引数中、最大の値を返します。
引数は <CODE>LEAST</CODE> の時と同じように比較されます。

<PRE>
mysql&#62; SELECT GREATEST(2,0);
        -&#62; 2
mysql&#62; SELECT GREATEST(34.0,3.0,5.0,767.0);
        -&#62; 767.0
mysql&#62; SELECT GREATEST("B","A","C");
        -&#62; "C"
</PRE>

バージョン 3.22.5 以前の MySQL では、<CODE>MAX()</CODE> を <CODE>GREATEST</CODE> の
代わりに使用できます。

<A NAME="IDX1268"></A>
<DT><CODE>DEGREES(X)</CODE>
<DD>
引数 <CODE>X</CODE> をラジアンから度に変換して返します:

<PRE>
mysql&#62; SELECT DEGREES(PI());
        -&#62; 180.000000
</PRE>

<A NAME="IDX1269"></A>
<DT><CODE>RADIANS(X)</CODE>
<DD>
引数 <CODE>X</CODE> を度からラジアンに変換して返します:

<PRE>
mysql&#62; SELECT RADIANS(90);
        -&#62; 1.570796
</PRE>

<A NAME="IDX1270"></A>
<DT><CODE>TRUNCATE(X,D)</CODE>
<DD>
少数点以下 <CODE>D</CODE> 桁で <CODE>X</CODE> を切り捨てた値を返します。
<CODE>D</CODE> が <CODE>0</CODE> の場合、結果は小数部や微小部を持ちません:

<PRE>
mysql&#62; SELECT TRUNCATE(1.223,1);
        -&#62; 1.2
mysql&#62; SELECT TRUNCATE(1.999,1);
        -&#62; 1.9
mysql&#62; SELECT TRUNCATE(1.999,0);
        -&#62; 1
mysql&#62; SELECT TRUNCATE(-1.999,1);
        -&#62; -1.9
</PRE>

Starting from MySQL 3.23.51 all numbers are rounded towards zero.

If <CODE>D</CODE> is negative, then the whole part of the number is zeroed out:


<PRE>
mysql&#62; SELECT TRUNCATE(122,-2);
       -&#62; 100
</PRE>

注意: コンピュータでは小数点数は正確な数値としては格納されず、double 値と
して格納されます。次の結果によってだまされるでしょう:

<A NAME="IDX1271"></A>

<PRE>
mysql&#62; SELECT TRUNCATE(10.28*100,0);
       -&#62; 1027
</PRE>

上記は 10.28 は実際には 10.2799999999999999 のようなものとして格納さえるた
めに発生します。
</DL>



<H3><A NAME="Date_and_time_functions" HREF="manual.ja_toc.html#Date_and_time_functions">6.3.4  日付と時刻関数</A></H3>

<P>
<A NAME="IDX1272"></A>
<A NAME="IDX1273"></A>

</P>
<P>
それぞれの型がもつ値の範囲と日と時間の値が記述される有効な形式については
  「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節. 

</P>
<P>
日付関数を使用する例:
<CODE>date_col</CODE> が最新の30日である全てのレコードを選択します:

</P>

<PRE>
mysql&#62; SELECT something FROM table
           WHERE TO_DAYS(NOW()) - TO_DAYS(date_col) &#60;= 30;
</PRE>

<DL COMPACT>

<DT><CODE>DAYOFWEEK(date)</CODE>
<DD>
<A NAME="IDX1274"></A>
 
Returns the weekday index

<CODE>date</CODE> の曜日を得ます (<CODE>1</CODE> = 日曜日, <CODE>2</CODE> = 月曜日, ... <CODE>7</CODE> =
 土曜日)
これは ODBC 標準に従います:


<PRE>
mysql&#62; SELECT DAYOFWEEK('1998-02-03');
        -&#62; 3
</PRE>

<A NAME="IDX1275"></A>
<DT><CODE>WEEKDAY(date)</CODE>
<DD>
<CODE>date</CODE> の曜日を得ます (<CODE>0</CODE> = 月曜日, <CODE>1</CODE> = 火曜日, ... <CODE>6</CODE> =
 日曜日):


<PRE>
mysql&#62; SELECT WEEKDAY('1998-02-03 22:23:00');
        -&#62; 1
mysql&#62; SELECT WEEKDAY('1997-11-05');
        -&#62; 2
</PRE>

<A NAME="IDX1276"></A>
<DT><CODE>DAYOFMONTH(date)</CODE>
<DD>
月の日を返します (<CODE>1</CODE> - <CODE>31</CODE>):


<PRE>
mysql&#62; SELECT DAYOFMONTH('1998-02-03');
        -&#62; 3
</PRE>

<A NAME="IDX1277"></A>
<DT><CODE>DAYOFYEAR(date)</CODE>
<DD>
年の日を返します (<CODE>1</CODE>-<CODE>366</CODE>):
<CODE>366</CODE>:


<PRE>
mysql&#62; SELECT DAYOFYEAR('1998-02-03');
        -&#62; 34
</PRE>

<A NAME="IDX1278"></A>
<DT><CODE>MONTH(date)</CODE>
<DD>
月を返します (<CODE>1</CODE> - <CODE>12</CODE>):


<PRE>
mysql&#62; SELECT MONTH('1998-02-03');
        -&#62; 2
</PRE>

<A NAME="IDX1279"></A>
<DT><CODE>DAYNAME(date)</CODE>
<DD>
曜日の名前を返します:


<PRE>
mysql&#62; SELECT DAYNAME("1998-02-05");
        -&#62; 'Thursday'
</PRE>

<A NAME="IDX1280"></A>
<DT><CODE>MONTHNAME(date)</CODE>
<DD>
月の名前を返します:


<PRE>
mysql&#62; SELECT MONTHNAME("1998-02-05");
        -&#62; 'February'
</PRE>

<A NAME="IDX1281"></A>
<DT><CODE>QUARTER(date)</CODE>
<DD>
<CODE>date</CODE> についての年の四半期を返します。範囲は <CODE>1</CODE> から 
<CODE>4</CODE> です:


<PRE>
mysql&#62; SELECT QUARTER('98-04-01');
        -&#62; 2
</PRE>

<A NAME="IDX1282"></A>
<DT><CODE>WEEK(date)</CODE>
<DD>
<DT><CODE>WEEK(date,first)</CODE>
<DD>
引数が一つの場合、<CODE>date</CODE> についての週を返します。範囲は <CODE>0</CODE> から 
<CODE>53</CODE> (そう、53週の最初というのもありえます)で、日曜日が週の
最初の日です。
引数が二つの形式の <CODE>WEEK()</CODE> は、週の開始を日曜日か月曜日か指定できます。
それぞれの場合の返り値は <CODE>0-53</CODE> か <CODE>1-52</CODE> です。

Here is a table for how the second arguments work:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Value</STRONG> </TD><TD> <CODE>Meaning</CODE>
</TR NOSAVE>
<TR><TD>0 </TD><TD> Week starts on Sunday and return value is in range 0-53
</TR NOSAVE>
<TR><TD>1 </TD><TD> Week starts on Monday and return value is in range 0-53
</TR NOSAVE>
<TR><TD>2 </TD><TD> Week starts on Sunday and return value is in range 1-53
</TR NOSAVE>
<TR><TD>3 </TD><TD> Week starts on Monday and return value is in range 1-53 (ISO 8601)
</TR>
</TABLE>


<PRE>
mysql&#62; SELECT WEEK('1998-02-20');
        -&#62; 7
mysql&#62; SELECT WEEK('1998-02-20',0);
        -&#62; 7
mysql&#62; SELECT WEEK('1998-02-20',1);
        -&#62; 8
mysql&#62; SELECT WEEK('1998-12-31',1);
        -&#62; 53
</PRE>

Note: in Version 4.0, <CODE>WEEK(#,0)</CODE> was changed to match the
calendar in the USA.

Note that if a week is the last week of the previous year, MySQL will
return 0 if you don't use 2 or 3 as the optional argument:


<PRE>
mysql&#62; SELECT YEAR('2000-01-01'), WEEK('2000-01-01',0);
        -&#62; 2000, 0
mysql&#62; SELECT WEEK('2000-01-01',2);
        -&#62; 52
</PRE>

One could argue that MySQL should return <CODE>52</CODE> for the <CODE>WEEK()</CODE>
function as the given date is actually the 52 second week of 1999.  We
decided to return 0 instead as we want the function to return 'the week
number in the given year'.  This makes the usage of the <CODE>WEEK()</CODE>
function reliable when combined with other functions that extracts a
date part from a date.

If you would prefer to know the correct year-week, then you should use
the 2 or 3 as the optional argument or use the <CODE>YEARWEEK()</CODE>
function:


<PRE>
mysql&#62; SELECT YEARWEEK('2000-01-01');
        -&#62; 199952
mysql&#62; SELECT MID(YEARWEEK('2000-01-01'),5,2);
        -&#62; 52
</PRE>

<A NAME="IDX1283"></A>
<DT><CODE>YEAR(date)</CODE>
<DD>
年を返します (<CODE>1000</CODE> - <CODE>9999</CODE>):


<PRE>
mysql&#62; SELECT YEAR('98-02-03');
        -&#62; 1998
</PRE>

<DT><CODE>YEARWEEK(date)</CODE>
<DD>
<DT><CODE>YEARWEEK(date,first)</CODE>
<DD>
データの年と週を返します。第2引数は <CODE>WEEK()</CODE> の第2引数とまったく同じ
ように働きます。注意: 年の最初と最後の週では、年が date 引数内の年とは異な
ることがあります！


<PRE>
mysql&#62; SELECT YEARWEEK('1987-01-01');
        -&#62; 198653
</PRE>

Note that the week number is different from what the <CODE>WEEK()</CODE>
function would return (<CODE>0</CODE>) for optional arguments 0 or 1,
as <CODE>WEEK()</CODE> then returns the week in the context of the given year.

<A NAME="IDX1284"></A>
<DT><CODE>HOUR(time)</CODE>
<DD>
時を返します (<CODE>0</CODE> - <CODE>23</CODE>):


<PRE>
mysql&#62; SELECT HOUR('10:05:03');
        -&#62; 10
</PRE>

<A NAME="IDX1285"></A>
<DT><CODE>MINUTE(time)</CODE>
<DD>
分を返します (<CODE>0</CODE>-<CODE>59</CODE>):


<PRE>
mysql&#62; SELECT MINUTE('98-02-03 10:05:03');
        -&#62; 5
</PRE>

<A NAME="IDX1286"></A>
<DT><CODE>SECOND(time)</CODE>
<DD>
秒を返します (<CODE>0</CODE> to <CODE>59</CODE>)


<PRE>
mysql&#62; SELECT SECOND('10:05:03');
        -&#62; 3
</PRE>

<A NAME="IDX1287"></A>
<DT><CODE>PERIOD_ADD(P,N)</CODE>
<DD>
<CODE>N</CODE> 月を期間 <CODE>P</CODE> (型 <CODE>YYMM</CODE> または <CODE>YYYYMM</CODE>) に追加
します。<CODE>YYYYMM</CODE> を返します。

注意: 期間引数 <CODE>P</CODE> は日付値では <STRONG>ありません</STRONG>。


<PRE>
mysql&#62; SELECT PERIOD_ADD(9801,2);
        -&#62; 199803
</PRE>

<A NAME="IDX1288"></A>
<DT><CODE>PERIOD_DIFF(P1,P2)</CODE>
<DD>
期間 <CODE>P1</CODE> と <CODE>P2</CODE> の差の月を返します。<CODE>P1</CODE> と <CODE>P2</CODE> は形
式 <CODE>YYMM</CODE> または <CODE>YYYYMM</CODE> です。

注意: 期間引数 <CODE>P1</CODE> と <CODE>P2</CODE> は日付値では <STRONG>ありません</STRONG>。


<PRE>
mysql&#62; SELECT PERIOD_DIFF(9802,199703);
        -&#62; 11
</PRE>

<A NAME="IDX1289"></A>
<A NAME="IDX1290"></A>
<A NAME="IDX1291"></A>
<A NAME="IDX1292"></A>
<A NAME="IDX1293"></A>
<DT><CODE>DATE_ADD(date,INTERVAL expr type)</CODE>
<DD>
<DT><CODE>DATE_SUB(date,INTERVAL expr type)</CODE>
<DD>
<DT><CODE>ADDDATE(date,INTERVAL expr type)</CODE>
<DD>
<DT><CODE>SUBDATE(date,INTERVAL expr type)</CODE>
<DD>
これら関数は日付の演算に使用します。 これらは MySQL バージョン 3.22 の
新しい機能です。 <CODE>ADDDATE()</CODE> と <CODE>SUBDATE()</CODE> は
<CODE>DATE_ADD()</CODE> , <CODE>DATE_SUB()</CODE> と同義です。

MySQL バージョン 3.23 では, <CODE>+</CODE> と <CODE>-</CODE> を
<CODE>DATE_ADD()</CODE> , <CODE>DATE_SUB()</CODE> の代わりに使用できます. (See example below.)

<CODE>date</CODE> には、<CODE>DATETIME</CODE> か <CODE>DATE</CODE> 型の値を指定します。
この値から演算が開始されます。
<CODE>expr</CODE> には、date から増減させる値を指定します。
<CODE>expr</CODE> が <SAMP>`-'</SAMP> から始まっていれば、負数を示します。
<CODE>type</CODE> はどれぐらいの期間かを示すキーワードです。

<CODE>EXTRACT(type FROM date)</CODE> 関数は、date から 'type' の部分を返します。

以下の表に、<CODE>type</CODE> と <CODE>expr</CODE> の関連を示します：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>type</CODE> <STRONG>value</STRONG> </TD><TD> <STRONG>Expected</STRONG> <CODE>expr</CODE> <STRONG>format</STRONG>
</TR NOSAVE>
<TR><TD><CODE>SECOND</CODE> </TD><TD> <CODE>SECONDS</CODE>
</TR NOSAVE>
<TR><TD><CODE>MINUTE</CODE> </TD><TD> <CODE>MINUTES</CODE>
</TR NOSAVE>
<TR><TD><CODE>HOUR</CODE> </TD><TD> <CODE>HOURS</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY</CODE> </TD><TD> <CODE>DAYS</CODE>
</TR NOSAVE>
<TR><TD><CODE>MONTH</CODE> </TD><TD> <CODE>MONTHS</CODE>
</TR NOSAVE>
<TR><TD><CODE>YEAR</CODE> </TD><TD> <CODE>YEARS</CODE>
</TR NOSAVE>
<TR><TD><CODE>MINUTE_SECOND</CODE> </TD><TD> <CODE>"MINUTES:SECONDS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>HOUR_MINUTE</CODE> </TD><TD> <CODE>"HOURS:MINUTES"</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY_HOUR</CODE> </TD><TD> <CODE>"DAYS HOURS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>YEAR_MONTH</CODE> </TD><TD> <CODE>"YEARS-MONTHS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>HOUR_SECOND</CODE> </TD><TD> <CODE>"HOURS:MINUTES:SECONDS"</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY_MINUTE</CODE> </TD><TD> <CODE>"DAYS HOURS:MINUTES"</CODE>
</TR NOSAVE>
<TR><TD><CODE>DAY_SECOND</CODE> </TD><TD> <CODE>"DAYS HOURS:MINUTES:SECONDS"</CODE>
</TR>
</TABLE>

MySQL は、 <CODE>expr</CODE> フォーマット内のいかなる句読点区切りをも許します。
上の表中の区切り文字は提案する区切り文字です。 もし <CODE>date</CODE> 引数が
 <CODE>DATE</CODE> 値で、<CODE>YEAR</CODE>, <CODE>MONTH</CODE>, <CODE>DAY</CODE> の部分のみを含む
計算をするなら、結果は <CODE>DATE</CODE> 値が返ります。 それ以外なら <CODE>DATETIME</CODE> 
値が返ります:


<PRE>
mysql&#62; SELECT "1997-12-31 23:59:59" + INTERVAL 1 SECOND;
        -&#62; 1998-01-01 00:00:00
mysql&#62; SELECT INTERVAL 1 DAY + "1997-12-31";
        -&#62; 1998-01-01
mysql&#62; SELECT "1998-01-01" - INTERVAL 1 SECOND;
       -&#62; 1997-12-31 23:59:59
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59",
    -&#62;                 INTERVAL 1 SECOND);
        -&#62; 1998-01-01 00:00:00
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59",
    -&#62;                 INTERVAL 1 DAY);
        -&#62; 1998-01-01 23:59:59
mysql&#62; SELECT DATE_ADD("1997-12-31 23:59:59",
    -&#62;                 INTERVAL "1:1" MINUTE_SECOND);
        -&#62; 1998-01-01 00:01:00
mysql&#62; SELECT DATE_SUB("1998-01-01 00:00:00",
    -&#62;                 INTERVAL "1 1:1:1" DAY_SECOND);
        -&#62; 1997-12-30 22:58:59
mysql&#62; SELECT DATE_ADD("1998-01-01 00:00:00",
    -&#62;                 INTERVAL "-1 10" DAY_HOUR);
        -&#62; 1997-12-30 14:00:00
mysql&#62; SELECT DATE_SUB("1998-01-02", INTERVAL 31 DAY);
        -&#62; 1997-12-02
</PRE>

もしあなたの指定する interval 値が短すぎるなら( <CODE>type</CODE> キーワードから
類推される値を含んでいない場合)、 MySQL は interval 値の一番
左の部分を指定し忘れたものだと仮定します。
例えば、もし <CODE>type</CODE> を <CODE>DAY_SECOND</CODE> に指定した場合、
 <CODE>expr</CODE> の値は 日、時、分、秒 からなる物と期待されます。
ここであなたが <CODE>"1:10"</CODE> のような値を指定していたなら、
 MySQL は、日、時 の部分が忘れ去られて、分、秒 が与えられたと
推定します。
つまり、 <CODE>"1:10" DAY_SECOND</CODE> は <CODE>"1:10" MINUTE_SECOND</CODE> で
あると理解されるのです。
これは、MySQL が <CODE>TIME</CODE> 値を時刻ではなく経過時間の表現と解釈
する方法に類似しています。

注意: 時刻部を含む何かに対して、日付値の加算や減算を行なう場合、日付値は自
動的に日時値に変換されます:


<PRE>
mysql&#62; SELECT DATE_ADD("1999-01-01", INTERVAL 1 DAY);
       -&#62; 1999-01-02
mysql&#62; SELECT DATE_ADD("1999-01-01", INTERVAL 1 HOUR);
       -&#62; 1999-01-01 01:00:00
</PRE>

もし、不正な値が使用されたなら、結果は <CODE>NULL</CODE> です.
もし <CODE>MONTH</CODE> や <CODE>YEAR_MONTH</CODE> や <CODE>YEAR</CODE> を足し算して、
結果となる日付が新しい月の最大日よりも大きい日になるようなら、
その日は、新しい月の最大日に修正されます。


<PRE>
mysql&#62; SELECT DATE_ADD('1998-01-30', Interval 1 month);
        -&#62; 1998-02-28
</PRE>

例のように、<CODE>INTERVAL</CODE> と <CODE>type</CODE> キーワードは
ケース依存ではありません.

<A NAME="IDX1294"></A>
<DT><CODE>EXTRACT(type FROM date)</CODE>
<DD>
The <CODE>EXTRACT()</CODE> function uses the same kinds of interval type
specifiers as <CODE>DATE_ADD()</CODE> or <CODE>DATE_SUB()</CODE>, but extracts parts
from the date rather than performing date arithmetic.


<PRE>
mysql&#62; SELECT EXTRACT(YEAR FROM "1999-07-02");
       -&#62; 1999
mysql&#62; SELECT EXTRACT(YEAR_MONTH FROM "1999-07-02 01:02:03");
       -&#62; 199907
mysql&#62; SELECT EXTRACT(DAY_MINUTE FROM "1999-07-02 01:02:03");
       -&#62; 20102
</PRE>

<A NAME="IDX1295"></A>
<DT><CODE>TO_DAYS(date)</CODE>
<DD>
日付 <CODE>date</CODE> を与えると、0年からの日数を返します。


<PRE>
mysql&#62; SELECT TO_DAYS(950501);
        -&#62; 728779
mysql&#62; SELECT TO_DAYS('1997-10-07');
        -&#62; 729669
</PRE>

<CODE>TO_DAYS()</CODE> はグレゴリオ歴の開始(1582)より前の値での使用を意図されて
いません。歴が変更された時に失われた日を考慮に入れてないからです。

<A NAME="IDX1296"></A>
<DT><CODE>FROM_DAYS(N)</CODE>
<DD>
与えられた日数 <CODE>N</CODE> から <CODE>DATE</CODE> 値を返します:


<PRE>
mysql&#62; SELECT FROM_DAYS(729669);
        -&#62; '1997-10-07'
</PRE>

<CODE>FROM_DAYS()</CODE> はグレゴリオ歴の開始(1582)より前の値での使用を意図され
ていません。歴が変更された時に失われた日を考慮に入れてないからです。

<A NAME="IDX1297"></A>
<DT><CODE>DATE_FORMAT(date,format)</CODE>
<DD>
<CODE>date</CODE> 値を <CODE>format</CODE> 文字列に従って整形します。次の指定が 
<CODE>format</CODE> 文字列で使用できます:
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Specifier</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>%M</CODE> </TD><TD> 月名 (<CODE>January</CODE>..<CODE>December</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%W</CODE> </TD><TD> 曜日 (<CODE>Sunday</CODE>..<CODE>Saturday</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%D</CODE> </TD><TD> 英語サフィックス付き月の日 (<CODE>0th</CODE>, <CODE>1st</CODE>, <CODE>2nd</CODE>, <CODE>3rd</CODE>, etc.)
</TR NOSAVE>
<TR><TD><CODE>%Y</CODE> </TD><TD> 4桁の年
</TR NOSAVE>
<TR><TD><CODE>%y</CODE> </TD><TD> 2桁の年
</TR NOSAVE>
<TR><TD><CODE>%X</CODE> </TD><TD> 週の年。週の最初の日は日曜日。4桁の数値。'%V' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%x</CODE> </TD><TD> 週の年。週の最初の日は月曜日。4桁の数値。'%v' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%a</CODE> </TD><TD> 省略された曜日名 (<CODE>Sun</CODE>..<CODE>Sat</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%d</CODE> </TD><TD> 月の日, 数値 (<CODE>00</CODE>..<CODE>31</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%e</CODE> </TD><TD> 月の日, 数値 (<CODE>0</CODE>..<CODE>31</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%m</CODE> </TD><TD> 月, 数値 (<CODE>00</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%c</CODE> </TD><TD> 月, 数値 (<CODE>0</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%b</CODE> </TD><TD> 省略された月名 (<CODE>Jan</CODE>..<CODE>Dec</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%j</CODE> </TD><TD> 年の日 (<CODE>001</CODE>..<CODE>366</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%H</CODE> </TD><TD> 時 (<CODE>00</CODE>..<CODE>23</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%k</CODE> </TD><TD> 時 (<CODE>0</CODE>..<CODE>23</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%h</CODE> </TD><TD> 時 (<CODE>01</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%I</CODE> </TD><TD> 時 (<CODE>01</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%l</CODE> </TD><TD> 時 (<CODE>1</CODE>..<CODE>12</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%i</CODE> </TD><TD> 分, 数値 (<CODE>00</CODE>..<CODE>59</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%r</CODE> </TD><TD> 時刻, 12時間 (<CODE>hh:mm:ss [AP]M</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%T</CODE> </TD><TD> 時刻, 24時間 (<CODE>hh:mm:ss</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%S</CODE> </TD><TD> 秒 (<CODE>00</CODE>..<CODE>59</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%s</CODE> </TD><TD> 秒 (<CODE>00</CODE>..<CODE>59</CODE>)
</TR NOSAVE>
<TR><TD><CODE>%p</CODE> </TD><TD> <CODE>AM</CODE> or <CODE>PM</CODE>
</TR NOSAVE>
<TR><TD><CODE>%w</CODE> </TD><TD> 週の日 (<CODE>0</CODE>=Sunday..<CODE>6</CODE>=Saturday)
</TR NOSAVE>
<TR><TD><CODE>%U</CODE> </TD><TD> 週 (<CODE>00</CODE>..<CODE>53</CODE>), 週のはじまりを 日曜とした場合
</TR NOSAVE>
<TR><TD><CODE>%u</CODE> </TD><TD> 週 (<CODE>00</CODE>..<CODE>53</CODE>), 週のはじまりを 月曜とした場合
</TR NOSAVE>
<TR><TD><CODE>%V</CODE> </TD><TD> 週 (<CODE>01</CODE>..<CODE>53</CODE>), 週のはじまりは日曜日。'%X' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%v</CODE> </TD><TD> 週 (<CODE>01</CODE>..<CODE>53</CODE>), 週のはじまりは月曜日。'%x' と共に使用されます
</TR NOSAVE>
<TR><TD><CODE>%%</CODE> </TD><TD> リテラル <SAMP>`%'</SAMP>。
</TR>
</TABLE>

他の全ての文字は解釈されずに結果にコピーされます:


<PRE>
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%W %M %Y');
        -&#62; 'Saturday October 1997'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00', '%H:%i:%s');
        -&#62; '22:23:00'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00',
                          '%D %y %a %d %m %b %j');
        -&#62; '4th 97 Sat 04 10 Oct 277'
mysql&#62; SELECT DATE_FORMAT('1997-10-04 22:23:00',
                          '%H %k %I %r %T %S %w');
        -&#62; '22 22 10 10:23:00 PM 22:23:00 00 6'
mysql&#62; SELECT DATE_FORMAT('1999-01-01', '%X %V');
        -&#62; '1998 52'
</PRE>

MySQL バージョン 3.23 では、 <CODE>%</CODE> 文字はフォーマット文字の前に必ず
必要とされます。
それより前のバージョンでは、 <CODE>%</CODE> 文字はオプションでした。

The reason the ranges for the month and day specifiers begin with zero
is that MySQL allows incomplete dates such as <CODE>'2004-00-00'</CODE> to be
stored as of MySQL 3.23.

<A NAME="IDX1298"></A>
<DT><CODE>TIME_FORMAT(time,format)</CODE>
<DD>
これは上記の <CODE>DATE_FORMAT()</CODE> のように使用されますが、
<CODE>format</CODE> オプションでは、時,分,秒だけを操作できます。
他のオプションは <CODE>NULL</CODE> or <CODE>0</CODE> を与えます。

<A NAME="IDX1299"></A>
<A NAME="IDX1300"></A>
<DT><CODE>CURDATE()</CODE>
<DD>
<DT><CODE>CURRENT_DATE</CODE>
<DD>
今日の日付を返します。日付の形式は、<CODE>CURDATE()</CODE> が数値または文字列のどち
らの文脈で使用されたかに依存して <CODE>YYYYMMDD</CODE> または <CODE>'YYYY-MM-DD'</CODE> で返
されます:


<PRE>
mysql&#62; SELECT CURDATE();
        -&#62; '1997-12-15'
mysql&#62; SELECT CURDATE() + 0;
        -&#62; 19971215
</PRE>

<A NAME="IDX1301"></A>
<A NAME="IDX1302"></A>
<DT><CODE>CURTIME()</CODE>
<DD>
<DT><CODE>CURRENT_TIME</CODE>
<DD>
現在の時刻を <CODE>HHMMSS</CODE> または <CODE>'HH:MM:SS'</CODE> の形式で返します。こ
れは <CODE>CURTIME()</CODE> が数値または文字列のどちらの文脈で使用されたかに依
存します:


<PRE>
mysql&#62; SELECT CURTIME();
        -&#62; '23:50:26'
mysql&#62; SELECT CURTIME() + 0;
        -&#62; 235026
</PRE>

<A NAME="IDX1303"></A>
<A NAME="IDX1304"></A>
<A NAME="IDX1305"></A>
<DT><CODE>NOW()</CODE>
<DD>
<DT><CODE>SYSDATE()</CODE>
<DD>
<DT><CODE>CURRENT_TIMESTAMP</CODE>
<DD>
現在の時刻を返します。数値または文字列のどちらの文脈で使用されたかに依存して
 <CODE>YYYYMMDDHHMMSS</CODE> または <CODE>'YYYY-MM-DD HH:MM:SS'</CODE> 形式で返されます:


<PRE>
mysql&#62; SELECT NOW();
        -&#62; '1997-12-15 23:50:26'
mysql&#62; SELECT NOW() + 0;
        -&#62; 19971215235026
</PRE>

Note that <CODE>NOW()</CODE> is only evaluated once per query, namely at the
start of query execution. This means that multiple references to
<CODE>NOW()</CODE> within a single query will always give the same time.

<A NAME="IDX1306"></A>
<DT><CODE>UNIX_TIMESTAMP()</CODE>
<DD>
<DT><CODE>UNIX_TIMESTAMP(date)</CODE>
<DD>
引数なしで呼び出された場合は、UNIX timestamp (GMT <CODE>'1970-01-01 00:00:00'</CODE> 
からの秒数) です。If
<CODE>UNIX_TIMESTAMP()</CODE> is called with a <CODE>date</CODE> argument, it
returns the value of the argument as seconds since <CODE>'1970-01-01
00:00:00'</CODE> GMT.
<CODE>date</CODE> はローカル時刻での <CODE>DATE</CODE>
文字列、<CODE>DATETIME</CODE> 文字列、<CODE>TIMESTAMP</CODE>, または <CODE>YYMMDD</CODE> または
<CODE>YYYYMMDD</CODE> 形式の数値です:


<PRE>
mysql&#62; SELECT UNIX_TIMESTAMP();
        -&#62; 882226357
mysql&#62; SELECT UNIX_TIMESTAMP('1997-10-04 22:23:00');
        -&#62; 875996580
</PRE>

<CODE>UNIX_TIMESTAMP</CODE> が <CODE>TIMESTAMP</CODE> フィールドに使用された場合、
この関数は、暗黙の ``文字から UNIX タイムスタンプ'' 変換をすることなく、
値を得ます。
If you pass an out-of-range date to <CODE>UNIX_TIMESTAMP()</CODE> it will
return 0, but please note that only basic checking is performed
(year 1970-2037, month 01-12, day 01-31).

If you want to subtract <CODE>UNIX_TIMESTAMP()</CODE> columns, you may want to
cast the result to signed integers.  「<A HREF="manual.ja_Reference.html#Cast_Functions">6.3.5  Cast Functions</A>」節参照.

<A NAME="IDX1307"></A>
<DT><CODE>FROM_UNIXTIME(unix_timestamp)</CODE>
<DD>
文脈(数値/文字列)に依存して、<CODE>'YYYY-MM-DD HH:MM:SS'</CODE> または 
<CODE>YYYYMMDDHHMMSS</CODE> 形式の timestamp 文字列を返します:


<PRE>
mysql&#62; SELECT FROM_UNIXTIME(875996580);
        -&#62; '1997-10-04 22:23:00'
mysql&#62; SELECT FROM_UNIXTIME(875996580) + 0;
        -&#62; 19971004222300
</PRE>

<A NAME="IDX1308"></A>
<DT><CODE>FROM_UNIXTIME(unix_timestamp,format)</CODE>
<DD>
<CODE>format</CODE> に従って整形された UNIX timestamp 文字列を返します。
<CODE>format</CODE> は <CODE>DATE_FORMAT()</CODE> 関数のエントリに一覧されたのと同じ指
定子を含むことができます:


<PRE>
mysql&#62; SELECT FROM_UNIXTIME(UNIX_TIMESTAMP(),
                            '%Y %D %M %h:%i:%s %x');
        -&#62; '1997 23rd December 03:43:30 1997'
</PRE>

<A NAME="IDX1309"></A>
<DT><CODE>SEC_TO_TIME(seconds)</CODE>
<DD>
<CODE>seconds</CODE> 引数を時分秒に変換して返します。関数が文字列文脈または数値
文脈のどちらで使用されたかに依存して、<CODE>'HH:MM:SS'</CODE> または 
<CODE>HHMMSS</CODE> 形式で値を返します:


<PRE>
mysql&#62; SELECT SEC_TO_TIME(2378);
        -&#62; '00:39:38'
mysql&#62; SELECT SEC_TO_TIME(2378) + 0;
        -&#62; 3938
</PRE>

<A NAME="IDX1310"></A>
<DT><CODE>TIME_TO_SEC(time)</CODE>
<DD>
<CODE>time</CODE> を秒に変換します。


<PRE>
mysql&#62; SELECT TIME_TO_SEC('22:23:00');
        -&#62; 80580
mysql&#62; SELECT TIME_TO_SEC('00:39:38');
        -&#62; 2378
</PRE>

</DL>



<H3><A NAME="Cast_Functions" HREF="manual.ja_toc.html#Cast_Functions">6.3.5  Cast Functions</A></H3>

<P>
The syntax of the <CODE>CAST</CODE> function is:

</P>
<P>
<A NAME="IDX1311"></A>
<A NAME="IDX1312"></A>

</P>

<PRE>
CAST(expression AS type)

or

CONVERT(expression,type)
</PRE>

<P>
Where type is one of:

<UL>
<LI>

<CODE>BINARY</CODE>
<LI>

<CODE>CHAR</CODE> (New in 4.0.6)
<LI>

<CODE>DATE</CODE>
<LI>

<CODE>DATETIME</CODE>
<LI>

<CODE>SIGNED {INTEGER}</CODE>
<LI>

<CODE>TIME</CODE>
<LI>

<CODE>UNSIGNED {INTEGER}</CODE>
</UL>

<P>
<CODE>CAST()</CODE> is ANSI SQL99 syntax and <CODE>CONVERT()</CODE> is ODBC syntax.

</P>
<P>
The cast function is mainly useful when you want to create a column with
a specific type in a <CODE>CREATE ... SELECT</CODE>:

</P>

<PRE>
CREATE TABLE new_table SELECT CAST('2000-01-01' AS DATE);
</PRE>

<P>
<CODE>CAST(string AS BINARY</CODE> is the same thing as <CODE>BINARY string</CODE>.
<CODE>CAST(expr AS CHAR</CODE> threats expression to be a string with the
default character set.

</P>
<P>
To cast a string to a numeric value, you don't normally have to do
anything; just use the string value as it would be a number:

</P>

<PRE>
mysql&#62; SELECT 1+'1';
       -&#62; 2
</PRE>

<P>
If you use a number in string context the number will automatically be
converted to a <CODE>BINARY</CODE> string.

</P>

<PRE>
mysql&#62; SELECT CONCAT("hello you ",2);
       -&#62;  "hello you 2"
</PRE>

<P>
MySQL supports arithmetic with both signed and unsigned 64-bit values.
If you are using an numerical operations (like <CODE>+</CODE>) and one of the
operands are <CODE>unsigned integer</CODE>, then the result will be unsigned.
You can override this by using the <CODE>SIGNED</CODE> and <CODE>UNSIGNED</CODE>
cast operators, which will cast the operation to a signed or
unsigned 64-bit integer, respectively.

</P>

<PRE>
mysql&#62; SELECT CAST(1-2 AS UNSIGNED)
        -&#62; 18446744073709551615
mysql&#62; SELECT CAST(CAST(1-2 AS UNSIGNED) AS SIGNED);
        -&#62; -1
</PRE>

<P>
Note that if either operation is a floating-point value (In this context
<CODE>DECIMAL()</CODE> is regarded as a floating-point value) the result will
be a floating-point value and is not affected by the above rule.

</P>

<PRE>
mysql&#62; SELECT CAST(1 AS UNSIGNED) -2.0
        -&#62; -1.0
</PRE>

<P>
If you are using a string in an arithmetic operation, this is converted
to a floating-point number.

</P>
<P>
The <CODE>CAST()</CODE> and <CODE>CONVERT()</CODE> functions were added in MySQL 4.0.2.

</P>
<P>
The handing of unsigned values was changed in MySQL 4.0 to be able to
support <CODE>BIGINT</CODE> values properly. If you have some code that you
want to run in both MySQL 4.0 and 3.23 (in which case you probably can't
use the CAST function), you can use the following trick to get a signed
result when subtracting two unsigned integer columns:

</P>

<PRE>
SELECT (unsigned_column_1+0.0)-(unsigned_column_2+0.0);
</PRE>

<P>
The idea is that the columns are converted to floating-point before doing
the subtraction.

</P>
<P>
If you get a problem with <CODE>UNSIGNED</CODE> columns in your old MySQL
application when porting to MySQL 4.0, you can use the
<CODE>--sql-mode=NO_UNSIGNED_SUBTRACTION</CODE> option when starting
<CODE>mysqld</CODE>.  Note however that as long as you use this, you will not
be able to make efficient use of the <CODE>UNSIGNED BIGINT</CODE> column type.

</P>


<H3><A NAME="Other_Functions" HREF="manual.ja_toc.html#Other_Functions">6.3.6  その他の関数</A></H3>



<H4><A NAME="Bit_functions" HREF="manual.ja_toc.html#Bit_functions">6.3.6.1  ビット関数</A></H4>

<P>
<A NAME="IDX1313"></A>
<A NAME="IDX1314"></A>
<A NAME="IDX1315"></A>
<A NAME="IDX1316"></A>

</P>
<P>
これらは最大 64 ビットの範囲を持ちます。MySQL は <CODE>BIGINT</CODE> (64-bit)
 演算を使用するためです。

</P>
<DL COMPACT>

<DT><CODE>|</CODE>
<DD>
<A NAME="IDX1317"></A>
 <A NAME="IDX1318"></A>
 
ビット演算 OR

<PRE>
mysql&#62; SELECT 29 | 15;
        -&#62; 31
</PRE>

The result is an unsigned 64-bit integer.

<A NAME="IDX1319"></A>
<A NAME="IDX1320"></A>
<DT><CODE>&#38;</CODE>
<DD>
ビット演算 AND

<PRE>
mysql&#62; SELECT 29 &#38; 15;
        -&#62; 13
</PRE>

The result is an unsigned 64-bit integer.

<A NAME="IDX1321"></A>
<A NAME="IDX1322"></A>
<DT><CODE>^</CODE>
<DD>
Bitwise XOR

<PRE>
mysql&#62; SELECT 1 ^ 1;
        -&#62; 0
mysql&#62; SELECT 1 ^ 0;
        -&#62; 1
mysql&#62; SELECT 11 ^ 3;
        -&#62; 8
</PRE>

The result is an unsigned 64-bit integer.

<CODE>XOR</CODE> was added in version 4.0.2.

<A NAME="IDX1323"></A>
<DT><CODE>&#60;&#60;</CODE>
<DD>
左に longlong (<CODE>BIGINT</CODE>) number 分、ビットをシフトします:

<PRE>
mysql&#62; SELECT 1 &#60;&#60; 2;
        -&#62; 4
</PRE>

The result is an unsigned 64-bit integer.

<A NAME="IDX1324"></A>
<DT><CODE>&#62;&#62;</CODE>
<DD>
右に longlong (<CODE>BIGINT</CODE>) number 分、ビットをシフトします:

<PRE>
mysql&#62; SELECT 4 &#62;&#62; 2;
        -&#62; 1
</PRE>

The result is an unsigned 64-bit integer.

<A NAME="IDX1325"></A>
<DT><CODE>~</CODE>
<DD>
Invert all bits:

<PRE>
mysql&#62; SELECT 5 &#38; ~1;
        -&#62; 4
</PRE>

The result is an unsigned 64-bit integer.

<A NAME="IDX1326"></A>
<DT><CODE>BIT_COUNT(N)</CODE>
<DD>
引数 <CODE>N</CODE> がいくつビットを持っているか(２進数表記したときの１の数):

<PRE>
mysql&#62; SELECT BIT_COUNT(29);
        -&#62; 4
</PRE>

</DL>



<H4><A NAME="Miscellaneous_functions" HREF="manual.ja_toc.html#Miscellaneous_functions">6.3.6.2  その他の関数</A></H4>

<P>
<A NAME="IDX1327"></A>
<A NAME="IDX1328"></A>

</P>
<DL COMPACT>

<DT><CODE>DATABASE()</CODE>
<DD>
<A NAME="IDX1329"></A>
 
現在のデータベース名を返します


<PRE>
mysql&#62; SELECT DATABASE();
        -&#62; 'test'
</PRE>

もしデータベースが選択されていないなら、<CODE>DATABASE()</CODE> は空文字を返します。

<A NAME="IDX1330"></A>
<A NAME="IDX1331"></A>
<A NAME="IDX1332"></A>
<DT><CODE>USER()</CODE>
<DD>
<DT><CODE>SYSTEM_USER()</CODE>
<DD>
<DT><CODE>SESSION_USER()</CODE>
<DD>
Returns the current MySQL user name:


<PRE>
mysql&#62; SELECT USER();
        -&#62; 'davida@localhost'
</PRE>

MySQL バージョン 3.22.11 以降では、この関数はユーザー名とクライアントの
ホスト名を含みます。
ユーザー名の部分だけ取り出すには次のようにします。
（これはホスト名が含まれていなくとも動くでしょう）：


<PRE>
mysql&#62; SELECT substring_index(USER(),"@",1);
        -&#62; 'davida'
</PRE>

<A NAME="IDX1333"></A>
<DT><CODE>CURRENT_USER()</CODE>
<DD>
Returns the user name, current session was authentificated as:


<PRE>
mysql&#62; SELECT USER();
        -&#62; 'davida@localhost'
mysql&#62; SELECT * FROM mysql.user;
        -&#62; ERROR 1044: Access denied for user: '@localhost' to database 'mysql'
mysql&#62; SELECT CURRENT_USER();
        -&#62; '@localhost'
</PRE>

<A NAME="IDX1334"></A>
<A NAME="IDX1335"></A>
<DT><CODE>PASSWORD(str)</CODE>
<DD>
<DT><CODE>OLD_PASSWORD(str)</CODE>
<DD>
プレーンテキストのパスワード <CODE>str</CODE> からパスワード文字列を計算します。
これは <CODE>user</CODE> 許可テーブルの <CODE>Password</CODE> フィールドに、
暗号化された MySQL パスワードを保存する際に使用されます:


<PRE>
mysql&#62; SELECT PASSWORD('badpwd');
        -&#62; '7f84554057dd964b'
</PRE>

<A NAME="IDX1336"></A>
<CODE>PASSWORD()</CODE> 暗号は不可逆です。

<CODE>PASSWORD()</CODE> は UNIX のパスワードが暗号化するのと同じ方法で
暗号化を行うわけではありません。 <CODE>ENCRYPT()</CODE> 参照。

<STRONG>注意:</STRONG>
<CODE>PASSWORD()</CODE> 関数は MySQL サーバー内の認証システムで使用されます。
その関数をあなたの独自アプリケーションでは使用すべきでは<STRONG>ありません</STRONG>。
そうしたければ、代わりに <CODE>MD5()</CODE> や <CODE>SHA1()</CODE> を使用します。
Also see <CODE>RFC-2195</CODE> for more information about handling passwords
and authentication securely in your application.

<A NAME="IDX1337"></A>
<DT><CODE>ENCRYPT(str[,salt])</CODE>
<DD>
UNIX の <CODE>crypt()</CODE> システムコールで <CODE>str</CODE> を暗号化します。
<CODE>salt</CODE> は2文字の文字列です。
(MySQL バージョン 3.22.16 で, <CODE>salt</CODE> は2文字以上許されるようになり
ました。)


<PRE>
mysql&#62; SELECT ENCRYPT("hello");
        -&#62; 'VxuFAJXVARROc'
</PRE>

システムで <CODE>crypt()</CODE> が利用できない場合は <CODE>ENCRYPT()</CODE> は常に 
<CODE>NULL</CODE> を返します。

少なくともいくつかのシステムでは、
<CODE>ENCRYPT()</CODE> は <CODE>str</CODE> 文字中の最初の 8 文字以外は全て無視します。
これは <CODE>crypt()</CODE> システムコールの振る舞いによって決定づけられます。

<A NAME="IDX1338"></A>
<DT><CODE>ENCODE(str,pass_str)</CODE>
<DD>
パスワードとして <CODE>pass_str</CODE> を用いて <CODE>str</CODE> を暗号化します。結果
を復号化するには、<CODE>DECODE()</CODE>を使用します。

結果はバイナリ文字列で、長さは <CODE>string</CODE> と同じです。
フィールドにそれを保存したい場合は <CODE>BLOB</CODE> フィールド型を使用してください。

<A NAME="IDX1339"></A>
<DT><CODE>DECODE(crypt_str,pass_str)</CODE>
<DD>
暗号化された文字列 <CODE>crypt_str</CODE> をパスワードとして <CODE>pass_str</CODE> を
用いて復号化します。<CODE>crypt_str</CODE> は <CODE>ENCODE()</CODE> から返された文字列
であるべきです。

<A NAME="IDX1340"></A>
<DT><CODE>MD5(string)</CODE>
<DD>
文字列を MD5 128bit チェックサムした結果を返します。 値は 32 桁の 16進表示です。
例えばハッシュキーとして使用できるように:


<PRE>
mysql&#62; SELECT MD5("testing");
        -&#62; 'ae2b1fca515949e5d54fb22b8ed95575'
</PRE>

これは "RSA Data Security, Inc. MD5 Message-Digest Algorithm".

<A NAME="IDX1341"></A>
<A NAME="IDX1342"></A>
<DT><CODE>SHA1(string)</CODE>
<DD>
<DT><CODE>SHA(string)</CODE>
<DD>
Calculates an SHA1 160 bit checksum for the string, as described in
RFC 3174 (Secure Hash Algorithm). The value is returned as a 40 digit
hex number, or <CODE>NULL</CODE> in case the input argument was <CODE>NULL</CODE>.
One of the possible uses for this function is as a hash key. You can
also use it as cryptographically safe function for storing passwords.


<PRE>
mysql&#62; SELECT SHA1("abc");
        -&#62; 'a9993e364706816aba3e25717850c26c9cd0d89d'
</PRE>

<CODE>SHA1()</CODE> was added in version 4.0.2, and can be considered
a cryptographically more secure equivalent of <CODE>MD5()</CODE>.
<CODE>SHA()</CODE> is synonym for <CODE>SHA1()</CODE>.

<A NAME="IDX1343"></A>
<A NAME="IDX1344"></A>
<DT><CODE>AES_ENCRYPT(string,key_string)</CODE>
<DD>
<DT><CODE>AES_DECRYPT(string,key_string)</CODE>
<DD>
These functions allow encryption/decryption of data using the official
AES (Advanced Encryption Standard) algorithm, previously known as Rijndael.
Encoding with 128 bit key length is used, but you can extend it up to
256 bit by patching the source. We chose 128 bits because it is much
faster and it is usually secure enough.

The input arguments may be any length. If either argument is <CODE>NULL</CODE>,
the result of this function is also <CODE>NULL</CODE>.

As AES is a block level algorithm, padding is used to encode uneven length
strings and so the result string length may be calculated as
16*(trunc(string_length/16)+1).

If <CODE>AES_DECRYPT()</CODE> detects invalid data or incorrect padding, it
will return <CODE>NULL</CODE>. However, it is possible for <CODE>AES_DECRYPT()</CODE>
to return a non-<CODE>NULL</CODE> value (possibly garbage) if the input data or
the key was invalid.

You can use the AES functions to store data in an encrypted form by
modifying your queries:

<PRE>
INSERT INTO t VALUES (1,AES_ENCRYPT("text","password"));
</PRE>

You can get even more security by avoiding transferring the key over the
connection for each query, which can be accomplished by storing it in a
server side variable at connection time:

<PRE>
SELECT @password:="my password";
INSERT INTO t VALUES (1,AES_ENCRYPT("text",@password));
</PRE>

<CODE>AES_ENCRYPT()</CODE> and <CODE>AES_DECRYPT()</CODE> were added in version 4.0.2,
and can be considered the most cryptographically secure encryption
functions currently available in MySQL.

<A NAME="IDX1345"></A>
<DT><CODE>DES_ENCRYPT(string_to_encrypt [, (key_number | key_string) ] )</CODE>
<DD>
Encrypts the string with the given key using the Triple-DES algorithm.

Note that this function only works if you have configured MySQL with
SSL support.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Secure_connections">4.3.9  Using Secure Connections</A>」節参照.

The encryption key to use is chosen the following way:

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Argument</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD>Only one argument </TD><TD>
The first key from <CODE>des-key-file</CODE> is used.
</TR NOSAVE>
<TR><TD>key number </TD><TD>
The given key (0-9) from the <CODE>des-key-file</CODE> is used.
</TR NOSAVE>
<TR><TD>string </TD><TD>
The given <CODE>key_string</CODE> will be used to crypt <CODE>string_to_encrypt</CODE>.
</TR>
</TABLE>

The return string will be a binary string where the first character
will be <CODE>CHAR(128 | key_number)</CODE>.

The 128 is added to make it easier to recognise an encrypted key.
If you use a string key, <CODE>key_number</CODE> will be 127.

On error, this function returns <CODE>NULL</CODE>.

The string length for the result will be
<CODE>new_length= org_length + (8-(org_length % 8))+1</CODE>.

The <CODE>des-key-file</CODE> has the following format:


<PRE>
key_number des_key_string
key_number des_key_string
</PRE>

Each <CODE>key_number</CODE> must be a number in the range from 0 to 9.  Lines in
the file may be in any order.  <CODE>des_key_string</CODE> is the string that
will be used to encrypt the message.  Between the number and the key there
should be at least one space.  The first key is the default key that will
be used if you don't specify any key argument to <CODE>DES_ENCRYPT()</CODE>

You can tell MySQL to read new key values from the key file with the
<CODE>FLUSH DES_KEY_FILE</CODE> command.  This requires the <CODE>Reload_priv</CODE>
privilege.

One benefit of having a set of default keys is that it gives applications
a way to check for existence of encrypted column values, without giving
the end user the right to decrypt those values.


<PRE>
mysql&#62; SELECT customer_address FROM customer_table WHERE
       crypted_credit_card = DES_ENCRYPT("credit_card_number");
</PRE>

<A NAME="IDX1346"></A>
<DT><CODE>DES_DECRYPT(string_to_decrypt [, key_string])</CODE>
<DD>
Decrypts a string encrypted with <CODE>DES_ENCRYPT()</CODE>.

Note that this function only works if you have configured MySQL with
SSL support.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Secure_connections">4.3.9  Using Secure Connections</A>」節参照.

If no <CODE>key_string</CODE> argument is given, <CODE>DES_DECRYPT()</CODE> examines
the first byte of the encrypted string to determine the DES key number
that was used to encrypt the original string, then reads the key
from the <CODE>des-key-file</CODE> to decrypt the message.  For this to work
the user must have the <CODE>SUPER</CODE> privilege.

If you pass this function a <CODE>key_string</CODE> argument, that string
is used as the key for decrypting the message.

If the <CODE>string_to_decrypt</CODE> doesn't look like an encrypted string, MySQL
will return the given <CODE>string_to_decrypt</CODE>.

On error, this function returns <CODE>NULL</CODE>.

<A NAME="IDX1347"></A>
<DT><CODE>LAST_INSERT_ID([expr])</CODE>
<DD>
最後に <CODE>AUTO_INCREMENT</CODE> フィールドに挿入されて自動的に生成された値を返しま
す。
 「<A HREF="manual.ja_Clients.html#mysql_insert_id">8.4.3.130  <CODE>mysql_insert_id()</CODE></A>」節参照.


<PRE>
mysql&#62; SELECT LAST_INSERT_ID();
        -&#62; 195
</PRE>

最後の作成された ID はそれぞれのコネクション毎にサーバーに維持されます。
これは他のクライアントからは変更できないでしょう。
もし他の非マジック値をもつ <CODE>AUTO_INCREMENT</CODE> フィールド
（値が <CODE>NULL</CODE> でも <CODE>0</CODE> でもないということ）
を更新しても、これは 変更されません。

一つの INSERT 文で同時に多くのレコードを挿入する場合、
<CODE>LAST_INSERT_ID()</CODE> は最初に挿入されたレコードの値を返します。この理由
は、他のサーバに対して同じ <CODE>INSERT</CODE> を簡単に再現できるようにするため
です。

<A NAME="IDX1348"></A>
If <CODE>expr</CODE> is given as an argument to <CODE>LAST_INSERT_ID()</CODE>, then
the value of the argument is returned by the function, is set as the
next value to be returned by <CODE>LAST_INSERT_ID()</CODE> and used as the next
auto_increment value.  
これは シーケンス番号のシミュレーションに使用できます：

最初にテーブルを作成：


<PRE>
mysql&#62; CREATE TABLE sequence (id int not null);
mysql&#62; INSERT INTO sequence VALUES (0);
</PRE>

そして以下のようにしてシーケンス番号を生成：


<PRE>
mysql&#62; UPDATE sequence SET id=LAST_INSERT_ID(id+1);
</PRE>

<CODE>LAST_INSERT_ID()</CODE> の呼び出し無しでシーケンス番号を生成することが可能
ですが、この方法でこの関数を使用するユーティリティは、ID 値が最後に自動的
に生成された値としてサーバに管理されます。MySQL 内の通常の任意の 
<CODE>AUTO_INCREMENT</CODE> 値を読み込んで新しい ID を取り出すことができます。例
えば、<CODE>LAST_INSERT_ID()</CODE> (引数無し) は新しい ID を返します。C API 関
数 <CODE>mysql_insert_id()</CODE> もこの値を得るために使用できます。

Note that as <CODE>mysql_insert_id()</CODE> is only updated after <CODE>INSERT</CODE>
and <CODE>UPDATE</CODE> statements, so you can't use the C API function to
retrieve the value for <CODE>LAST_INSERT_ID(expr)</CODE> after executing other
SQL statements like <CODE>SELECT</CODE> or <CODE>SET</CODE>.

<A NAME="IDX1349"></A>
<DT><CODE>FORMAT(X,D)</CODE>
<DD>
<CODE>'#,###,###.##'</CODE> のような形式(小数部 <CODE>X</CODE> 桁)で数値 <CODE>D</CODE> を整形
します。 もし <CODE>D</CODE> が <CODE>0</CODE> なら, 結果にはいかなる
小数点も小数部も含まれません。


<PRE>
mysql&#62; SELECT FORMAT(12332.123456, 4);
        -&#62; '12,332.1235'
mysql&#62; SELECT FORMAT(12332.1,4);
        -&#62; '12,332.1000'
mysql&#62; SELECT FORMAT(12332.2,0);
        -&#62; '12,332'
</PRE>

<A NAME="IDX1350"></A>
<DT><CODE>VERSION()</CODE>
<DD>
MySQL サーバのバージョンを返します:


<PRE>
mysql&#62; SELECT VERSION();
        -&#62; '3.23.13-log'
</PRE>

注意: バージョンが <CODE>-log</CODE> で終わる場合はロギングが有効であることを意
味します。

<A NAME="IDX1351"></A>
<DT><CODE>CONNECTION_ID()</CODE>
<DD>
接続の接続 ID (<CODE>thread_id</CODE>) を返します。すべての接続は接続自身の一意
な ID を持ちます:


<PRE>
mysql&#62; SELECT CONNECTION_ID();
        -&#62; 1
</PRE>

<A NAME="IDX1352"></A>
<A NAME="IDX1353"></A>
<DT><CODE>GET_LOCK(str,timeout)</CODE>
<DD>
<CODE>timeout</CODE> 秒のタイムアウトで、<CODE>str</CODE> と名付けられたロックの獲得を試み
ます。ロックを獲得した場合は <CODE>1</CODE>, タイムアウトの場合は <CODE>0</CODE>, エラーの場
合(メ
モリ不足やスレッドが <CODE>mysqladmin kill</CODE> で殺された場合など)は <CODE>NULL</CODE>
が返ります。<CODE>RELEASE_LOCK</CODE> の実行、新しい <CODE>GET_LOCK</CODE> の実行、
スレッドの終了の場合に、ロックは解放されます。この関数はアプリケーション
ロックやレコードロックのシミュレートのために使用できます。
これは、同じ名前のロックを行おうとする他のクライアントからのリクエストを
ブロックします； 与えられた名前のロックに応じているクライアントは、
協調してロッキングを行うために、その文字列を使用できます:


<PRE>
mysql&#62; SELECT GET_LOCK("lock1",10);
        -&#62; 1
mysql&#62; SELECT IS_FREE_LOCK("lock2");
        -&#62; 1
mysql&#62; SELECT GET_LOCK("lock2",10);
        -&#62; 1
mysql&#62; SELECT RELEASE_LOCK("lock2");
        -&#62; 1
mysql&#62; SELECT RELEASE_LOCK("lock1");
        -&#62; NULL
</PRE>

２つ目の <CODE>RELEASE_LOCK()</CODE> は <CODE>NULL</CODE> を返します。
なぜなら、 <CODE>"lock1"</CODE> は、２つ目の <CODE>GET_LOCK()</CODE> の呼び出し時点で、
自動的に解放されるからです。

<A NAME="IDX1354"></A>
<DT><CODE>RELEASE_LOCK(str)</CODE>
<DD>
<CODE>GET_LOCK</CODE> で獲得したロック <CODE>str</CODE> を解放します。ロックが解
放された場合は <CODE>1</CODE>, このスレッドによってロックされていない場合は <CODE>0</CODE> 
(この場合、ロックは解放されません), 
<CODE>str</CODE>が存在しない場合は <CODE>NULL</CODE> が返ります。
もし、 <CODE>GET_LOCK()</CODE> をコールして得られなかった場合、
あるいは、既に解放されている場合は、ロックは存在しないでしょう。

The <CODE>DO</CODE> statement is convinient to use with <CODE>RELEASE_LOCK()</CODE>.
 「<A HREF="manual.ja_Reference.html#DO">6.4.10  <CODE>DO</CODE> Syntax</A>」節参照.

<A NAME="IDX1355"></A>
<DT><CODE>IS_FREE_LOCK(str)</CODE>
<DD>
Checks if the lock named <CODE>str</CODE> is free to use (i.e., not locked).
Returns <CODE>1</CODE> if the lock is free (no one is using the lock),
<CODE>0</CODE> if the lock is in use, and
<CODE>NULL</CODE> on errors (like incorrect arguments).

<A NAME="IDX1356"></A>
<DT><CODE>BENCHMARK(count,expr)</CODE>
<DD>
<CODE>BENCHMARK()</CODE> 関数は <CODE>expr</CODE> で与えられた文を <CODE>count</CODE> 回
繰り返し実行します。 これは MySQL のその文の処理がどれぐらい
速いのか知るのに使用されるでしょう。 結果は常に <CODE>0</CODE> です。
想定している使用は、 <CODE>mysql</CODE> クライアントです。
あるクエリの実行時間を知るための使用です:


<PRE>
mysql&#62; SELECT BENCHMARK(1000000,ENCODE("hello","goodbye"));
+----------------------------------------------+
| BENCHMARK(1000000,ENCODE("hello","goodbye")) |
+----------------------------------------------+
|                                            0 |
+----------------------------------------------+
1 row in set (4.74 sec)
</PRE>

報告された時間は、クライアントでの経過時間です。 サーバー側の CPU 時間では
ありません。<CODE>BENCHMARK()</CODE> を何回か実行して、サーバマシンの負荷の重さ
を考慮して結果を解釈することを勧めます。

<A NAME="IDX1357"></A>
<DT><CODE>INET_NTOA(expr)</CODE>
<DD>
数値表現に対するネットワークアドレス(4 または 8 バイト) を返します:


<PRE>
mysql&#62; SELECT INET_NTOA(3520061480);
       -&#62;  "209.207.224.40"
</PRE>

<A NAME="IDX1358"></A>
<DT><CODE>INET_ATON(expr)</CODE>
<DD>
ネットワークアドレスに対する数値を表す整数を返します。アドレスは 4 または 
8 バイトアドレスです:


<PRE>
mysql&#62; SELECT INET_ATON("209.207.224.40");
       -&#62;  3520061480
</PRE>

生成された数値は常にネットワークバイトオーダです; たとえば、上記の数値は
<CODE>209*255^3 + 207*255^2 + 224*255 +40</CODE> として計算されます。

<A NAME="IDX1359"></A>
<DT><CODE>MASTER_POS_WAIT(log_name, log_pos)</CODE>
<DD>
マスターログの指定された位置にスレーブが到達するまで(すなわち、スレーブが
読み込んで全て更新しおわるまで)ブロックします。
マスター情報が初期化されていないか引数が違う場合、<CODE>NULL</CODE> が返ります。
スレーブが動作していない場合、ブロックし、スレーブが起動し、指定位置にくるまで待ちます。
スレーブが既に指定位置を通り過ぎていた場合、即時復帰します。

If <CODE>timeout</CODE> (new in 4.0.10) is specified, will give up waiting
when <CODE>timeout</CODE> seconds have elapsed. <CODE>timeout</CODE> must be greater
than 0; a zero or negative <CODE>timeout</CODE> means no timeout. The return
value is the number of log events it had to wait to get to the specified
position, or <CODE>NULL</CODE> in case of error, or <CODE>-1</CODE> if the timeout
has been exceeded.

This command is useful for control of master-slave synchronisation, but
was originally written to facilitate replication testing.

<A NAME="IDX1360"></A>
<A NAME="IDX1361"></A>
<DT><CODE>FOUND_ROWS()</CODE>
<DD>
Returns the number of rows that the last <CODE>SELECT SQL_CALC_FOUND_ROWS ...</CODE>
command would have returned, if it had not been restricted with <CODE>LIMIT</CODE>.


<PRE>
mysql&#62; SELECT SQL_CALC_FOUND_ROWS * FROM tbl_name
       WHERE id &#62; 100 LIMIT 10;
mysql&#62; SELECT FOUND_ROWS();
</PRE>

The second <CODE>SELECT</CODE> will return a number indicating how many rows the
first <CODE>SELECT</CODE> would have returned had it been written without the
<CODE>LIMIT</CODE> clause.

Note that if you are using <CODE>SELECT SQL_CALC_FOUND_ROWS ...</CODE> MySQL has
to calculate all rows in the result set.  However, this is faster than
if you would not use <CODE>LIMIT</CODE>, as the result set need not be sent
to the client.

<CODE>SQL_CALC_FOUND_ROWS</CODE> is available starting at MySQL version 4.0.0.
</DL>



<H4><A NAME="Group_by_functions" HREF="manual.ja_toc.html#Group_by_functions">6.3.6.3  Functions for Use with <CODE>GROUP BY</CODE> Clauses</A></H4>

<P>
<A NAME="IDX1362"></A>
<A NAME="IDX1363"></A>

</P>
<P>
<CODE>GROUP BY</CODE>節を含まない文でグループ関数を使用すると
全てのレコードについてグループされたものとみなされます。

</P>
<DL COMPACT>

<DT><CODE>COUNT(expr)</CODE>
<DD>
<A NAME="IDX1364"></A>
 
Returns a count of the number of non-<CODE>NULL</CODE> values in the rows
retrieved by a <CODE>SELECT</CODE> statement:
<CODE>SELECT</CODE>文により選択されたレコードから<CODE>NULL</CODE>ではないものの数を返します。


<PRE>
mysql&#62; SELECT student.student_name,COUNT(*)
           FROM student,course
           WHERE student.student_id=course.student_id
           GROUP BY student_name;

</PRE>

<CODE>COUNT(*)</CODE>は<CODE>NULL</CODE>を含むかどうかで選択されたレコードの数を返すだけです。

<CODE>COUNT(*)</CODE>は一つのテーブルから一つだけカラムが選択され、
尚且つ<CODE>WHERE</CODE>節が使用されていない場合に最適化され、高速に動作します。
例えば以下のように使います。


<PRE>
mysql&#62; SELECT COUNT(*) FROM student;
</PRE>

<A NAME="IDX1365"></A>
<A NAME="IDX1366"></A>
<DT><CODE>COUNT(DISTINCT expr,[expr...])</CODE>
<DD>
これは<CODE>NULL</CODE>値では無い値を持つデータの数を区別して返すことが出来ます。


<PRE>
mysql&#62; SELECT COUNT(DISTINCT results) from student;
</PRE>

複数の選択されたデータ群から<CODE>NULL</CODE>を含まないデータの総数算出が必要な場合、
MySQLでは必要な選択リストを与えることによって得ることが出来ます。
一方でANSIのSQLではその選択一つ一つについて <CODE>COUNT(DISTINCT ...)</CODE> を使う必要があります。

<A NAME="IDX1367"></A>
<DT><CODE>AVG(expr)</CODE>
<DD>
<CODE>expr</CODE>で得られる値の平均値を返します。


<PRE>
mysql&#62; SELECT student_name, AVG(test_score)
           FROM student
           GROUP BY student_name;
</PRE>

<A NAME="IDX1368"></A>
<A NAME="IDX1369"></A>
<DT><CODE>MIN(expr)</CODE>
<DD>
<DT><CODE>MAX(expr)</CODE>
<DD>
<CODE>expr</CODE>で得られる値の最大値、最小値を返します。
<CODE>MIN()</CODE>と<CODE>MAX()</CODE>の引数は文字列を取ることもできます。
この際は文字列の値の大小を比較し、最大と最小を返します。 「<A HREF="manual.ja_MySQL_Optimisation.html#MySQL_indexes">5.4.3  MySQL はどのようにインデックスを使用するか？</A>」節.


<PRE>
mysql&#62; SELECT student_name, MIN(test_score), MAX(test_score)
    -&#62;        FROM student
    -&#62;        GROUP BY student_name;
</PRE>

In <CODE>MIN()</CODE>, <CODE>MAX()</CODE> and other aggregate functions, MySQL
currently compares <CODE>ENUM</CODE> and <CODE>SET</CODE> columns by their string
value rather than by the string's relative position in the set.
This will be rectified.

<A NAME="IDX1370"></A>
<DT><CODE>SUM(expr)</CODE>
<DD>
<CODE>expr</CODE>で得られる値の総計を返します。
もしも得られるレコードが見つからない場合は<CODE>NULL</CODE>が返ってきます。

<A NAME="IDX1371"></A>
<DT><CODE>VARIANCE(expr)</CODE>
<DD>
Returns the standard variance of <CODE>expr</CODE>. This is an extension to
ANSI SQL (available only in version 4.1 or later).

<A NAME="IDX1372"></A>
<A NAME="IDX1373"></A>
<A NAME="IDX1374"></A>
<A NAME="IDX1375"></A>
<DT><CODE>STD(expr)</CODE>
<DD>
<DT><CODE>STDDEV(expr)</CODE>
<DD>
<CODE>expr</CODE>で得られる値の標準偏差を返します。
これはANSI SQLの格調になっています。
関数としての<CODE>STDDEV()</CODE>の形はOracleのものと互換性があります。

<A NAME="IDX1376"></A>
<DT><CODE>BIT_OR(expr)</CODE>
<DD>
<CODE>expr</CODE>で得られる値のビット和(<CODE>OR</CODE>)を返します。
計算は64-bit(<CODE>BIGINT</CODE>)の精度で行われます。

<A NAME="IDX1377"></A>
<DT><CODE>BIT_AND(expr)</CODE>
<DD>
<CODE>expr</CODE>で得られる値のビット積(<CODE>AND</CODE>)を返します。
計算は64-bit(<CODE>BIGINT</CODE>)の精度で行われます。

</DL>

<P>
<A NAME="IDX1378"></A>
MySQLの<CODE>GROUP BY</CODE>は拡張された使い方が可能です。
<CODE>SELECT</CODE>で使用したフィールド名や計算式を<CODE>GROUP BY</CODE>には使用しない、
という使い方が可能です。
このことは<EM>グループにはどんな値も使用可能</EM>ということを表しています。
データの並べ替えやグループ分けに適さない要素を排除することによって
より良好なパフォーマンスを得ることが出来ます。
例えば、次のようなクエリで<CODE>customer.name</CODE>についてのグループ分けをする必要はありません。

</P>

<PRE>
mysql&#62; SELECT order.custid,customer.name,MAX(payments)
    -&#62;        FROM order,customer
    -&#62;        WHERE order.custid = customer.custid
    -&#62;        GROUP BY order.custid;
</PRE>

<P>
ANSI SQLでは<CODE>customer.name</CODE>を<CODE>GROUP BY</CODE>のところに追加する必要があります。
MySQLではANSIモードで動かしていない限り余計な記述の必要はありません。

</P>
<P>
<CODE>GROUP BY</CODE>で省略するフィールドはグループ内でユニークでなくてはいけません。
もしそうでない場合は結果は予想もしないようなものになるでしょう。

</P>
<P>
たとえユニークでは無くても特定のフィールドの値を得るために
<CODE>MIN()</CODE>や<CODE>MAX()</CODE>を使用できるケースもあります。
次の例は<CODE>sort</CODE>フィールド中の最小値を持つレコードから
特定の<CODE>column</CODE>の値を取り出します。

</P>

<PRE>
SUBSTR(MIN(CONCAT(RPAD(sort,6,' '),column)),7)
</PRE>

<P>
 「<A HREF="manual.ja_Tutorial.html#example-Maximum-column-group-row">3.5.4  The Rows Holding the Group-wise Maximum of a Certain Field</A>」節参照.

</P>
<P>
<A NAME="IDX1379"></A>
<A NAME="IDX1380"></A>
<A NAME="IDX1381"></A>
<A NAME="IDX1382"></A>
<A NAME="IDX1383"></A>
<A NAME="IDX1384"></A>
MySQLの3.22以前のバージョンをお使いであるか、ANSI SQLに沿っての使用をされる場合は
<CODE>GROUP BY</CODE>と<CODE>ORDER BY</CODE>内に選択表現を記述してはいけません。
この制限を守った上で作業を進めるにはエイリアスを使用します。

</P>

<PRE>
mysql&#62; SELECT id,FLOOR(value/100) AS val FROM tbl_name
    -&#62;        GROUP BY id,val ORDER BY val;
</PRE>

<P>
MySQLのバージョン3.23では次のようにも記述できます。

</P>

<PRE>
mysql&#62; SELECT id,FLOOR(value/100) FROM tbl_name ORDER BY RAND();
</PRE>



<H2><A NAME="Data_Manipulation" HREF="manual.ja_toc.html#Data_Manipulation">6.4  Data Manipulation: <CODE>SELECT</CODE>, <CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, <CODE>DELETE</CODE></A></H2>



<H3><A NAME="SELECT" HREF="manual.ja_toc.html#SELECT">6.4.1  <CODE>SELECT</CODE> 構文</A></H3>

<P>
<A NAME="IDX1385"></A>

</P>

<PRE>
SELECT [STRAIGHT_JOIN]
       [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
       [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] [HIGH_PRIORITY]
       [DISTINCT | DISTINCTROW | ALL]
    select_expression,...
    [INTO {OUTFILE | DUMPFILE} 'file_name' export_options]
    [FROM table_references
      [WHERE where_definition]
      [GROUP BY {unsigned_integer | col_name | formula} [ASC | DESC], ...]
      [HAVING where_definition]
      [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] ,...]
      [LIMIT [offset,] rows | rows OFFSET offset]
      [PROCEDURE procedure_name(argument_list)]
      [FOR UPDATE | LOCK IN SHARE MODE]]
</PRE>

<P>
<CODE>SELECT</CODE>は通常、1つまたは1つ以上のテーブルからレコードを検索して抽出
するのに使用されます。
<CODE>select_expression</CODE> は取り出したいフィールドを示します。
<CODE>SELECT</CODE>はまた、テーブルの参照なしに計算によって求められたレコードを
取り出すために使用されます。例:

</P>

<PRE>
mysql&#62; SELECT 1 + 1;
         -&#62; 2
</PRE>

<P>
全てのキーワードの使用は、上記に示すような順序で正確に与えられる必要があります。
例えば、<CODE>HAVING</CODE>節は必ず<CODE>GROUP BY</CODE>節の後、<CODE>ORDER BY</CODE>節の前でなければなりません。

</P>

<UL>

<LI>

<A NAME="IDX1386"></A>
<A NAME="IDX1387"></A>
<CODE>SELECT</CODE>の表現では、<CODE>AS</CODE>による別名の指定が可能です。別名は、
フィールド名の表現として使われ、<CODE>ORDER BY</CODE>及び<CODE>HAVING</CODE>節とともに使用することができます。
例:


<PRE>
mysql&#62; SELECT CONCAT(last_name,', ',first_name) AS full_name
    FROM mytable ORDER BY full_name;
</PRE>

<LI>

It is not allowed to use a column alias in a <CODE>WHERE</CODE> clause,
because the column value may not yet be determined when the
<CODE>WHERE</CODE> clause is executed.
 「<A HREF="manual.ja_Problems.html#Problems_with_alias">A.5.4  <CODE>alias</CODE> の問題</A>」節参照.

<LI>

<A NAME="IDX1388"></A>
<A NAME="IDX1389"></A>
<A NAME="IDX1390"></A>
<A NAME="IDX1391"></A>
<A NAME="IDX1392"></A>
<A NAME="IDX1393"></A>
<CODE>FROM table_references</CODE>節は、(例えば、選択するレコードにより、1つ又はそれ以上の)
結合するテーブルのリストを示します。
このリストはまた、<CODE>LEFT OUTER JOIN</CODE>参照を含むことがあります。
 「<A HREF="manual.ja_Reference.html#JOIN">6.4.1.1  <CODE>JOIN</CODE> 構文</A>」節. を参照してください。
For each table specified, you may optionally specify an alias.

<PRE>
table_name [[AS] alias] [[USE INDEX (key_list)] | [IGNORE INDEX (key_list)] | FORCE INDEX (key_list)]]
</PRE>

As of MySQL Version 3.23.12, you can give hints about which
index MySQL should use when retrieving information from a
table. This is useful if <CODE>EXPLAIN</CODE> shows that MySQL is
using the wrong index from the list of possible indexes.  By specifying
<CODE>USE INDEX (key_list)</CODE>, you can tell MySQL to use only one of the
possible indexes to find rows in the table.  The alternative syntax
<CODE>IGNORE INDEX (key_list)</CODE> can be used to tell MySQL to not use some
particular index.

In MySQL 4.0.9 you can also use <CODE>FORCE INDEX</CODE>. This acts likes
<CODE>USE INDEX (key_list)</CODE> but with the addition that a table scan
is assumed to be VERY expensive.  In other words a table scan will
only be used if there is no way to use one of the given index to
find rows in the table.

<CODE>USE/IGNORE/FORCE KEY</CODE> are synonyms for <CODE>USE/IGNORE/FORCE INDEX</CODE>.

<LI>

You can refer to a table as <CODE>tbl_name</CODE> (within the current database),
or as <CODE>dbname.tbl_name</CODE> to explicitly specify a database.
<CODE>col_name</CODE>、<CODE>tbl_name.col_name</CODE>、<CODE>db_name.tbl_name.col_name</CODE>の
ようにしてフィールドを表すことができます。
<CODE>SELECT</CODE>ステートメント内での列の参照が曖昧でなければ、<CODE>tbl_name</CODE>や
<CODE>db_name.tbl_name</CODE>のようなプリフィックスを詳細に記述する必要はありません。
より明示的なフィールドの指定形式をを必要とする曖昧な参照の例は、 「<A HREF="manual.ja_Reference.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A>」節を参照のこと。

<LI>

<A NAME="IDX1394"></A>
<A NAME="IDX1395"></A>
テーブル参照は、<CODE>tbl_name AS alias_name</CODE>又は<CODE>tbl_name alias_name</CODE>を
使って別名を使用することが可能です:


<PRE>
mysql&#62; SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
    -&#62;        WHERE t1.name = t2.name;
mysql&#62; SELECT t1.name, t2.salary FROM employee t1, info t2
    -&#62;        WHERE t1.name = t2.name;
</PRE>

<LI>

出力用に選択されたフィールドは、<CODE>ORDER BY</CODE>節や<CODE>GROUP BY</CODE>節において、
フィールド名、フィールドのエイリアス名、又はフィールド番号にて指し示すことが
できます。フィールド番号は1から始まります。


<PRE>
mysql&#62; SELECT college, region, seed FROM tournament
    -&#62;        ORDER BY region, seed;
mysql&#62; SELECT college, region AS r, seed AS s FROM tournament
    -&#62;        ORDER BY r, s;
mysql&#62; SELECT college, region, seed FROM tournament
    -&#62;        ORDER BY 2, 3;
</PRE>

逆順で並べたい場合には、 <CODE>ORDER BY</CODE> 節の中で、あなたが並べたいと思っている
フィールドの名前の後ろに、 <CODE>DESC</CODE> (descending) キーワードを
追加します。
デフォルトは昇順です； これは <CODE>ASC</CODE> キーワードを指定したことになります。

<LI>

<CODE>WHERE</CODE> 節で MySQL がサポートする任意の関数を使用することが
できます。 「<A HREF="manual.ja_Reference.html#Functions">6.3  <CODE>SELECT</CODE> と <CODE>WHERE</CODE> 節で使用する関数</A>」節参照.

<LI>

<CODE>HAVING</CODE>節は、<CODE>select_expression</CODE>においてどのフィールドの名前や
エイリアス名でも指し示すことができます。
これは最後に適用され、クライアントにアイテムが送られる直前に実行されるので、
最適化されません。
<CODE>WHERE</CODE>節で書くべきものに<CODE>HAVING</CODE>を用いてはいけません。
例えば、次のように書いてはいけません:


<PRE>
mysql&#62; SELECT col_name FROM tbl_name HAVING col_name &#62; 0;
</PRE>

その代わりに、次のように書いてください:


<PRE>
mysql&#62; SELECT col_name FROM tbl_name WHERE col_name &#62; 0;
</PRE>

MySQL バージョン 3.22.5以降では、次のようにクエリを記述することができます:


<PRE>
mysql&#62; SELECT user,MAX(salary) FROM users
           GROUP BY user HAVING MAX(salary)&#62;10;
</PRE>

MySQLの古いバージョンでは、この代わりに次のように記述できます:


<PRE>
mysql&#62; SELECT user,MAX(salary) AS sum FROM users
           GROUP BY user HAVING sum&#62;10;
</PRE>

<LI>

The options <CODE>DISTINCT</CODE>, <CODE>DISTINCTROW</CODE> and <CODE>ALL</CODE> specify
whether duplicate rows should be returned. The default is (<CODE>ALL</CODE>),
all matching rows are returned. <CODE>DISTINCT</CODE> and <CODE>DISTINCTROW</CODE>
are synonyms and specify that duplicate rows in the result set should
be removed.

<LI>

<CODE>SQL_SMALL_RESULT</CODE>, <CODE>SQL_BIG_RESULT</CODE>, <CODE>SQL_BUFFER_RESULT</CODE>,
<CODE>STRAIGHT_JOIN</CODE>, <CODE>HIGH_PRIORITY</CODE> は ANSI SQL に対する MySQL 拡張です。

<LI>

<CODE>HIGH_PRIORITY</CODE> は、テーブルの更新よりも <CODE>SELECT</CODE> を優先させます。
これは一度で完了する、とても速いクエリにのみ適用すべきです。
もしリードロックされているテーブルがあったとし、
たとえ update 文がこのテーブルの解除を待っていたとしても、
<CODE>SELECT HIGH_PRIORITY</CODE> クエリは実行されます。

<LI>

<CODE>SQL_BIG_RESULT</CODE> は <CODE>GROUP BY</CODE> や <CODE>DISTINCT</CODE> と共に使用する
事ができ、結果セットが多くのレコードを持つことをオプティマイザに知らせます。
この場合、必要なら MySQL はディスクベースの一時テーブルを直接使用
します。<CODE>MySQL</CODE> はこの場合、<CODE>GROUP BY</CODE> 要素上のキーで一時テーブ
ルを行なう代わりにソートを行なうことを選択します。

<LI>

<CODE>SQL_BUFFER_RESULT</CODE> は結果を一時テーブルへ強制的に置きます。これは 
MySQL がテーブルロックを速く解放して、クライアントに結果セットを
送るために長い時間が掛かる場合の助けになります。

<LI>

<CODE>SQL_CALC_FOUND_ROWS</CODE> (version 4.0.0 and up) tells MySQL to calculate
how many rows there would be in the result set, disregarding any
<CODE>LIMIT</CODE> clause.
The number of rows can then be retrieved with <CODE>SELECT FOUND_ROWS()</CODE>.
 「<A HREF="manual.ja_Reference.html#Miscellaneous_functions">6.3.6.2  その他の関数</A>」節参照.

Please note that in versions prior to 4.1.0 this does not work with
<CODE>LIMIT 0</CODE>, which is optimised to return instantly (resulting in a
row count of 0).  「<A HREF="manual.ja_MySQL_Optimisation.html#LIMIT_optimisation">5.2.8  MySQL はどのように <CODE>LIMIT</CODE> を最適化するか？</A>」節参照.
<LI>

<CODE>SQL_CACHE</CODE> tells MySQL to store the query result in the query cache
if you are using <CODE>QUERY_CACHE_TYPE=2</CODE> (<CODE>DEMAND</CODE>).
 「<A HREF="manual.ja_Reference.html#Query_Cache">6.9  MySQL Query Cache (4.0.1以上)</A>」節参照.

<LI>

<CODE>SQL_NO_CACHE</CODE> tells MySQL to not allow the query result to be stored
in the query cache.  「<A HREF="manual.ja_Reference.html#Query_Cache">6.9  MySQL Query Cache (4.0.1以上)</A>」節参照.

<LI>

<CODE>SQL_SMALL_RESULT</CODE> (MySQL 固有のオプション) は <CODE>GROUP BY</CODE>
か <CODE>DISTINCT</CODE> と共に使用する事ができ、
結果セットが小さくなることをオプティマイザに知らせます。この場合、
MySQL はソートする代わりに、速い一時テーブルを結果の保存のた
めに使用します。 MySQL バージョン 3.23 では、これは通常必要ではありません。

<LI>

<A NAME="IDX1396"></A>
<CODE>GROUP BY</CODE> を使用する場合、<CODE>GROUP BY</CODE> 内のすべてのフィールドを 
<CODE>ORDER BY</CODE> に記述したかのように、出力レコードは <CODE>GROUP BY</CODE> に従っ
てソートされます。MySQL は、<CODE>ASC</CODE> と <CODE>DESC</CODE> を 
<CODE>GROUP BY</CODE> に記述できるように、<CODE>GROUP BY</CODE> を拡張しています:


<PRE>
SELECT a,COUNT(b) FROM test_table GROUP BY a DESC
</PRE>

<LI>

MySQL は、<CODE>GROUP BY</CODE> 節に記述されていないフィールドを 
select できるように <CODE>GROUP BY</CODE> の使用を拡張しています。あなたのクエリ
から期待した結果を得ない場合、<CODE>GROUP BY</CODE> の説明を読んでください。
 「<A HREF="manual.ja_Reference.html#Group_by_functions">6.3.6.3  Functions for Use with <CODE>GROUP BY</CODE> Clauses</A>」節参照.

<LI>

<A NAME="IDX1397"></A>
<CODE>STRAIGHT_JOIN</CODE>は、<CODE>FROM</CODE>節にて記述されたテーブルの順序に従って結合するよう、
オプティマイザに強制します。オプティマイザが、テーブルを最適な順序で結合しない
場合に、クエリのスピードアップのためにこれを使用することが可能です。
 「<A HREF="manual.ja_MySQL_Optimisation.html#EXPLAIN">5.2.1  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.

<LI>

<CODE>LIMIT</CODE> 節は、 <CODE>SELECT</CODE> 構文で返されるレコード数を指定するのに
使用されます。 <CODE>LIMIT</CODE> は一つか二つの数字の引数を取ります。

引数が2つ与えられたならば、最初の引数は最初のレコードからのオフセットを示し、
2つめの引数は返すレコードの最大数を示します。
初めのレコードのオフセットは0です(1ではありません)。

To be compatible with PostgreSQL MySQL also supports the syntax:
<CODE>LIMIT # OFFSET #</CODE>.


<PRE>
mysql&#62; SELECT * FROM table LIMIT 5,10;  # 6〜15行目を返す
</PRE>

To retrieve all rows from a certain offset upto the end of the result set,
you can use -1 for the second parameter:


<PRE>
mysql&#62; SELECT * FROM table LIMIT 95,-1; # Retrieve rows 96-last.
</PRE>

もし引数が一つなら、返すべきレコードの最大行数を指定したことになります。


<PRE>
mysql&#62; SELECT * FROM table LIMIT 5;     # 最初の5行を取り出す
</PRE>

いいかえれば、<CODE>LIMIT n</CODE> は <CODE>LIMIT 0,n</CODE> と同じです。

<LI>

<A NAME="IDX1398"></A>
<CODE>SELECT</CODE>の書式、<CODE>SELECT ... INTO OUTFILE 'file_name'</CODE>は、
選択されたレコードをファイルに書き込みます。
ファイルはサーバ機に作成され、既に存在するファイルであってはなりません
(<TT>`/etc/passwd'</TT>のようなファイルの破壊を防止します)。

<CODE>SELECT ... INTO OUTFILE</CODE> は主に、サーバマシン上でとても速くテーブル
をダンプすることを意図されています。サーバホストでない別のホスト上で結果ファ
イルを生成したい場合は、<CODE>SELECT ... INTO OUTFILE</CODE> を使用できません。
この場合は代わりに、<CODE>mysqldump --tab</CODE> や <CODE>mysql -e "SELECT
..." &#62; outfile</CODE> のようなクライアントプログラムを使用して、ファイルを生成す
べきです。

<CODE>SELECT ... INTO OUTFILE</CODE>は、<CODE>LOAD DATA INFILE</CODE>の逆です。
<CODE>export_options</CODE>の構文は、<CODE>LOAD DATA INFILE</CODE>ステートメントの一部で
使われる<CODE>FIELDS</CODE>節や<CODE>LINES</CODE>節と同じような構成です。
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">6.4.9  <CODE>LOAD DATA INFILE</CODE> 構文</A>」節参照.

結果として取り出されるテキストファイルでは、
以下に示す文字が <CODE>ESCAPED BY</CODE> 指定の文字によってエスケープされます：


<UL>
<LI><CODE>ESCAPED BY</CODE> 文字自身

<LI><CODE>FIELDS TERMINATED BY</CODE> の最初の文字

<LI><CODE>LINES TERMINATED BY</CODE> の最初の文字

</UL>

さらに、 <CODE>ASCII 0</CODE> は、<CODE>ESCAPED BY</CODE> 0 (<CODE>ASCII 48</CODE>) にコンバートされます。

いかなる <CODE>FIELDS TERMINATED BY</CODE>, <CODE>ESCAPED BY</CODE>, <CODE>LINES TERMINATED BY</CODE>
指定されている文字も、エスケープしなければならない理由は、
テキストファイルを読み返せれるようにするためなのです。
<CODE>ASCII 0</CODE> はいくつかのページャーでも見れるようにするために
エスケープされるのです。

結果のファイルは SQL の文を含んでいないので、何もエスケープする必要はありません。

次は、多くの古いプログラムによって使用されるフォーマットでファイルを得る例
です。


<PRE>
SELECT a,b,a+b INTO OUTFILE "/tmp/result.text"
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
LINES TERMINATED BY "\n"
FROM test_table;
</PRE>

<LI>

<A NAME="IDX1399"></A>
<CODE>INTO OUTFILE</CODE> の代わりに <CODE>INTO DUMPFILE</CODE> を使用すると、
MySQL はファイルに１レコードだけを書きます。フィールドや行の終端
とすべてのエスケープを含みません。これはファイル内に BLOB を格納したい場合
に便利です。

<LI>

Note that any file created by <CODE>INTO OUTFILE</CODE> and <CODE>INTO
DUMPFILE</CODE> is going to be writeable for all users!  The reason is that the
MySQL server can't create a file that is owned by anyone else
than the user it's running as (you should never run <CODE>mysqld</CODE> as root),
the file has to be world-writeable so that you can manipulate it.

<LI>

ページ／レコードロックとともに ストレ-ジ・エンジン 上で <CODE>FOR UPDATE</CODE> を使
用すると、検査されるレコードは書き込みロックされます。
</UL>



<H4><A NAME="JOIN" HREF="manual.ja_toc.html#JOIN">6.4.1.1  <CODE>JOIN</CODE> 構文</A></H4>

<P>
<A NAME="IDX1400"></A>
<A NAME="IDX1401"></A>
<A NAME="IDX1402"></A>
<A NAME="IDX1403"></A>
<A NAME="IDX1404"></A>
<A NAME="IDX1405"></A>
<A NAME="IDX1406"></A>
<A NAME="IDX1407"></A>
<A NAME="IDX1408"></A>
<A NAME="IDX1409"></A>
<A NAME="IDX1410"></A>
<A NAME="IDX1411"></A>

</P>
<P>
MySQLは、以下に示す<CODE>SELECT</CODE>ステートメントにおける<CODE>JOIN</CODE>構文をサポートします:

</P>

<PRE>
table_reference, table_reference
table_reference [CROSS] JOIN table_reference
table_reference INNER JOIN table_reference join_condition
table_reference STRAIGHT_JOIN table_reference
table_reference LEFT [OUTER] JOIN table_reference join_condition
table_reference LEFT [OUTER] JOIN table_reference
table_reference NATURAL [LEFT [OUTER]] JOIN table_reference
{ OJ table_reference LEFT OUTER JOIN table_reference ON conditional_expr }
table_reference RIGHT [OUTER] JOIN table_reference join_condition
table_reference RIGHT [OUTER] JOIN table_reference
table_reference NATURAL [RIGHT [OUTER]] JOIN table_reference
</PRE>

<P>
Where <CODE>table_reference</CODE> is defined as:
<A NAME="IDX1412"></A>

<PRE>
table_name [[AS] alias] [[USE INDEX (key_list)] | [IGNORE INDEX (key_list)] | [FORCE INDEX (key_list)]]
</PRE>

<P>
and <CODE>join_condition</CODE> is defined as:

</P>

<PRE>
ON conditional_expr |
USING (column_list)
</PRE>

<P>
You should generally not have any conditions in the <CODE>ON</CODE> part that are
used to restrict which rows you have in the result set (there are exceptions
to this rule).  If you want to restrict which rows should be in the result,
you have to do this in the <CODE>WHERE</CODE> clause.

</P>
<P>
注意: 3.23.17 より前のバージョンでは、<CODE>INNER JOIN</CODE> は <CODE>join_condition</CODE>
を取りません！

</P>
<P>
<A NAME="IDX1413"></A>
<A NAME="IDX1414"></A>
上に示す最後の<CODE>LEFT OUTER JOIN</CODE>構文は、ODBCとの互換性のためだけに存在します:

</P>

<UL>
<LI>

table referenceは、<CODE>tbl_name AS alias_name</CODE>や<CODE>tblname alias_name</CODE>に
よる別名を指定することができます:


<PRE>
mysql&#62; SELECT t1.name, t2.salary FROM employee AS t1, info AS t2
    -&#62;        WHERE t1.name = t2.name;
</PRE>

<LI>

<CODE>INNER JOIN</CODE>と<CODE>,</CODE> (コンマ)は、同義語です。どちらも使用される
テーブル間の直積をとります。通常は<CODE>WHERE</CODE>条件にて、テーブルがどのように
リンクされるべきかを定義します。

<LI>

<CODE>ON</CODE>条件節は、<CODE>WHERE</CODE>節で使用されるような条件文の書式です。

<LI>

もし、<CODE>LEFT JOIN</CODE> の <CODE>ON</CODE> や <CODE>USING</CODE> において
右側のテーブルにマッチするレコードが無かった場合、
全てのフィールドが<CODE>NULL</CODE>である1つのレコードが、右側のテーブルとして使用されます。
この事実は、あるテーブルについて、他のテーブルに対応するレコードが存在しない
レコードを探すということに利用できます:


<PRE>
mysql&#62; SELECT table1.* FROM table1
    -&#62;        LEFT JOIN table2 ON table1.id=table2.id
    -&#62;        WHERE table2.id IS NULL;
</PRE>

この例は、<CODE>table1</CODE>の内、<CODE>id</CODE>の値が<CODE>table2</CODE>に存在しない全ての
レコードを検索します。
(即ち、<CODE>table2</CODE>内のレコードと一致しない<CODE>table1</CODE>の全てのレコード。)
もちろん、この場合の<CODE>table2.id</CODE>は、<CODE>NOT NULL</CODE>と定義されているもの
と仮定します。
 「<A HREF="manual.ja_MySQL_Optimisation.html#LEFT_JOIN_optimisation">5.2.6  MySQL はどのように <CODE>LEFT JOIN</CODE> と <CODE>RIGHT JOIN</CODE> を最適化するか？</A>」節参照.

<LI>

<CODE>USING</CODE> <CODE>(column_list)</CODE>節のフィールド名リストは、両方のテーブルに
存在しなければなりません。<CODE>USING</CODE>節が次のように:


<PRE>
A LEFT JOIN B USING (C1,C2,C3,...)
</PRE>

定義されることは、<CODE>ON</CODE>式がこのように定義されるのと同義です:


<PRE>
A.C1=B.C1 AND A.C2=B.C2 AND A.C3=B.C3,...
</PRE>

<LI>

同じフィールド名を持つ2つのテーブルの <CODE>NATURAL [LEFT] JOIN</CODE> は、
<CODE>USING</CODE> 節を伴った <CODE>INNER JOIN</CODE> や <CODE>LEFT JOIN</CODE> と
同じとして定義されます。

<LI>

<A NAME="IDX1415"></A>
<CODE>INNER JOIN</CODE> and <CODE>,</CODE> (comma) are semantically equivalent.
Both do a full join between the tables used. Normally, you specify
how the tables should be linked in the WHERE condition.

<LI>

<CODE>RIGHT JOIN</CODE> works analogously as <CODE>LEFT JOIN</CODE>.  To keep code
portable across databases, it's recommended to use <CODE>LEFT JOIN</CODE>
instead of <CODE>RIGHT JOIN</CODE>.

<LI>

<A NAME="IDX1416"></A>
<CODE>STRAIGHT_JOIN</CODE>は、右側のテーブルの前に、常に左側のテーブルを読むことを
除けば、<CODE>JOIN</CODE>と全く同じことです。これは、結合オプティマイザが、不当な
順序でテーブルを出力するようなまれな事態に使用できます。

<LI>

<A NAME="IDX1417"></A>
<A NAME="IDX1418"></A>
<A NAME="IDX1419"></A>
MySQL バージョン 3.23.12 から、テーブルから情報を取り出す時に、
MySQL がどのインデックスを使用すべきかというヒントを与えることが
できるようになりました。これは、MySQL が間違ったインデックスを使
用していることを <CODE>EXPLAIN</CODE> が示す場合に有用です。<CODE>USE INDEX
(key_list)</CODE> を指定することによって、テーブルからレコードを見つけるために、
指定されたインデックスの一つだけを使用するように MySQL に伝えるこ
とができます。別の構文 <CODE>IGNORE INDEX (key_list)</CODE> は、MySQL 
に特定のインデックスを使用しないように伝えるために使用できます。

<A NAME="IDX1420"></A>
In MySQL 4.0.9 you can also use <CODE>FORCE INDEX</CODE>. This acts likes
<CODE>USE INDEX (key_list)</CODE> but with the addition that a table scan
is assumed to be VERY expensive.  In other words a table scan will
only be used if there is no way to use one of the given index to
find rows in the table.

<A NAME="IDX1421"></A>
<A NAME="IDX1422"></A>
<CODE>USE/IGNORE KEY</CODE> are synonyms for <CODE>USE/IGNORE INDEX</CODE>.
</UL>

<P>
例:

</P>

<PRE>
mysql&#62; SELECT * FROM table1,table2 WHERE table1.id=table2.id;
mysql&#62; SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id;
mysql&#62; SELECT * FROM table1 LEFT JOIN table2 USING (id);
mysql&#62; SELECT * FROM table1 LEFT JOIN table2 ON table1.id=table2.id
    -&#62;          LEFT JOIN table3 ON table2.id=table3.id;
mysql&#62; SELECT * FROM table1 USE INDEX (key1,key2)
    -&#62;          WHERE key1=1 AND key2=2 AND key3=3;
mysql&#62; SELECT * FROM table1 IGNORE INDEX (key3)
    -&#62;          WHERE key1=1 AND key2=2 AND key3=3;
</PRE>

<P>
 「<A HREF="manual.ja_MySQL_Optimisation.html#LEFT_JOIN_optimisation">5.2.6  MySQL はどのように <CODE>LEFT JOIN</CODE> と <CODE>RIGHT JOIN</CODE> を最適化するか？</A>」節参照.

</P>



<H4><A NAME="UNION" HREF="manual.ja_toc.html#UNION">6.4.1.2  <CODE>UNION</CODE> Syntax</A></H4>

<P>
<A NAME="IDX1423"></A>

</P>

<PRE>
SELECT ...
UNION [ALL]
SELECT ...
  [UNION
   SELECT ...]
</PRE>

<P>
<CODE>UNION</CODE> is implemented in MySQL 4.0.0.

</P>
<P>
<CODE>UNION</CODE> is used to combine the result from many <CODE>SELECT</CODE>
statements into one result set.

</P>
<P>
The columns listed in the select_expression portion of the <CODE>SELECT</CODE>
should have the same type. The column names used in the first
<CODE>SELECT</CODE> query will be used as the column names for the results
returned.

</P>
<P>
The <CODE>SELECT</CODE> commands are normal select commands, but with the following
restrictions:

</P>

<UL>
<LI>

Only the last <CODE>SELECT</CODE> command can have <CODE>INTO OUTFILE</CODE>.
</UL>

<P>
If you don't use the keyword <CODE>ALL</CODE> for the <CODE>UNION</CODE>, all
returned rows will be unique, as if you had done a <CODE>DISTINCT</CODE> for
the total result set.  If you specify <CODE>ALL</CODE>, then you will get all
matching rows from all the used <CODE>SELECT</CODE> statements.

</P>
<P>
If you want to use an <CODE>ORDER BY</CODE> for the total <CODE>UNION</CODE> result,
you should use parentheses:

</P>

<PRE>
(SELECT a FROM table_name WHERE a=10 AND B=1 ORDER BY a LIMIT 10)
UNION
(SELECT a FROM table_name WHERE a=11 AND B=2 ORDER BY a LIMIT 10)
ORDER BY a;
</PRE>

<P>
<A NAME="IDX1424"></A>


<H3><A NAME="HANDLER" HREF="manual.ja_toc.html#HANDLER">6.4.2  <CODE>HANDLER</CODE> Syntax</A></H3>


<PRE>
HANDLER tbl_name OPEN [ AS alias ]
HANDLER tbl_name READ index_name { = | &#62;= | &#60;= | &#60; } (value1,value2,...)
    [ WHERE ... ] [LIMIT ... ]
HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }
    [ WHERE ... ] [LIMIT ... ]
HANDLER tbl_name READ { FIRST | NEXT }
    [ WHERE ... ] [LIMIT ... ]
HANDLER tbl_name CLOSE
</PRE>

<P>
The <CODE>HANDLER</CODE> statement provides direct access to the <CODE>MyISAM</CODE> table
storage engine interface.

</P>
<P>
The first form of <CODE>HANDLER</CODE> statement opens a table, making
it accessible via subsequent <CODE>HANDLER ... READ</CODE> statements.
This table object is not shared by other threads and will not be closed
until the thread calls <CODE>HANDLER tbl_name CLOSE</CODE> or the thread dies.

</P>

<P>
The second form fetches one row (or more, specified by <CODE>LIMIT</CODE> clause)
where the index specified complies to the condition and <CODE>WHERE</CODE>
condition is met. If the index consists of several parts (spans over
several columns) the values are specified in comma-separated list,
providing values only for few first columns is possible.

</P>
<P>
The third form fetches one row (or more, specified by <CODE>LIMIT</CODE> clause)
from the table in index order, matching <CODE>WHERE</CODE> condition.

</P>
<P>
The fourth form (without index specification) fetches one row (or more, specified
by <CODE>LIMIT</CODE> clause) from the table in natural row order (as stored
in datafile) matching <CODE>WHERE</CODE> condition. It is faster than
<CODE>HANDLER tbl_name READ index_name</CODE> when a full table scan is desired.

</P>
<P>
<CODE>HANDLER ... CLOSE</CODE> closes a table that was opened with
<CODE>HANDLER ... OPEN</CODE>.

</P>
<P>
<CODE>HANDLER</CODE> is a somewhat low-level statement.  For example, it does
not provide consistency.  That is, <CODE>HANDLER ... OPEN</CODE> does <STRONG>NOT</STRONG>
take a snapshot of the table, and does <STRONG>NOT</STRONG> lock the table. This
means that after a <CODE>HANDLER ... OPEN</CODE> is issued, table data can be
modified (by this or any other thread) and these modifications may appear
only partially in <CODE>HANDLER ... NEXT</CODE> or <CODE>HANDLER ... PREV</CODE> scans.

</P>
<P>
The reasons to use this interface instead of normal SQL are:

</P>

<UL>
<LI>

It's faster than <CODE>SELECT</CODE> because:

<UL>
<LI>

A designated storage engine is allocated for the thread in <CODE>HANDLER OPEN</CODE>.
<LI>

There is less parsing involved.
<LI>

No optimiser and no query checking overhead.
<LI>

The used table doesn't have to be locked between two handler requests.
<LI>

The handler interface doesn't have to provide a consistent look of the
data (for example, dirty-reads are allowed), so the storage engine can
do optimisations that SQL doesn't normally allow.
</UL>

<LI>

It makes it much easier to port applications that uses an ISAM like
interface to MySQL.
<LI>

It allows one to traverse a database in a manner that is not easy
(in some case impossible) to do with SQL. The handler interface is
more natural way to look at data when working with applications that
provide an interactive user interfaces to the database.
</UL>



<H3><A NAME="INSERT" HREF="manual.ja_toc.html#INSERT">6.4.3  <CODE>INSERT</CODE> 構文</A></H3>

<P>
<A NAME="IDX1425"></A>

</P>

<PRE>
    INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        VALUES ((expression | DEFAULT),...),(...),...
        [ ON DUPLICATE KEY UPDATE col_name=expression, ... ]
or  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
or  INSERT [LOW_PRIORITY | DELAYED] [IGNORE]
        [INTO] tbl_name
        SET col_name=(expression | DEFAULT), ...
        [ ON DUPLICATE KEY UPDATE col_name=expression, ... ]

</PRE>

<P>
<CODE>INSERT</CODE>は、既存のテーブルに新しいレコードを挿入します。
<CODE>INSERT ... VALUES</CODE>書式は、値の明示指定を基本としてレコードを挿入します。
<CODE>INSERT ... SELECT</CODE>書式は、他の表(複数可)から抽出したレコードを挿入します。
複数の値リストを用いる<CODE>INSERT ... VALUES</CODE>書式は、
MySQL バージョン 3.22.5以降でサポートされています。
<CODE>col_name=expression</CODE>構文は、
MySQL バージョン 3.22.10以降でサポートされています。

</P>
<P>
<CODE>tbl_name</CODE>は、レコードを挿入するテーブルです。フィールド名リストは、
後続の値定義ステートメントのフィールドを指し示します:

</P>

<UL>
<LI>

もしいかなるフィールドも <CODE>INSERT ... VALUES</CODE> や <CODE>INSERT ... SELECT</CODE>
などで明示しなければ、全てのフィールドの値が <CODE>VALUES()</CODE> の中に与えられ
なくてはなりません。テーブル内のフィールド順が不明な場合、
これを調べるために<CODE>DESCRIBE tbl_name</CODE>を使用して下さい。

<LI>

テーブル内の一部のフィールドしか指定しない場合、指定されなかったフィールドには、
それぞれの初期値が指定されます。初期値の割当ては、
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節. で述べられています。

You can also use the keyword <CODE>DEFAULT</CODE> to set a column to its
default value. (New in MySQL 4.0.3.)  This makes it easier to write
<CODE>INSERT</CODE> statements that assign values to all but a few columns,
because it allows you to avoid writing an incomplete <CODE>VALUES()</CODE> list
(a list that does not include a value for each column in the table).
Otherwise, you would have to write out the list of column names
corresponding to each value in the <CODE>VALUES()</CODE> list.

MySQL always has a default value for all fields. This is something
that is imposed on MySQL to be able to work with both transactional
and not transactional tables.

Our view is that checking of fields content should be done in the
application and not in the database server.

<LI>

<CODE>expression</CODE>は、値リスト内で先頭に近い方のフィールドを参照しなければなりません。
例えば、次のように記述できます:


<PRE>
mysql&#62; INSERT INTO tbl_name (col1,col2) VALUES(15,col1*2);
</PRE>

しかし、次のようには記述できません:


<PRE>
mysql&#62; INSERT INTO tbl_name (col1,col2) VALUES(col2*2,15);
</PRE>

<LI>

キーワード<CODE>LOW_PRIORITY</CODE>を指定した場合、<CODE>INSERT</CODE>の実行はそのテー
ブルから値を読み込むクライアントがいなくなるまで遅らされます。この場合、ク
ライアントは insert 文が完了するまで待たされます。テーブルが頻繁に使用され
る場合、長い時間かかります。これはクライアントを一度に継続させる 
<CODE>INSERT DELAYED</CODE> と対称的です。
 「<A HREF="manual.ja_Reference.html#INSERT_DELAYED">6.4.4  <CODE>INSERT DELAYED</CODE> 構文</A>」節参照.  Note that <CODE>LOW_PRIORITY</CODE>
should normally not be used with <CODE>MyISAM</CODE> tables as this disables
concurrent inserts.  「<A HREF="manual.ja_Table_types.html#MyISAM">7.1  <CODE>MyISAM</CODE> テーブル (3.23.0以上)</A>」節参照.

<LI>

もし <CODE>IGNORE</CODE> キーワードを <CODE>INSERT</CODE> に 値とともに 与えるなら、
テーブル内の <CODE>PRIMARY</CODE> や <CODE>UNIQUE</CODE> キーにすでに存在する重複した
ものは無視され、挿入されません。
多重行の値を含むレコードの <CODE>INSERT</CODE> にキーワード <CODE>IGNORE</CODE> を
指定しない場合、テーブルの <CODE>PRIMARY</CODE> キーや <CODE>UNIQUE</CODE> キーに
重複が起こる際に、挿入処理が異常終了します。
<CODE>IGNORE</CODE> を指定した場合、重複するキー値を持つレコードは挿入されません。
C API 関数 <CODE>mysql_info()</CODE> により、テーブルにいくつのレコードが挿入
されたかチェックすることができます。

<LI>

If you specify <CODE>ON DUPLICATE KEY UPDATE</CODE> clause (new in MySQL 4.1.0), and
a row is inserted that would cause a duplicate value in <CODE>PRIMARY</CODE> or
<CODE>UNIQUE</CODE> key, an <CODE>UPDATE</CODE> of the old row is performed. For
example, the command:


<PRE>
mysql&#62; INSERT INTO table (a,b,c) VALUES (1,2,3)
   --&#62; ON DUPLICATE KEY UPDATE c=c+1;
</PRE>

in case of column <CODE>a</CODE> is declared as <CODE>UNIQUE</CODE> and already
holds <CODE>1</CODE> once, would be identical to the


<PRE>
mysql&#62; UPDATE table SET c=c+1 WHERE a=1;
</PRE>

<STRONG>Note:</STRONG> that if column <CODE>b</CODE> is unique too, the
<CODE>UPDATE</CODE> command would be written as


<PRE>
mysql&#62; UPDATE table SET c=c+1 WHERE a=1 OR b=2 LIMIT 1;
</PRE>

and if <CODE>a=1 OR b=2</CODE> matches several rows, only <STRONG>one</STRONG> row
will be updated! In general, one should try to avoid using
<CODE>ON DUPLICATE KEY</CODE> clause on tables with multiple <CODE>UNIQUE</CODE> keys.

When one uses <CODE>ON DUPLICATE KEY UPDATE</CODE>,
the <CODE>DELAYED</CODE> option is ignored.

<LI>

MySQLが、<CODE>DONT_USE_DEFAULT_FIELDS</CODE>オプションにより制限されていた
場合、<CODE>NULL</CODE>値を許さない全てのフィールドに明示的に値をしないと
<CODE>INSERT</CODE>ステートメントは、エラーを生成します。
 「<A HREF="manual.ja_Installing.html#configure_options">2.3.3  典型的な <CODE>configure</CODE> オプション</A>」節参照.

<LI>

<CODE>mysql_insert_id</CODE> 関数で <CODE>AUTO_INCREMENT</CODE> フィールドに使用された
値を見つけることができます。
 「<A HREF="manual.ja_Clients.html#mysql_insert_id">8.4.3.130  <CODE>mysql_insert_id()</CODE></A>」節参照.
</UL>

<P>
<A NAME="IDX1426"></A>
多重の値リストを持つ <CODE>INSERT ... SELECT ...</CODE> 又は <CODE>INSERT ... VALUES()</CODE>
ステートメントを使用する場合、クエリーに関する情報を得るために
C API関数 <CODE>mysql_info()</CODE> を使用することができます。
その情報の書式は以下に示す文字列のようになります:

</P>

<PRE>
Records: 100 Duplicates: 0 Warnings: 0
</PRE>

<P>
<CODE>Duplicates</CODE>は、既に存在するユニークインデックスの値と重複することにより、
挿入できなかったレコード数を表します。
<CODE>Warnings</CODE>は、挿入されたフィールドが何らかの疑わしい値であったという
数を表します。警告は、次のような条件の下で発生します:

</P>

<UL>
<LI>

<CODE>NOT NULL</CODE>定義されたフィールドへの<CODE>NULL</CODE>の挿入。フィールドには
初期値が設定されます。

<LI>

数値フィールドの範囲を超える値のセット。値は範囲内の限界値に補正されます。

<LI>

数値フィールドへの <CODE>`10.34 a'</CODE> のような値のセット。引きずっている
ゴミは取り除かれ、残りの数値部分が挿入されます。
値が数値として判断できなかった場合、フィールドには <CODE>0</CODE> がセットされます。

<LI>

<CODE>CHAR</CODE>、<CODE>VARCHAR</CODE>、<CODE>VARCHAR</CODE>、<CODE>TEXT</CODE>又は<CODE>BLOB</CODE>
フィールドへの最大長を超える文字列の挿入。値はフィールドの最大長に切り捨てられます。

<LI>

日付又は時刻フィールドへのフィールド属性に反した挿入。その属性に適した
``ゼロ''値がセットされます。
</UL>

<P>
<A NAME="IDX1427"></A>
<A NAME="IDX1428"></A>

</P>



<H4><A NAME="INSERT_SELECT" HREF="manual.ja_toc.html#INSERT_SELECT">6.4.3.1  <CODE>INSERT ... SELECT</CODE> 構文</A></H4>


<PRE>
INSERT [LOW_PRIORITY] [IGNORE] [INTO] tbl_name [(column list)] SELECT ...
</PRE>

<P>
With <CODE>INSERT ... SELECT</CODE> statement you can quickly insert many rows
into a table from one or many tables.

</P>

<PRE>
INSERT INTO tblTemp2 (fldID) SELECT tblTemp1.fldOrder_ID FROM tblTemp1 WHERE
tblTemp1.fldOrder_ID &#62; 100;
</PRE>

<P>
The following conditions hold for an <CODE>INSERT ... SELECT</CODE> statement:

</P>

<UL>
<LI>

The target table of the <CODE>INSERT</CODE> statement cannot appear in the
<CODE>FROM</CODE> clause of the <CODE>SELECT</CODE> part of the query because it's
forbidden in ANSI SQL to <CODE>SELECT</CODE> from the same table into which you are
inserting.  (The problem is that the <CODE>SELECT</CODE> possibly would
find records that were inserted earlier during the same run.  When using
subquery clauses, the situation could easily be very confusing!)

<LI>

<CODE>AUTO_INCREMENT</CODE> columns work as usual.

<LI>

You can use the C API function <CODE>mysql_info()</CODE> to get information about
the query.  「<A HREF="manual.ja_Reference.html#INSERT">6.4.3  <CODE>INSERT</CODE> 構文</A>」節参照.

<LI>

To ensure that the update log/binary log can be used to re-create the
original tables, MySQL will not allow concurrent inserts during
<CODE>INSERT ... SELECT</CODE>.
</UL>

<P>
You can of course also use <CODE>REPLACE</CODE> instead of <CODE>INSERT</CODE> to
overwrite old rows.

</P>



<H3><A NAME="INSERT_DELAYED" HREF="manual.ja_toc.html#INSERT_DELAYED">6.4.4  <CODE>INSERT DELAYED</CODE> 構文</A></H3>

<P>
<A NAME="IDX1429"></A>
<A NAME="IDX1430"></A>

</P>
<P>
<A NAME="IDX1431"></A>

</P>

<PRE>
INSERT DELAYED ...
</PRE>

<P>
<CODE>INSERT</CODE> 構文の <CODE>DELAYED</CODE> オプションは MySQL 独自の
オプションで、これは <CODE>INSERT</CODE> が完全に終了することを待てない
クライアントを持つ場合に、とても役立ちます。
これは、ロギングのために MySQL を使用する時の一般的な問題で、完了
に長い時間がかかる <CODE>SELECT</CODE> ステートメントも定期的に実行できます。
<CODE>DELAYED</CODE> は MySQL 3.22.15 で導入されました。  これは
 ANSI SQL92 に対する MySQL 拡張です。

</P>
<P>
<CODE>INSERT DELAYED</CODE> only works with <CODE>ISAM</CODE> and <CODE>MyISAM</CODE>
tables.  Note that as <CODE>MyISAM</CODE> tables supports concurrent
<CODE>SELECT</CODE> and <CODE>INSERT</CODE>, if there is no free blocks in the
middle of the datafile, you very seldom need to use <CODE>INSERT
DELAYED</CODE> with <CODE>MyISAM</CODE>.  「<A HREF="manual.ja_Table_types.html#MyISAM">7.1  <CODE>MyISAM</CODE> テーブル (3.23.0以上)</A>」節参照.

</P>
<P>
<CODE>INSERT DELAYED</CODE> を使用する時、クライアントは一度 ok となり、テーブル
が他のスレッドで使用中でない時にレコードが挿入されます。

</P>
<P>
<CODE>INSERT DELAYED</CODE> を使用して得られるほかの利益は、
多くのクライアントからの insert が同時に束ねられ、一つのブロックで
書かれることです。 これは多くの別々の insert を実行するより
とても速くなります。

</P>
<P>
現在、キューイングされたレコードは、それらがテーブルに代入されるまで
メモリーに保持されているだけです。 これは、もし <CODE>mysqld</CODE> を
強引な方法 (<CODE>kill -9</CODE>) でキルしたり、 <CODE>mysqld</CODE> が予期せず
死んだ場合、キューイングされているレコードはディスクに書かれず失われます！

</P>
<P>
<CODE>DELAYED</CODE> オプションを <CODE>INSERT</CODE> や <CODE>REPLACE</CODE> で使用する場合、
以下のことがおきます。
ここで ``スレッド'' とは <CODE>INSERT DELAYED</CODE> コマンドを受けたスレッドをさし、
``ハンドラー'' とは特定のテーブルのための全ての
<CODE>INSERT DELAYED</CODE> 構文を操作するスレッドを指します。

</P>

<UL>
<LI>

スレッドがあるテーブルに対し <CODE>DELAYED</CODE> 構文を実行するとき、
そのテーブルに対する全ての <CODE>DELAYED</CODE> 構文
を処理するためにハンドラースレッドが作成されます。
もしそのようなハンドラーが存在していない場合には。

<LI>

そのスレッドは、そのハンドラーが <CODE>DELAYED</CODE> ロックを既に持っているか
どうかをチェックします； もし持っていないなら、そうするように
ハンドラーに告げます。 
たとえ他のスレッドが <CODE>READ</CODE> か <CODE>WRITE</CODE> ロックをそのテーブルに
持っていたとしても、 <CODE>DELAYED</CODE> ロックを得ることができます。
しかし、そのハンドラーは全ての <CODE>ALTER TABLE</CODE> ロックか
 <CODE>FLUSH TABLES</CODE> を待ちます。 そのテーブル構造が最新であるのを
確実にするために。

<LI>

スレッドは <CODE>INSERT</CODE> ステートメントを実行しますが、レコードをテーブル
に書く代わりに、ハンドラスレッドによって管理されるキューに最後のレコードの
コピーを置きます。文法エラーはスレッドによって通知され、クライアントプログ
ラムに報告されます。

<LI>

クライアントは結果行の重複数や <CODE>AUTO_INCREMENT</CODE> の値を
報告できません； それはサーバーから得ることができません。 なぜなら、
 <CODE>INSERT</CODE> はインサートオペレーションが完全に終了する前に
返るからです。 もし C API を使用しているなら、 <CODE>mysql_info()</CODE> 関数は
同様の理由によりなにも返しません。

<LI>

更新ログは、レコードがそのテーブルに insert されたとき、そのハンドラースレッド
によって更新されます。 複数レコードの挿入の場合、 更新ログは最初の行が
挿入されたときに更新されます。

<LI>

それぞれの <CODE>delayed_insert_limit</CODE> レコードが書かれた後、そのハンドラーは
いかなる <CODE>SELECT</CODE> 文もまだ延期されていないかを確認します。
もしそうなら、続ける前にこれらに対して実行を可能にします。

<LI>

ハンドラーのキュー内にレコードがなくなったとき、テーブルはアンロックされます。
もし新しい <CODE>INSERT DELAYED</CODE> コマンドが <CODE>delayed_insert_timeout</CODE> 秒以内に
受け付けられなければ、ハンドラーは終了します。

<LI>

もし、特定のハンドラーのキュー内に <CODE>delayed_queue_size</CODE> 以上のレコードが
既に延期されているならば、そのスレッドは、キューに余裕がある間待ちます。
これは <CODE>mysqld</CODE> サーバーが delayed されたキューに全ての
メモリーを確実に使用しないようにするのに役立ちます。

<LI>

そのハンドラースレッドは  MySQL プロセスリストの <CODE>Command</CODE> 項
内に、 <CODE>delayed_insert</CODE> と共に表示されます。
これは <CODE>FLUSH TABLES</CODE> コマンドか <CODE>KILL thread_id</CODE> を実行することで、
kill できるでしょう。
しかし、これらは、終了する前に、キュー内の全てのレコードをテーブルに
保存しようとします。
この間、このスレッドは、他のスレッドから来たいかなる
新しい <CODE>INSERT</CODE> コマンドも受け付けません。
もし、この後に <CODE>INSERT DELAYED</CODE> コマンドを実行するなら、
新しいハンドラースレッドが作成されます。

上記のことは、もし <CODE>INSERT DELAYED</CODE> コマンドが既に走っているなら、
 <CODE>INSERT DELAYED</CODE> コマンドは、普通の <CODE>INSERT</CODE> コマンドよりも高い
優先度を持つということです！
他の update コマンドは <CODE>INSERT DELAY</CODE> キューが空になるまで、
あるいは誰かが <CODE>KILL thread_id</CODE> や <CODE>FLUSH TABLES</CODE> を実行して
ハンドラーをキルするまで、
待たされます。

<LI>

以下のステータス変数は <CODE>INSERT DELAYED</CODE> コマンドについての情報を
与えます：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Variable</STRONG> </TD><TD> <STRONG>Meaning</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Delayed_insert_threads</CODE> </TD><TD> ハンドラースレッドの数
</TR NOSAVE>
<TR><TD><CODE>Delayed_writes</CODE> </TD><TD> <CODE>INSERT DELAYED</CODE> で書かれるレコード数
</TR NOSAVE>
<TR><TD><CODE>Not_flushed_delayed_rows</CODE> </TD><TD> 書き込みを待つレコード数
</TR>
</TABLE>

これらの変数は <CODE>SHOW STATUS</CODE> 構文を発行したり
 <CODE>mysqladmin extended-status</CODE> コマンドを実行することで見れます.
</UL>

<P>
注意: <CODE>INSERT DELAYED</CODE> は、テーブルが使用中でない場合、通常の 
INSERT よりも遅くなります。<CODE>INSERT DELAYED</CODE> を使用する各テーブルにつ
いて別のスレッドを操作するサーバの、追加のオーバーヘッドもあります。これは、
確実にそれを必要とする時にだけ <CODE>INSERT DELAYED</CODE> を使用すべきことを意
味します！

</P>



<H3><A NAME="UPDATE" HREF="manual.ja_toc.html#UPDATE">6.4.5  <CODE>UPDATE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1432"></A>

</P>

<PRE>
UPDATE [LOW_PRIORITY] [IGNORE] tbl_name
    SET col_name1=expr1 [, col_name2=expr2 ...]
    [WHERE where_definition]
    [ORDER BY ...]
    [LIMIT rows]

or

UPDATE [LOW_PRIORITY] [IGNORE] tbl_name [, tbl_name ...]
    SET col_name1=expr1 [, col_name2=expr2 ...]
    [WHERE where_definition]
</PRE>

<P>
<CODE>UPDATE</CODE> はテーブルに存在するレコードのフィールドを、新しい値に更新します。
<CODE>SET</CODE> 節はどのフィールドをどういった値にすべきかを示します。
<CODE>WHERE</CODE> 節が与えられた場合、更新すべきレコードを特定することになります。
それ以外は、全てのレコードを更新します。
<CODE>ORDER BY</CODE> 節が指定された場合、レコードは指定された順に更新されます。

</P>
<P>
<CODE>LOW_PRIORITY</CODE> キーワードを指定した場合、<CODE>UPDATE</CODE> の実行は、
テーブルを読んでいるクライアントがなくなるまで、遅らされます。

</P>
<P>
<CODE>IGNORE</CODE> キーワードを指定した場合は、update 文は、
update 中に二重キーのエラーを得たとしても、異常終了しません。
衝突を引き起こすレコードは更新されません。

</P>
<P>
表記中の <CODE>tbl_name</CODE> からのフィールドをアクセスすると、<CODE>UPDATE</CODE> 
は現在のフィールド値を使用します。例えば、次のステートメントは 
<CODE>age</CODE> フィールドにその現在値より１大きい値を設定します:

</P>

<PRE>
mysql&#62; UPDATE persondata SET age=age+1;
</PRE>

<P>
<CODE>UPDATE</CODE> は左から右に評価されます。例えば、以下の文は <CODE>age</CODE> フィールド
を 2倍にし、そのあと1増やします：

</P>

<PRE>
mysql&#62; UPDATE persondata SET age=age*2, age=age+1;
</PRE>

<P>
もしフィールドに現在もっている値を指定した場合、MySQL はそれを通知し、
値は更新しません。

</P>
<P>
<A NAME="IDX1433"></A>
<CODE>UPDATE</CODE> は変更されたレコード数を返します。
MySQL バージョン 3.22 以上では、C API 関数 <CODE>mysql_info()</CODE> が
マッチし更新されたレコード数を返します。また <CODE>UPDATE</CODE> 中に起きた
ワーニングの数も返します。

</P>
<P>
MySQL バージョン 3.23 では、 <CODE>LIMIT #</CODE> で指定した数だけレコードを
変更できます。

</P>
<P>
Starting with MySQL Version 4.0.4, you can also perform <CODE>UPDATE</CODE>
operations that cover multiple tables:

</P>

<PRE>
UPDATE items,month SET items.price=month.price
WHERE items.id=month.id;
</PRE>

<P>
Note: you can not use <CODE>ORDER BY</CODE> or <CODE>LIMIT</CODE> with multi-table
<CODE>UPDATE</CODE>.

</P>



<H3><A NAME="DELETE" HREF="manual.ja_toc.html#DELETE">6.4.6  <CODE>DELETE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1434"></A>

</P>

<PRE>
DELETE [LOW_PRIORITY] [QUICK] FROM table_name
       [WHERE where_definition]
       [ORDER BY ...]
       [LIMIT rows]

or

DELETE [LOW_PRIORITY] [QUICK] table_name[.*] [, table_name[.*] ...]
       FROM table-references
       [WHERE where_definition]

or

DELETE [LOW_PRIORITY] [QUICK]
       FROM table_name[.*] [, table_name[.*] ...]
       USING table-references
       [WHERE where_definition]
</PRE>

<P>
<CODE>DELETE</CODE>は、<CODE>tbl_name</CODE>より、<CODE>where_definition</CODE>にて与えられた条件
を満たすレコードを削除し、削除されたレコード数を返します。

</P>
<P>
<CODE>WHERE</CODE>節を指定することなしに<CODE>DELETE</CODE>を発行した場合、全てのレコードが
削除されます。
もし <CODE>AUTOCOMMIT</CODE> モードでこの操作を実行するならば、これは
<CODE>TRUNCATE</CODE> と同様に動作します。 「<A HREF="manual.ja_Reference.html#TRUNCATE">6.4.7  <CODE>TRUNCATE</CODE> 構文</A>」節参照.
MySQL 3.23では、<CODE>DELETE</CODE> は削除したレコード数を 0 で返します。

</P>
<P>
もし全てのレコードを削除している時に、いくつのレコードが消され、いくつのレコード
が
スピードを犠牲にしているのか、本当に知りたいならば、
<CODE>DELETE</CODE> 構文を以下のように使用します：

</P>

<PRE>
mysql&#62; DELETE FROM tbl_name WHERE 1&#62;0;
</PRE>

<P>
これは <CODE>DELETE FROM tbl_name</CODE> を <CODE>WHERE</CODE> 節なしで行うよりも、
とても遅いです。なぜなら一度で消そうとするからです。

</P>
<P>
キーワード<CODE>LOW_PRIORITY</CODE>を指定した場合、そのテーブルを読んでいるクライアン
トがいなくなるまで<CODE>DELETE</CODE>の実行は遅らせられます。

</P>
<P>
削除されたレコードはリンクリストで維持され、次の<CODE>INSERT</CODE>操作は、古いレコー
ド位置を再利用します。
ファイルをより小さくしたい場合は、<CODE>OPTIMIZE TABLE</CODE>ステートメントかテーブル
の再編成のために<CODE>myisamchk</CODE>ユティリティを使用してください。
<CODE>OPTIMIZE TABLE</CODE>の方が簡単ですが、<CODE>myisamchk</CODE>の方が早く動作します。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#OPTIMIZE_TABLE">4.5.1  <CODE>OPTIMIZE TABLE</CODE> 構文</A>」節参照.

</P>
<P>
If you specify the word <CODE>QUICK</CODE> then the storage engine will not
merge index leaves during delete, which may speed up certain kind of
deletes.

</P>
<P>
The first multi-table delete format is supported starting from MySQL 4.0.0.
The second multi-table delete format is supported starting from MySQL 4.0.2.

</P>
<P>
The idea is that only matching rows from the tables listed
<STRONG>before</STRONG> the <CODE>FROM</CODE> or before the <CODE>USING</CODE> clause are
deleted. The effect is that you can delete rows from many tables at the
same time and also have additional tables that are used for searching.

</P>
<P>
The <CODE>.*</CODE> after the table names is there just to be compatible with
<CODE>Access</CODE>:

</P>

<PRE>
DELETE t1,t2 FROM t1,t2,t3 WHERE t1.id=t2.id AND t2.id=t3.id

or

DELETE FROM t1,t2 USING t1,t2,t3 WHERE t1.id=t2.id AND t2.id=t3.id
</PRE>

<P>
In the above case we delete matching rows just from tables <CODE>t1</CODE> and
<CODE>t2</CODE>.

</P>
<P>
If an <CODE>ORDER BY</CODE> clause is used (available from MySQL 4.0), the rows
will be deleted in that order. This is really only useful in conjunction
with <CODE>LIMIT</CODE>.  For example:

</P>

<PRE>
DELETE FROM somelog
WHERE user = 'jcole'
ORDER BY timestamp
LIMIT 1
</PRE>

<P>
This will delete the oldest entry (by <CODE>timestamp</CODE>) where the row matches
the <CODE>WHERE</CODE> clause.

</P>
<P>
MySQL-特化  <CODE>DELETE</CODE> の <CODE>LIMIT rows</CODE> オプションは
サーバーに消す最大のレコード数をつげます。これは <CODE>DELETE</CODE> コマンドが
あまりに多くの時間を取らないために使用されます。
<CODE>LIMIT</CODE> 値よりも affected row の数が少なくなるまで、
単純に <CODE>DELETE</CODE> コマンドを繰り返すだけです。

</P>
<P>
From MySQL 4.0, you can specify multiple tables in the <CODE>DELETE</CODE>
statement to delete rows from one table depending on a particular condition
in multiple tables. However, you can not use <CODE>ORDER BY</CODE> or <CODE>LIMIT</CODE>
in a multi-table <CODE>DELETE</CODE>.

</P>



<H3><A NAME="TRUNCATE" HREF="manual.ja_toc.html#TRUNCATE">6.4.7  <CODE>TRUNCATE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1435"></A>

</P>

<PRE>
TRUNCATE TABLE table_name
</PRE>

<P>
3.23 では、<CODE>COMMIT ; DELETE FROM table_name</CODE> と同じことです。  「<A HREF="manual.ja_Reference.html#DELETE">6.4.6  <CODE>DELETE</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>TRUNCATE TABLE</CODE> differs from <CODE>DELETE FROM ...</CODE>
in the following ways:

</P>

<UL>
<LI>

Truncate はテーブルを破棄して再生成するように実装されています。これは多くのレコードを
削除する時により速くなります。
<LI>

トランザクション安全ではありません; <CODE>COMMIT</CODE> が呼ばれたかのように 
<CODE>TRUNCATE TABLE</CODE> は自動的に現在のトランザクションを終了します。
<LI>

削除したレコード数を返しません。
<LI>

テーブル定義ファイル <TT>`table_name.frm'</TT> が正しい限り、たとえ、データや
インデックスファイルが汚れても、テーブルはこの方法で再生成できます。
</UL>

<P>
<CODE>TRUNCATE</CODE> は ORACLE SQL 拡張です。

</P>


<H3><A NAME="REPLACE" HREF="manual.ja_toc.html#REPLACE">6.4.8  <CODE>REPLACE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1436"></A>

</P>

<PRE>
    REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        VALUES (expression,...),(...),...
or  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name [(col_name,...)]
        SELECT ...
or  REPLACE [LOW_PRIORITY | DELAYED]
        [INTO] tbl_name
        SET col_name=expression, col_name=expression,...
</PRE>

<P>
<CODE>REPLACE</CODE>は、テーブル中にある古いレコードの
<CODE>UNIQUE</CODE> インデックスか <CODE>PRIMARY KEY</CODE> 上にある値が、新しいレコード
と同じ場合に、新しいレコードを挿入する前に
古いレコードを削除するということを除けば、<CODE>INSERT</CODE>と全く同じように
動作します。 
 「<A HREF="manual.ja_Reference.html#INSERT">6.4.3  <CODE>INSERT</CODE> 構文</A>」節参照.

</P>
<P>
In other words, you can't access the values of the old row from a
<CODE>REPLACE</CODE> statement.  In some old MySQL versions it appeared that
you could do this, but that was a bug that has been corrected.

</P>
<P>
To be able to use <CODE>REPLACE</CODE> you must have <CODE>INSERT</CODE> and
<CODE>DELETE</CODE> privileges for the table.

</P>
<P>
When you use a <CODE>REPLACE</CODE> command, <CODE>mysql_affected_rows()</CODE>
will return 2 if the new row replaced an old row.  This is because
one row was inserted after the duplicate was deleted.

</P>
<P>
This fact makes it easy to determine whether <CODE>REPLACE</CODE> added
or replaced a row: check whether the affected-rows value is 1 (added)
or 2 (replaced).

</P>
<P>
Note that unless you use a <CODE>UNIQUE</CODE> index or <CODE>PRIMARY KEY</CODE>,
using a <CODE>REPLACE</CODE> command makes no sense, since it would just do
an <CODE>INSERT</CODE>.

</P>



<H3><A NAME="LOAD_DATA" HREF="manual.ja_toc.html#LOAD_DATA">6.4.9  <CODE>LOAD DATA INFILE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1437"></A>

</P>

<PRE>
LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE 'file_name.txt'
    [REPLACE | IGNORE]
    INTO TABLE tbl_name
    [FIELDS
        [TERMINATED BY '\t']
        [[OPTIONALLY] ENCLOSED BY '']
        [ESCAPED BY '\\' ]
    ]
    [LINES TERMINATED BY '\n']
    [IGNORE number LINES]
    [(col_name,...)]
</PRE>

<P>
<CODE>LOAD DATA INFILE</CODE>ステートメントは、テキストファイルからテーブルへと、
レコードを高速に読み込みます。 <CODE>LOCAL</CODE> キーワードが指定されれば、ファイルは
クライアント・ホストから読み込まれます。
<CODE>LOCAL</CODE>が指定されなければ、ファイルはサーバに位置する必要があります
(<CODE>LOCAL</CODE>は、MySQL バージョン 3.22.6以降で利用できます)。

</P>
<P>
セキュリティ上の理由から、サーバからテキストファイルを読み出す時は、
ファイルがデータベースディレクトリに存在するか、
全てに読み込み権限がある必要があります。
また、サーバファイルで <CODE>LOAD DATA INFILE</CODE> を使用するには、
データベースの <CODE>FILE</CODE> 権限も持たなければなりません。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Privileges_provided">4.2.7  MySQL が提供する権限</A>」節参照.

</P>
<P>
In MySQL 3.23.49 and MySQL 4.0.2 <CODE>LOCAL</CODE> will only work if you have
not started <CODE>mysqld</CODE> with <CODE>--local-infile=0</CODE> or if you
have not enabled your client to support <CODE>LOCAL</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#LOAD_DATA_LOCAL">4.2.4  Security issues with LOAD DATA LOCAL</A>」節参照.

</P>
<P>
もし <CODE>LOW_PRIORITY</CODE> を指定した場合、<CODE>LOAD DATA</CODE> 構文は
そのテーブルから他のクライアントが読み込みを行っている間、
遅らされます。

</P>
<P>
If you specify the keyword <CODE>CONCURRENT</CODE> with a <CODE>MyISAM</CODE> table,
then other threads can retrieve data from the table while <CODE>LOAD
DATA</CODE> is executing. Using this option will of course affect the
performance of <CODE>LOAD DATA</CODE> a bit even if no other thread is using
the table at the same time.

</P>
<P>
<CODE>LOCAL</CODE> 使用をすると、クライアント・ホストからサーバ・ホストへ
ファイルの内容が転送される分、多少遅くなるでしょう。
いうならば、ローカルのファイルを読み込むのに、
<CODE>FILE</CODE> 権限は必要ないということです。

</P>
<P>
If you are using MySQL before Version 3.23.24 you can't read from a
FIFO with <CODE>LOAD DATA INFILE</CODE>.  If you need to read from a FIFO (for
example the output from gunzip), use <CODE>LOAD DATA LOCAL INFILE</CODE>
instead.

</P>
<P>
<A NAME="IDX1438"></A>
<CODE>mysqlimport</CODE>ユティリティは、データファイルの読み込みに使用することができま
す。; これは、サーバに<CODE>LOAD DATA INFILE</CODE>コマンドを送信することによって処理
を実現しています。
<CODE>--local</CODE>オプションは、<CODE>mysqlimport</CODE>に、クライアント・ホストからデータ
ファイルを読み込ませます。
クライアントとサーバが圧縮プロトコルをサポートしていれば、低速なネットワークでよ
り良いパフォーマンスを得るために、<CODE>--compress</CODE>オプションを指定することがで
きます。

</P>
<P>
サーバ・ホストにファイルを置く場合、サーバは、以下のルールを使用します:

</P>

<UL>
<LI>

完全なパスでファイル名が与えられた場合、サーバはパス名をそのまま使用します。

<A NAME="IDX1439"></A>
<A NAME="IDX1440"></A>
<LI>

１つ又は複数の構成要素から成る相対パスと共にファイル名が与えられた場合、サーバは
、サーバのデータディレクトリ以下からファイルを探します。

<LI>

ファイル名だけが単に与えられた場合、サーバは、
カレントのデータベースディレクトリを探します。
</UL>

<P>
これらのルールは、ファイルが <TT>`myfile.txt'</TT> のように与えられれば
データベースディレクトリからファイルが読み出され、
<TT>`./myfile.txt'</TT> のように与えられれば、現在選択しているデータベースのデータデ
ィレクトリから
ファイルが読み出されるという意味であることに注意して下さい。

</P>
<P>
例えば、以下の <CODE>LOAD DATA</CODE> 文は、<TT>`data.txt'</TT> ファイルを
<CODE>db1</CODE> データベースディレクトリから読みます。 なぜなら、<CODE>db1</CODE> は
現在選択されているデータベースだからです。 たとえ、<CODE>db2</CODE> データベース
のテーブルに、ファイルから読み込んだデータを挿入するとしても。：

</P>
<P>
以下に示すような構文では、ファイルは <CODE>db1</CODE> データベースディレクトリ
から読まれます。<CODE>db2</CODE> ではありません:

</P>

<PRE>
mysql&#62; USE db1;
mysql&#62; LOAD DATA INFILE "data.txt" INTO TABLE db2.my_table;
</PRE>

<P>
<CODE>REPLACE</CODE> と <CODE>IGNORE</CODE> キーワードは、すでに存在するユニークキーに
重複しているレコードの入力に対する制御です。
<CODE>REPLACE</CODE> 指定の場合、同じユニークキーを持つ既存のレコードは新しいレコード
で置き換えられます。
<CODE>IGNORE</CODE> 指定の場合、既存のレコードのユニークキーと重複するキーをもつ新しい
レコードは飛ばされます。 もし、どちらも指定しなかった場合、重複したキーが
見つかった場合エラーが発生し、テキストファイルは無視されます。

</P>
<P>
<CODE>LOCAL</CODE> キーワードを使用してデータをローカルからロードする場合、
サーバーは操作の途中で転送をとめる方法を知りません。
それでデフォルトの動作としては <CODE>IGNORE</CODE> が指定されたのと
同じになります。

</P>
<P>
If you use <CODE>LOAD DATA INFILE</CODE> on an empty <CODE>MyISAM</CODE> table,
all non-unique indexes are created in a separate batch (like in <CODE>REPAIR</CODE>).
This normally makes <CODE>LOAD DATA INFILE</CODE> much faster when you have many
indexes.

</P>
<P>
<CODE>LOAD DATA INFILE</CODE>は、<CODE>SELECT ... INTO OUTFILE</CODE>の逆です。
 「<A HREF="manual.ja_Reference.html#SELECT">6.4.1  <CODE>SELECT</CODE> 構文</A>」節参照.
データベースからファイルへデータを書き込むには、<CODE>SELECT ... INTO OUTFILE</CODE>を
使用します。
ファイルからデータベースに読み戻すには、<CODE>LOAD DATA INFILE</CODE>を使用します。
<CODE>FIELDS</CODE>と<CODE>LINES</CODE>節の構文は両方のコマンドとも同じです。
どちらの節もオプションですが、両方を指定する場合は、<CODE>FIELDS</CODE>は、<CODE>LINES</CODE>
より先に指定しなければなりません。

</P>
<P>
<CODE>FIELDS</CODE>節を指定した場合、その段落(<CODE>TERMINATED BY</CODE>、<CODE>[OPTIONALLY]
 ENCLOSED BY</CODE>及び<CODE>ESCAPED BY</CODE>)は、少なくとも１つを指定しなければならないこ
とを除いて、それらもまたオプションとなります。

</P>
<P>
<CODE>FIELDS</CODE>節を指定しなかった場合、初期値は以下のように記述したのと等価となり
ます:

</P>

<PRE>
FIELDS TERMINATED BY '\t' ENCLOSED BY '' ESCAPED BY '\\'
</PRE>

<P>
<CODE>LINES</CODE>節を指定しなかった場合、初期値は以下のように記述したのと等価となりま
す:

</P>

<PRE>
LINES TERMINATED BY '\n'
</PRE>

<P>
言い換えると、<CODE>LOAD DATA INFILE</CODE> の初期値は、出力へ書き込む際に以下のように
振舞います:

</P>

<UL>
<LI>

改行をレコードの境界とみなす

<LI>

タブ文字によってフィールドを区切る

<LI>

クォート文字でフィールドを囲んでいないものとする

<LI>

タブ文字や改行文字及び<SAMP>`\'</SAMP>の前に<SAMP>`\'</SAMP>があることにより、それらをフィールド
値の一部のリテラル文字であるとして処理する。
</UL>

<P>
逆に、<CODE>LOAD DATA INFILE</CODE>の初期値は、入力を読み込む際に以下のように振舞いま
す:

</P>

<UL>
<LI>

フィールド間にタブ文字を書く

<LI>

いずれのクォート文字でもフィールドを囲まない

<LI>

<SAMP>`\'</SAMP>の使用により、フィールド値の中で使用するタブ文字や改行文字、<SAMP>`\'</SAMP>をエ
スケープする

<LI>

レコードの終りに改行文字を書く
</UL>

<P>
 <CODE>FIELDS ESCAPED BY '\\'</CODE>と書いた場合、単一のバックスラッシュとして読み出さ
れる値とするために、２つのバックスラッシュを指定しなければならないことに注意して
下さい。

</P>
<P>
<CODE>IGNORE number LINES</CODE> オプションはファイルの先頭にあるレコードを無視するの
に使用されます：

</P>

<PRE>
mysql&#62; LOAD DATA INFILE "/tmp/file_name" INTO TABLE test IGNORE 1 LINES;
</PRE>

<P>
データベースからファイルへデータを書き、それから後でそのファイルからデータベース
へデータを読み戻すために、<CODE>SELECT ... INTO OUTFILE</CODE>と対に<CODE>LOAD DATA IN
FILE</CODE>を使う場合、双方のフィールドとレコードの取扱いに関するオプションは、一致し
なければなりません。さもなければ、<CODE>LOAD DATA INFILE</CODE>は適切にファイルを処理
しないでしょう。
 フィールドをコンマで区切ってファイルへ書き出すために、<CODE>SELECT ... INTO OUT
FILE</CODE>を使用するとすれば:

</P>

<PRE>
mysql&#62; SELECT * INTO OUTFILE 'data.txt'
    -&#62;          FIELDS TERMINATED BY ','
    -&#62;          FROM ...;
</PRE>

<P>
コンマ区切りファイルから読み戻すため、正しいステートメントはこうなるでしょう:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE table2
    -&#62;           FIELDS TERMINATED BY ',';
</PRE>

<P>
その代わりとして次に示すようなステートメントでファイルを読み込もうとしても、正し
く動作しないでしょう。なぜなら、これは、<CODE>LOAD DATA INFILE</CODE>に対してフィール
ドの間にタブを探すよう指示するからです:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE table2
    -&#62;           FIELDS TERMINATED BY '\t';
</PRE>

<P>
おそらく、それぞれの入力行は単一のフィールドとして処理されるでしょう。

</P>
<P>
<CODE>LOAD DATA INFILE</CODE>は外部ソースからもファイルを読み出すことができます。
例えば、dBASEフォーマットのファイルは、フィールドをコンマで区切られ、ダブルクォ
ーテーションで囲まれています。
レコードが改行文字で区切られているとしたら、次に示すフィールド及びレコードの取扱
オプションを指定したコマンドが、このようなファイルを読み込むのに使用できます。

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'data.txt' INTO TABLE tbl_name
    -&#62;           FIELDS TERMINATED BY ',' ENCLOSED BY '"'
    -&#62;           LINES TERMINATED BY '\n';
</PRE>

<P>
いくつかのフィールド及びレコードの取扱オプションに、空文字列(<CODE>''</CODE>)を
指定することがあります。空でないなら、
<CODE>FIELDS [OPTIONALLY] ENCLOSED BY</CODE>と<CODE>FIELDS ESCAPED BY</CODE>の値は
単一の文字でなければなりません。
<CODE>FIELDS TERMINATED BY</CODE>と<CODE>LINES TERMINATED BY</CODE>は２つ以上の文字となるで
しょう。

</P>
<P>
例えば、リターン文字と改行文字のペアで区切られたレコードを書き込んだり、
このようなレコードを含んだファイルを読み込んだりするには、
<CODE>LINES TERMINATED BY '\r\n'</CODE>節を指定します。

</P>

<PRE>
CREATE TABLE jokes (a int not null auto_increment primary key, joke text
not null);
LOAD DATA INFILE "/tmp/jokes.txt" INTO TABLE jokes FIELDS TERMINATED BY ""
LINES TERMINATED BY "\n%%\n" (joke);
</PRE>

<P>
<CODE>FIELDS [OPTIONALLY] ENCLOSED BY</CODE>は、フィールドの引用符を制御します。出力の
際(<CODE>SELECT ... INTO OUTFILE</CODE>)、<CODE>OPTIONALLY</CODE>語を省いたなら、全てのフィ
ールドは<CODE>ENCLOSED BY</CODE>文字で囲まれます。このような出力(フィールド区切りにコ
ンマを使用)の例を次に示します:

</P>

<PRE>
"1","a string","100.20"
"2","a string containing a , comma","102.20"
"3","a string containing a \" quote","102.20"
"4","a string containing a \", quote and comma","102.20"
</PRE>

<P>
<CODE>OPTIONALLY</CODE>を指定すれば、<CODE>ENCLOSED BY</CODE>文字は、 <CODE>CHAR</CODE>フィールド
と<CODE>VARCHAR</CODE>フィールドのみ囲むのに使用されます:

</P>

<PRE>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20
</PRE>

<P>
フィールド値の中における<CODE>ENCLOSED BY</CODE>文字の出現は、<CODE>ESCAPED BY</CODE>文字を
その前に置くことによりエスケープされることに注意して下さい。<CODE>ESCAPED BY</CODE>値
に空を指定すると、<CODE>LOAD DATA INFILE</CODE>により正しく読み込めない出力を生成する
でしょう。例えば、このようにエスケープ文字を空にした場合、以下に示すような出力と
なります。４行目の２つ目のフィールドに、(誤って)フィールドを区切るかのようなクォ
ートに続くコンマを含んでいることに注視して下さい:

</P>

<PRE>
1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a " quote",102.20
4,"a string containing a ", quote and comma",102.20
</PRE>

<P>
入力において、<CODE>ENCLOSED BY</CODE>文字が指定されており、それがフィールド値の両端に
現れた場合、その文字は取り去られます。(これは、<CODE>OPTIONALLY</CODE>が指定されたかど
うかに拘らず、当てはまります;<CODE>OPTIONALLY</CODE>は入力解析には効果がありません。)
 <CODE>ESCAPED BY</CODE>文字を前置きされた<CODE>ENCLOSED BY</CODE>文字の出現は、現在のフィー
ルド値の一部として処理されます。具体的には、あるフィールドがそれ自身、た<CODE>EN
CLOSED BY</CODE>文字で始まっている場合、フィールドらの内部で発生する２重の<CODE>ENCLOS
ED BY</CODE>文字は、単一の<CODE>ENCLOSED BY</CODE>文字として処理されます。
 例えば、<CODE>ENCLOSED BY '"'</CODE>が指定されると、引用符は以下のように操作されます:

</P>

<PRE>
"The ""BIG"" boss"  -&#62; The "BIG" boss
The "BIG" boss      -&#62; The "BIG" boss
The ""BIG"" boss    -&#62; The ""BIG"" boss
</PRE>

<P>
<CODE>FIELDS ESCAPED BY</CODE>は、特殊文字をどのように書き込んだり読み込んだりするかを
制御します。
 <CODE>FIELDS ESCAPED BY</CODE>文字が空でない場合、出力において次のような文字(文字列)
のプリフィックスに使用されます:

<UL>
<LI>

<CODE>FIELDS ESCAPED BY</CODE>文字
<LI>

<CODE>FIELDS [OPTIONALLY] ENCLOSED BY</CODE>文字
<LI>

<CODE>FIELDS TERMINATED BY</CODE>値と<CODE>LINES TERMINATED BY</CODE>値の最初の文字
<LI>

ASCII 0 (エスケープ文字の後に続いて実際に書かれる文字はASCII <CODE>'0'</CODE>で、'ゼロ
値'バイトではありません)
</UL>

<P>
<CODE>FIELDS ESCAPED BY</CODE>文字が空であれば、どの文字もエスケープされません。
特に、フィールド値が上に示した文字を含んでいるならば、エスケープ文字に空を指定す
るのはあまり良い考えとは言えないでしょう。

</P>
<P>
入力において、<CODE>FIELDS ESCAPED BY</CODE>文字が空でない場合、この文字の出現は取り去
られ、後続の文字はフィールド値の一部としてそのまま受け取られます。
例外は、エスケープされた<SAMP>`0'</SAMP>や<SAMP>`N'</SAMP>です
(例えば、エスケープ文字が<SAMP>`\'</SAMP>である時の<CODE>\0</CODE>や<CODE>\N</CODE>)。
これらのシーケンスは、ASCII 0('ゼロ値'バイト) 、<CODE>NULL</CODE>として処理されます。
code{NULL}操作の規則は下を参照して下さい。

</P>
<P>
<SAMP>`\'</SAMP>-escape syntaxに関するこれ以外の情報は、 「<A HREF="manual.ja_Reference.html#Literals">6.1.1  文字列と数値をどのように書くか？</A>」節参照。

</P>
<P>
フィールドとレコード操作オプションが確実に相互作用する事例:

</P>

<UL>
<LI>

<CODE>LINES TERMINATED BY</CODE>が空文字列で<CODE>FIELDS TERMINATED BY</CODE>が空でない場合
、各レコードもまた<CODE>FIELDS TERMINATED BY</CODE>で終らせられます。

<LI>

<CODE>FIELDS TERMINATED BY</CODE>と<CODE>FIELDS ENCLOSED BY</CODE>値が両方とも空(<CODE>''</CODE>)
の時、(区切られない)固定長行フォーマットが使用されます。
固定長行フォーマットでは、フィールド間に区切り文字列が使用されません。
その代わり、フィールド値は、フィールドの``表示''幅を使って書き込まれたり、読み込
まれます。
例えば、あるフィールドが<CODE>INT(7)</CODE>で定義されている場合、フィールドの値は7文字
の桁を使って書き込まれます。
入力においてフィールドは、７文字の読み込みにより得られます。
固定長行フォーマットはまた、<CODE>NULL</CODE>値の操作に好んで用いられます;下を参照のこ
と。
注意: マルチバイト文字セットを使用している場合は固定長フォーマットは働きま
せん。
</UL>

<P>
<CODE>FIELDS</CODE>と<CODE>LINES</CODE>オプションによる<CODE>NULL</CODE>値の多様な取扱い:

</P>

<UL>
<LI>

<CODE>FIELDS</CODE>と<CODE>LINES</CODE>の初期値のために、出力時に<CODE>NULL</CODE>は<CODE>\N</CODE>とし
て書き込まれ、入力時に<CODE>\N</CODE>は<CODE>NULL</CODE>として読み込まれます(当然のことなが
ら、<CODE>ESCAPED BY</CODE>文字は<SAMP>`\'</SAMP>とします)。

<LI>

<CODE>FIELDS ENCLOSED BY</CODE>が空で無い時、定数<CODE>NULL</CODE>のフィールド値は<CODE>NULL
</CODE>値として読み込まれます(これは、文字列<CODE>'NULL'</CODE>として読み込まれる<CODE>FIELD
S ENCLOSED BY</CODE>文字列で囲まれた<CODE>NULL</CODE>とは異なります)。

<LI>

<CODE>FIELDS ESCAPED BY</CODE>が空の時、<CODE>NULL</CODE>は<CODE>NULL</CODE>として書き込まれます。

<LI>

固定長行フォーマット(<CODE>FIELDS TERMINATED BY</CODE>と<CODE>FIELDS ENCLOSED BY</CODE>がい
ずれも空の場合に起こります)において、<CODE>NULL</CODE>は、空白文字列として書き込まれま
す。
これは、ファイル内では、<CODE>NULL</CODE>値と空白値の見分けがつかないということを示し
ていることに注意して下さい。ファイルからデータを読み戻す時に両者を区別しなければ
ならない場合、固定長行フォーマットは使用すべきではありません。
</UL>

<P>
<CODE>LOAD DATA INFILE</CODE>でサポートされないケース:

<UL>

<LI>

固定長行(<CODE>FIELDS TERMINATED BY</CODE>と<CODE>FIELDS ENCLOSED BY</CODE>の両方が空)と
<CODE>BLOB</CODE>フィールド。
<LI>

あるセパレータを他と同じかもしくは他のプリフィックスとした場合、<CODE>LOAD DATA 
INFILE</CODE>は、正しい入力処理ができないでしょう。
例えば、以下の<CODE>FIELDS</CODE>節は問題の原因となります:


<PRE>
FIELDS TERMINATED BY '"' ENCLOSED BY '"'
</PRE>

<LI>

<CODE>FIELDS ESCAPED BY</CODE>が空で、フィールド値に、<CODE>FIELDS ENCLOSED BY</CODE>値や
<CODE>LINES TERMINATED BY</CODE>値の後に<CODE>FIELDS TERMINATED BY</CODE>値がくるようなものを含
む場合、フィールドや行の読み込みが早めに打ち切られてしまいます。
これは、<CODE>LOAD DATA INFILE</CODE>が、フィールドやレコードの終了位置を正しく決めら
れないことにより発生します。
</UL>

<P>
次の例は、<CODE>persondata</CODE>テーブルの全てのフィールドを読み込みます:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'persondata.txt' INTO TABLE persondata;
</PRE>

<P>
フィールドリストが指定されていませんから、<CODE>LOAD DATA INFILE</CODE>は、入力レコー
ドがテーブルのそれぞれのフィールドを含むものと想定します。
<CODE>FIELDS</CODE>と<CODE>LINES</CODE>の初期値が使用されます。

</P>
<P>
テーブルの一部のフィールドのみ読み込みたい場合、フィールドリストを指定します:

</P>

<PRE>
mysql&#62; LOAD DATA INFILE 'persondata.txt'
    -&#62;           INTO TABLE persondata (col1,col2,...);
</PRE>

<P>
テーブル内のフィールド順と入力ファイルのフィールド順が異なる場合にも、<STRONG>My
SQL</STRONG>にテーブルのフィールドと入力フィールドの対応を教えるために、フィールドリスト
を指定しなければなりません。

</P>
<P>
入力レコードのフィールド数の方が少ない場合、入力フィールド値が与えられないフィー
ルドは、初期値が設定されます。
初期値の割当てについては、 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節.
で述べられています。

</P>
<P>
空のフィールド値は変換されます：

</P>

<UL>
<LI>

文字型の場合、 フィールドの値は空文字にセットされます。

<LI>

数値型の場合、フィールドの値は <CODE>0</CODE> にセットされます。

<LI>

日付と時刻の型の場合、 フィールドの値は ``zero'' の意味する値がセットされます。
 「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節参照.
</UL>

<P>
Note that these are the same values that result if you assign an empty
string explicitly to a string, numeric, or date or time type explicitly
in an <CODE>INSERT</CODE> or <CODE>UPDATE</CODE> statement.

</P>
<P>
<CODE>TIMESTAMP</CODE> フィールドは、フィールド値に <CODE>NULL</CODE> 値が指定されていた場合
もしくは、
フィールドリストが指定されている時に <CODE>TIMESTAMP</CODE> フィールドがそのリストから
除外されていた場合
(最初の<CODE>TIMESTAMP</CODE>フィールドのみ)、現在時刻が設定されるだけです。

</P>
<P>
入力レコードのフィールド数の方が多い場合、余分なフィールドは無視され、警告の数が
増やされます。

</P>
<P>
<CODE>LOAD DATA INFILE</CODE>は全ての入力を文字列と文字列とみなすことから、<CODE>INSER
T</CODE>ステートメントでできるような<CODE>ENUM</CODE>フィールドや<CODE>SET</CODE>フィールドへの数
値の指定はできません。全ての<CODE>ENUM</CODE>及び<CODE>SET</CODE>値は文字列として与えられな
ければいけません！

</P>
<P>
<A NAME="IDX1441"></A>
<CODE>LOAD DATA INFILE</CODE>クエリの終了時、クエリの情報を得るためにC API関数<CODE>my
sql_info()</CODE>を使用することができます。情報の書式は以下に示すようなものです:

</P>

<PRE>
Records: 1  Deleted: 0  Skipped: 0  Warnings: 0
</PRE>

<P>
<CODE>LOAD DATA INFILE</CODE> が、入力レコードのフィールド数の過不足があった時にも
警告を引き起こす事を除けば、<CODE>INSERT</CODE> ステートメント
( 「<A HREF="manual.ja_Reference.html#INSERT">6.4.3  <CODE>INSERT</CODE> 構文</A>」節参照. ) により値が挿入される時に
警告が発生するのと同じ状況下で、警告が発生します。
警告はどこにも保存されません； 警告の数は全てうまくいった場合にだけ
使用できます。 もし警告を知りたい、その警告の理由を知りたいのなら、
一つ方法があります。 <CODE>SELECT ... INTO OUTFILE</CODE> を使用して
他のファイルに落とし、オリジナルのファイルと比べます。

</P>
<P>
パイプからの読み込みで <CODE>LOAD DATA</CODE> の必要があれば、次のトリッ
クを使用できます:

</P>

<PRE>
mkfifo /mysql/db/x/x
chmod 666 /mysql/db/x/x
cat &#60; /dev/tcp/10.1.1.12/4711 &#62; /nt/mysql/db/x/x
mysql -e "LOAD DATA INFILE 'x' INTO TABLE x" x
</PRE>

<P>
If you are using a version of MySQL older than 3.23.25
you can only do the above with <CODE>LOAD DATA LOCAL INFILE</CODE>.

</P>
<P>
<CODE>INSERT</CODE>と比較した<CODE>LOAD DATA INFILE</CODE>の効率や<CODE>LOAD DATA INFILE</CODE>の
高速化についてのより詳しい情報は、 「<A HREF="manual.ja_MySQL_Optimisation.html#Insert_speed">5.2.9  <CODE>INSERT</CODE> クエリの速度</A>」節参照を参照のこと。

</P>



<H3><A NAME="DO" HREF="manual.ja_toc.html#DO">6.4.10  <CODE>DO</CODE> Syntax</A></H3>

<P>
<A NAME="IDX1442"></A>

</P>

<PRE>
DO expression, [expression, ...]
</PRE>

<P>
Execute the expression but don't return any results.  This is a
shorthand of <CODE>SELECT expression, expression</CODE>, but has the advantage
that it's slightly faster when you don't care about the result.

</P>
<P>
This is mainly useful with functions that has side effects, like
<CODE>RELEASE_LOCK</CODE>.

</P>



<H2><A NAME="Data_Definition" HREF="manual.ja_toc.html#Data_Definition">6.5  Data Definition: <CODE>CREATE</CODE>, <CODE>DROP</CODE>, <CODE>ALTER</CODE></A></H2>



<H3><A NAME="CREATE_DATABASE" HREF="manual.ja_toc.html#CREATE_DATABASE">6.5.1  <CODE>CREATE DATABASE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1443"></A>

</P>

<PRE>
CREATE DATABASE [IF NOT EXISTS] db_name
</PRE>

<P>
<CODE>CREATE DATABASE</CODE> は与えられた名前のデータベースを作ります。データベースの
名前として許される命名規則は、 「<A HREF="manual.ja_Reference.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A>」節に依ります。
もし、データベースがすでに存在しているにもかかわらず <CODE>IF NOT EXISTS</CODE> を
指定していなかったら、エラーが発生します。

</P>
<P>
MySQLにおけるデータベースは、データベース内のテーブルに相当するファイル
を含むディレクトリとして実装されます。初期作成後はデータベース内にテーブルは存在
せず、<CODE>CREATE DATABASE</CODE>ステートメントは、MySQLデータディレクトリ下
にディレクトリを作成するだけです。

</P>
<P>
<A NAME="IDX1444"></A>
<CODE>mysqladmin</CODE>でもデータベースを作成することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  MySQL Client-Side Scripts and Utilities</A>」節参照.

</P>



<H3><A NAME="DROP_DATABASE" HREF="manual.ja_toc.html#DROP_DATABASE">6.5.2  <CODE>DROP DATABASE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1445"></A>
<A NAME="IDX1446"></A>
<A NAME="IDX1447"></A>

</P>

<PRE>
DROP DATABASE [IF EXISTS] db_name
</PRE>

<P>
<CODE>DROP DATABASE</CODE>は、データベース内の全てのテーブルと共にデータベースを破棄し
ます。
シンボリックリンクされた <CODE>DROP DATABASE</CODE> を行なうと、リンクとオリジナ
ルデータベースの両方が削除されます。
<STRONG>このコマンドの使用には万全の注意を払って下さい！</STRONG> 

</P>
<P>
<CODE>DROP DATABASE</CODE>は、データベースディレクトリから削除されたファイルの数を返し
ます。それぞれのテーブルは<TT>`.MYD'</TT>ファイル／<TT>`.MYI'</TT>ファイル／<TT>`.frm'</TT>
ファイルに相当することから、通常この値はテーブルの３倍の数となります。

</P>
<P>
<CODE>DROP DATABASE</CODE> コマンドは与えられたデータベースディレクトリから、次
の拡張子のすべてのファイルを削除します:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Ext</STRONG> </TD><TD> <STRONG>Ext</STRONG> </TD><TD> <STRONG>Ext</STRONG> </TD><TD> <STRONG>Ext</STRONG>
</TR NOSAVE>
<TR><TD>.BAK </TD><TD> .DAT </TD><TD> .HSH </TD><TD> .ISD
</TR NOSAVE>
<TR><TD>.ISM </TD><TD> .ISM </TD><TD> .MRG </TD><TD> .MYD
</TR NOSAVE>
<TR><TD>.MYI </TD><TD> .db </TD><TD> .frm </TD><TD>
</TR>
</TABLE>

<P>
2桁の数値のすべてのサブディレクトリ(<CODE>RAID</CODE> ディレクトリ)も削除されま
す。

</P>
<P>
MySQL 3.22以降では、データベースが存在しないことに起因するエラーを防ぐ
ために、キーワード <CODE>IF EXISTS</CODE> を使用することができます。

</P>
<P>
<A NAME="IDX1448"></A>
<CODE>mysqladmin</CODE>でもデータベースを破棄することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#Client-Side_Scripts">4.8  MySQL Client-Side Scripts and Utilities</A>」節参照.

</P>


<H3><A NAME="CREATE_TABLE" HREF="manual.ja_toc.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1449"></A>

</P>


<PRE>
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)]
[table_options] [select_statement]

or

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name LIKE old_table_name;

create_definition:
  col_name type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT]
            [PRIMARY KEY] [reference_definition]
  or    PRIMARY KEY (index_col_name,...)
  or    KEY [index_name] (index_col_name,...)
  or    INDEX [index_name] (index_col_name,...)
  or    UNIQUE [INDEX] [index_name] (index_col_name,...)
  or    FULLTEXT [INDEX] [index_name] (index_col_name,...)
  or    [CONSTRAINT symbol] FOREIGN KEY [index_name] (index_col_name,...)
            [reference_definition]
  or    CHECK (expr)

type:
        TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  or    SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  or    MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  or    INT[(length)] [UNSIGNED] [ZEROFILL]
  or    INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  or    BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  or    REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DECIMAL(length,decimals) [UNSIGNED] [ZEROFILL]
  or    NUMERIC(length,decimals) [UNSIGNED] [ZEROFILL]
  or    CHAR(length) [BINARY]
  or    VARCHAR(length) [BINARY]
  or    DATE
  or    TIME
  or    TIMESTAMP
  or    DATETIME
  or    TINYBLOB
  or    BLOB
  or    MEDIUMBLOB
  or    LONGBLOB
  or    TINYTEXT
  or    TEXT
  or    MEDIUMTEXT
  or    LONGTEXT
  or    ENUM(value1,value2,value3,...)
  or    SET(value1,value2,value3,...)

index_col_name:
        col_name [(length)]

reference_definition:
        REFERENCES tbl_name [(index_col_name,...)]
                   [MATCH FULL | MATCH PARTIAL]
                   [ON DELETE reference_option]
                   [ON UPDATE reference_option]

reference_option:
        RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

table_options:
	TYPE = {BDB | HEAP | ISAM | InnoDB | MERGE | MRG_MYISAM | MYISAM }
or	AUTO_INCREMENT = #
or	AVG_ROW_LENGTH = #
or	CHECKSUM = {0 | 1}
or	COMMENT = "string"
or	MAX_ROWS = #
or	MIN_ROWS = #
or	PACK_KEYS = {0 | 1 | DEFAULT}
or	PASSWORD = "string"
or	DELAY_KEY_WRITE = {0 | 1}
or      ROW_FORMAT= { default | dynamic | fixed | compressed }
or	RAID_TYPE= {1 | STRIPED | RAID0 } RAID_CHUNKS=#  RAID_CHUNKSIZE=#
or	UNION = (table_name,[table_name...])
or	INSERT_METHOD= {NO | FIRST | LAST }
or      DATA DIRECTORY="absolute path to directory"
or      INDEX DIRECTORY="absolute path to directory"

select_statement:
	[IGNORE | REPLACE] SELECT ...  (Some legal select statement)
</PRE>

<P>
<CODE>CREATE TABLE</CODE>はカレントデータベースに、与えられた名前のテーブルを
作成します。テーブルの名前として許される命名規則は、 「<A HREF="manual.ja_Reference.html#Legal_names">6.1.2  データベース名、テーブル名、インデックス名、フィールド名、エイリアス名</A>」節参照に
依ります。
カレントデータベースが無い場合や、テーブルが既に存在している場合はエラーが
発生します。

</P>
<P>
MySQL バージョン 3.22 以降ではテーブル名は <CODE>db_name.tbl_name</CODE> とい
う形で与える事もできます。
これはカレントデータベースがあるかどうかにに関係なく動作します。

</P>
<P>
MySQL バージョン 3.23 からは、テーブル作成時に <CODE>TEMPORARY</CODE> キーワー
ドを使用することができます。 
一時テーブルの名前はそれぞれの接続内に制限されます。
一時テーブルは、もし、コネクションが落ちた場合、自動で消去されます。
これは、二つの違う接続で、同じ名前の一時テーブルを
衝突することなく、使用できるという事です。
さらには、既に存在するテーブルと同名であっても、一時テーブルは使用できます。
(一時テーブルが削除されるまで、実在するテーブルは隠されます)
From MySQL 4.0.2 one must
have the <CODE>CREATE TEMPORARY TABLES</CODE> privilege to be able to create
temporary tables.

</P>
<P>
MySQL バージョン 3.23 以降では、 <CODE>IF NOT EXISTS</CODE> キーワードを使用
できます。
これは、もしテーブルが既に存在していた場合、エラーを発生させません。
テーブルの構造が一意かどうかまでは検査しないことに注意。

</P>
<P>
In MySQL 4.1 you can use <CODE>LIKE</CODE> to create a table based on a table
definition in another table.  In MySQL 4.1 you can also specify the
type for a generated column:

</P>

<PRE>
CREATE TABLE foo (a tinyint not null) SELECT b+1 AS 'a' FROM bar;
</PRE>

<P>
それぞれのテーブルは、データベースディレクトリにおける以下の複数の
ファイルで表されます。これは MyISAM 型 のテーブル場合：

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>File</STRONG> </TD><TD> <STRONG>Purpose</STRONG>
</TR NOSAVE>
<TR><TD><CODE>tbl_name.frm</CODE> </TD><TD> Table definition (form) file
</TR NOSAVE>
<TR><TD><CODE>tbl_name.MYD</CODE> </TD><TD> Datafile
</TR NOSAVE>
<TR><TD><CODE>tbl_name.MYI</CODE> </TD><TD> Index file
</TR>
</TABLE>

<P>
フィールドに対する種々の型属性の詳細は、 「<A HREF="manual.ja_Reference.html#Column_types">6.2  フィールド型</A>」節を参照のこと。

</P>

<UL>
<LI>

 <CODE>NULL</CODE>も<CODE>NOT NULL</CODE>も指定されなかった場合、フィールドは<CODE>NULL</CODE>が指
定されたものとして扱われます。

<LI>

   整数型のフィールドには付加属性<CODE>AUTO_INCREMENT</CODE>も指定することができます。
<CODE>AUTO_INCREMENT</CODE>のフィールドに値<CODE>NULL</CODE>又は<CODE>0</CODE>を挿入した場合、フィ
ールドには<CODE>value+1</CODE>の値がセットされます。<CODE>value</CODE>は、そのテーブル内の当
該フィールドにおける現在の最大値です。
<CODE>AUTO_INCREMENT</CODE> は <CODE>1</CODE> からはじまります.
 「<A HREF="manual.ja_Clients.html#mysql_insert_id">8.4.3.130  <CODE>mysql_insert_id()</CODE></A>」節参照.

 削除したレコードが、<CODE>AUTO_INCREMENT</CODE>フィールドの最大値を含んでいた場合、
その値は、<CODE>ISAM</CODE> と <CODE>BDB</CODE> テーブルでは、次に再利用されますが、
<CODE>MyISAM</CODE> と <CODE>InnoDB</CODE> テーブルでは再利用されません。
また、テーブル内の全てのレコードを <CODE>DELETE FROM table_name</CODE> (<CODE>WHERE</CODE>節
無しで) を
<CODE>AUTOCOMMIT</CODE> モードで使用して削除した場合は、すべてのテーブル型で始めから採
番し直します。

<STRONG>注意</STRONG>: 1つのテーブルには1つしか<CODE>AUTO_INCREMENT</CODE>フィールドを指定でき
ません。
また、インデックスを指定する必要があります。
MySQL 3.23 は auto_increment フィールドが正の数を持っている場合に
だけ、正しく動作します。負の数の挿入はとても大きな正の数の挿入とみなされま
す。これは、数値が正から負への 'wrap' over する時の精度の問題を回避するた
めと、アクシデント的に 0 を含む auto_increment フィールドを得ることがない
ことを確実にするために、行なわれます。

In MyISAM and BDB tables you can specify <CODE>AUTO_INCREMENT</CODE> secondary
column in a multi-column key.   「<A HREF="manual.ja_Tutorial.html#example-AUTO_INCREMENT">3.5.9  Using <CODE>AUTO_INCREMENT</CODE></A>」節参照.

<A NAME="IDX1450"></A>
<A NAME="IDX1451"></A>
MySQL をいくつかの ODBC アプリケーションと互換にするために、次の
クエリで最後に挿入されたレコードを見つけることができます:


<PRE>
SELECT * FROM tbl_name WHERE auto_col IS NULL
</PRE>

<LI>

<CODE>CREATE TABLE</CODE> automatically commits the current InnoDB
transaction if MySQL binary logging is used.

<LI>

<CODE>TIMESTAMP</CODE>フィールドにおける<CODE>NULL</CODE>値は、他のフィールド属性と違った扱
われ方をします。定数<CODE>NULL</CODE>を<CODE>TIMESTAMP</CODE>フィールドに格納することはでき
ません。<CODE>NULL</CODE>値の指定は現在時刻をセットすることを意味します。
<CODE>TIMESTAMP</CODE>フィールドがこのように振舞うので、通常は<CODE>NULL</CODE>属性や
<CODE>NOT NULL</CODE>属性は適用できません。それらを指定しても無視されます。

 一方、MySQLクライアントからは、より安易に<CODE>TIMESTAMP</CODE>フィールドを
利用でき、サーバも<CODE>TIMESTAMP</CODE>フィールドへの<CODE>NULL</CODE>の適用を報告しますが
、<CODE>TIMESTAMP</CODE>フィールドは実際には<CODE>NULL</CODE>値を保存することはありません。
code{DESCRIBE tbl_name}を使用して、テーブル定義文を取得することにより、この現象
を確認することができます。

 <CODE>TIMESTAMP</CODE>フィールドに<CODE>0</CODE>を指定することは、<CODE>NULL</CODE>を指定すること
と等しくないことに注意してください。なぜなら、<CODE>0</CODE>は<CODE>TIMESTAMP</CODE>の値とし
て不正であるからです。

<LI>

<A NAME="IDX1452"></A>
A <CODE>DEFAULT</CODE> value has to be a constant, it cannot be a function or
an expression.

フィールドに対して <CODE>DEFAULT</CODE> 値が指定されない場合は MySQL が
自動的にそれを割り当てます。

フィールドが <CODE>NULL</CODE> を値として取り得る場合は、デフォルト値は 
<CODE>NULL</CODE> です。

フィールドが <CODE>NOT NULL</CODE> として宣言された場合は、デフォルト値はフィー
ルド型に依存します:


<UL>
<LI>

<CODE>AUTO_INCREMENT</CODE> 定義された以外の数値型のフィールドに対しては、
初期値は<CODE>0</CODE>となります。
<CODE>AUTO_INCREMENT</CODE>フィールドでは、デフォルト値は次のシーケンス番号になります。

<LI>

<CODE>TIMESTAMP</CODE> 型以外の日付型と時刻型のフィールドに対しては、
初期値はその型において適切な``ゼロ''値となります。
例外: フィールドがそのテーブル内で最初の<CODE>TIMESTAMP</CODE>フィールドである場合、初
期値は現在時刻になります。
 「<A HREF="manual.ja_Reference.html#Date_and_time_types">6.2.2  日付と時間の型</A>」節参照.

<LI>

<CODE>ENUM</CODE> 以外の文字列型のフィールドに対しては、初期値は空文字列となります。
<CODE>ENUM</CODE> では、デフォルト値は最初の列挙の値です。
</UL>

Default values must be constants. This means, for example, that you cannot
set the default for a date column to be the value of a function such as
<CODE>NOW()</CODE> or <CODE>CURRENT_DATE</CODE>.

<LI>

<CODE>KEY</CODE>は、<CODE>INDEX</CODE>の同義語です。

<LI>

MySQLでは、<CODE>UNIQUE</CODE>キーは固有値しか持つことができません。既に存在
するレコードとキーの値が重複するレコードを挿入しようとした場合、エラーが発生しま
す。

<LI>

<A NAME="IDX1453"></A>
<CODE>PRIMARY KEY</CODE> はユニーク <CODE>KEY</CODE> で、すべてのキーフィールドは 
<CODE>NOT NULL</CODE> として定義されなければならないという特別な制限を伴います。
MySQL ではキーは <CODE>PRIMARY</CODE> と名付けられます。テーブルは 
<CODE>PRIMARY KEY</CODE> を一つだけ持つことができます。<CODE>PRIMARY KEY</CODE> を持た
ない場合に、アプリケーションがテーブル内の <CODE>PRIMARY KEY</CODE> を尋ねると、
MySQL は <CODE>PRIMARY KEY</CODE> として、<CODE>NULL</CODE> フィールドを持た
ない最初の <CODE>UNIQUE</CODE> キーを返します。

<LI>

<CODE>PRIMARY KEY</CODE>は複数フィールドインデックスとできます。しかしながら、1つのフ
ィールド定義内では<CODE>PRIMARY KEY</CODE>属性を用いて複合インデックスを定義することが
できませんので、フィールド定義内における指定は、プライマリ・キーが単独フィールド
の場合のみとして下さい。複合フィールドの場合は、
<CODE>PRIMARY KEY(index_col_name,...)</CODE>文を使用しなければなりません。

<LI>

<CODE>PRIMARY</CODE> や <CODE>UNIQUE</CODE> キーが１つのフィールドだけからなり、その型が整数
の場合、それを <CODE>_rowid</CODE> としても参照することができます
(バージョン 3.23.11 での新機能)。

<LI>

インデックスに名前を割り当てない場合、一意な名前を付けるために、
<CODE>index_col_name</CODE> 内の最初のフィールド名に(<CODE>_2</CODE>, <CODE>_3</CODE>, ...)のような
サフィックスを付加したものが割り当てられます。
テーブルが使用しているインデックス名は、
<CODE>SHOW INDEX FROM tbl_name</CODE>により確認することができます。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_DATABASE_INFO">4.5.6.1  Retrieving information about Database, Tables, Columns, and Indexes</A>」節参照.

<LI>

<A NAME="IDX1454"></A>
<A NAME="IDX1455"></A>
<CODE>MyISAM</CODE> テーブルのみが、<CODE>NULL</CODE> 値をもつフィールドに対して
インデックスを持つことが出来ます。
その他のテーブル型の場合、フィールドを <CODE>NOT NULL</CODE> で定義しなくてはなりませ
ん。

<LI>

<CODE>col_name(length)</CODE>文を共に指定することで、<CODE>CHAR</CODE>フィールド又は
<CODE>VARCHAR</CODE>フィールドの一部分だけをインデックスとして定義できます。
これによりインデックスファイルを適度に小さくすることができます。
 「<A HREF="manual.ja_MySQL_Optimisation.html#Indexes">5.4.4  Column Indexes</A>」節参照.

<LI>

<A NAME="IDX1456"></A>
<A NAME="IDX1457"></A>
<A NAME="IDX1458"></A>
<A NAME="IDX1459"></A>
<CODE>MyISAM</CODE> テーブル型のみが、 <CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィールド上に
インデックスを持つことが出来ます。 <CODE>BLOB</CODE> と <CODE>TEXT</CODE> フィールドに
インデックスを張る場合、常に、インデックスの長さを指定しなくてはなりません：

<PRE>
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</PRE>

<LI>

<CODE>TEXT</CODE>フィールドや<CODE>BLOB</CODE>フィールドで <CODE>ORDER BY</CODE> や
<CODE>GROUP BY</CODE> を使用すると、
最初の<CODE>max_sort_length</CODE>バイトだけが使用されます。
 「<A HREF="manual.ja_Reference.html#BLOB">6.2.3.2  <CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型</A>」節参照.

<LI>

MySQL バージョン 3.23.23 以降では、特殊な <CODE>FULLTEXT</CODE> インデックスも
生成できます。それらは全文検索に使用されます。<CODE>MyISAM</CODE> テーブル型
だけが <CODE>FULLTEXT</CODE> インデックスをサポートします。それらは <CODE>CHAR</CODE>,
 <CODE>VARCHAR</CODE>, <CODE>TEXT</CODE> フィールドからだけ生成できます。
インデックスは常にフィールド全体に起こります。部分インデックスは
サポートされません。オペレーションの詳細は  「<A HREF="manual.ja_Reference.html#Fulltext_Search">6.8  MySQL Full-text Search</A>」節 を見てください。

<LI>

In MySQL Version 3.23.44 or later, <CODE>InnoDB</CODE> tables support checking of
foreign key constraints.  「<A HREF="manual.ja_Table_types.html#InnoDB">7.5  <CODE>InnoDB</CODE> テーブル (3.23.6以上)</A>」節参照. Note that the
<CODE>FOREIGN KEY</CODE> syntax in InnoDB is more restricted than
the syntax presented above. InnoDB does not allow
<CODE>index_name</CODE> to be specified, and the columns of the referenced
table always have to be explicitly named. Starting from
4.0.8 InnoDB supports both <CODE>ON DELETE</CODE> and <CODE>ON UPDATE</CODE>
actions on foreign keys.
See the InnoDB manual section for the precise syntax.  「<A HREF="manual.ja_Table_types.html#InnoDB">7.5  <CODE>InnoDB</CODE> テーブル (3.23.6以上)</A>」節参照.
For other table types, MySQL Server does parse the <CODE>FOREIGN KEY</CODE>,
<CODE>CHECK</CODE>, and <CODE>REFERENCES</CODE> syntax in <CODE>CREATE TABLE</CODE> commands,
but without further action being taken.  「<A HREF="manual.ja_Introduction.html#ANSI_diff_Foreign_Keys">1.7.4.5  外部キー</A>」節参照.

<LI>

全ての<CODE>NULL</CODE>フィールドは、1ビット余計に消費し、直近のバイトに丸められます。

<LI>

レコードの最大長は、以下のようにして求められます:


<PRE>
レコードの長さ = 1
             + (フィールドの長さの合計)
             + (NULLフィールドの数 + 7)/8
             + (可変長フィールドの数)
</PRE>

<LI>

<CODE>table_options</CODE> と <CODE>SELECT</CODE> オプションは、
MySQL 3.23 以上でのみ実装されます。
 
テーブル型は：

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table type</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD>BDB または BerkeleyDB </TD><TD> トランザクションセーフなテーブル  「<A HREF="manual.ja_Table_types.html#BDB">7.6  <CODE>BDB</CODE> or <CODE>BerkeleyDB</CODE> Tables</A>」節参照.
</TR NOSAVE>
<TR><TD>HEAP </TD><TD> このテーブルのデータは、メモリー内にのみ蓄えられる  「<A HREF="manual.ja_Table_types.html#HEAP">7.4  <CODE>HEAP</CODE> Tables (3.23.0以上)</A>」節参照.
</TR NOSAVE>
<TR><TD>ISAM </TD><TD> オリジナルのテーブル  「<A HREF="manual.ja_Table_types.html#ISAM">7.3  <CODE>ISAM</CODE> Tables</A>」節参照.
</TR NOSAVE>
<TR><TD>InnoDB </TD><TD> レコードロッキングを持ったトランザクション安全テーブル  「<A HREF="manual.ja_Table_types.html#InnoDB">7.5  <CODE>InnoDB</CODE> テーブル (3.23.6以上)</A>」節参照.
</TR NOSAVE>
<TR><TD>MERGE </TD><TD> 一つのテーブルとして使用される MyISAM テーブルの集まり  「<A HREF="manual.ja_Table_types.html#MERGE">7.2  <CODE>MERGE</CODE> Tables (3.23.25以上)</A>」節参照.
</TR NOSAVE>
<TR><TD>MRG_MyISAM </TD><TD> An alias for MERGE tables
</TR NOSAVE>
<TR><TD>MyISAM </TD><TD> ISAM にかわる 新しい バイナリ互換のテーブル。  「<A HREF="manual.ja_Table_types.html#MyISAM">7.1  <CODE>MyISAM</CODE> テーブル (3.23.0以上)</A>」節参照.
</TR>
</TABLE>
 「<A HREF="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</A>」節参照.

テーブル型が指定され、特定の型が有効でない場合、MySQL は指定され
たものに近いテーブル型を選択します。例えば、<CODE>TYPE=BDB</CODE> が指定されて、
MySQL のディストリビューションが <CODE>BDB</CODE> テーブルをサポートし
ない場合、代わりにテーブルは <CODE>MyISAM</CODE> として生成されます。

その他のテーブルオプションを使って、テーブルの振る舞いを最適化します。
たいていの場合は、オプションを明示する必要がありません。 
明示的に指定されなかった場合、オプションはすべてのテーブル型に作用します。

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Option</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>AUTO_INCREMENT</CODE> </TD><TD> あなたがこのテーブルにセットしたい、次の <CODE>AUTO_INCREMENT</CODE> 値
</TR NOSAVE>
<TR><TD><CODE>AVG_ROW_LENGTH</CODE> </TD><TD> テーブルに含まれるレコードの長さのおおよその平均値。 可変長のレコードを持つ大きなテーブルに対してのみ、これをセットします。
</TR NOSAVE>
<TR><TD><CODE>CHECKSUM</CODE> </TD><TD> MySQL に全てのレコードをチェックさせたい場合、これを 1 にセットします。 (これは更新を遅くさせますが、不整合の生じたテーブルを見つけ出しやすくなります) (MyISAM)
</TR NOSAVE>
<TR><TD><CODE>COMMENT</CODE> </TD><TD> テーブルの、60文字コメント
</TR NOSAVE>
<TR><TD><CODE>MAX_ROWS</CODE> </TD><TD> あなたがテーブルに保存したいと考えている最大レコード数。
</TR NOSAVE>
<TR><TD><CODE>MIN_ROWS</CODE> </TD><TD> あなたがテーブルに保存したいと考えている最低レコード数
</TR NOSAVE>
<TR><TD><CODE>PACK_KEYS</CODE> </TD><TD> より小さいインデックスにしたいなら、これを 1 にします。 これは更新を遅くしますが、読み出しは速くなります (MyISAM, ISAM). Setting this to 0 will disable all packing of keys. Setting this to <CODE>DEFAULT</CODE> (MySQL 4.0) will tell the storage engine to only pack long <CODE>CHAR</CODE>/<CODE>VARCHAR</CODE> columns.
</TR NOSAVE>
<TR><TD><CODE>PASSWORD</CODE> </TD><TD> <CODE>.frm</CODE> ファイルをパスワード付きで暗号化。 このオプションは、標準の MySQL バージョンではなにも行いません。
</TR NOSAVE>
<TR><TD><CODE>DELAY_KEY_WRITE</CODE> </TD><TD> テーブルがクローズされるまでキーテーブルの更新を送らせたい場合、1に設定します(MyISAM)。
</TR NOSAVE>
<TR><TD><CODE>ROW_FORMAT</CODE> </TD><TD> レコードがどのように格納されるかを定義します。現在 DYNAMIC と STATIC オプションが MyISAM テーブルのために使用できるだけです。
</TR>
</TABLE>

<CODE>MyISAM</CODE> テーブルを使用するならば、MySQL は
<CODE>max_rows * avg_row_length</CODE> の値を、テーブルがどのくらい大きくなるか
の推定に使用します。 
もし、上記のオプションをなにも指定しなかった場合、テーブルの最大サイズは
4G になります。(か、あなたの OS が 2G しかサポートしていなければ 2G まで)
この理由は、大きなファイルを本当に必要としない場合は、インデックスをより小
さく、より速くするため、ポインタサイズを小さく保持するためです。

<CODE>PACK_KEYS</CODE> を使用しない場合、デフォルトは文字列だけをパックし、数値
はパックしません。<CODE>PACK_KEYS=1</CODE> を使用するとさらに数値もパックされま
す。

バイナリ数値キーをパックする時、MySQL はプレフィックス圧縮を使用
します。これは、同じ数値を多く持つ場合にだけこの大きな恩恵を得るということ
を意味します。プレフィックス圧縮は、前のキーの何バイトが次のキーと同じであ
るかを示すための余計な1バイトがすべてのキーに必要となることを意味します(注
意: レコードへのポインタは、圧縮の向上のため high-byte-first-order でキー
の直後に格納されます)。これは、2つのレコードが同じキー多く持つ場合、後のす
べての'同じ'キーは通常2バイト(レコードへのポインタを含む)だけを必要とする
ということです。これを、通常のケースと比較してみてください。通常のケースは、
後のキーは'キーの格納サイズ' + ポインタサイズ(通常4)を必要とします。一方、
すべてのキーが全く異なっていると、キーが <CODE>NULL</CODE> 値を持つことができる
キーではない場合では、キー毎に1バイトを消費します(この場合、パックされたキー
の長さは、キーが <CODE>NULL</CODE> の時にマークのために使用されるのと同じバイト
数で格納されます)。

<LI>

もし <CODE>CREATE</CODE> ステートメントの後に <CODE>SELECT</CODE> を指定するならば、
MySQL は、<CODE>SELECT</CODE> で返ってくる全ての項目を収めるために、
新しいフィールドを作成します。
例えば：


<PRE>
mysql&#62; CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,
    -&#62;        PRIMARY KEY (a), KEY(b))
    -&#62;        TYPE=MyISAM SELECT b,c FROM test2;
</PRE>

これは 3つのフィールド a, b, c を <CODE>MyISAM</CODE> テーブルに作成します。
<CODE>SELECT</CODE> ステートメントからのフィールドがテーブルの右側に追加され、上
書きされないことに注意してください。次の例を見てください:


<PRE>
mysql&#62; SELECT * FROM foo;
+---+
| n |
+---+
| 1 |
+---+

mysql&#62; CREATE TABLE bar (m INT) SELECT n FROM foo;
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql&#62; SELECT * FROM bar;
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)
</PRE>

テーブル <CODE>foo</CODE> の各レコードについて、<CODE>foo</CODE> からの値と新しいフィー
ルドのデフォルト値を伴って <CODE>bar</CODE> のレコードが 挿入されます。

<CODE>CREATE TABLE ... SELECT</CODE> will not automatically create any indexes
for you.  This is done intentionally to make the command as flexible as
possible.  If you want to have indexes in the created table, you should
specify these before the <CODE>SELECT</CODE> statement:


<PRE>
mysql&#62; CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;
</PRE>

もしデータをテーブルにコピーしている最中にエラーが起きたなら、
このテーブルは自動的に消去されることに注意してください。

更新ログ／バイナリログはオリジナルテーブルを再生成するために使用できます。
MySQL は <CODE>CREATE TABLE .... SELECT</CODE> 中に並行しての挿入を許し
ません。

<LI>

<CODE>RAID_TYPE</CODE> オプションは、大規模ファイルをサポートしていない OS 上の
2G/4Gの制限を破る手助けをします。Note that this option is not recommended for
filesystem that supports big files!

また、<CODE>RAID</CODE> ディレクトリを別の物理
ディスクに置くことにより、IO ボトルネックからさらに速度を得ることができま
す。<CODE>RAID_TYPE</CODE> は、MySQL を <CODE>--with-raid</CODE> でコンフィグ
すれば、どんな OS 上でも働きます。現在、<CODE>RAID_TYPE</CODE> は 
<CODE>STRIPED</CODE> だけが許されています(<CODE>1</CODE> と <CODE>RAID0</CODE> はこれの別名
です)。

<CODE>RAID_TYPE=STRIPED</CODE> を <CODE>MyISAM</CODE> テーブルに指定すると、
<CODE>MyISAM</CODE> はデータベースディレクトリ中に 00, 01, 02 という名前の 
<CODE>RAID_CHUNKS</CODE> サブディレクトリを生成します。これらのディレクトリのそ
れぞれに、<CODE>MyISAM</CODE> は <CODE>table_name.MYD</CODE> を生成します。データファ
イルにデータが書き込まれる時、<CODE>RAID</CODE> ハンドラは最初の 
<CODE>RAID_CHUNKSIZE</CODE> *1024 バイトを最初のファイルに、次の 
<CODE>RAID_CHUNKSIZE</CODE> *1024 バイトを次のファイルにマップします。

<LI>

<CODE>UNION</CODE> は同じテーブルの集まりを一つとして使用したい時に使用されます。
これは MERGE テーブルでだけ動作します。 「<A HREF="manual.ja_Table_types.html#MERGE">7.2  <CODE>MERGE</CODE> Tables (3.23.25以上)</A>」節参照.

今のところ、<CODE>MERGE</CODE> テーブルをマップするテーブル上に <CODE>SELECT</CODE>,
<CODE>UPDATE</CODE>, <CODE>DELETE</CODE> 権限を持つことが必要です。マップされたすべて
のテーブルは <CODE>MERGE</CODE> テーブルとして、同じデータベース内にある必要があ
ります。

<LI>

If you want to insert data in a <CODE>MERGE</CODE> table, you have to specify with
<CODE>INSERT_METHOD</CODE> into with table the row should be inserted.
 「<A HREF="manual.ja_Table_types.html#MERGE">7.2  <CODE>MERGE</CODE> Tables (3.23.25以上)</A>」節参照. This option was introduced in MySQL 4.0.0.

<LI>

生成されたテーブルでは、<CODE>PRIMARY</CODE> キーは最初に置かれ、次にすべての 
<CODE>UNIQUE</CODE> キー、それから通常のキーが続きます。これは MySQL オ
プティマイザを助け、どのキーを使用するかの優先度付けを行ない、重なった 
<CODE>UNIQUE</CODE> キーをさらにすばやく検出します。

<LI>

<CODE>DATA DIRECTORY="directory"</CODE> または <CODE>INDEX
DIRECTORY="directory"</CODE> を使用することで、the storage engine が
テーブルとインデックスファイルを置くべき場所を指定できます。<CODE>--skip-symlink</CODE> オプショ
ンを使用しない時、これは <CODE>MySQL</CODE> 4.0 で <CODE>MyISAM</CODE> テーブルでだけ
動作します。  「<A HREF="manual.ja_MySQL_Optimisation.html#Symbolic_links_to_tables">5.6.1.2  Using Symbolic Links for Tables</A>」節参照.

</UL>



<H4><A NAME="Silent_column_changes" HREF="manual.ja_toc.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A></H4>

<P>
<A NAME="IDX1460"></A>

</P>
<P>
いくつかのケースにおいてMySQLは、<CODE>CREATE TABLE</CODE>ステートメントで与
えられたフィールド定義を暗黙の内に変更します
(これは <CODE>ALTER TABLE</CODE> で起きるかもしれません)

</P>

<UL>
<LI>

<CODE>VARCHAR</CODE> columns with a length less than four are changed to
<CODE>CHAR</CODE>.

<LI>

テーブル内にいくつかの可変長フィールドがある場合、結果的にレコード全体が可変長と
なります。
その結果、テーブルがいくつかの可変長フィールド(<CODE>VARCHAR</CODE>、<CODE>TEXT</CODE>及び
<CODE>BLOB</CODE>)を持つならば、3文字より大きいフィールド長の全ての<CODE>CHAR</CODE>フィールドは、
<CODE>VARCHAR</CODE>フィールドに変更されます。
このことは、フィールドの使用方法には影響しません。
MySQLでは、<CODE>VARCHAR</CODE>は文字列を格納するための1つの手段に過ぎません。
MySQLは、スペース埋めのコンバージョンを行いますし、テーブル操作もより速
く行います。   「<A HREF="manual.ja_Table_types.html#Table_types">7  MySQL テーブル型</A>」節参照.

<LI>

<CODE>TIMESTAMP</CODE>フィールドの表示サイズは、2〜14の範囲の偶数でなければなりません。
表示サイズを0や14より大きく指定した場合、サイズは14に強制されます。1から13の範
囲の奇数の場合、大きい方の偶数値に強制されます。

<LI>

<CODE>TIMESTAMP</CODE> フィールドには <CODE>NULL</CODE> を代入できません； <CODE>NULL</CODE> は
現在の日時をセットします。
<CODE>NULL</CODE> and <CODE>NOT NULL</CODE> 属性は通常の方法では適用されず、それらを
与えた場合は無視されます。
<CODE>DESCRIBE tbl_name</CODE> は常に <CODE>TIMESTAMP</CODE> フィールドに <CODE>NULL</CODE> 値が割
り当てられた事を告げます。

<LI>

MySQL は他の SQL データベースの使用している型を MySQL 型に
マップします。  「<A HREF="manual.ja_Reference.html#Other-vendor_column_types">6.2.5  他のデータベースエンジンのフィールド型の使用</A>」節参照.
</UL>

<P>
もし MySQL がフィールドの型をあなたが指定したものと違うものにしたかどう
かを知りたい場合、テーブルの作成、alter 後に、 <CODE>DESCRIBE tbl_name</CODE> 構文
を発行します。

</P>
<P>
<A NAME="IDX1461"></A>
<CODE>myisampack</CODE>を使用してテーブルを圧縮した場合、別のフィールド定義変更がある
程度起こることがあります。  「<A HREF="manual.ja_Table_types.html#Compressed_format">7.1.2.3  圧縮テーブルの特徴</A>」節参照.

</P>



<H3><A NAME="ALTER_TABLE" HREF="manual.ja_toc.html#ALTER_TABLE">6.5.4  <CODE>ALTER TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1462"></A>
<A NAME="IDX1463"></A>
<A NAME="IDX1464"></A>

</P>

<PRE>
ALTER [IGNORE] TABLE tbl_name alter_spec [, alter_spec ...]

alter_specification:
        ADD [COLUMN] create_definition [FIRST | AFTER column_name ]
  or    ADD [COLUMN] (create_definition, create_definition,...)
  or    ADD INDEX [index_name] (index_col_name,...)
  or    ADD PRIMARY KEY (index_col_name,...)
  or    ADD UNIQUE [index_name] (index_col_name,...)
  or    ADD FULLTEXT [index_name] (index_col_name,...)
  or	ADD [CONSTRAINT symbol] FOREIGN KEY [index_name] (index_col_name,...)
            [reference_definition]
  or    ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
  or    CHANGE [COLUMN] old_col_name create_definition
               [FIRST | AFTER column_name]
  or    MODIFY [COLUMN] create_definition [FIRST | AFTER column_name]
  or    DROP [COLUMN] col_name
  or    DROP PRIMARY KEY
  or    DROP INDEX index_name
  or    DISABLE KEYS
  or    ENABLE KEYS
  or    RENAME [TO] new_tbl_name
  or    ORDER BY col
  or    table_options
</PRE>

<P>
<CODE>ALTER TABLE</CODE>は、既存のテーブルの構造変更を可能にします。
例えば、フィールドの追加や削除、インデックスの作成や破棄、既存のフィールド属性の
変更、及びフィールドやテーブルそのものの名前の変更です。
また、テーブルのコメントやテーブルの型式を変更することも可能です。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照.

</P>
<P>
もし <CODE>ALTER TABLE</CODE> でフィールド定義を変えても <CODE>DESCRIBE tbl_name</CODE> が
フィールドを変更していないと示すなら、これは MySQL が
  「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節. に述べている理由の一つで変更していない可能性が
あります。 例えば、 <CODE>VARCHAR</CODE> フィールドを <CODE>CHAR</CODE> にしようとすると, 
MySQL はそのテーブルに他の可変長のフィールドがあるかぎり、
<CODE>VARCHAR</CODE> のままにしようとします。

</P>
<P>
<CODE>ALTER TABLE</CODE>はオリジナルのテーブルの一時的なコピーを作成することにより動作
します。
コピーへの変更作業が完了すると、オリジナルのテーブルは削除され新しく
作られた方の名前が変更されます。これは全ての変更が自動的に新しいテーブルに
対して実施されることにより、誤った変更無しに完了します。
<CODE>ALTER TABLE</CODE>が実行されている間、オリジナルのテーブルは他の
クライアントから読みだしが可能です。このテーブルへの更新や書き込みは、
新しいテーブルが準備完了となるまで遅らされます。

</P>
<P>
注意: <CODE>ALTER TABLE</CODE> に <CODE>RENAME</CODE> 以外のオプションを使用する場合、
MySQL は常に一時テーブルを生成します。データが厳密にコピーする必
要がないとしてもです(フィールドの名前を変更する時など)。
We plan to fix this in the future, but as one doesn't
normally do <CODE>ALTER TABLE</CODE> that often this isn't that high on our TODO.
For MyISAM tables, you can speed up the index recreation part (which is the
slowest part of the recreation process) by setting the
<CODE>myisam_sort_buffer_size</CODE> variable to a high value.

</P>

<UL>
<LI>

<CODE>ALTER TABLE</CODE>を使うには、そのテーブルに <CODE>ALTER</CODE>, <CODE>INSERT</CODE>,
<CODE>CREATE</CODE> 権限が必要です。

<LI>

<CODE>IGNORE</CODE>はANSI SQL92に対するMySQLの拡張です。
これは、新しいテーブルのユニークキーで重複があった場合の動作を制御します。
<CODE>IGNORE</CODE>が指定されない場合、コピーは異常終了し、ロールバックされます。
<CODE>IGNORE</CODE>が指定された場合、ユニークキーの重複があったレコードに対し、最初の
レコードだけを使用し、他は削除されます。

<LI>

1つの<CODE>ALTER TABLE</CODE>ステートメントの中で、<CODE>ADD</CODE>、<CODE>ALTER</CODE>、
<CODE>DROP</CODE>、それから<CODE>CHANGE</CODE>節の複合的な発行が可能です。
これは、<CODE>ALTER TABLE</CODE>ステートメント毎に1つだけしかこれらの節を
許さないANSI SQL92に対するMySQLの拡張です。

<LI>

<CODE>CHANGE col_name</CODE>、<CODE>DROP col_name</CODE>及び<CODE>DROP
INDEX</CODE>はANSI SQL92に対するMySQLの拡張です。

<LI>

<CODE>MODIFY</CODE> は <CODE>Oracle</CODE> の <CODE>ALTER TABLE</CODE> 拡張です。

<LI>

オプション語<CODE>COLUMN</CODE>は蛇足であり、記述を省くことが可能です。

<LI>

他のオプション無しで<CODE>ALTER TABLE tbl_name RENAME TO new_name</CODE>を使用すると、
MySQLは<CODE>tbl_name</CODE>に一致するテーブルの名前を単純に変更します。
テンポラリテーブルの作成は必要としません。
 「<A HREF="manual.ja_Reference.html#RENAME_TABLE">6.5.5  <CODE>RENAME TABLE</CODE> 構文</A>」節参照.

<LI>

<CODE>create_definition</CODE>は、<CODE>CREATE TABLE</CODE>における<CODE>ADD</CODE>や<CODE>CHANGE</CODE>
と同じ構文を使用します。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照.

<LI>

<CODE>CHANGE old_col_name create_definition</CODE>節を使用することによりフィールドの名
前を変更することができます。
このようなことを行うためには、フィールドの旧名称と新名称、それからそのフィールド
の現在の型を指定する必要があります。例えば、ある<CODE>INTEGER</CODE>フィールドを<CODE>
a</CODE>から<CODE>b</CODE>に変更する場合、以下のように実行することができます:


<PRE>
mysql&#62; ALTER TABLE t1 CHANGE a b INTEGER;
</PRE>

もしフィールドの名前を変えることなく、型だけを変更したい場合であっても、
この <CODE>CHANGE</CODE> 構文は、たとえ同じ名前であっても、
２つの名前を指定するよう要求します。
例:


<PRE>
mysql&#62; ALTER TABLE t1 CHANGE b b BIGINT NOT NULL;
</PRE>

しかし MySQL バージョン 3.22.16a からは,  <CODE>MODIFY</CODE> を使用して、
名称変更をすることなくフィールドの型を変更することができます。


<PRE>
mysql&#62; ALTER TABLE t1 MODIFY b BIGINT NOT NULL;
</PRE>

<LI>

<CODE>CHANGE</CODE> や <CODE>MODIFY</CODE> を使用して、フィールドの一部にインデックス
が存在するようなフィールドを短くしようとしても(例えば <CODE>VARCHAR</CODE> フィー
ルドの最初の10文字上ににインデックスがある場合)、インデックスされた文字数
よりもフィールドを短くすることはできません。

<LI>

<CODE>CHANGE</CODE> や <CODE>MODIFY</CODE> を用いてフィールドの型を変更する場合、
MySQLは可能な限り新しい型にデータをコンバートしようと試みます。

<LI>

MySQL バージョン 3.22以降では、
<CODE>FIRST</CODE>又は<CODE>ADD ... AFTER col_name</CODE>を使用して、
テーブルのレコード内の指定した位置に、フィールドを追加すること
ができます。
デフォルトでは、フィールドは(そのレコードの)最後に追加されます。
From MySQL Version 4.0.1, you can also use the <CODE>FIRST</CODE> and
<CODE>AFTER</CODE> keywords in <CODE>CHANGE</CODE> or <CODE>MODIFY</CODE>.

<A NAME="IDX1465"></A>
<A NAME="IDX1466"></A>
<A NAME="IDX1467"></A>
<A NAME="IDX1468"></A>
<A NAME="IDX1469"></A>
<LI>

<CODE>ALTER COLUMN</CODE>は、フィールドの新たな初期値を指定したり、フィールドの古い初
期値を削除したりします。
古い初期値が削除され、フィールドが<CODE>NULL</CODE>を許す場合、新たな初期値は
<CODE>NULL</CODE>となります。
<CODE>NULL</CODE>が許されない場合、 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節 で
説明されている通り、MySQL は初期値を割り当てます。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節.

<A NAME="IDX1470"></A>
<A NAME="IDX1471"></A>
<A NAME="IDX1472"></A>
<LI>

<CODE>DROP INDEX</CODE>は、インデックスを削除します。これはANSI SQL92に対する
MySQL の拡張です。  「<A HREF="manual.ja_Reference.html#DROP_INDEX">6.5.8  <CODE>DROP INDEX</CODE> 構文</A>」節参照.

<LI>

フィールドがテーブルから削除されると、そのフィールドが含まれているインデックスか
らもそのフィールドが削除されます。
インデックスを構成する全てのフィールドが削除されると、そのインデックスも削除され
ます。

<LI>

テーブルが一つのフィールドだけを含む場合、フィールドは破棄できません。テー
ブルを削除するつもりなら、<CODE>DROP TABLE</CODE> を代わりに使用してください。

<A NAME="IDX1473"></A>
<A NAME="IDX1474"></A>
<A NAME="IDX1475"></A>
<LI>

<CODE>DROP PRIMARY KEY</CODE>は、プライマリ・インデックスを削除します。もしプライマリ
インデックスが存在しなければ、そのテーブルの最初の<CODE>UNIQUE</CODE>インデックスが削
除されます。
(MySQLは、明示的に<CODE>PRIMARY KEY</CODE>が指定されなければ最初の<CODE>UNIQU
E</CODE>キーを<CODE>PRIMARY KEY</CODE>として扱います。)

<A NAME="IDX1476"></A>
<A NAME="IDX1477"></A>
If you add a <CODE>UNIQUE INDEX</CODE> or <CODE>PRIMARY KEY</CODE> to a table, this
is stored before any not <CODE>UNIQUE</CODE> index so that MySQL can detect
duplicate keys as early as possible.

<A NAME="IDX1478"></A>
<LI>

<CODE>ORDER BY</CODE> は指定した順のレコードで新しいテーブルを生成することができ
ます。注意: 挿入と削除の後にはこの順序は保持されません。テーブルを、後で 
order をしたいフィールドの順にしておくと MySQL のソートがより簡単
になる場合があります。このオプションは、主に一定の順でレコードをクエリする
つもりであることを知っているときに、主に有用です; テーブルに大きな変更をし
た後にこのオプションを使用することで、より高い性能を得ることができるdしょ
う。

<A NAME="IDX1479"></A>
<A NAME="IDX1480"></A>
<A NAME="IDX1481"></A>
<LI>

<CODE>ALTER TABLE</CODE> を <CODE>MyISAM</CODE> テーブルに使用する場合、すべての非ユニー
クインデックスは(<CODE>REPAIR</CODE> のような)別のバッチで生成されます。これは多
くのインデックスがある場合、<CODE>ALTER TABLE</CODE> をより速くします。

<LI>

Since <STRONG>MySQL 4.0</STRONG> the above feature can be activated explicitly.
<CODE>ALTER TABLE ... DISABLE KEYS</CODE> makes MySQL to stop updating
non-unique indexes for <CODE>MyISAM</CODE> table.
<CODE>ALTER TABLE ... ENABLE KEYS</CODE> then should be used to recreate missing
indexes. As MySQL does it with special algorithm which is much
faster then inserting keys one by one, disabling keys could give a
considerable speedup on bulk inserts.

<LI>

<A NAME="IDX1482"></A>
C API関数<CODE>mysql_info()</CODE>により、どれだけのレコードがコピーされたか、(<CODE>I
GNORE</CODE>が指定されている時は)どれだけのレコードがユニークキーの重複により削除され
たかを調べることができます。

<LI>

<A NAME="IDX1483"></A>
<A NAME="IDX1484"></A>
<CODE>FOREIGN KEY</CODE>、<CODE>CHECK</CODE>及び<CODE>REFERENCES</CODE>節は、
<CODE>ADD CONSTRAINT FOREIGN KEY (...) REFERENCES ... (...)</CODE> を
サポートする InnoDB 型以外のテーブルでは実際には何もしません。
Note that InnoDB does not allow an <CODE>index_name</CODE>
to be specified.  「<A HREF="manual.ja_Table_types.html#InnoDB">7.5  <CODE>InnoDB</CODE> テーブル (3.23.6以上)</A>」節参照.
他のテーブルに対するこれらの構文は、互換性のためだけに用意されており、
他のSQLサーバからのコードの移植を容易にしたり、
参照情報と共にテーブルを作成するようなアプリケーションを動作
させることを目的としています。
 「<A HREF="manual.ja_Introduction.html#Differences_from_ANSI">1.7.4  MySQL と ANSI SQL92 との違い</A>」節参照.
</UL>

<P>
以下は、<CODE>ALTER TABLE</CODE>の使用例を表す例です。
次に示すように作成されたテーブル<CODE>t1</CODE>から始めます:

</P>

<PRE>
mysql&#62; CREATE TABLE t1 (a INTEGER,b CHAR(10));
</PRE>

<P>
テーブル<CODE>t1</CODE>の名前を<CODE>t2</CODE>に変更するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t1 RENAME t2;
</PRE>

<P>
フィールド <CODE>a</CODE>を <CODE>INTEGER</CODE> から <CODE>TINYINT NOT NULL</CODE> に
(名前は同じままで)変更し、
<CODE>b</CODE> を <CODE>CHAR(10)</CODE> から <CODE>CHAR(20)</CODE> に変更しつつ、
名前を <CODE>b</CODE> から <CODE>c</CODE>に変更するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);
</PRE>

<P>
<CODE>TIMESTAMP</CODE>を追加し、名前を<CODE>d</CODE>とするには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 ADD d TIMESTAMP;
</PRE>

<P>
フィールド<CODE>d</CODE>にインデックスを追加し、フィールド<CODE>a</CODE>をプライマリ・キーと
するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 ADD INDEX (d), ADD PRIMARY KEY (a);
</PRE>

<P>
フィールド<CODE>c</CODE>を削除するには:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 DROP COLUMN c;
</PRE>

<P>
To add a new <CODE>AUTO_INCREMENT</CODE> integer column named <CODE>c</CODE>:

</P>

<PRE>
mysql&#62; ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
    -&#62;       ADD INDEX (c);
</PRE>

<P>
ここで我々が <CODE>c</CODE> をインデックス指定したのは、 <CODE>AUTO_INCREMENT</CODE> フィー
ルドはインデックスであるべきだからで、 <CODE>c</CODE> を <CODE>NOT NULL</CODE> 指定しているのは
インデックスフィールドは <CODE>NULL</CODE> にできないからです。

</P>
<P>
<CODE>AUTO_INCREMENT</CODE> フィールドを追加した場合、フィールドの値は
自動的にシーケンス番号で埋められます。
最初のシーケンス番号は、<CODE>ALTER TABLE</CODE> 前に <CODE>SET INSERT_ID=#</CODE> を
実行するか、または <CODE>AUTO_INCREMENT = #</CODE> テーブルオプションを使用する
ことで設定できます。
 「<A HREF="manual.ja_MySQL_Optimisation.html#SET_OPTION">5.5.6  <CODE>SET</CODE> 構文</A>」節参照.

</P>
<P>
MyISAM テーブルでは、<CODE>AUTO_INCREMENT</CODE> フィールドを変更しない場合、シー
ケンス番号は影響を受けません。<CODE>AUTO_INCREMENT</CODE> フィールドを破棄し、そ
れから別の <CODE>AUTO_INCREMENT</CODE> フィールドを追加した場合、番号は再度 1 か
ら始まります。

</P>
<P>
 「<A HREF="manual.ja_Problems.html#ALTER_TABLE_problems">A.6.1  Problems with <CODE>ALTER TABLE</CODE>.</A>」節参照.

</P>



<H3><A NAME="RENAME_TABLE" HREF="manual.ja_toc.html#RENAME_TABLE">6.5.5  <CODE>RENAME TABLE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1485"></A>

</P>

<PRE>
RENAME TABLE tbl_name TO new_tbl_name[, tbl_name2 TO new_tbl_name2,...]
</PRE>

<P>
リネームは自動的に行なわれます。これは、他のスレッドはリネームが動作中はテー
ブルのどこにもアクセスできないことを意味します。空のテーブルでテーブルを置
き換えることが可能です:

</P>

<PRE>
CREATE TABLE new_table (...);
RENAME TABLE old_table TO backup_table, new_table TO old_table;
</PRE>

<P>
リネームは左から右に行なわれます。２つのテーブルの名前を交換したい場合には、
次のようにする必要があることを意味します:

</P>

<PRE>
RENAME TABLE old_table    TO backup_table,
             new_table    TO old_table,
             backup_table TO new_table;
</PRE>

<P>
２つのデータベースが同じディスク上にあれば、あるデータベースから他のデータ
ベースにリネームすることも可能です:

</P>

<PRE>
RENAME TABLE current_database.table_name TO other_database.table_name;
</PRE>

<P>
<CODE>RENAME</CODE> 実行時には、ロックされたテーブルや有効なトランザクションを持
つことはできません。元のテーブルで <CODE>ALTER</CODE> と <CODE>DROP</CODE> 権限を、新
しいテーブルで <CODE>CREATE</CODE> と <CODE>INSERT</CODE> 権限を持つことも必要です。

</P>
<P>
MySQL が複数のテーブルのリネームで何らかのエラーに遭遇した場合、
リネームしたすべてのテーブルを逆にリネームし、すべてを元の状態に戻します。

</P>
<P>
<CODE>RENAME TABLE</CODE> was added in MySQL 3.23.23.

</P>


<H3><A NAME="DROP_TABLE" HREF="manual.ja_toc.html#DROP_TABLE">6.5.6  <CODE>DROP TABLE</CODE> Syntax</A></H3>

<P>
<A NAME="IDX1486"></A>
<A NAME="IDX1487"></A>
<A NAME="IDX1488"></A>

</P>

<PRE>
DROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name,...] [RESTRICT | CASCADE]
</PRE>

<P>
<CODE>DROP TABLE</CODE>は、1つ又は1つ以上のテーブルを破棄します。テーブルの全てのデー
タとテーブル定義は<EM>破棄</EM>されますので、このコマンドの使用は慎重に行ってくだ
さい！

</P>
<P>
MySQL バージョン 3.22以降では、テーブルが存在しないことに起因するエラー
を防ぐために、キーワード <CODE>IF EXISTS</CODE> を使用することができます。
In 4.1 one gets a <CODE>NOTE</CODE> for all not existing tables when using
<CODE>IF EXISTS</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_WARNINGS">4.5.6.9  <CODE>SHOW WARNINGS | ERRORS</CODE></A>」節参照.
  
<CODE>RESTRICT</CODE> と <CODE>CASCADE</CODE> は移植を簡単にするために許されています。
しばらくはこれらは何も行ないません。
  
<STRONG>注意</STRONG>: <CODE>DROP TABLE</CODE> はトランザクション安全ではなく、自動的に
すべてのアクティブトランザクションをコミットします。
 (except if you are using 4.1 and the <CODE>TEMPORARY</CODE>
key word. )

</P>
<P>
Option <CODE>TEMPORARY</CODE> is ignored in 4.0.  In 4.1 this option works as
follows:

</P>

<UL>
<LI>

Only drops temporary tables.
<LI>

It doesn't end a running transactions.
<LI>

No access rights is checked.
</UL>

<P>
Using <CODE>TEMPORARY</CODE> is a good way to ensure that you don't accidently
drop a real table.

</P>


<H3><A NAME="CREATE_INDEX" HREF="manual.ja_toc.html#CREATE_INDEX">6.5.7  <CODE>CREATE INDEX</CODE> 構文</A></H3>

<P>
<A NAME="IDX1489"></A>

</P>
<P>
<A NAME="IDX1490"></A>
<A NAME="IDX1491"></A>
<A NAME="IDX1492"></A>

</P>

<PRE>
CREATE [UNIQUE|FULLTEXT] INDEX index_name
       ON tbl_name (col_name[(length)],... )
</PRE>

<P>
<CODE>CREATE INDEX</CODE> 構文は MySQL 3.22 より以前のバージョンではなにもし
ません。
バージョン 3.22 以降で、<CODE>CREATE INDEX</CODE> はインデックスの作成のために
<CODE>ALTER TABLE</CODE> を呼びだしています。
@xref{ALTER TABLE, , <CODE>ALTER TABLE</CODE>}.

</P>
<P>
通常、テーブル内の全てのインデックスは <CODE>CREATE TABLE</CODE> で
テーブルを作るときに一度に作成されます。
 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">6.5.3  <CODE>CREATE TABLE</CODE> 構文</A>」節参照.
<CODE>CREATE INDEX</CODE> は既に存在するテーブルに対し、インデックスを追加します。
<CODE>CREATE INDEX</CODE> allows you to add indexes to existing tables.

</P>
<P>
フィールドを <CODE>(col1,col2,...)</CODE> として指定すると、複数フィールドインデックス
を作成します。
インデックスの値は、与えられたフィールドの値を連結して、構成されます。

</P>
<P>
<CODE>CHAR</CODE> と <CODE>VARCHAR</CODE> フィールドでは、インデックスはフィールドの一部分だ
けを使用して
作成されます。これは <CODE>col_name(length)</CODE> 構文を使用します。
(<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 節では length が必要です)。
最初の10文字をインデックスとして使用するには、この構文は以下のようにして使用しま
す(<CODE>name</CODE> フィールドにインデックスを作ります)：

</P>

<PRE>
mysql&#62; CREATE INDEX part_of_name ON customer (name(10));
</PRE>

<P>
フィールドの一部分だけをインデックスに使用すれば、インデックスファイルをはるかに
小さくすることができます。
ほとんどの名前が最初の10文字において通常異なるので、
このインデックスは <CODE>name</CODE> フィールド全部を使用して創り出したインデックスに
比べて遅くなることはありません。また、多くのディスクスペースを節約でき、
 <CODE>INSERT</CODE> を速くするのです！

</P>
<P>
MySQL version 3.23.2 以上で <CODE>MyISAM</CODE> 型のテーブルを使用している
場合、<CODE>NULL</CODE> 値をもつフィールドや、 <CODE>BLOB</CODE>/<CODE>TEXT</CODE> フィールドに対して
インデックスを張ることが可能です。

</P>
<P>
MySQL がどのようにしてインデックスを使用するかは →
 「<A HREF="manual.ja_MySQL_Optimisation.html#MySQL_indexes">5.4.3  MySQL はどのようにインデックスを使用するか？</A>」節.

</P>
<P>
<CODE>FULLTEXT</CODE> indexes can index only <CODE>VARCHAR</CODE> and
<CODE>TEXT</CODE> columns, and only in <CODE>MyISAM</CODE> tables. <CODE>FULLTEXT</CODE> indexes
are available in MySQL Version 3.23.23 and later.
 「<A HREF="manual.ja_Reference.html#Fulltext_Search">6.8  MySQL Full-text Search</A>」節.

</P>



<H3><A NAME="DROP_INDEX" HREF="manual.ja_toc.html#DROP_INDEX">6.5.8  <CODE>DROP INDEX</CODE> 構文</A></H3>

<P>
<A NAME="IDX1493"></A>
<A NAME="IDX1494"></A>
<A NAME="IDX1495"></A>

</P>

<PRE>
DROP INDEX index_name ON tbl_name
</PRE>

<P>
<CODE>DROP INDEX</CODE> は <CODE>index_name</CODE> という名前のインデックスをテーブル 
<CODE>tbl_name</CODE> から破棄します。
<CODE>DROP INDEX</CODE> は MySQL バージョン 3.22 より以前のバージョンではなに
もしません。
3.22 以降で、<CODE>DROP INDEX</CODE> はインデックスの破棄のために
<CODE>ALTER TABLE</CODE> を呼びだしています。
 「<A HREF="manual.ja_Reference.html#ALTER_TABLE">6.5.4  <CODE>ALTER TABLE</CODE> 構文</A>」節参照.

</P>



<H2><A NAME="Basic_User_Commands" HREF="manual.ja_toc.html#Basic_User_Commands">6.6  Basic MySQL User Utility Commands</A></H2>



<H3><A NAME="USE" HREF="manual.ja_toc.html#USE">6.6.1  <CODE>USE</CODE> 構文</A></H3>

<P>
<A NAME="IDX1496"></A>

</P>

<PRE>
USE db_name
</PRE>

<P>
<CODE>USE db_name</CODE> 構文は、 MySQL に <CODE>db_name</CODE> データベースを
この後のクエリのデフォルトのデータベースにするように指示します。
指定されたデータベースは、セッションの最後まで、あるいは、他の <CODE>USE</CODE> 構文
が発行されるまで残ります：

</P>

<PRE>
mysql&#62; USE db1;
mysql&#62; SELECT count(*) FROM mytable;      # selects from db1.mytable
mysql&#62; USE db2;
mysql&#62; SELECT count(*) FROM mytable;      # selects from db2.mytable
</PRE>

<P>
<CODE>USE</CODE> 構文で特定のデータベースをカレントにしても、
他のデータベースのテーブルからアクセスすることを妨げません。
以下は <CODE>db1</CODE> データベースの <CODE>author</CODE> テーブルと、
 <CODE>db2</CODE> データベースの <CODE>editor</CODE> テーブルにアクセスする例です：

</P>

<PRE>
mysql&#62; USE db1;
mysql&#62; SELECT author_name,editor_name FROM author,db2.editor
    -&#62;        WHERE author.editor_id = db2.editor.editor_id;
</PRE>

<P>
<A NAME="IDX1497"></A>
<A NAME="IDX1498"></A>
<CODE>USE</CODE> 構文は Sybase の互換のために提供されています。

</P>



<H3><A NAME="DESCRIBE" HREF="manual.ja_toc.html#DESCRIBE">6.6.2  <CODE>DESCRIBE</CODE> 構文 (フィールドについての情報を得る)</A></H3>

<P>
<A NAME="IDX1499"></A>
<A NAME="IDX1500"></A>

</P>

<PRE>
{DESCRIBE | DESC} tbl_name [col_name | wild]
</PRE>

<P>
<CODE>DESCRIBE</CODE> is a shortcut for <CODE>SHOW COLUMNS FROM</CODE>.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_DATABASE_INFO">4.5.6.1  Retrieving information about Database, Tables, Columns, and Indexes</A>」節参照.

</P>
<P>
<CODE>DESCRIBE</CODE> はフィールドについての情報を与えます。
<CODE>col_name</CODE> はフィールドはフィールド名または文字列です。
文字列は SQL <SAMP>`%'</SAMP>,<SAMP>`_'</SAMP> ワイルドカードを含めます。
There is no need to enclose the string in quotes.

</P>
<P>
もしフィールドの型があなたが <CODE>CREATE TABLE</CODE> 文で与えた物と違っているなら、
これは MySQL がフィールドの型を変更していることに注意してください。
 「<A HREF="manual.ja_Reference.html#Silent_column_changes">6.5.3.1  暗黙のフィールド定義変更</A>」節参照.

</P>
<P>
<A NAME="IDX1501"></A>
<A NAME="IDX1502"></A>
このコマンドは Oracle の互換のためにあります。

</P>
<P>
<CODE>SHOW</CODE> 構文は似たような情報を提供します。
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW">4.5.6  <CODE>SHOW</CODE> 構文</A>」節参照.

</P>



<H2><A NAME="Transactional_Commands" HREF="manual.ja_toc.html#Transactional_Commands">6.7  MySQL Transactional and Locking Commands</A></H2>



<H3><A NAME="COMMIT" HREF="manual.ja_toc.html#COMMIT">6.7.1  <CODE>BEGIN/COMMIT/ROLLBACK</CODE> 構文</A></H3>

<P>
<A NAME="IDX1503"></A>
<A NAME="IDX1504"></A>
<A NAME="IDX1505"></A>
<A NAME="IDX1506"></A>

</P>
<P>
デフォルトでは MySQL は <CODE>autocommit</CODE> モードで動作します。こ
れは、更新を実行するとすぐに MySQL が更新をディスクに格納すること
を意味します。

</P>
<P>
もし トランザクションセーフのテーブル(like <CODE>BDB</CODE>,
<CODE>InnoDB</CODE>) を使用するなら, 以下のコマンドで MySQL を
非 <CODE>autocommit</CODE> モード状態にすることができます：

</P>

<PRE>
SET AUTOCOMMIT=0
</PRE>

<P>
この後、ディスクに変更を格納するためには <CODE>COMMIT</CODE> を使用し、また、変
更を無視するためには <CODE>ROLLBACK</CODE> する必要があります。

</P>
<P>
ある一連のステートメントのために <CODE>AUTOCOMMIT</CODE> モードからスイッチし
たい場合は、<CODE>START TRANSACTION</CODE> か <CODE>BEGIN</CODE> または
<CODE>BEGIN WORK</CODE> ステートメントを使用できます。

</P>

<PRE>
START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summmary=@A WHERE type=1;
COMMIT;
</PRE>

<P>
<CODE>START TRANSACTION</CODE> was added to MySQL 4.0.11;  This is the recommended
way to start an ad-hoc transaction as this is ANSI SQL syntax.
(訳注： 4.0.11より前では、<CODE>BEGIN</CODE> を使用します)

</P>
<P>
注意: トランザクション安全テーブルを使用していない場合は、<CODE>autocommit</CODE>
モードのステータスには依存せずに、変更はすぐに格納されます。

</P>
<P>
If you do a <CODE>ROLLBACK</CODE> when you have updated a non-transactional
table you will get an error (<CODE>ER_WARNING_NOT_COMPLETE_ROLLBACK</CODE>) as
a warning.  All transaction-safe tables will be restored but any
non-transaction-safe table will not change.

</P>
<P>
If you are using <CODE>START TRANSACTION</CODE> or <CODE>SET AUTOCOMMIT=0</CODE>, you
should use the MySQL binary log for backups instead of the
older update log.  Transactions are stored in the binary log
in one chunk, upon <CODE>COMMIT</CODE>, to ensure that transactions which are
rolled back are not stored.   「<A HREF="manual.ja_MySQL_Database_Administration.html#Binary_log">4.9.4  The Binary Update Log バイナリ更新ログ (3.23.15以上)</A>」節参照.

</P>
<P>
The following commands automatically end a transaction (as if you had done
a <CODE>COMMIT</CODE> before executing the command):

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Command</STRONG> </TD><TD> <STRONG>Command</STRONG> </TD><TD> <STRONG>Command</STRONG>
</TR NOSAVE>
<TR><TD><CODE>ALTER TABLE</CODE> </TD><TD> <CODE>BEGIN</CODE> </TD><TD> <CODE>CREATE INDEX</CODE>
</TR NOSAVE>
<TR><TD><CODE>DROP DATABASE</CODE> </TD><TD> <CODE>DROP TABLE</CODE> </TD><TD> <CODE>RENAME TABLE</CODE>
</TR NOSAVE>
<TR><TD><CODE>TRUNCATE</CODE> </TD><TD> </TD><TD> 
</TR>
</TABLE>

<P>
You can change the isolation level for transactions with
<CODE>SET TRANSACTION ISOLATION LEVEL ...</CODE>.  「<A HREF="manual.ja_Reference.html#SET_TRANSACTION">6.7.3  <CODE>SET TRANSACTION</CODE> 構文</A>」節参照.

</P>



<H3><A NAME="LOCK_TABLES" HREF="manual.ja_toc.html#LOCK_TABLES">6.7.2  <CODE>LOCK TABLES/UNLOCK TABLES</CODE> 構文</A></H3>

<P>
<A NAME="IDX1507"></A>
<A NAME="IDX1508"></A>

</P>

<PRE>
LOCK TABLES tbl_name [AS alias] {READ [LOCAL] | [LOW_PRIORITY] WRITE}
            [, tbl_name [AS alias] {READ [LOCAL] | [LOW_PRIORITY] WRITE} ...]
...
UNLOCK TABLES
</PRE>

<P>
<CODE>LOCK TABLES</CODE> はカレントのスレッドのためにテーブルをロックします。
<CODE>UNLOCK TABLES</CODE> はこのスレッドの全てのロックを解除します。
カレントスレッドによってロックされた全てのテーブルは、
スレッドが他の <CODE>LOCK TABLES</CODE> を発行した場合やサーバーが接続を閉じた場合、
自動で解除されます。

</P>
<P>
To use <CODE>LOCK TABLES</CODE> in MySQL 4.0.2 you need the global
<CODE>LOCK TABLES</CODE> privilege and a <CODE>SELECT</CODE> privilege on the
involved tables. In MySQL 3.23 you need to have <CODE>SELECT</CODE>,
<CODE>insert</CODE>, <CODE>DELETE</CODE> and <CODE>UPDATE</CODE> privileges for the
tables.

</P>
<P>
The main reasons to use <CODE>LOCK TABLES</CODE> are for emulating transactions
or getting more speed when updating tables.  This is explained in more
detail later.

</P>
<P>
スレッドがテーブルに <CODE>READ</CODE> ロックを持つ場合、そのスレッド(と他の全てのスレ
ッド)はテーブルからの読み込みだけができます。スレッドがテーブルに
<CODE>WRITE</CODE> ロックを持つ場合、
このスレッドだけがテーブルの <CODE>READ</CODE> と <CODE>WRITE</CODE> ができます。
他のスレッドはブロックされます。

</P>
<P>
<CODE>READ LOCAL</CODE> と <CODE>READ</CODE> の違いは、<CODE>READ LOCAL</CODE> は、ロックが
保持されている間にコンフリクトしない <CODE>INSERT</CODE> ステートメントを実行で
きることです。ただし、これはロックを保持している間に MySQL の外で
データベースファイルを操作しようとする場合は使用できません。

</P>
<P>
When you use <CODE>LOCK TABLES</CODE>, you must lock all tables that you are
going to use and you must use the same alias that you are going to use
in your queries!  If you are using a table multiple times in a query
(with aliases), you must get a lock for each alias!

</P>
<P>
<CODE>WRITE</CODE> ロックは普通、できる限り更新を行わせるため、
 <CODE>READ</CODE> ロックよりも優先順位が高くなっています。
これはあるスレッドが <CODE>READ</CODE> ロックをかけ、それ以外のスレッドが <CODE>WRITE</CODE>
 を要求した場合、 <CODE>READ</CODE> は、<CODE>WRITE</CODE> スレッドがロックをし、それを解除
するまで待つということです。
<CODE>LOW_PRIORITY WRITE</CODE> を使用すれば、
<CODE>WRITE</CODE> ロックを待っているスレッドに <CODE>READ</CODE> ロックを得させることができ
ます。
<CODE>LOW_PRIORITY WRITE</CODE> は <CODE>READ</CODE> ロックをしているスレッドが一つもないと
わかっている場合に使用すべきです。

</P>
<P>
<CODE>LOCK TABLES</CODE> works as follows:

<OL>
<LI>

Sort all tables to be locked in a internally defined order (from the
user standpoint the order is undefined).
<LI>

If a table is locked with a read and a write lock, put the write lock
before the read lock.
<LI>

Lock one table at a time until the thread gets all locks.
</OL>

<P>
This policy ensures that table locking is deadlock free. There is
however other things one needs to be aware of with this schema:

</P>
<P>
If you are using a <CODE>LOW_PRIORITY WRITE</CODE> lock for a table, this
means only that MySQL will wait for this particlar lock until
there is no threads that wants a <CODE>READ</CODE> lock.  When the thread has
got the <CODE>WRITE</CODE> lock and is waiting to get the lock for the next
table in the lock table list, all other threads will wait for the
<CODE>WRITE</CODE> lock to be released.  If this becomes a serious problem
with your application, you should consider converting some of your
tables to transactions safe tables.

</P>
<P>
You can safely kill a thread that is waiting for a table lock with
<CODE>KILL</CODE>.   「<A HREF="manual.ja_MySQL_Database_Administration.html#KILL">4.5.5  <CODE>KILL</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>INSERT DELAYED</CODE> で使用しているいかなるテーブルも、ロックすべきではありませ
ん。この場合 <CODE>INSERT</CODE> は別のスレッドで行なわれるからです。

</P>
<P>
通常、全ての単一の <CODE>UPDATE</CODE> 構文においては、テーブルをロックする必要はあり
ません；
スレッドは、他のスレッドが現在実行している SQL 文に干渉することができません。
これらはテーブルをロックした方がよい、まれな場合です：

</P>

<UL>
<LI>

テーブルをまとめて多くの操作を実行しようとする場合、使用しようとしているテー
ブルをロックするととても速くなります。もちろん、他のスレッドは <CODE>READ</CODE> ロッ
クされたテーブルの更新はできませんし、他のスレッドは <CODE>WRITE</CODE> ロックされた
テーブルを読むことはできません。

The reason some things are faster under <CODE>LOCK TABLES</CODE> is that
MySQL will not flush the key cache for the locked tables until
<CODE>UNLOCK TABLES</CODE> is called (normally the key cache is flushed after
each SQL statement). This speeds up inserting/updateing/deletes on
<CODE>MyISAM</CODE> tables.

<LI>

<CODE>MySQL</CODE> のトランザクションをサポートしない the storage engine を使用
している場合、他のスレッドが <CODE>SELECT</CODE>,<CODE>UPDATE</CODE> の間に来ないことを
保証したいならば、<CODE>LOCK TABLES</CODE> を使用する必要があります。
次の例は安全のためには <CODE>LOCK TABLES</CODE> を必要とします：


<PRE>
mysql&#62; LOCK TABLES trans READ, customer WRITE;
mysql&#62; SELECT sum(value) FROM trans WHERE customer_id= some_id;
mysql&#62; UPDATE customer SET total_value=sum_from_previous_statement
    -&#62;        WHERE customer_id=some_id;
mysql&#62; UNLOCK TABLES;
</PRE>

 <CODE>LOCK TABLES</CODE> を使用しない場合、<CODE>SELECT</CODE> の実行と <CODE>UPDATE</CODE> の
実行を行う間に、他のスレッドが新しい <CODE>trans</CODE> 行を挿入する隙ができます。
</UL>

<P>
インクリメント アップデイト (<CODE>UPDATE customer SET
value=value+new_value</CODE>) または 
<CODE>LAST_INSERT_ID()</CODE> 関数の使用により、多くの場合 <CODE>LOCK TABLES</CODE> を回避
できます。

</P>
<P>
いくつかの場合、ユーザレベルロック: <CODE>GET_LOCK()</CODE> と <CODE>RELEASE_LOCK()</CODE> 
の使用
によっても解決できます。これらのロックはサーバ内のハッシュテーブル内に保
持され、高速のため <CODE>pthread_mutex_lock()</CODE> で実装されました。
 「<A HREF="manual.ja_Reference.html#Miscellaneous_functions">6.3.6.2  その他の関数</A>」節参照.

</P>
<P>
ロックポリシーのさらなる情報については  「<A HREF="manual.ja_MySQL_Optimisation.html#Internal_locking">5.3.1  MySQL はどのようにテーブルをロックするか</A>」節 を見てくださ
い。

</P>
<P>
You can lock all tables in all databases with read locks with the
<CODE>FLUSH TABLES WITH READ LOCK</CODE> command.  「<A HREF="manual.ja_MySQL_Database_Administration.html#FLUSH">4.5.3  <CODE>FLUSH</CODE> 構文</A>」節参照. This is very
convenient way to get backups if you have a filesystem, like Veritas,
that can take snapshots in time.

</P>
<P>
<STRONG>NOTE</STRONG>: <CODE>LOCK TABLES</CODE> is not transaction-safe and will
automatically commit any active transactions before attempting to lock the
tables.

</P>



<H3><A NAME="SET_TRANSACTION" HREF="manual.ja_toc.html#SET_TRANSACTION">6.7.3  <CODE>SET TRANSACTION</CODE> 構文</A></H3>

<P>
<A NAME="IDX1509"></A>
<A NAME="IDX1510"></A>

</P>

<PRE>
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL
{ READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
</PRE>

<P>
Sets the transaction isolation level for the global, whole session or
the next transaction.

</P>
<P>
The default behaviour is to set the isolation level for the next (not
started) transaction.  If you use the <CODE>GLOBAL</CODE> keyword, the statement
sets the default transaction level globally for all new connections
created from that point on.  You will need the <CODE>SUPER</CODE>
privilege to do this.  Using the <CODE>SESSION</CODE> keyword sets the
default transaction level for all future transactions performed on the
current connection.

</P>
<P>
You can set the default global isolation level for <CODE>mysqld</CODE> with
<CODE>--transaction-isolation=...</CODE>.  「<A HREF="manual.ja_MySQL_Database_Administration.html#Command-line_options">4.1.1  <CODE>mysqld</CODE> コマンド行オプション</A>」節参照.

</P>


<H2><A NAME="Fulltext_Search" HREF="manual.ja_toc.html#Fulltext_Search">6.8  MySQL Full-text Search</A></H2>

<P>
<A NAME="IDX1511"></A>
<A NAME="IDX1512"></A>
<A NAME="IDX1513"></A>

</P>
<P>
As of Version 3.23.23, MySQL has support for full-text indexing
and searching.  Full-text indexes in MySQL are an index of type
<CODE>FULLTEXT</CODE>.  <CODE>FULLTEXT</CODE> indexes are used with <CODE>MyISAM</CODE> tables
and can be created from <CODE>CHAR</CODE>, <CODE>VARCHAR</CODE>,
or <CODE>TEXT</CODE> columns at <CODE>CREATE TABLE</CODE> time or added later with
<CODE>ALTER TABLE</CODE> or <CODE>CREATE INDEX</CODE>.  For large datasets, it will be
much faster to load your data into a table that has no <CODE>FULLTEXT</CODE>
index, then create the index with <CODE>ALTER TABLE</CODE> (or <CODE>CREATE
INDEX</CODE>).  Loading data into a table that already has a <CODE>FULLTEXT</CODE>
index will be slower.

</P>
<P>
Full-text searching is performed with the <CODE>MATCH()</CODE> function.

</P>

<PRE>
mysql&#62; CREATE TABLE articles (
    -&#62;   id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    -&#62;   title VARCHAR(200),
    -&#62;   body TEXT,
    -&#62;   FULLTEXT (title,body)
    -&#62; );
Query OK, 0 rows affected (0.00 sec)

mysql&#62; INSERT INTO articles VALUES
    -&#62; (NULL,'MySQL Tutorial', 'DBMS stands for DataBase ...'),
    -&#62; (NULL,'How To Use MySQL Efficiently', 'After you went through a ...'),
    -&#62; (NULL,'Optimising MySQL','In this tutorial we will show ...'),
    -&#62; (NULL,'1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
    -&#62; (NULL,'MySQL vs. YourSQL', 'In the following database comparison ...'),
    -&#62; (NULL,'MySQL Security', 'When configured properly, MySQL ...');
Query OK, 6 rows affected (0.00 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql&#62; SELECT * FROM articles
    -&#62;          WHERE MATCH (title,body) AGAINST ('database');
+----+-------------------+------------------------------------------+
| id | title             | body                                     |
+----+-------------------+------------------------------------------+
|  5 | MySQL vs. YourSQL | In the following database comparison ... |
|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |
+----+-------------------+------------------------------------------+
2 rows in set (0.00 sec)
</PRE>

<P>
The <CODE>MATCH()</CODE> function performs a natural language search for a string
against a text collection (a set of one or more columns included in
a <CODE>FULLTEXT</CODE> index).  The search string is given as the argument to
<CODE>AGAINST()</CODE>.  The search is performed in case-insensitive fashion.
For every row in the table, <CODE>MATCH()</CODE> returns a relevance value,
that is, a similarity measure between the search string and the text in
that row in the columns named in the <CODE>MATCH()</CODE> list.

</P>
<P>
When <CODE>MATCH()</CODE> is used in a <CODE>WHERE</CODE> clause (see example above)
the rows returned are automatically sorted with highest relevance first.
Relevance values are non-negative floating-point numbers.  Zero relevance
means no similarity.  Relevance is computed based on the number of words
in the row, the number of unique words in that row, the total number of
words in the collection, and the number of documents (rows) that contain
a particular word.

</P>
<P>
It is also possible to perform a boolean mode search.  This is explained
later in the section.

</P>
<P>
The preceding example is a basic illustration showing how to use the
<CODE>MATCH()</CODE> function. Rows are returned in order of decreasing
relevance.

</P>
<P>
The next example shows how to retrieve the relevance values explicitly.
As neither <CODE>WHERE</CODE> nor <CODE>ORDER BY</CODE> clauses are present, returned
rows are not ordered.

</P>

<PRE>
mysql&#62; SELECT id,MATCH title,body AGAINST ('Tutorial') FROM articles;
+----+-----------------------------------------+
| id | MATCH (title,body) AGAINST ('Tutorial') |
+----+-----------------------------------------+
|  1 |                        0.64840710366884 |
|  2 |                                       0 |
|  3 |                        0.66266459031789 |
|  4 |                                       0 |
|  5 |                                       0 |
|  6 |                                       0 |
+----+-----------------------------------------+
6 rows in set (0.00 sec)
</PRE>

<P>
The following example is more complex.  The query returns the relevance
and still sorts the rows in order of decreasing relevance. To achieve
this result, you should specify <CODE>MATCH()</CODE> twice. This will cause no
additional overhead, because the MySQL optimiser will notice that the
two <CODE>MATCH()</CODE> calls are identical and invoke the full-text search
code only once.

</P>

<PRE>
mysql&#62; SELECT id, body, MATCH (title,body) AGAINST
    -&#62; ('Security implications of running MySQL as root') AS score
    -&#62; FROM articles WHERE MATCH (title,body) AGAINST
    -&#62; ('Security implications of running MySQL as root');
+----+-------------------------------------+-----------------+
| id | body                                | score           |
+----+-------------------------------------+-----------------+
|  4 | 1. Never run mysqld as root. 2. ... | 1.5055546709332 |
|  6 | When configured properly, MySQL ... |   1.31140957288 |
+----+-------------------------------------+-----------------+
2 rows in set (0.00 sec)
</PRE>

<P>
MySQL uses a very simple parser to split text into words.  A ``word''
is any sequence of characters consisting of letters, digits, <SAMP>`''</SAMP>,
and <SAMP>`_'</SAMP>.  Any ``word'' that is present in the stopword list or is just
too short (3 characters or less) is ignored.

</P>
<P>
Every correct word in the collection and in the query is weighted
according to its significance in the query or collection.  This way, a
word that is present in many documents will have lower weight (and may
even have a zero weight), because it has lower semantic value in this
particular collection.  Otherwise, if the word is rare, it will receive a
higher weight.  The weights of the words are then combined to compute the
relevance of the row.

</P>
<P>
Such a technique works best with large collections (in fact, it was
carefully tuned this way).  For very small tables, word distribution
does not reflect adequately their semantic value, and this model
may sometimes produce bizarre results.

</P>

<PRE>
mysql&#62; SELECT * FROM articles WHERE MATCH (title,body) AGAINST ('MySQL');
Empty set (0.00 sec)
</PRE>

<P>
The search for the word <CODE>MySQL</CODE> produces no results in the above
example, because that word is present in more than half the rows.  As such,
it is effectively treated as a stopword (that is, a word with zero semantic
value).  This is the most desirable behaviour -- a natural language query
should not return every second row from a 1GB table.

</P>
<P>
A word that matches half of rows in a table is less likely to locate relevant
documents.  In fact, it will most likely find plenty of irrelevant documents.
We all know this happens far too often when we are trying to find something on
the Internet with a search engine.  It is with this reasoning that such rows
have been assigned a low semantic value in <STRONG>this particular dataset</STRONG>.

</P>
<P>
As of Version 4.0.1, MySQL can also perform boolean full-text searches using
the <CODE>IN BOOLEAN MODE</CODE> modifier.

</P>

<PRE>
mysql&#62; SELECT * FROM articles WHERE MATCH (title,body)
    -&#62;     AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);
+----+------------------------------+-------------------------------------+
| id | title                        | body                                |
+----+------------------------------+-------------------------------------+
|  1 | MySQL Tutorial               | DBMS stands for DataBase ...        |
|  2 | How To Use MySQL Efficiently | After you went through a ...        |
|  3 | Optimising MySQL             | In this tutorial we will show ...   |
|  4 | 1001 MySQL Tricks            | 1. Never run mysqld as root. 2. ... |
|  6 | MySQL Security               | When configured properly, MySQL ... |
+----+------------------------------+-------------------------------------+
</PRE>

<P>
This query retrieved all the rows that contain the word <CODE>MySQL</CODE>
(note: the 50% threshold is not used), but that do <STRONG>not</STRONG> contain
the word <CODE>YourSQL</CODE>.  Note that a boolean mode search does not
automatically sort rows in order of decreasing relevance.  You can
see this from result of the preceding query, where the row with the
highest relevance (the one that contains <CODE>MySQL</CODE> twice) is listed
last, not first.  A boolean full-text search can also work even without
a <CODE>FULLTEXT</CODE> index, although it would be <STRONG>slow</STRONG>.

</P>
<P>
The boolean full-text search capability supports the following operators:

</P>
<DL COMPACT>

<DT><CODE>+</CODE>
<DD>
A leading plus sign indicates that this word <STRONG>must be</STRONG>
present in every row returned.
<DT><CODE>-</CODE>
<DD>
A leading minus sign indicates that this word <STRONG>must not be</STRONG>
present in any row returned.
<DT><CODE></CODE>
<DD>
By default (when neither plus nor minus is specified) the word is optional,
but the rows that contain it will be rated higher. This mimicks the
behaviour of <CODE>MATCH() ... AGAINST()</CODE> without the <CODE>IN BOOLEAN
MODE</CODE> modifier.
<DT><CODE>&#60; &#62;</CODE>
<DD>
These two operators are used to change a word's contribution to the
relevance value that is assigned to a row.  The <CODE>&#60;</CODE> operator
decreases the contribution and the <CODE>&#62;</CODE> operator increases it.
See the example below.
<DT><CODE>( )</CODE>
<DD>
Parentheses are used to group words into subexpressions.
<DT><CODE>~</CODE>
<DD>
A leading tilde acts as a negation operator, causing the word's
contribution to the row relevance to be negative. It's useful for marking
noise words. A row that contains such a word will be rated lower than
others, but will not be excluded altogether, as it would be with the
<CODE>-</CODE> operator.
<DT><CODE>*</CODE>
<DD>
An asterisk is the truncation operator. Unlike the other operators, it
should be <STRONG>appended</STRONG> to the word, not prepended.
<DT><CODE>"</CODE>
<DD>
The phrase, that is enclosed in double quotes <CODE>"</CODE>, matches only
rows that contain this phrase <STRONG>literally, as it was typed</STRONG>.
</DL>

<P>
And here are some examples:

</P>
<DL COMPACT>

<DT><CODE>apple banana</CODE>
<DD>
find rows that contain at least one of these words.
<DT><CODE>+apple +juice</CODE>
<DD>
... both words.
<DT><CODE>+apple macintosh</CODE>
<DD>
... word ``apple'', but rank it higher if it also contain ``macintosh''.
<DT><CODE>+apple -macintosh</CODE>
<DD>
... word ``apple'' but not ``macintosh''.
<DT><CODE>+apple +(&#62;pie &#60;strudel)</CODE>
<DD>
... ``apple'' and ``pie'', or ``apple'' and ``strudel'' (in any
order), but rank ``apple pie'' higher than ``apple strudel''.
<DT><CODE>apple*</CODE>
<DD>
... ``apple'', ``apples'', ``applesauce'', and ``applet''.
<DT><CODE>"some words"</CODE>
<DD>
... ``some words of wisdom'', but not ``some noise words''.
</DL>



<H3><A NAME="Fulltext_Restrictions" HREF="manual.ja_toc.html#Fulltext_Restrictions">6.8.1  Full-text Restrictions</A></H3>


<UL>
<LI>

All parameters to the <CODE>MATCH()</CODE> function must be columns from the
same table that is part of the same <CODE>FULLTEXT</CODE> index, unless the
<CODE>MATCH()</CODE> is <CODE>IN BOOLEAN MODE</CODE>.
<LI>

The <CODE>MATCH()</CODE> column list must exactly match the column list in some
<CODE>FULLTEXT</CODE> index definition for the table, unless this <CODE>MATCH()</CODE>
is <CODE>IN BOOLEAN MODE</CODE>.
<LI>

The argument to <CODE>AGAINST()</CODE> must be a constant string.
</UL>



<H3><A NAME="Fulltext_Fine-tuning" HREF="manual.ja_toc.html#Fulltext_Fine-tuning">6.8.2  Fine-tuning MySQL Full-text Search</A></H3>

<P>
Unfortunately, full-text search has few user-tunable parameters yet,
although adding some is very high on the TODO. If you have a
MySQL source distribution ( 「<A HREF="manual.ja_Installing.html#Installing_source">2.3  MySQL ソースディストリビューションのインストール</A>」節参照), you can
exert more control over full-text searching behaviour.

</P>
<P>
Note that full-text search was carefully tuned for the best searching
effectiveness.  Modifying the default behaviour will, in most cases,
only make the search results worse.  Do not alter the MySQL sources
unless you know what you are doing!

</P>

<UL>

<LI>

The minimum length of words to be indexed is defined by the MySQL
variable <CODE>ft_min_word_len</CODE>.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.
Change it to the value you prefer, and rebuild your <CODE>FULLTEXT</CODE> indexes.
(This variable is only available from MySQL version 4.0.)

<LI>

The stopword list can be loaded from file specified by
<CODE>ft_stopword_file</CODE> variable.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.
Rebuild your <CODE>FULLTEXT</CODE> indexes after modifying the stopword list.
(This variable is only available from MySQL version 4.0.10 and onwards)

<LI>

The 50% threshold is determined by the particular weighting scheme chosen.
To disable it, change the following line in <TT>`myisam/ftdefs.h'</TT>:

<PRE>
#define GWS_IN_USE GWS_PROB
</PRE>

To:

<PRE>
#define GWS_IN_USE GWS_FREQ
</PRE>

Then recompile MySQL.
There is no need to rebuild the indexes in this case.
<STRONG>Note</STRONG>: by doing this you <STRONG>severely</STRONG> decrease MySQL's ability
to provide adequate relevance values for the <CODE>MATCH()</CODE> function.
If you really need to search for such common words, it would be better to
search using <CODE>IN BOOLEAN MODE</CODE> instead, which does not observe the 50%
threshold.

<LI>

Sometimes the search engine maintainer would like to change the operators used
for boolean full-text searches. These are defined by the
<CODE>ft_boolean_syntax</CODE> variable.
 「<A HREF="manual.ja_MySQL_Database_Administration.html#SHOW_VARIABLES">4.5.6.4  <CODE>SHOW VARIABLES</CODE></A>」節参照.
Still, this variable is read-only, its value is set in
<TT>`myisam/ft_static.c'</TT>.

</UL>

<P>
For those changes that require you to rebuild your <CODE>FULLTEXT</CODE> indexes,
the easiest way to do so for a MyISAM table is to use the following
statement, which rebuilds the index file:

</P>

<PRE>
mysql&#62; REPAIR TABLE tbl_name QUICK;
</PRE>



<H3><A NAME="Fulltext_TODO" HREF="manual.ja_toc.html#Fulltext_TODO">6.8.3  Full-text Search TODO</A></H3>


<UL>
<LI>Make all operations with <CODE>FULLTEXT</CODE> index <STRONG>faster</STRONG>.

<LI>Proximity operators

<LI>Support for "always-index words". They could be any strings

the user wants to treat as words, examples are "C++", "AS/400", "TCP/IP", etc.
<LI>Support for full-text search in <CODE>MERGE</CODE> tables.

<LI>Support for multi-byte charsets.

<LI>Make stopword list to depend of the language of the data.

<LI>Stemming (dependent of the language of the data, of course).

<LI>Generic user-suppliable UDF preparser.

<LI>Make the model more flexible (by adding some adjustable

parameters to <CODE>FULLTEXT</CODE> in <CODE>CREATE/ALTER TABLE</CODE>).
</UL>



<H2><A NAME="Query_Cache" HREF="manual.ja_toc.html#Query_Cache">6.9  MySQL Query Cache (4.0.1以上)</A></H2>

<P>
<A NAME="IDX1514"></A>
<A NAME="IDX1515"></A>

</P>
<P>
From version 4.0.1, <CODE>MySQL server</CODE> features a <CODE>Query Cache</CODE>.
When in use, the query cache stores the text of a <CODE>SELECT</CODE> query
together with the corresponding result that was sent to the client.
If an identical query is later received, the server will retrieve
the results from the query cache rather than parsing and executing the
same query again.

</P>
<P>
<STRONG>NOTE:</STRONG> The query cache does not return stale data. When data
is modified, any relevant entries in the query cache are flushed.

</P>
<P>
The query cache is extremely useful in an environment where (some)
tables don't change very often and you have a lot of identical queries.
This is a typical situation for many web servers that use a lot of
dynamic content.

</P>
<P>
Below is some performance data for the query cache. (These results were 
generated by running the MySQL benchmark suite on a Linux Alpha
2 x 500 MHz with 2GB RAM and a 64MB query cache):

</P>

<UL>
<LI>

If all of the queries you're performing are simple (such as selecting a
row from a table with one row); but still differ so that the queries can
not be cached, the overhead for having the query cache active is 13%.
This could be regarded as the worst case scenario. However, in real life,
queries are much more complicated than our simple example so the overhead
is normally significantly lower.
<LI>

Searches after one row in a one row table is 238% faster.
This can be regarded as close to the minimum speedup to be expected for
a query that is cached.
<LI>

If you want to disable the query cache code set <CODE>query_cache_size=0</CODE>.
By disabling the query cache code there is no noticeable overhead.
(query cache can be excluded from code with help of configure option
<CODE>--without-query-cache</CODE>)
</UL>



<H3><A NAME="Query_Cache_How" HREF="manual.ja_toc.html#Query_Cache_How">6.9.1  How The Query Cache Operates</A></H3>

<P>
Queries are compared before parsing, thus

</P>

<PRE>
SELECT * FROM tbl_name
</PRE>

<P>
and

</P>

<PRE>
Select * from tbl_name
</PRE>

<P>
are regarded as different queries for query cache, so queries need
to be exactly the same (byte for byte) to be seen as identical.
In addition, a query may be seen as different if for instance one
client is using a new communication protocol format or another
character set than another client.

</P>
<P>
Queries that uses different databases, uses different protocol versions
or the uses different default character sets are considered different
queries and cached separately.

</P>
<P>
The cache does work for <CODE>SELECT CALC_ROWS ...</CODE> and
<CODE>SELECT FOUND_ROWS() ...</CODE> type queries because the number of
found rows is also stored in the cache.

</P>
<P>
If query result was returned from query cache then status variable
<CODE>Com_select</CODE> will not be increased, but <CODE>Qcache_hits</CODE> will be. 
 「<A HREF="manual.ja_Reference.html#Query_Cache_Status_and_Maintenance">6.9.4  Query Cache Status and Maintenance</A>」節参照.

</P>
<P>
If a table changes (<CODE>INSERT</CODE>, <CODE>UPDATE</CODE>, <CODE>DELETE</CODE>,
<CODE>TRUNCATE</CODE>, <CODE>ALTER</CODE> or <CODE>DROP TABLE|DATABASE</CODE>),
then all cached queries that used this table (possibly through a
<CODE>MRG_MyISAM</CODE> table!) become invalid and are removed from the cache.

</P>
<P>
Transactional <CODE>InnoDB</CODE> tables that have been changed will be invalidated
when a <CODE>COMMIT</CODE> is performed.

</P>
<P>
A query cannot be cached if it contains one of the functions:
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Function</STRONG>
 </TD><TD> <STRONG>Function</STRONG>
 </TD><TD> <STRONG>Function</STRONG>
</TR NOSAVE>
<TR><TD><CODE>User-Defined Functions</CODE>
 </TD><TD> <CODE>CONNECTION_ID</CODE>
 </TD><TD> <CODE>FOUND_ROWS</CODE>
</TR NOSAVE>
<TR><TD><CODE>GET_LOCK</CODE>
 </TD><TD> <CODE>RELEASE_LOCK</CODE>
 </TD><TD> <CODE>LOAD_FILE</CODE>
</TR NOSAVE>
<TR><TD><CODE>MASTER_POS_WAIT</CODE>
 </TD><TD> <CODE>NOW</CODE>
 </TD><TD> <CODE>SYSDATE</CODE>
</TR NOSAVE>
<TR><TD><CODE>CURRENT_TIMESTAMP</CODE>
 </TD><TD> <CODE>CURDATE</CODE>
 </TD><TD> <CODE>CURRENT_DATE</CODE>
</TR NOSAVE>
<TR><TD><CODE>CURTIME</CODE>
 </TD><TD> <CODE>CURRENT_TIME</CODE>
 </TD><TD> <CODE>DATABASE</CODE>
</TR NOSAVE>
<TR><TD><CODE>ENCRYPT</CODE> (with one parameter)
 </TD><TD> <CODE>LAST_INSERT_ID</CODE>
 </TD><TD> <CODE>RAND</CODE>
</TR NOSAVE>
<TR><TD><CODE>UNIX_TIMESTAMP</CODE> (without parameters)
 </TD><TD> <CODE>USER</CODE>
 </TD><TD> <CODE>BENCHMARK</CODE>
</TR>
</TABLE>

</P>
<P>
Nor can a query be cached if it contains user variables,
references the mysql system database,
is of the form <CODE>SELECT ... IN SHARE MODE</CODE>,
<CODE>SELECT ... INTO OUTFILE ...</CODE>,
<CODE>SELECT ... INTO DUMPFILE ...</CODE> or
of the form <CODE>SELECT * FROM AUTOINCREMENT_FIELD IS NULL</CODE>
(to retrieve last insert id - ODBC work around).

</P>
<P>
However, <CODE>FOUND ROWS()</CODE> will return the correct value,
even if the preceding query was fetched from the cache.

</P>
<P>
In case a query does not use any tables, or uses temporary tables,
or if the user has a column privilege for any of the involved tables,
that query will not be cached.

</P>
<P>
Before a query is fetched from the query cache, MySQL will check that
the user has SELECT privilege to all the involved databases and
tables. If this is not the case, the cached result will not be used.

</P>


<H3><A NAME="Query_Cache_Configuration" HREF="manual.ja_toc.html#Query_Cache_Configuration">6.9.2  Query Cache Configuration</A></H3>

<P>
The query cache adds a few <CODE>MySQL</CODE> system variables for
<CODE>mysqld</CODE> which may be set in a configuration file, on the
command-line when starting <CODE>mysqld</CODE>.

</P>

<UL>
<LI><CODE>query_cache_limit</CODE>

Don't cache results that are bigger than this. (Default 1M).

<LI><CODE>query_cache_size</CODE>

The amount of memory (specified in bytes) allocated to store results from
old queries. If this is 0, the query cache is disabled (default).

<LI><CODE>query_cache_type</CODE>

This may be set (only numeric) to
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Option</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD>0 </TD><TD> (OFF, don't cache or retrieve results)
</TR NOSAVE>
<TR><TD>1 </TD><TD> (ON, cache all results except <CODE>SELECT SQL_NO_CACHE ...</CODE> queries)
</TR NOSAVE>
<TR><TD>2 </TD><TD> (DEMAND, cache only <CODE>SELECT SQL_CACHE ...</CODE> queries)
</TR>
</TABLE>
</UL>

<P>
Inside a thread (connection), the behaviour of the query cache can be
changed from the default. The syntax is as follows:

</P>
<P>
<CODE>QUERY_CACHE_TYPE = OFF | ON | DEMAND</CODE>
<CODE>QUERY_CACHE_TYPE = 0   | 1  | 2</CODE>

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Option</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD>0 or OFF </TD><TD> Don't cache or retrieve results.
</TR NOSAVE>
<TR><TD>1 or ON </TD><TD> Cache all results except <CODE>SELECT SQL_NO_CACHE ...</CODE> queries.
</TR NOSAVE>
<TR><TD>2 or DEMAND </TD><TD> Cache only <CODE>SELECT SQL_CACHE ...</CODE> queries.
</TR>
</TABLE>



<H3><A NAME="Query_Cache_in_SELECT" HREF="manual.ja_toc.html#Query_Cache_in_SELECT">6.9.3  Query Cache Options in <CODE>SELECT</CODE></A></H3>

<P>
There are two possible query cache related parameters that may be
specified in a <CODE>SELECT</CODE> query:

</P>
<P>
<A NAME="IDX1516"></A>
<A NAME="IDX1517"></A>

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Option</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>SQL_CACHE</CODE>
 </TD><TD> If <CODE>QUERY_CACHE_TYPE</CODE> is <CODE>DEMAND</CODE>, allow the query to be cached.
 If <CODE>QUERY_CACHE_TYPE</CODE> is <CODE>ON</CODE>, this is the default.
 If <CODE>QUERY_CACHE_TYPE</CODE> is <CODE>OFF</CODE>, do nothing.
</TR NOSAVE>
<TR><TD><CODE>SQL_NO_CACHE</CODE>
 </TD><TD> Make this query non-cachable, don't allow this query to be stored in the cache.
</TR>
</TABLE>



<H3><A NAME="Query_Cache_Status_and_Maintenance" HREF="manual.ja_toc.html#Query_Cache_Status_and_Maintenance">6.9.4  Query Cache Status and Maintenance</A></H3>

<P>
With the <CODE>FLUSH QUERY CACHE</CODE> command you can defragment the query
cache to better utilise its memory. This command will not remove any
queries from the cache.
<CODE>FLUSH TABLES</CODE> also flushes the query cache.

</P>
<P>
The <CODE>RESET QUERY CACHE</CODE> command removes all query results from the
query cache.

</P>
<P>
You can check whether the query cache is present in your MySQL version:

</P>

<PRE>
mysql&#62; SHOW VARIABLES LIKE 'have_query_cache';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
1 row in set (0.00 sec)
</PRE>

<P>
You can monitor query cache performance in <CODE>SHOW STATUS</CODE>:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Variable</STRONG> </TD><TD> <STRONG>Description</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Qcache_queries_in_cache</CODE>
 </TD><TD> Number of queries registered in the cache.
</TR NOSAVE>
<TR><TD><CODE>Qcache_inserts</CODE>
 </TD><TD> Number of queries added to the cache.
</TR NOSAVE>
<TR><TD><CODE>Qcache_hits</CODE>
 </TD><TD> Number of cache hits.
</TR NOSAVE>
<TR><TD><CODE>Qcache_lowmem_prunes</CODE>
 </TD><TD> Number of queries that were deleted from cache because of low memory.
</TR NOSAVE>
<TR><TD><CODE>Qcache_not_cached</CODE>
 </TD><TD> Number of non-cached queries
 (not cachable, or due to <CODE>QUERY_CACHE_TYPE</CODE>).
</TR NOSAVE>
<TR><TD><CODE>Qcache_free_memory</CODE>
 </TD><TD> Amount of free memory for query cache.
</TR NOSAVE>
<TR><TD><CODE>Qcache_free_blocks</CODE>
 </TD><TD> Number of free memory blocks in query cache.
</TR NOSAVE>
<TR><TD><CODE>Qcache_total_blocks</CODE>
 </TD><TD> Total number of blocks in query cache.
</TR>
</TABLE>

<P>
Total number of queries =
<CODE>Qcache_inserts</CODE> + <CODE>Qcache_hits</CODE> + <CODE>Qcache_not_cached</CODE>.

</P>
<P>
The query cache uses variable length blocks, so <CODE>Qcache_total_blocks</CODE>
and <CODE>Qcache_free_blocks</CODE> may indicate query cache memory fragmentation.
After <CODE>FLUSH QUERY CACHE</CODE> only a single (big) free block remains.

</P>
<P>
Note: Every query needs a minimum of two blocks (one for the query text
and one or more for the query results). Also, every table that is used
by a query needs one block, but if two or more queries use same table
only one block needs to be allocated.

</P>
<P>
You can use the <CODE>Qcache_lowmem_prunes</CODE> status variable to tune the query
cache size. It counts the number of queries that have been removed from the
cache to free up memory for caching new queries. The query cache uses a
<CODE>least recently used</CODE> (<CODE>LRU</CODE>) strategy to decide which queries to
remove from the cache.

</P>
<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_MySQL_Optimisation.html">previous</A>, <A HREF="manual.ja_Table_types.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
