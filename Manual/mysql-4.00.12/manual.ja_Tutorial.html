  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 4 March 2004 -->

  <TITLE>MySQL Reference Manual for version 4.0.12. - 3  Tutorial Introduction</TITLE>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=euc-jp">
  </HEAD>
  <BODY BGCOLOR=silver TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Installing.html">previous</A>, <A HREF="manual.ja_MySQL_Database_Administration.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Tutorial" HREF="manual.ja_toc.html#Tutorial">3  Tutorial Introduction</A></H1>

<P>
<A NAME="IDX358"></A>
<A NAME="IDX359"></A>
<A NAME="IDX360"></A>
<A NAME="IDX361"></A>

</P>

<P>
この章では、 <CODE>mysql</CODE> クライアントプログラムの使用の仕方と
単純なデータベースの作成と使用の仕方を例題としてとり上げます。
<CODE>mysql</CODE> (``terminal monitor'' や ``monitor'' として参照されます)は
MySQL サーバーに接続できる対話モードのプログラムで、
クエリの実行や結果の表示が可能です。
<CODE>mysql</CODE> はバッチモードも可能です： クエリをまずファイルに書いておき、
そしてそのファイルを <CODE>mysql</CODE> に実行させます。
どちらの方法でも <CODE>mysql</CODE> はこの章の説明でカバーされます。

</P>
<P>
<CODE>mysql</CODE> の提供するオプションを見るには、 <CODE>--help</CODE> オプションを
実行します：

</P>

<PRE>
shell&#62; mysql --help
</PRE>

<P>
この章では <CODE>mysql</CODE> が既にあなたのマシンにインストールされているものとし、
また MySQL サーバーに接続可能であるとします。 もしそうでないなら、
あなたの MySQL 管理者に連絡を取ってください。
(もし<STRONG>あなた自身が</STRONG>管理者なら、このマニュアルの他のセクションを参照してください。)

</P>
<P>
本章ではデータベース設定の全体のプロセス、データベースの使用について述べます。
もしあなたが既に存在しているデータベースにアクセスする事だけに興味があるなら、
この章のデータベース、テーブルの作成方法の説明を読み飛ばしてもかまいません。

</P>
<P>
この章が本質的にはチュートリアルであるので、多くの詳細は、かならず違う章にあります。
ここに書かれている事柄で、
さらに詳しい情報についてはマニュアルの適切なセクションを調べて下さい。 

</P>



<H2><A NAME="Connecting-disconnecting" HREF="manual.ja_toc.html#Connecting-disconnecting">3.1  サーバーへの接続と切断</A></H2>

<P>
<A NAME="IDX362"></A>
<A NAME="IDX363"></A>
<A NAME="IDX364"></A>
<A NAME="IDX365"></A>

</P>
<P>
サーバーに <CODE>mysql</CODE> コマンドから接続するためには、通常、
MySQL ユーザ名、パスワードを指定する必要があるでしょう。
もしあなたがログインしている以外のマシンの上でサーバーが走っていれば、
あなたは、ホスト名を明示する必要があるでしょう。
まずあなたの管理者に問い合わせて、あなたが使うべき接続のためのパラメーターを見つけ出して下さい。
(すなわち、どのようなホスト、ユーザー名とパスワードを使うべきなのか。)
適切なパラメーターを知っていれば、あなたは、以下のようにして接続できます：

</P>

<PRE>
shell&#62; mysql -h host -u user -p
Enter password: ********
</PRE>

<P>
<CODE>********</CODE> とかかれている部分にはあなたのパスワードを入れます；
<CODE>mysql</CODE> が <CODE>Enter password:</CODE> プロンプトを出したときに。

</P>
<P>
きちんと動けば、いくつかの情報と <CODE>mysql&#62;</CODE> プロンプトが現れます：

</P>

<PRE>
shell&#62; mysql -h host -u user -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 459 to server version: 3.22.20a-log

Type 'help' for help.

mysql&#62;
</PRE>

<P>
このプロンプトは <CODE>mysql</CODE> がコマンド入力を待っている状態を示します。

</P>
<P>
いくつかの MySQL インストレーションでは、ローカルホストで
実行されているサーバーに、ユーザーに``匿名''(名前無し)の接続を許しています。
もしあなたのマシンがこの場合に当てはまるなら、<CODE>mysql</CODE> をオプション無しで
起動すべきです：

</P>

<PRE>
shell&#62; mysql
</PRE>

<P>
接続が成功した後、 <CODE>mysql&#62;</CODE> プロンプトで、<CODE>QUIT</CODE> とタイプすれば
いつでも接続を切ることができます：

</P>

<PRE>
mysql&#62; QUIT
Bye
</PRE>

<P>
Control-D で切断してもかまいません。

</P>
<P>
以下のセクションでのほとんどの例では、あなたがサーバーに接続しているものと
しています。その場合は <CODE>mysql&#62;</CODE> プロンプトによって、それを示しています。

</P>



<H2><A NAME="Entering_queries" HREF="manual.ja_toc.html#Entering_queries">3.2  Entering Queries</A></H2>

<P>
<A NAME="IDX366"></A>
<A NAME="IDX367"></A>
<A NAME="IDX368"></A>

</P>
<P>
前のセクションで述べたように、あなたがサーバーとつながっていることを確かめて下さい。
この状態ではまだどんなデータベースも選択していない状態です。しかしそれはかまいません。
ここでは、テーブルの作成やデータの入力、取り出しよりも、
いかにクエリを発行するかに重点を置きます。
このセクションでは、あなた自身を <CODE>mysql</CODE> の動きに慣れさせるために、
あなたがやってみることができるであろう、いくつかのクエリを使用して、
コマンド入力の基本的な原則を述べます。

</P>
<P>
サーバーのバージョン、今日の日付をサーバーに問い合わせる、単純なコマンド
がここにあります。 以下のように <CODE>mysql&#62;</CODE> プロンプトの後に入力し
 RETURN キーを押してみてください：

</P>

<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
+--------------+--------------+
| VERSION()    | CURRENT_DATE |
+--------------+--------------+
| 3.22.20a-log | 1999-03-19   |
+--------------+--------------+
1 row in set (0.01 sec)
mysql&#62;
</PRE>

<P>
このクエリは、<CODE>mysql</CODE> のいくつかの事を説明しています：

</P>

<UL>
<LI>

通常、コマンドは、セミコロンで終わる SQL ステートメントから、構成されます。
(セミコロンが必要とされないいくつかの例外があります。
以前に述べた <CODE>QUIT</CODE> はそのうちの一つです。後で他も出てきます。)

<LI>

コマンドを発行すると、<CODE>mysql</CODE> はそれをサーバーに送り、結果を表示します。
その後、 <CODE>mysql&#62;</CODE> プロンプトを出し、他のコマンドが受け付けれる状態であると
示します。

<LI>

<CODE>mysql</CODE> はクエリの結果を表にして出します。 最初の行は項目のラベル名です。
その下の行に、クエリの結果が続きます。 通常、項目のラベル名はデータベースのテーブルから
あなたが取り出したフィールド名になります。 テーブルのフィールド名以外の式を
あなたが検索したのなら(ちょうど例のように)、<CODE>mysql</CODE> は与えられた式自身を
項目のラベル名として表示します。

<LI>

<CODE>mysql</CODE> は何レコード(rows)返ってきたかを示し、実行にどれくらいの時間が
かかったかも示します。 これはおおざっぱなサーバーのパフォーマンスを示します。
これらの値は wall clock time (CPU や マシンタイムではなく) を使用しており、さらに、
サーバーの負荷、およびネットワーク待ち時間といった要因にも影響されるので、
不正確です。
(この章の他の例題においては ``rows in set'' の行は省きます。)
</UL>

<P>
キーワードは、いかなる大文字小文字でも記述できます。
以下に示すクエリは同じです：

</P>

<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
mysql&#62; select version(), current_date;
mysql&#62; SeLeCt vErSiOn(), current_DATE;
</PRE>

<P>
以下のクエリは、<CODE>mysql</CODE> を簡単な計算機として使用した例です：

</P>

<PRE>
mysql&#62; SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
</PRE>

<P>
今までは見てきたたコマンドは、比較的短い、一行のの文です。
あなたは一行に複数、文を書くことが出来ます。
それぞれの文の終わりにはセミコロンを付けます： 

</P>

<PRE>
mysql&#62; SELECT VERSION(); SELECT NOW();
+--------------+
| VERSION()    |
+--------------+
| 3.22.20a-log |
+--------------+

+---------------------+
| NOW()               |
+---------------------+
| 1999-03-19 00:15:33 |
+---------------------+
</PRE>

<P>
コマンドは一行にかく必要もありません。 複数行にわたる長いコマンドでも問題ありません。
<CODE>mysql</CODE> はセミコロンで、一文の終わりと見なします。 その行の最後を文の最後とは
見なしません。 （いうなれば、<CODE>mysql</CODE> は自由な入力を許し、セミコロンが現れるまでは
それらの入力された行を実行しません）

</P>
<P>
複数行にまたがった文の例です：

</P>

<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; ,
    -&#62; CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| joesmith@localhost | 1999-03-18   |
+--------------------+--------------+
</PRE>

<P>
この例では、複数にまたがるクエリにおいて、最初の行の入力のあと、
いかにプロンプトが <CODE>mysql&#62;</CODE> から <CODE>-&#62;</CODE> に変わるかを示しています。
これは <CODE>mysql</CODE> が、まだ文が終わっておらず、残りの部分の入力を待っている
ことを示します。プロンプトは役立つフィードバックを提供してくれるあなたの友
人です。そのフィードバックを使用すると、<CODE>mysql</CODE> が何を待っているのか
にいつも気が付くでしょう。

</P>
<P>
入力中にコマンドの実行を取りやめようと思った場合、
<CODE>\c</CODE> でこれをキャンセルできます：

</P>

<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; \c
mysql&#62;
</PRE>

<P>
ここでもプロンプトに注意してください。<CODE>\c</CODE> のタイプ後に 
<CODE>mysql&#62;</CODE> に戻っています。<CODE>mysql</CODE> が新しいコマンドの準備ができた
ことを示すフィードバックを提供しています。

</P>
<P>
次のテーブルはあなたが目にするであろう各プロンプトと、それらが意味する 
<CODE>mysql</CODE> がどの状態にあるかについての要約です:

</P>
<P>
<A NAME="IDX369"></A>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>プロンプト</STRONG> </TD><TD> <STRONG>意味</STRONG>
</TR NOSAVE>
<TR><TD><CODE>mysql&#62;</CODE> </TD><TD> 新しいコマンドの待状態
</TR NOSAVE>
<TR><TD><CODE>    -&#62;</CODE> </TD><TD> 複数行にまたがるコマンドの、次の行の入力を待っている状態。
</TR NOSAVE>
<TR><TD><CODE>    '&#62;</CODE> </TD><TD> シングルクオート (<SAMP>`''</SAMP>) で始められた文字の、次の行の入力を待っている状態。
</TR NOSAVE>
<TR><TD><CODE>    "&#62;</CODE> </TD><TD> ダブルクオート (<SAMP>`"'</SAMP>) で始められた文字の、次の行の入力を待っている状態。
</TR>
</TABLE>

</P>
<P>
あなたが文をセミコロンで終わらすことを忘れて実行した場合に、
複数行の入力待ちが起こります。 この場合、 <CODE>mysql</CODE> は
次の入力を待ちます：

</P>

<PRE>
mysql&#62; SELECT USER()
    -&#62;
</PRE>

<P>
If this happens to you (you think you've entered a statement but the only
response is a <CODE>-&#62;</CODE> prompt), most likely <CODE>mysql</CODE> is waiting for the
semicolon.  If you don't notice what the prompt is telling you, you might sit
there for a while before realising what you need to do.  Enter a semicolon to
complete the statement, and <CODE>mysql</CODE> will execute it:

</P>

<PRE>
mysql&#62; SELECT USER()
    -&#62; ;
+--------------------+
| USER()             |
+--------------------+
| joesmith@localhost |
+--------------------+
</PRE>

<P>
The <CODE>'&#62;</CODE> and <CODE>"&#62;</CODE> prompts occur during string collection.
In MySQL, you can write strings surrounded by either <SAMP>`''</SAMP>
or <SAMP>`"'</SAMP> characters (for example, <CODE>'hello'</CODE> or <CODE>"goodbye"</CODE>),
and <CODE>mysql</CODE> lets you enter strings that span multiple lines.  When you
see a <CODE>'&#62;</CODE> or <CODE>"&#62;</CODE> prompt, it means that you've entered a line
containing a string that begins with a <SAMP>`''</SAMP> or <SAMP>`"'</SAMP> quote character,
but have not yet entered the matching quote that terminates the string.
That's fine if you really are entering a multiple-line string, but how likely
is that?  Not very.  More often, the <CODE>'&#62;</CODE> and <CODE>"&#62;</CODE> prompts indicate
that you've inadvertantly left out a quote character.  For example:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE name = "Smith AND age &#60; 30;
    "&#62;
</PRE>

<P>
If you enter this <CODE>SELECT</CODE> statement, then press Enter and wait for the
result, nothing will happen.  Instead of wondering why this
query takes so long, notice the clue provided by the <CODE>"&#62;</CODE> prompt.  It
tells you that <CODE>mysql</CODE> expects to see the rest of an unterminated
string.  (Do you see the error in the statement?  The string <CODE>"Smith</CODE> is
missing the second quote.)

</P>
<P>
At this point, what do you do?  The simplest thing is to cancel the command.
However, you cannot just type <CODE>\c</CODE> in this case, because <CODE>mysql</CODE>
interprets it as part of the string that it is collecting!  Instead, enter
the closing quote character (so <CODE>mysql</CODE> knows you've finished the
string), then type <CODE>\c</CODE>:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE name = "Smith AND age &#60; 30;
    "&#62; "\c
mysql&#62;
</PRE>

<P>
The prompt changes back to <CODE>mysql&#62;</CODE>, indicating that <CODE>mysql</CODE>
is ready for a new command.

</P>
<P>
It's important to know what the <CODE>'&#62;</CODE> and <CODE>"&#62;</CODE> prompts signify,
because if you mistakenly enter an unterminated string, any further lines you
type will appear to be ignored by <CODE>mysql</CODE>@-including a line
containing <CODE>QUIT</CODE>!  This can be quite confusing, especially if you
don't know that you need to supply the terminating quote before you can
cancel the current command.

</P>



<H2><A NAME="Database_use" HREF="manual.ja_toc.html#Database_use">3.3  Creating and Using a Database</A></H2>

<P>
<A NAME="IDX370"></A>
<A NAME="IDX371"></A>
<A NAME="IDX372"></A>

</P>

<P>
Now that you know how to enter commands, it's time to access a database.

</P>
<P>
Suppose you have several pets in your home (your menagerie) and you'd
like to keep track of various types of information about them.  You can do so
by creating tables to hold your data and loading them with the desired
information.  Then you can answer different sorts of questions about your
animals by retrieving data from the tables.  This section shows you how to:

</P>

<UL>
<LI>

Create a database
<LI>

Create a table
<LI>

Load data into the table
<LI>

Retrieve data from the table in various ways
<LI>

Use multiple tables
</UL>

<P>
The menagerie database will be simple (deliberately), but it is not difficult
to think of real-world situations in which a similar type of database might
be used.  For example, a database like this could be used by a farmer to keep
track of livestock, or by a veterinarian to keep track of patient records.
A menagerie distribution containing some of the queries and sample data used
in the following sections can be obtained from the MySQL web site.
It's available in either compressed <CODE>tar</CODE> format
(<a HREF="http://www.mysql.com/Downloads/Contrib/Examples/menagerie.tar.gz">http://www.mysql.com/Downloads/Contrib/Examples/menagerie.tar.gz</a>)
or Zip format
(<a HREF="http://www.mysql.com/Downloads/Contrib/Examples/menagerie.zip">http://www.mysql.com/Downloads/Contrib/Examples/menagerie.zip</a>).

</P>
<P>
Use the <CODE>SHOW</CODE> statement to find out what databases currently exist
on the server:

</P>

<PRE>
mysql&#62; SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
</PRE>

<P>
The list of databases is probably different on your machine, but the
<CODE>mysql</CODE> and <CODE>test</CODE> databases are likely to be among them.  The
<CODE>mysql</CODE> database is required because it describes user access
privileges.  The <CODE>test</CODE> database is often provided as a workspace for
users to try things out.

</P>
<P>
Note that you may not see all databases if you don't have the
<CODE>SHOW DATABASES</CODE> privilege.  「<A HREF="manual.ja_MySQL_Database_Administration.html#GRANT">4.3.1  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照.

</P>
<P>
If the <CODE>test</CODE> database exists, try to access it:

</P>

<PRE>
mysql&#62; USE test
Database changed
</PRE>

<P>
Note that <CODE>USE</CODE>, like <CODE>QUIT</CODE>, does not require a semicolon.  (You
can terminate such statements with a semicolon if you like; it does no harm.)
The <CODE>USE</CODE> statement is special in another way, too:  it must be given on
a single line.

</P>
<P>
You can use the <CODE>test</CODE> database (if you have access to it) for the
examples that follow, but anything you create in that database can be
removed by anyone else with access to it.  For this reason, you should
probably ask your MySQL administrator for permission to use a
database of your own.  Suppose you want to call yours <CODE>menagerie</CODE>.  The
administrator needs to execute a command like this:

</P>

<PRE>
mysql&#62; GRANT ALL ON menagerie.* TO your_mysql_name;
</PRE>

<P>
where <CODE>your_mysql_name</CODE> is the MySQL user name assigned to
you.

</P>



<H3><A NAME="Creating_database" HREF="manual.ja_toc.html#Creating_database">3.3.1  Creating and Selecting a Database</A></H3>

<P>
<A NAME="IDX373"></A>
<A NAME="IDX374"></A>

</P>
<P>
If the administrator creates your database for you when setting up your
permissions, you can begin using it.  Otherwise, you need to create it
yourself:

</P>

<PRE>
mysql&#62; CREATE DATABASE menagerie;
</PRE>

<P>
Under Unix, database names are case-sensitive (unlike SQL keywords), so you
must always refer to your database as <CODE>menagerie</CODE>, not as
<CODE>Menagerie</CODE>, <CODE>MENAGERIE</CODE>, or some other variant.  This is also true
for table names.  (Under Windows, this restriction does not apply, although
you must refer to databases and tables using the same lettercase throughout a
given query.)

</P>
<P>
Creating a database does not select it for use; you must do that explicitly.
To make <CODE>menagerie</CODE> the current database, use this command:

</P>

<PRE>
mysql&#62; USE menagerie
Database changed
</PRE>

<P>
Your database needs to be created only once, but you must select it for use
each time you begin a <CODE>mysql</CODE> session.  You can do this by issuing a
<CODE>USE</CODE> statement as shown above.  Alternatively, you can select the
database on the command-line when you invoke <CODE>mysql</CODE>.  Just specify its
name after any connection parameters that you might need to provide.  For
example:

</P>

<PRE>
shell&#62; mysql -h host -u user -p menagerie
Enter password: ********
</PRE>

<P>
Note that <CODE>menagerie</CODE> is not your password on the command just shown.
If you want to supply your password on the command-line after the <CODE>-p</CODE>
option, you must do so with no intervening space (for example, as
<CODE>-pmypassword</CODE>, not as <CODE>-p mypassword</CODE>).  However, putting your
password on the command-line is not recommended, because doing so exposes it
to snooping by other users logged in on your machine.

</P>



<H3><A NAME="Creating_tables" HREF="manual.ja_toc.html#Creating_tables">3.3.2  テーブルの作成</A></H3>

<P>
<A NAME="IDX375"></A>
<A NAME="IDX376"></A>

</P>
<P>
データベースを作成することは容易ですが、作成しただけでは中身はからっぽです。
例えば <CODE>SHOW TABLES</CODE> を実行してみると以下のようになるでしょう:

</P>

<PRE>
mysql&#62; SHOW TABLES;
Empty set (0.00 sec)
</PRE>

<P>
難しいのはデータベースの構造をどうするかを決定することです。
どんなテーブルが必要で、その中にどんな要素を入れるかです。

</P>
<P>
まずそれぞれのペットに関するレコードを含んだテーブルが必要でしょう。
これは <CODE>pet</CODE> テーブルとしましょう。
そしてその中には、最低でもそれぞれの動物の名前は入れる必要があるでしょう。
名前だけではあまり面白くないのでその他の情報も入れることにしましょう。例えば、もし家族の２人以上がペットを買っているならば、飼い主の名前も入れたくなるでしょう。
またその他にもペットの種類や性別など、いくつかの基本的な情報も入れたくなるかもしれません。

</P>
<P>
年齢はどうでしょうか？
確かにいいかもしれませんが、データベースに蓄積するにはあまり良くないものです。
年齢は時とともに変化します。つまりその都度レコードを更新する必要があるということです。
これに代わるデータとして適切なのは、例えば誕生日です。
そうしておいて年齢が必要なときは今日の日付と誕生日から計算すればよいのです。
MySQL には日付を算術演算する関数がありますので、難しいことはありません。
年齢ではなくて誕生日を記録しておくことには他のメリットもあります。

</P>

<UL>
<LI>

ペットの誕生日が近づいてきたことを知らせてくれる目的にもこのデータベースは使えることになります。
（下らないと思う人は、仕事上の付き合いの関係で、
顧客データベースから誕生日のお祝いメッセージを送らないといけない顧客を割り出す仕事を想定してみてください。）

<LI>

今日の日付以外に、関係する日付からも年齢の計算が出来ます。
例えば、もしペットが死亡した日をデータベースに入れておけば、
そのペットが何歳で死んだのかも簡単に計算することが出来ます。
</UL>

<P>
その他にも <CODE>pet</CODE> テーブルに加えるべき有用な情報はいろいろあるでしょう。
しかしとりあえずはこの辺で十分としましょう。名前、飼い主、種類、性別、誕生日、そして死亡日です。

</P>
<P>
<CODE>CREATE TABLE</CODE> 文を使ってテーブルのレイアウトを指定しましょう：

</P>

<PRE>
mysql&#62; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    -&#62; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
</PRE>

<P>
<CODE>name</CODE>, <CODE>owner</CODE>,そして<CODE>species</CODE> フィールドには
<CODE>VARCHAR</CODE> を用いた方がよいでしょう。なぜならこれらの値の長さは変化するからです。
これらのフィールドの長さは全て同じである必要もなく、<CODE>20</CODE>文字である必要もありません。
<CODE>1</CODE>から<CODE>255</CODE>の間でもっともリーズナブルな値を選べばよいでしょう。
（長さの選択を誤ってあとで文字数が足らなくなったとしても、
MySQLは <CODE>ALTER TABLE</CODE> で長さを変えることができます）

</P>
<P>
動物の性別を表す値にはいくつかのタイプが考えられます。
<CODE>"m"</CODE> と <CODE>"f"</CODE> 、あるいは<CODE>"male"</CODE> と <CODE>"female"</CODE> なども考えられるでしょう。
ここでは最も簡単に、一文字の <CODE>"m"</CODE> と <CODE>"f"</CODE> で表すことにしましょう。

</P>
<P>
<CODE>birth</CODE> と <CODE>death</CODE> のフィールドには、明らかに <CODE>DATE</CODE> データ型を用いるべきでしょう。

</P>
<P>
テーブルを作ってみると、<CODE>SHOW TABLES</CODE> で何らかの出力が得られるはずです：

</P>

<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
</PRE>

<P>
テーブルが期待したとおりに作成されたかどうかをチェックするために、 
<CODE>DESCRIBE</CODE> 文を使います：

</P>

<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P>
<CODE>DESCRIBE</CODE> 文はいつでも、
例えばテーブルの列の名前やそのタイプを忘れてしまったときにも使うことが出来ます。

</P>



<H3><A NAME="Loading_tables" HREF="manual.ja_toc.html#Loading_tables">3.3.3  ファイルからデータをテーブルへ取り込む</A></H3>

<P>
<A NAME="IDX377"></A>
<A NAME="IDX378"></A>
<A NAME="IDX379"></A>

</P>
<P>
テーブルを作ったら、中にデータを入れる必要があります。
このとき <CODE>LOAD DATA</CODE> 文と<CODE>INSERT</CODE> 文を用いると便利です。

</P>
<P>
例えばあなたのペットに関する記録が以下のようになっていたとします。
（MySQLにおける日付の表記が <CODE>'YYYY-MM-DD'</CODE> の形式になっていることに注意してください。
あなたが慣れている形式とは異なるかもしれません）

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>name</STRONG> </TD><TD> <STRONG>owner</STRONG> </TD><TD> <STRONG>species</STRONG> </TD><TD> <STRONG>sex</STRONG> </TD><TD> <STRONG>birth</STRONG> </TD><TD> <STRONG>death</STRONG>
</TR NOSAVE>
<TR><TD>Fluffy </TD><TD> Harold </TD><TD> cat </TD><TD> f </TD><TD> 1993-02-04 </TD><TD>
</TR NOSAVE>
<TR><TD>Claws </TD><TD> Gwen </TD><TD> cat </TD><TD> m </TD><TD> 1994-03-17 </TD><TD>
</TR NOSAVE>
<TR><TD>Buffy </TD><TD> Harold </TD><TD> dog </TD><TD> f </TD><TD> 1989-05-13 </TD><TD>
</TR NOSAVE>
<TR><TD>Fang </TD><TD> Benny </TD><TD> dog </TD><TD> m </TD><TD> 1990-08-27 </TD><TD>
</TR NOSAVE>
<TR><TD>Bowser </TD><TD> Diane </TD><TD> dog </TD><TD> m </TD><TD> 1998-08-31 </TD><TD> 1995-07-29
</TR NOSAVE>
<TR><TD>Chirpy </TD><TD> Gwen </TD><TD> bird </TD><TD> f </TD><TD> 1998-09-11 </TD><TD>
</TR NOSAVE>
<TR><TD>Whistler </TD><TD> Gwen </TD><TD> bird </TD><TD> </TD><TD> 1997-12-09 </TD><TD>
</TR NOSAVE>
<TR><TD>Slim </TD><TD> Benny </TD><TD> snake </TD><TD> m </TD><TD> 1996-04-29 </TD><TD>
</TR>
</TABLE>

<P>
もし空のテーブルから作り始めるのなら、
一行に一つのペットのデータを記述したテキストファイルを作っておいて、
先に挙げた命令で中身を読み込ませると楽です。

</P>
<P>
そのファイルを <TT>`pet.txt'</TT> とします。
各レコードを一行ずつ書き、各項目はタブで区切ります。
項目の順番は <CODE>CREATE TABLE</CODE> 文で定義したときと同じ順番とします。
項目が空のときは（例えばペットがまだ生きている場合、死亡日欄は空白です）
<CODE>NULL</CODE> を用いることが出来ます。ファイル中では <CODE>\N</CODE> を用います。
例えば鳥の Whistler のレコードは以下のようになります。（項目の間の空白はタブ１個です）:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>name</STRONG> </TD><TD> <STRONG>owner</STRONG> </TD><TD> <STRONG>species</STRONG> </TD><TD> <STRONG>sex</STRONG> </TD><TD> <STRONG>birth</STRONG> </TD><TD> <STRONG>death</STRONG>
</TR NOSAVE>
<TR><TD><CODE>Whistler</CODE> </TD><TD> <CODE>Gwen</CODE> </TD><TD> <CODE>bird</CODE> </TD><TD> <CODE>\N</CODE> </TD><TD> <CODE>1997-12-09</CODE> </TD><TD> <CODE>\N</CODE>
</TR>
</TABLE>

<P>
このファイル <TT>`pet.txt'</TT> をテーブル <CODE>pet</CODE> に読み込むには、以下のコマンドを用います：

</P>

<PRE>
mysql&#62; LOAD DATA LOCAL INFILE "pet.txt" INTO TABLE pet;
</PRE>

<P>
もし必要であれば、項目の区切りや行末の符号を <CODE>LOAD DATA</CODE> 文で明示的に定めることが出来ます。
デフォルトでは区切りはタブ、行末はラインフィードです。
これにより <TT>`pet.txt'</TT> を適切に読み込むことが出来ます。

</P>
<P>
また新しい複数のレコードを１個づつ追加したいときは <CODE>INSERT</CODE> が便利です。
それぞれの項を <CODE>CREATE TABLE</CODE> で定義したときと同じ順番で入力するだけで追加できます。
例えばDianeが新しくハムスターをもらってきてPuffballと名づけました。
<CODE>INSERT</CODE> を用いて以下のようにレコードを追加することが出来ます：

</P>

<PRE>
mysql&#62; INSERT INTO pet
    -&#62; VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
</PRE>

<P>
文字列や日付を引用符号で括っていることに注意してください。
また <CODE>INSERT</CODE> を用いて空白の項を入力するときには <CODE>NULL</CODE> を直接挿入することができます。
<CODE>LOAD DATA</CODE> を使っているときとは違って <CODE>\N</CODE> は使えません。

</P>
<P>
この例から、初めにレコードを <CODE>INSERT</CODE> 文で入力するのは、
<CODE>LOAD DATA</CODE> 文を用いるよりも相当多くのタイピングを要してしまうことがわかると思います。

</P>



<H3><A NAME="Retrieving_data" HREF="manual.ja_toc.html#Retrieving_data">3.3.4  Retrieving Information from a Table</A></H3>

<P>
<A NAME="IDX380"></A>
<A NAME="IDX381"></A>
<A NAME="IDX382"></A>
<A NAME="IDX383"></A>

</P>

<P>
The <CODE>SELECT</CODE> statement is used to pull information from a table.
The general form of the statement is:

</P>

<PRE>
SELECT what_to_select
FROM which_table
WHERE conditions_to_satisfy
</PRE>

<P>
<CODE>what_to_select</CODE> indicates what you want to see.  This can be a list of
columns, or <CODE>*</CODE> to indicate ``all columns.'' <CODE>which_table</CODE>
indicates the table from which you want to retrieve data.  The <CODE>WHERE</CODE>
clause is optional.  If it's present, <CODE>conditions_to_satisfy</CODE> specifies
conditions that rows must satisfy to qualify for retrieval.

</P>



<H4><A NAME="Selecting_all" HREF="manual.ja_toc.html#Selecting_all">3.3.4.1  Selecting All Data</A></H4>

<P>
The simplest form of <CODE>SELECT</CODE> retrieves everything from a table:

</P>

<PRE>
mysql&#62; SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1998-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
</PRE>

<P>
This form of <CODE>SELECT</CODE> is useful if you want to review your entire table,
for instance, after you've just loaded it with your initial dataset.  As it
happens, the output just shown reveals an error in your datafile:  Bowser
appears to have been born after he died!  Consulting your original pedigree
papers, you find that the correct birth year is 1989, not 1998.

</P>
<P>
There are least a couple of ways to fix this:

</P>

<UL>
<LI>

Edit the file <TT>`pet.txt'</TT> to correct the error, then empty the table
and reload it using <CODE>DELETE</CODE> and <CODE>LOAD DATA</CODE>:


<PRE>
mysql&#62; SET AUTOCOMMIT=1;  # Used for quick re-create of the table
mysql&#62; DELETE FROM pet;
mysql&#62; LOAD DATA LOCAL INFILE "pet.txt" INTO TABLE pet;
</PRE>

However, if you do this, you must also re-enter the record for Puffball.

<LI>

Fix only the erroneous record with an <CODE>UPDATE</CODE> statement:


<PRE>
mysql&#62; UPDATE pet SET birth = "1989-08-31" WHERE name = "Bowser";
</PRE>

</UL>

<P>
As shown above, it is easy to retrieve an entire table.  But typically you
don't want to do that, particularly when the table becomes large.  Instead,
you're usually more interested in answering a particular question, in which
case you specify some constraints on the information you want.  Let's look at
some selection queries in terms of questions about your pets that they
answer.

</P>



<H4><A NAME="Selecting_rows" HREF="manual.ja_toc.html#Selecting_rows">3.3.4.2  Selecting Particular Rows</A></H4>

<P>
<A NAME="IDX384"></A>
<A NAME="IDX385"></A>

</P>
<P>
You can select only particular rows from your table.  For example, if you want
to verify the change that you made to Bowser's birth date, select Bowser's
record like this:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name = "Bowser";
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
</PRE>

<P>
The output confirms that the year is correctly recorded now as 1989, not 1998.

</P>
<P>
String comparisons are normally case-insensitive, so you can specify the
name as <CODE>"bowser"</CODE>, <CODE>"BOWSER"</CODE>, etc.  The query result will be
the same.

</P>
<P>
You can specify conditions on any column, not just <CODE>name</CODE>.  For example,
if you want to know which animals were born after 1998, test the <CODE>birth</CODE>
column:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE birth &#62;= "1998-1-1";
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f    | 1999-03-30 | NULL  |
+----------+-------+---------+------+------------+-------+
</PRE>

<P>
You can combine conditions, for example, to locate female dogs:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE species = "dog" AND sex = "f";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
The preceding query uses the <CODE>AND</CODE> logical operator.  There is also an
<CODE>OR</CODE> operator:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE species = "snake" OR species = "bird";
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
</PRE>

<P>
<CODE>AND</CODE> and <CODE>OR</CODE> may be intermixed.  If you do that, it's a good idea
to use parentheses to indicate how conditions should be grouped:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE (species = "cat" AND sex = "m")
    -&#62; OR (species = "dog" AND sex = "f");
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>



<H4><A NAME="Selecting_columns" HREF="manual.ja_toc.html#Selecting_columns">3.3.4.3  Selecting Particular Columns</A></H4>

<P>
<A NAME="IDX386"></A>
<A NAME="IDX387"></A>

</P>
<P>
If you don't want to see entire rows from your table, just name the columns
in which you're interested, separated by commas.  For example, if you want to
know when your animals were born, select the <CODE>name</CODE> and <CODE>birth</CODE>
columns:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>
To find out who owns pets, use this query:

</P>

<PRE>
mysql&#62; SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
</PRE>

<P>
<A NAME="IDX388"></A>
However, notice that the query simply retrieves the <CODE>owner</CODE> field from
each record, and some of them appear more than once.  To minimise the output,
retrieve each unique output record just once by adding the keyword
<CODE>DISTINCT</CODE>:

</P>

<PRE>
mysql&#62; SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
</PRE>

<P>
You can use a <CODE>WHERE</CODE> clause to combine row selection with column
selection.  For example, to get birth dates for dogs and cats only,
use this query:

</P>

<PRE>
mysql&#62; SELECT name, species, birth FROM pet
    -&#62; WHERE species = "dog" OR species = "cat";
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
</PRE>



<H4><A NAME="Sorting_rows" HREF="manual.ja_toc.html#Sorting_rows">3.3.4.4  Sorting Rows</A></H4>

<P>
<A NAME="IDX389"></A>
<A NAME="IDX390"></A>
<A NAME="IDX391"></A>
<A NAME="IDX392"></A>

</P>
<P>
You may have noticed in the preceding examples that the result rows are
displayed in no particular order.  However, it's often easier to examine
query output when the rows are sorted in some meaningful way.  To sort a
result, use an <CODE>ORDER BY</CODE> clause.

</P>
<P>
Here are animal birthdays, sorted by date:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>
On character type columns, sorting@-like all other comparison
operations@-is normally performed in a case-insensitive fashion.
This means that the order will be undefined for columns that are identical
except for their case. You can force a case-sensitive sort by using the
BINARY cast: <CODE>ORDER BY BINARY(field)</CODE>.

</P>
<P>
To sort in reverse order, add the <CODE>DESC</CODE> (descending) keyword to the
name of the column you are sorting by:

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
</PRE>

<P>
You can sort on multiple columns.  For example, to sort by type of
animal, then by birth date within animal type with youngest animals first,
use the following query:

</P>

<PRE>
mysql&#62; SELECT name, species, birth FROM pet ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
</PRE>

<P>
Note that the <CODE>DESC</CODE> keyword applies only to the column name immediately
preceding it (<CODE>birth</CODE>); <CODE>species</CODE> values are still sorted in
ascending order.

</P>



<H4><A NAME="Date_calculations" HREF="manual.ja_toc.html#Date_calculations">3.3.4.5  日付の計算</A></H4>

<P>
<A NAME="IDX393"></A>
<A NAME="IDX394"></A>
<A NAME="IDX395"></A>
<A NAME="IDX396"></A>

</P>
<P>
MySQL はいくつかの日付の計算を行う関数を提供します。
例えば、年の計算や日付の部分を取り出したり。

</P>
<P>
To determine how many years old each of your pets is, compute the
difference in the year part of the current date and the birth date, then
subtract one if the current date occurs earlier in the calendar year than
the birth date.  The following query shows, for each pet, the birth date,
the current date, and the age in years.

</P>

<PRE>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; - (RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
+----------+------------+--------------+------+
</PRE>

<P>
Here, <CODE>YEAR()</CODE> pulls out the year part of a date and <CODE>RIGHT()</CODE>
pulls off the rightmost five characters that represent the <CODE>MM-DD</CODE>
(calendar year) part of the date.  The part of the expression that
compares the <CODE>MM-DD</CODE> values evaluates to 1 or 0, which adjusts the
year difference down a year if <CODE>CURRENT_DATE</CODE> occurs earlier in
the year than <CODE>birth</CODE>.  The full expression is somewhat ungainly,
so an alias (<CODE>age</CODE>) is used to make the output column label more
meaningful.

</P>
<P>
The query works, but the result could be scanned more easily if the rows
were presented in some order.  This can be done by adding an <CODE>ORDER
BY name</CODE> clause to sort the output by name:

</P>

<PRE>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; - (RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet ORDER BY name;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
+----------+------------+--------------+------+
</PRE>

<P>
To sort the output by <CODE>age</CODE> rather than <CODE>name</CODE>, just use a
different <CODE>ORDER BY</CODE> clause:

</P>

<PRE>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; - (RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet ORDER BY age;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
+----------+------------+--------------+------+
</PRE>

<P>
似たクエリが、既に死んでしまった動物の、死んだ時点の年齢を調べるのにも
使用できます。 どの動物が死んでいるかどうかは、<CODE>death</CODE> 値が <CODE>NULL</CODE> か
どうかで判断します。 これらの値が 非<CODE>NULL</CODE> ならば、 <CODE>death</CODE> と <CODE>birth</CODE>
の差の計算を行います：

</P>

<PRE>
mysql&#62; SELECT name, birth, death,
    -&#62; (YEAR(death)-YEAR(birth)) - (RIGHT(death,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
</PRE>

<P>
このクエリでは、 <CODE>death &#60;&#62; NULL</CODE> ではなく <CODE>death IS NOT NULL</CODE> を
使用します。 なぜなら、 <CODE>NULL</CODE> は特別な値だからです。 これは後で解説します。
 「<A HREF="manual.ja_Tutorial.html#Working_with_NULL">3.3.4.6  <CODE>NULL</CODE> 値の振る舞い</A>」節参照.

</P>
<P>
もしあなたが翌月誕生日の動物を知りたいとします。 この種の計算では、
年と日が関係ありません。  <CODE>birth</CODE> フィールドの月だけを単に
取り出したくなるでしょう。 MySQL は日付の部分を取り出すいくつかの関数を
提供します。 <CODE>YEAR()</CODE>, <CODE>MONTH()</CODE>, <CODE>DAYOFMONTH()</CODE> など。
ここでは <CODE>MONTH()</CODE> がいいでしょう。 これがどのように動くか確かめるには、
<CODE>birth</CODE> と <CODE>MONTH(birth)</CODE> の両方を表示させるクエリを実行してみます：

</P>

<PRE>
mysql&#62; SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
</PRE>

<P>
来月誕生日を迎える動物を見つけるのは簡単です。 現在4月だとします。
すると、5月生まれの動物を探します：

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
</PRE>

<P>
もし現在が12月なら、ちょっと困るかもしれません。 月の数字 (<CODE>12</CODE>) に
1 を足して 13 月生まれの動物を探すわけにはいきません。 かわりに1月生まれの
動物を探します。

</P>
<P>
現在が何月なのかを気にすることなく、動作するクエリを書くことが可能です。
この方法では、あなたは月の数字をクエリに使用することがありません。
<CODE>DATE_ADD()</CODE> 関数は与えた日付からある時間を足すことが可能です。
もし現時点 <CODE>NOW()</CODE> の値に 1ヶ月 足し、 <CODE>MONTH()</CODE> で月の
部分を取り出し、その結果を、誕生月を調べるために使用します：

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MONTH(DATE_ADD(NOW(), INTERVAL 1 MONTH));
</PRE>

<P>
同じことができる別の方法として、剰余関数 を使用した結果に 1 を足す方法があります。
(もし今月が12月なら、剰余関数 (<CODE>MOD</CODE>) を使用した結果は <CODE>0</CODE> になります)：

</P>

<PRE>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MOD(MONTH(NOW()), 12) + 1;
</PRE>

<P>
Note that <CODE>MONTH</CODE> returns a number between 1 and 12. And
<CODE>MOD(something,12)</CODE> returns a number between 0 and 11. So the
addition has to be after the <CODE>MOD()</CODE>, otherwise we would go from
November (11) to January (1).

</P>



<H4><A NAME="Working_with_NULL" HREF="manual.ja_toc.html#Working_with_NULL">3.3.4.6  <CODE>NULL</CODE> 値の振る舞い</A></H4>

<P>
<A NAME="IDX397"></A>
<A NAME="IDX398"></A>

</P>
<P>
あなたがそれに慣れるまでは、<CODE>NULL</CODE> 値には驚くかもしれません。
概念的に、<CODE>NULL</CODE> 値は ``値無し'' か ``未知な値'' を意味し、
他の値よりもいくぶん異なって扱われます。
<CODE>NULL</CODE> の評価の際には、数値の比較演算子 <CODE>=</CODE>, <CODE>&#60;</CODE>, <CODE>&#60;&#62;</CODE> を
使用することは出来ません。 あなた自身これをデモするために、以下のようにしてみてください：

</P>

<PRE>
mysql&#62; SELECT 1 = NULL, 1 &#60;&#62; NULL, 1 &#60; NULL, 1 &#62; NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 &#60;&#62; NULL | 1 &#60; NULL | 1 &#62; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</PRE>

<P>
確実にこれらの比較からいかなる意味がある結果も受け取りません。
この代わりに、 <CODE>IS NULL</CODE> , <CODE>IS NOT NULL</CODE> 演算子を使用します：

</P>

<PRE>
mysql&#62; SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</PRE>

<P>
MySQL では, 0 や <CODE>NULL</CODE> は false（偽） で、それ以外全てが true（真）です。
The default truth value from a boolean operation is 1.

</P>
<P>
この <CODE>NULL</CODE> の特別な扱いはなぜなのか。 前のセクションを見てください。
どの動物がもはや生きていないことを決定づけるためには、
<CODE>death &#60;&#62; NULL</CODE> ではなく <CODE>death IS NOT NULL</CODE> の使用が
必要とされるのです。

</P>
<P>
Two <CODE>NULL</CODE> values are regarded as equal in a <CODE>GROUP BY</CODE>.

</P>
<P>
When doing an <CODE>ORDER BY</CODE>, <CODE>NULL</CODE> values are presented first if you
do <CODE>ORDER BY ... ASC</CODE> and last if you do <CODE>ORDER BY ... DESC</CODE>.

</P>
<P>
Note that between MySQL 4.0.2 - 4.0.10, <CODE>NULL</CODE> values incorrectly
were always sorted first regardless of the sort direction.

</P>



<H4><A NAME="Pattern_matching" HREF="manual.ja_toc.html#Pattern_matching">3.3.4.7  パターン・マッチ</A></H4>

<P>
<A NAME="IDX399"></A>
<A NAME="IDX400"></A>
<A NAME="IDX401"></A>

</P>
<P>
MySQL は標準SQLのパターン・マッチを提供します。
また、拡張された正規表現を基にした形式のパターン・マッチ、
これは <CODE>vi</CODE>, <CODE>grep</CODE> , <CODE>sed</CODE> など UNIX のユーティリティに
使用されている物と似ていますが、これも提供します。

</P>
<P>
SQL パターン・マッチは、 <SAMP>`_'</SAMP> でいかなる１文字とも一致し、
<SAMP>`%'</SAMP> であらゆる0こ以上の文字列に一致します。
MySQL では、デフォルトで SQL パターンはケース非依存です。
いくつか例を以下に示します。 SQLパターンを使用する場合、 <CODE>=</CODE> や
<CODE>!=</CODE> を使用しないように注意してください。 <CODE>LIKE</CODE> か <CODE>NOT LIKE</CODE>
を代わりに使用します。

</P>
<P>
<SAMP>`b'</SAMP> から始まる名前を見つけるには:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "b%";
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</PRE>

<P>
<SAMP>`fy'</SAMP> で終わる名前を見つけるには:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%fy";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>
<SAMP>`w'</SAMP> を含む名前を見つけるには:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%w%";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>
5文字の名前を見つけるには, <SAMP>`_'</SAMP> パターン文字を使用して：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "_____";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
MySQL では他のパターン・マッチの形も提供されます。正規表現の拡張を使用して。
これらのパターン・マッチをテストする際には、<CODE>REGEXP</CODE> と <CODE>NOT REGEXP</CODE>
演算子（あるいは<CODE>RLIKE</CODE>, <CODE>NOT RLIKE</CODE> 演算子。これらは同義です）
を使用します。

</P>
<P>
拡張正規表現のいくつかの特徴：

</P>

<UL>
<LI>

<SAMP>`.'</SAMP> はいかなる一文字とも一致します。

<LI>

<SAMP>`[...]'</SAMP> は、かっこ内にある文字と一致します。
例えば、<SAMP>`[abc]'</SAMP> は <SAMP>`a'</SAMP>, <SAMP>`b'</SAMP> あるいは <SAMP>`c'</SAMP> にマッチします。
文字を範囲指定する場合にはダッシュを使用します。 <SAMP>`[a-z]'</SAMP> はいかなる
小文字のアルファベット文字にも一致し、 <SAMP>`[0-9]'</SAMP> はいかなる数字にも
一致します。

<LI>

<SAMP>`*'</SAMP> は、先に指定されている文字 0 個以上にマッチします。
例えば、<SAMP>`x*'</SAMP> は 文字 <SAMP>`x'</SAMP> がいくつも連続している物にマッチし、
<SAMP>`[0-9]*'</SAMP> はいかなる数値ともマッチし、 <SAMP>`.*'</SAMP> はあらゆる文字列に
一致します。

<LI>

パターンは、テストされた値の中のどこかにある場合、マッチします。
(SQL patterns match only if they match the entire value.)

<LI>

値のはじめ、あるいは終わりに位置を指定してマッチさせたい場合は、
パターンの初めにマッチさせる場合は <SAMP>`^'</SAMP> を使用し、
パターンの終わりにマッチさせる場合は <SAMP>`$'</SAMP> を使用します。
(これらはアンカーと呼ばれます)
</UL>

<P>
以下は拡張された正規表現がどう動くかの例です。
上に示した <CODE>LIKE</CODE> のクエリは <CODE>REGEXP</CODE> で以下のように書き換えれます：

</P>
<P>
<SAMP>`b'</SAMP> で始まる名前をみつけるには、<SAMP>`^'</SAMP> で名前の頭にマッチさせ、
かつ <SAMP>`[bB]'</SAMP> として、大文字小文字にもマッチさせます：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^b";
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</PRE>

<P>
Prior to MySQL Version 3.23.4, <CODE>REGEXP</CODE> is case-sensitive,
and the previous query will return no rows. To match either lowercase or
uppercase <SAMP>`b'</SAMP>, use this query instead:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^[bB]";
</PRE>

<P>
From MySQL 3.23.4 on, to force a <CODE>REGEXP</CODE> comparison to
be case-sensitive, use the <CODE>BINARY</CODE> keyword to make one of the
strings a binary string. This query will match only lowercase <SAMP>`b'</SAMP>
at the beginning of a name:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP BINARY "^b";
</PRE>

<P>
To find names ending with <SAMP>`fy'</SAMP>, use <SAMP>`$'</SAMP> to match the end of the
name:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "fy$";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>
To find names containing a lowercase or uppercase <SAMP>`w'</SAMP>, use this query:

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "w";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>
正規表現はもし値中のどこかにでもあればマッチするため、
SQL パターンのように、パターンの前後にワイルドカードを書く必要はありません。

</P>
<P>
5文字の名前を見つけるには、<SAMP>`^'</SAMP> と <SAMP>`$'</SAMP> を使用して名前の初めと終わりに
マッチさせ、その間に <SAMP>`.'</SAMP> を5個入れます：

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.....$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>
前のクエリは <SAMP>`{n}'</SAMP> ``<CODE>n</CODE>回繰り返し'' オペレーターで
書換え可能です。

</P>

<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.{5}$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>



<H4><A NAME="Counting_rows" HREF="manual.ja_toc.html#Counting_rows">3.3.4.8  Counting Rows</A></H4>

<P>
<A NAME="IDX402"></A>
<A NAME="IDX403"></A>
<A NAME="IDX404"></A>

</P>
<P>
Databases are often used to answer the question, ``How often does a certain
type of data occur in a table?''  For example, you might want to know how
many pets you have, or how many pets each owner has, or you might want to
perform various kinds of censuses on your animals.

</P>
<P>
Counting the total number of animals you have is the same question as ``How
many rows are in the <CODE>pet</CODE> table?'' because there is one record per pet.
The <CODE>COUNT()</CODE> function counts the number of non-<CODE>NULL</CODE> results, so
the query to count your animals looks like this:

</P>

<PRE>
mysql&#62; SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
</PRE>

<P>
Earlier, you retrieved the names of the people who owned pets.  You can
use <CODE>COUNT()</CODE> if you want to find out how many pets each owner has:

</P>

<PRE>
mysql&#62; SELECT owner, COUNT(*) FROM pet GROUP BY owner;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
</PRE>

<P>
Note the use of <CODE>GROUP BY</CODE> to group together all records for each
<CODE>owner</CODE>.  Without it, all you get is an error message:

</P>

<PRE>
mysql&#62; SELECT owner, COUNT(owner) FROM pet;
ERROR 1140 at line 1: Mixing of GROUP columns (MIN(),MAX(),COUNT()...)
with no GROUP columns is illegal if there is no GROUP BY clause
</PRE>

<P>
<CODE>COUNT()</CODE> and <CODE>GROUP BY</CODE> are useful for characterising your
data in various ways.  The following examples show different ways to
perform animal census operations.

</P>
<P>
Number of animals per species:

</P>

<PRE>
mysql&#62; SELECT species, COUNT(*) FROM pet GROUP BY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</PRE>

<P>
Number of animals per sex:

</P>

<PRE>
mysql&#62; SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</PRE>

<P>
(In this output, <CODE>NULL</CODE> indicates sex unknown.)

</P>
<P>
Number of animals per combination of species and sex:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>

<P>
You need not retrieve an entire table when you use <CODE>COUNT()</CODE>.  For
example, the previous query, when performed just on dogs and cats, looks like
this:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE species = "dog" OR species = "cat"
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</PRE>

<P>
Or, if you wanted the number of animals per sex only for known-sex animals:

</P>

<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE sex IS NOT NULL
    -&#62; GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>



<H4><A NAME="Multiple_tables" HREF="manual.ja_toc.html#Multiple_tables">3.3.4.9  Using More Than one Table</A></H4>

<P>
<A NAME="IDX405"></A>

</P>
<P>
The <CODE>pet</CODE> table keeps track of which pets you have.  If you want to
record other information about them, such as events in their lives like
visits to the vet or when litters are born, you need another table.  What
should this table look like? It needs:

</P>

<UL>
<LI>

To contain the pet name so you know which animal each event pertains
to.

<LI>

A date so you know when the event occurred.

<LI>

A field to describe the event.

<LI>

An event type field, if you want to be able to categorise events.
</UL>

<P>
Given these considerations, the <CODE>CREATE TABLE</CODE> statement for the
<CODE>event</CODE> table might look like this:

</P>

<PRE>
mysql&#62; CREATE TABLE event (name VARCHAR(20), date DATE,
    -&#62; type VARCHAR(15), remark VARCHAR(255));
</PRE>

<P>
As with the <CODE>pet</CODE> table, it's easiest to load the initial records
by creating a tab-delimited text file containing the information:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>name</STRONG> </TD><TD> <STRONG>date</STRONG> </TD><TD> <STRONG>type</STRONG> </TD><TD> <STRONG>remark</STRONG>
</TR NOSAVE>
<TR><TD>Fluffy </TD><TD> 1995-05-15 </TD><TD> litter </TD><TD> 4 kittens, 3 female, 1 male
</TR NOSAVE>
<TR><TD>Buffy </TD><TD> 1993-06-23 </TD><TD> litter </TD><TD> 5 puppies, 2 female, 3 male
</TR NOSAVE>
<TR><TD>Buffy </TD><TD> 1994-06-19 </TD><TD> litter </TD><TD> 3 puppies, 3 female
</TR NOSAVE>
<TR><TD>Chirpy </TD><TD> 1999-03-21 </TD><TD> vet </TD><TD> needed beak straightened
</TR NOSAVE>
<TR><TD>Slim </TD><TD> 1997-08-03 </TD><TD> vet </TD><TD> broken rib
</TR NOSAVE>
<TR><TD>Bowser </TD><TD> 1991-10-12 </TD><TD> kennel </TD><TD>
</TR NOSAVE>
<TR><TD>Fang </TD><TD> 1991-10-12 </TD><TD> kennel </TD><TD>
</TR NOSAVE>
<TR><TD>Fang </TD><TD> 1998-08-28 </TD><TD> birthday </TD><TD> Gave him a new chew toy
</TR NOSAVE>
<TR><TD>Claws </TD><TD> 1998-03-17 </TD><TD> birthday </TD><TD> Gave him a new flea collar
</TR NOSAVE>
<TR><TD>Whistler </TD><TD> 1998-12-09 </TD><TD> birthday </TD><TD> First birthday
</TR>
</TABLE>

<P>
Load the records like this:

</P>

<PRE>
mysql&#62; LOAD DATA LOCAL INFILE "event.txt" INTO TABLE event;
</PRE>

<P>
Based on what you've learned from the queries you've run on the <CODE>pet</CODE>
table, you should be able to perform retrievals on the records in the
<CODE>event</CODE> table; the principles are the same.  But when is the
<CODE>event</CODE> table by itself insufficient to answer questions you might ask?

</P>
<P>
Suppose you want to find out the ages of each pet when they had their
litters.  The <CODE>event</CODE> table indicates when this occurred, but to
calculate the age of the mother, you need her birth date.  Because that is
stored in the <CODE>pet</CODE> table, you need both tables for the query:

</P>

<PRE>
mysql&#62; SELECT pet.name,
    -&#62; (TO_DAYS(date) - TO_DAYS(birth))/365 AS age,
    -&#62; remark
    -&#62; FROM pet, event
    -&#62; WHERE pet.name = event.name AND type = "litter";
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy | 2.27 | 4 kittens, 3 female, 1 male |
| Buffy  | 4.12 | 5 puppies, 2 female, 3 male |
| Buffy  | 5.10 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
</PRE>

<P>
There are several things to note about this query:

</P>

<UL>
<LI>

The <CODE>FROM</CODE> clause lists two tables because the query needs to pull
information from both of them.

<LI>

When combining (joining) information from multiple tables, you need to
specify how records in one table can be matched to records in the other.
This is easy because they both have a <CODE>name</CODE> column.  The query uses
<CODE>WHERE</CODE> clause to match up records in the two tables based on the
<CODE>name</CODE> values.

<LI>

Because the <CODE>name</CODE> column occurs in both tables, you must be specific
about which table you mean when referring to the column.  This is done
by prepending the table name to the column name.
</UL>

<P>
You need not have two different tables to perform a join.  Sometimes it is
useful to join a table to itself, if you want to compare records in a table
to other records in that same table.  For example, to find breeding pairs
among your pets, you can join the <CODE>pet</CODE> table with itself to pair up
males and females of like species:

</P>

<PRE>
mysql&#62; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    -&#62; FROM pet AS p1, pet AS p2
    -&#62; WHERE p1.species = p2.species AND p1.sex = "f" AND p2.sex = "m";
+--------+------+--------+------+---------+
| name   | sex  | name   | sex  | species |
+--------+------+--------+------+---------+
| Fluffy | f    | Claws  | m    | cat     |
| Buffy  | f    | Fang   | m    | dog     |
| Buffy  | f    | Bowser | m    | dog     |
+--------+------+--------+------+---------+
</PRE>

<P>
In this query, we specify aliases for the table name in order
to refer to the columns and keep straight which instance of the table
each column reference is associated with.

</P>



<H2><A NAME="Getting_information" HREF="manual.ja_toc.html#Getting_information">3.4  データベースとテーブルの情報を得る</A></H2>

<P>
<A NAME="IDX406"></A>
<A NAME="IDX407"></A>
<A NAME="IDX408"></A>

</P>
<P>
データベースやテーブルの名前が何であったか、あるいはテーブルの構造はどうであったか、
(なんというフィールドがあったのか)忘れてしまった場合。
MySQL ではいくつかのデータベースとテーブルの情報を提供する文を通じて
この問題を処理します。

</P>
<P>
あなたは既に <CODE>SHOW DATABASES</CODE> を知っているはずで, これはサーバーが
管理するデーターベースの一覧を表示します。 現在選択しているデータベースが
何であるかを知るには、<CODE>DATABASE()</CODE> 関数を使用します：

</P>

<PRE>
mysql&#62; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
</PRE>

<P>
もしデータベースをまだ何も選択していなければ、結果はブランクです。

</P>
<P>
データベースに含まれるテーブルを見つけるには(たとえば、あなたがテーブル名を
知らない場合)、このコマンドを使用します：

</P>

<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
</PRE>

<P>
もしテーブルの構造を知りたいなら、<CODE>DESCRIBE</CODE> コマンドが便利です；
これはテーブルのそれぞれのフィールドについての情報を表示します。

</P>

<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P>
<CODE>Field</CODE> はフィールド名を示し、<CODE>Type</CODE> はフィールドのデータ型、
<CODE>Null</CODE> はこのフィールドが <CODE>Null</CODE> 値を含むかを示し、
<CODE>Key</CODE> はこのフィールドがインデックス化されているかを示し、
<CODE>Default</CODE> はフィールドのデフォルトの値を示します。

</P>
<P>
もしテーブルにインデックスを持っているなら、
<CODE>SHOW INDEX FROM tbl_name</CODE> がそれらの情報を示します。

</P>



<H2><A NAME="Examples" HREF="manual.ja_toc.html#Examples">3.5  一般的なクエリー例</A></H2>

<P>
<A NAME="IDX409"></A>
<A NAME="IDX410"></A>

</P>
<P>
以下は、MySQLの一般的な問題を解決するための例です。

</P>
<P>
Some of the examples use the table <CODE>shop</CODE> to hold the price of each
article (item number) for certain traders (dealers).  
各業者に対して各商品の価格が1つ決められているとし、(article, 
dealer)をレコードの主キーとします。

</P>
<P>
Start the command-line tool <CODE>mysql</CODE> and select a database:

</P>

<PRE>
mysql your-database-name
</PRE>

<P>
（MySQLのインストールを通常通り行った場合は、'test'データベースをお使いいただけます。）

</P>
<P>
以下のSQL文でサンプル テーブルを作成します。

</P>

<PRE>
CREATE TABLE shop (
 article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
 dealer  CHAR(20)                 DEFAULT ''     NOT NULL,
 price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL,
 PRIMARY KEY(article, dealer));

INSERT INTO shop VALUES
(1,'A',3.45),(1,'B',3.99),(2,'A',10.99),(3,'B',1.45),(3,'C',1.69),
(3,'D',1.25),(4,'D',19.95);
</PRE>

<P>
サンプル データを表示します。

</P>

<PRE>
mysql&#62; SELECT * FROM shop;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | A      |  3.45 |
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | B      |  1.45 |
|    0003 | C      |  1.69 |
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>



<H3><A NAME="example-Maximum-column" HREF="manual.ja_toc.html#example-Maximum-column">3.5.1  カラムの最大値</A></H3>

<P>
”articleカラムの最大値は？”

</P>

<PRE>
SELECT MAX(article) AS article FROM shop

+---------+
| article |
+---------+
|       4 |
+---------+
</PRE>



<H3><A NAME="example-Maximum-row" HREF="manual.ja_toc.html#example-Maximum-row">3.5.2  特定のカラムの最大値を含んだ行</A></H3>

<P>
”最も高い価格の商品の番号と、業者、価格を求める。”

</P>
<P>
ANSI SQL（MySQLではVersion4.1から）では、副問い合わせを使用することで簡単に求められます。

</P>

<PRE>
SELECT article, dealer, price
FROM   shop
WHERE  price=(SELECT MAX(price) FROM shop)
</PRE>

<P>
MySQL4.1以前では、以下の2つのステップで求めます。

</P>

<OL>
<LI>

<CODE>SELECT</CODE>構文でテーブルから最大値を取得します。
<LI>

1で求めた値をに使用して、実際のクエリーをコンパイルします。

<PRE>
SELECT article, dealer, price
FROM   shop
WHERE  price=19.95
</PRE>

</OL>

<P>
その他には全ての行をpriceカラムをもとに降順で並び替え、
MySQL特有 <CODE>LIMIT</CODE> 節を使用して最初の行のみを取得する方法があります。

</P>

<PRE>
SELECT article, dealer, price
FROM   shop
ORDER BY price DESC
LIMIT 1
</PRE>

<P>
<STRONG>注意</STRONG>：一番高い商品が複数存在する場合は（例えば、19.95ドルの商品が複数ある場合）、<CODE>LIMIT</CODE> 節はそのうちの1つの商品しか表示しません。

</P>



<H3><A NAME="example-Maximum-column-group" HREF="manual.ja_toc.html#example-Maximum-column-group">3.5.3  カラムのグループごとの最大値</A></H3>

<P>
”商品ごとの価格の最大値は？”

</P>

<PRE>
SELECT article, MAX(price) AS price
FROM   shop
GROUP BY article

+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
</PRE>



<H3><A NAME="example-Maximum-column-group-row" HREF="manual.ja_toc.html#example-Maximum-column-group-row">3.5.4  The Rows Holding the Group-wise Maximum of a Certain Field</A></H3>

<P>
``For each article, find the dealer(s) with the most expensive price.''

</P>
<P>
In ANSI SQL (and MySQL Version 4.1 or greater), I'd do it with a subquery like this:

</P>

<PRE>
SELECT article, dealer, price
FROM   shop s1
WHERE  price=(SELECT MAX(s2.price)
              FROM shop s2
              WHERE s1.article = s2.article);
</PRE>

<P>
In MySQL versions prior to 4.1 it's best do it in several steps:

</P>

<OL>
<LI>

Get the list of (article,maxprice).
<LI>

For each article get the corresponding rows that have the stored maximum
price.
</OL>

<P>
This can easily be done with a temporary table:

</P>

<PRE>
CREATE TEMPORARY TABLE tmp (
        article INT(4) UNSIGNED ZEROFILL DEFAULT '0000' NOT NULL,
        price   DOUBLE(16,2)             DEFAULT '0.00' NOT NULL);

LOCK TABLES shop read;

INSERT INTO tmp SELECT article, MAX(price) FROM shop GROUP BY article;

SELECT shop.article, dealer, shop.price FROM shop, tmp
WHERE shop.article=tmp.article AND shop.price=tmp.price;

UNLOCK TABLES;

DROP TABLE tmp;
</PRE>

<P>
If you don't use a <CODE>TEMPORARY</CODE> table, you must also lock the 'tmp' table.

</P>
<P>
``Can it be done with a single query?''

</P>
<P>
Yes, but only by using a quite inefficient trick that I call the
``MAX-CONCAT trick'':

</P>

<PRE>
SELECT article,
       SUBSTRING( MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 7) AS dealer,
  0.00+LEFT(      MAX( CONCAT(LPAD(price,6,'0'),dealer) ), 6) AS price
FROM   shop
GROUP BY article;

+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

<P>
The last example can, of course, be made a bit more efficient by doing the
splitting of the concatenated column in the client.

</P>



<H3><A NAME="example-user-variables" HREF="manual.ja_toc.html#example-user-variables">3.5.5  ユーザー変数の使用</A></H3>

<P>
MySQLのユーザー変数を使用すると、クライアントの一時変数に格納せずに結果を
記憶できます。 「<A HREF="manual.ja_Reference.html#Variables">6.1.4  ユーザー変数</A>」節参照。

</P>
<P>
例えば、商品の価格の最大値と最小値を求めるには、以下のSELECT構文を実行します。

</P>

<PRE>
mysql&#62; SELECT @min_price:=MIN(price),@max_price:=MAX(price) FROM shop;
mysql&#62; SELECT * FROM shop WHERE price=@min_price OR price=@max_price;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>



<H3><A NAME="example-Foreign_keys" HREF="manual.ja_toc.html#example-Foreign_keys">3.5.6  Using Foreign Keys</A></H3>

<P>
<A NAME="IDX411"></A>
<A NAME="IDX412"></A>

</P>
<P>
In MySQL 3.23.44 and up, <CODE>InnoDB</CODE> tables supports checking of
foreign key constraints.  「<A HREF="manual.ja_Table_types.html#InnoDB">7.5  <CODE>InnoDB</CODE> テーブル (3.23.6以上)</A>」節参照.
See also  「<A HREF="manual.ja_Introduction.html#ANSI_diff_Foreign_Keys">1.7.4.5  外部キー</A>」節.

</P>
<P>
You don't actually need foreign keys to join 2 tables.
The only thing MySQL currently doesn't do (in table types other than
<CODE>InnoDB</CODE>), is <CODE>CHECK</CODE> to make sure that the keys you use
really exist in the table(s) you're referencing and it
doesn't automatically delete rows from a table with a foreign key
definition. If you use your keys like normal, it'll work just fine:

</P>


<PRE>
CREATE TABLE person (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    name CHAR(60) NOT NULL,
    PRIMARY KEY (id)
);

CREATE TABLE shirt (
    id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
    color ENUM('red', 'blue', 'orange', 'white', 'black') NOT NULL,
    owner SMALLINT UNSIGNED NOT NULL REFERENCES person(id),
    PRIMARY KEY (id)
);

INSERT INTO person VALUES (NULL, 'Antonio Paz');

INSERT INTO shirt VALUES
(NULL, 'polo', 'blue', LAST_INSERT_ID()),
(NULL, 'dress', 'white', LAST_INSERT_ID()),
(NULL, 't-shirt', 'blue', LAST_INSERT_ID());

INSERT INTO person VALUES (NULL, 'Lilliana Angelovska');

INSERT INTO shirt VALUES
(NULL, 'dress', 'orange', LAST_INSERT_ID()),
(NULL, 'polo', 'red', LAST_INSERT_ID()),
(NULL, 'dress', 'blue', LAST_INSERT_ID()),
(NULL, 't-shirt', 'white', LAST_INSERT_ID());

SELECT * FROM person;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+

SELECT * FROM shirt;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+

SELECT s.* FROM person p, shirt s
 WHERE p.name LIKE 'Lilliana%'
   AND s.owner = p.id
   AND s.color &#60;&#62; 'white';

+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
</PRE>



<H3><A NAME="Searching_on_two_keys" HREF="manual.ja_toc.html#Searching_on_two_keys">3.5.7  Searching on Two Keys</A></H3>

<P>
<A NAME="IDX413"></A>
<A NAME="IDX414"></A>
<A NAME="IDX415"></A>

</P>
<P>
MySQL doesn't yet optimize when you search on two different
keys combined with <CODE>OR</CODE> (searching on one key with different <CODE>OR</CODE>
parts is optimized quite well):

</P>

<PRE>
SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1'
OR  field2_index = '1'
</PRE>

<P>
The reason is that we haven't yet had time to come up with an efficient
way to handle this in the general case. (The <CODE>AND</CODE> handling is,
in comparison, now completely general and works very well.)

</P>
<P>
For the moment you can solve this very efficiently by using a
<CODE>TEMPORARY</CODE> table. This type of optimization is also very good if
you are using very complicated queries where the SQL server does the
optimizations in the wrong order.

</P>

<PRE>
CREATE TEMPORARY TABLE tmp
SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1';
INSERT INTO tmp
SELECT field1_index, field2_index FROM test_table WHERE field2_index = '1';
SELECT * from tmp;
DROP TABLE tmp;
</PRE>

<P>
The above way to solve this query is in effect a <CODE>UNION</CODE> of two queries.
 「<A HREF="manual.ja_Reference.html#UNION">6.4.1.2  <CODE>UNION</CODE> Syntax</A>」節参照.

</P>


<H3><A NAME="Calculating_days" HREF="manual.ja_toc.html#Calculating_days">3.5.8  Calculating Visits Per Day</A></H3>

<P>
<A NAME="IDX416"></A>
<A NAME="IDX417"></A>
<A NAME="IDX418"></A>
<A NAME="IDX419"></A>

</P>
<P>
The following shows an idea of how you can use the bit group functions
to calculate the number of days per month a user has visited a web page.

</P>

<PRE>
CREATE TABLE t1 (year YEAR(4), month INT(2) UNSIGNED ZEROFILL,
             day INT(2) UNSIGNED ZEROFILL);
INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),(2000,2,2),
            (2000,2,23),(2000,2,23);
SELECT year,month,BIT_COUNT(BIT_OR(1&#60;&#60;day)) AS days FROM t1
       GROUP BY year,month;

Which returns:

+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |    01 |    3 |
| 2000 |    02 |    2 |
+------+-------+------+
</PRE>

<P>
The above calculates how many different days was used for a given
year/month combination, with automatic removal of duplicate entries.

</P>


<H3><A NAME="example-AUTO_INCREMENT" HREF="manual.ja_toc.html#example-AUTO_INCREMENT">3.5.9  Using <CODE>AUTO_INCREMENT</CODE></A></H3>

<P>
<A NAME="IDX420"></A>
The <CODE>AUTO_INCREMENT</CODE> attribute can be used to generate a unique
identity for new rows:

</P>

<PRE>
CREATE TABLE animals (
             id MEDIUMINT NOT NULL AUTO_INCREMENT,
             name CHAR(30) NOT NULL,
             PRIMARY KEY (id)
             );
INSERT INTO animals (name) VALUES ("dog"),("cat"),("penguin"),
                                  ("lax"),("whale");
SELECT * FROM animals;

Which returns:

+----+---------+
| id | name    |
+----+---------+
|  1 | dog     |
|  2 | cat     |
|  3 | penguin |
|  4 | lax     |
|  5 | whale   |
+----+---------+
</PRE>

<P>
You can retrieve the used <CODE>AUTO_INCREMENT</CODE> key with the
<CODE>LAST_INSERT_ID()</CODE> SQL function or the <CODE>mysql_insert_id()</CODE> API
function.
Note: for a multi-row insert,
<CODE>LAST_INSERT_ID()</CODE>/<CODE>mysql_insert_id()</CODE> will actually return the
<CODE>AUTO_INCREMENT</CODE> key from the <STRONG>first</STRONG> inserted row. This allows
multi-row inserts to be reproduced on other servers.

</P>
<P>
For MyISAM and BDB tables you can specify <CODE>AUTO_INCREMENT</CODE> on
secondary column in a multi-column key.  In this case the generated
value for the autoincrement column is calculated as
<CODE>MAX(auto_increment_column)+1) WHERE prefix=given-prefix</CODE>.  This is
useful when you want to put data into ordered groups.

</P>

<PRE>
CREATE TABLE animals (
             grp ENUM('fish','mammal','bird') NOT NULL,
             id MEDIUMINT NOT NULL AUTO_INCREMENT,
             name CHAR(30) NOT NULL,
             PRIMARY KEY (grp,id)
             );
INSERT INTO animals (grp,name) VALUES("mammal","dog"),("mammal","cat"),
                  ("bird","penguin"),("fish","lax"),("mammal","whale");
SELECT * FROM animals ORDER BY grp,id;

Which returns:

+--------+----+---------+
| grp    | id | name    |
+--------+----+---------+
| fish   |  1 | lax     |
| mammal |  1 | dog     |
| mammal |  2 | cat     |
| mammal |  3 | whale   |
| bird   |  1 | penguin |
+--------+----+---------+
</PRE>

<P>
Note that in this case, the <CODE>AUTO_INCREMENT</CODE> value will be reused if you
delete the row with the biggest <CODE>AUTO_INCREMENT</CODE> value in any group.

</P>



<H2><A NAME="Batch_mode" HREF="manual.ja_toc.html#Batch_mode">3.6  <CODE>mysql</CODE> のバッチモードでの使用</A></H2>

<P>
<A NAME="IDX421"></A>
<A NAME="IDX422"></A>
<A NAME="IDX423"></A>
<A NAME="IDX424"></A>
<A NAME="IDX425"></A>

</P>
<P>
前のセクションでは、<CODE>mysql</CODE> を対話モードで使用し、クエリの入力と
結果を表示しました。 <CODE>mysql</CODE> はバッチモードでも実行可能です。
これを行うには、あなたが実行したいコマンドをファイルに書いておき、
そのファイルから入力を読み込むようにして <CODE>mysql</CODE> を実行します：

</P>

<PRE>
shell&#62; mysql &#60; batch-file
</PRE>

<P>
If you are running <CODE>mysql</CODE> under windows and have some special
characters in the file that causes problems, you can do:

</P>

<PRE>
dos&#62; mysql -e "source batch-file"
</PRE>

<P>
もし接続パラメターを指定する必要がある場合は、以下のようになるでしょう：

</P>

<PRE>
shell&#62; mysql -h host -u user -p &#60; batch-file
Enter password: ********
</PRE>

<P>
この方法で <CODE>mysql</CODE> を使用するとき、あなたはスクリプトファイルを
作成し、それを実行することになるでしょう。

</P>
<P>
If you want the script to continue even if you have errors, you should
use the <CODE>--force</CODE> command-line option.

</P>
<P>
なぜスクリプトを使用するのか？ それには以下の理由があります：

</P>

<UL>
<LI>

もし繰り返しクエリを実行する場合(毎日とか毎週とか)、スクリプトを書くことで、
その実行の度にあなたがコマンドをタイプすることを省くことが可能です。

<LI>

もし既にあるクエリに似た新しいクエリを書く場合、それらをコピーし
スクリプトファイルを編集できます。

<LI>

バッチモードはクエリの開発中や複数にまたがるコマンドには役に立ちます。
もしコマンドが間違っていたとしても全てを打ち直す必要がありません。
エラーを修正するためにスクリプトを編集し、再び <CODE>mysql</CODE> に実行させます。

<LI>

もし多くの出力を出すようなクエリの場合、ページャーを使用して出力を見ることが
出来ます。 出力がスクロールして画面から見えなくなるよりいいでしょう：


<PRE>
shell&#62; mysql &#60; batch-file | more
</PRE>

<LI>

あなたはより処理を行うために、結果をファイルに書き出すことが可能です：


<PRE>
shell&#62; mysql &#60; batch-file &#62; mysql.out
</PRE>

<LI>

あなたは、他人へのあなたのスクリプトを配布することができます。これにより、ほかの人たちも
コマンドを実行することができます。 

<LI>

いくつかの状況では、対話モードでは使用に耐えません。 たとえば、クエリを
 <CODE>cron</CODE> ジョブとして実行する場合。 この場合、バッチモードでなければなりません。

<LI>

端末が正しく扱えない文字を <CODE>mysql</CODE> コマンドに渡す場合。
たとえば、EUC-JP, Shift_JIS の漢字文字などは、端末や環境によっては直接入力できない場合もあるでしょう。
あるいは、文字コードの違う MySQL サーバーにデータを転送するときなども。
</UL>

<P>
<CODE>mysql</CODE> をバッチモードで使用するか、対話モードで使用するかで、
デフォルトの出力形式が変わります。 例えば、 <CODE>SELECT DISTINCT species FROM pet</CODE> の
出力は対話モードでは次のようになります：

</P>

<PRE>
+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
</PRE>

<P>
しかし、バッチモードでは：

</P>

<PRE>
species
bird
cat
dog
hamster
snake
</PRE>

<P>
もしバッチモードでも対話モードのような出力を得たい場合には、<CODE>mysql -t</CODE> とします。
出力中に、実行したコマンドを表示させるならば、<CODE>mysql -vvv</CODE> とします。

</P>
<P>
You can also use scripts in the <CODE>mysql</CODE> command-line prompt by
using the <CODE>source</CODE> command:

</P>

<PRE>
mysql&#62; source filename;
</PRE>



<H2><A NAME="Twin" HREF="manual.ja_toc.html#Twin">3.7  Queries from Twin Project</A></H2>

<P>
<A NAME="IDX426"></A>
<A NAME="IDX427"></A>

</P>
<P>
At Analytikerna and Lentus, we have been doing the systems and field work
for a big research project. This project is a collaboration between the
Institute of Environmental Medicine at Karolinska Institutet Stockholm
and the Section on Clinical Research in Aging and Psychology at the
University of Southern California.

</P>
<P>
The project involves a screening part where all twins in Sweden older
than 65 years are interviewed by telephone. Twins who meet certain
criteria are passed on to the next stage. In this latter stage, twins who
want to participate are visited by a doctor/nurse team. Some of the
examinations include physical and neuropsychological examination,
laboratory testing, neuroimaging, psychological status assessment, and family
history collection. In addition, data are collected on medical and
environmental risk factors.

</P>
<P>
More information about Twin studies can be found at:
<a HREF="http://www.imm.ki.se/TWIN/TWINUKW.HTM">http://www.imm.ki.se/TWIN/TWINUKW.HTM</a>

</P>
<P>
The latter part of the project is administered with a web interface
written using Perl and MySQL.

</P>
<P>
Each night all data from the interviews are moved into a MySQL
database.

</P>



<H3><A NAME="Twin_pool" HREF="manual.ja_toc.html#Twin_pool">3.7.1  Find all Non-distributed Twins</A></H3>

<P>
The following query is used to determine who goes into the second part of the
project:

</P>

<PRE>
SELECT
        CONCAT(p1.id, p1.tvab) + 0 AS tvid,
        CONCAT(p1.christian_name, " ", p1.surname) AS Name,
        p1.postal_code AS Code,
        p1.city AS City,
        pg.abrev AS Area,
        IF(td.participation = "Aborted", "A", " ") AS A,
        p1.dead AS dead1,
        l.event AS event1,
        td.suspect AS tsuspect1,
        id.suspect AS isuspect1,
        td.severe AS tsevere1,
        id.severe AS isevere1,
        p2.dead AS dead2,
        l2.event AS event2,
        h2.nurse AS nurse2,
        h2.doctor AS doctor2,
        td2.suspect AS tsuspect2,
        id2.suspect AS isuspect2,
        td2.severe AS tsevere2,
        id2.severe AS isevere2,
        l.finish_date
FROM
        twin_project AS tp
        /* For Twin 1 */
        LEFT JOIN twin_data AS td ON tp.id = td.id
                  AND tp.tvab = td.tvab
        LEFT JOIN informant_data AS id ON tp.id = id.id
                  AND tp.tvab = id.tvab
        LEFT JOIN harmony AS h ON tp.id = h.id
                  AND tp.tvab = h.tvab
        LEFT JOIN lentus AS l ON tp.id = l.id
                  AND tp.tvab = l.tvab
        /* For Twin 2 */
        LEFT JOIN twin_data AS td2 ON p2.id = td2.id
                  AND p2.tvab = td2.tvab
        LEFT JOIN informant_data AS id2 ON p2.id = id2.id
                  AND p2.tvab = id2.tvab
        LEFT JOIN harmony AS h2 ON p2.id = h2.id
                  AND p2.tvab = h2.tvab
        LEFT JOIN lentus AS l2 ON p2.id = l2.id
                  AND p2.tvab = l2.tvab,
        person_data AS p1,
        person_data AS p2,
        postal_groups AS pg
WHERE
        /* p1 gets main twin and p2 gets his/her twin. */
        /* ptvab is a field inverted from tvab */
        p1.id = tp.id AND p1.tvab = tp.tvab AND
        p2.id = p1.id AND p2.ptvab = p1.tvab AND
        /* Just the sceening survey */
        tp.survey_no = 5 AND
        /* Skip if partner died before 65 but allow emigration (dead=9) */
        (p2.dead = 0 OR p2.dead = 9 OR
         (p2.dead = 1 AND
          (p2.death_date = 0 OR
           (((TO_DAYS(p2.death_date) - TO_DAYS(p2.birthday)) / 365)
            &#62;= 65))))
        AND
        (
        /* Twin is suspect */
        (td.future_contact = 'Yes' AND td.suspect = 2) OR
        /* Twin is suspect - Informant is Blessed */
        (td.future_contact = 'Yes' AND td.suspect = 1
                                   AND id.suspect = 1) OR
        /* No twin - Informant is Blessed */
        (ISNULL(td.suspect) AND id.suspect = 1
                            AND id.future_contact = 'Yes') OR
        /* Twin broken off - Informant is Blessed */
        (td.participation = 'Aborted'
         AND id.suspect = 1 AND id.future_contact = 'Yes') OR
        /* Twin broken off - No inform - Have partner */
        (td.participation = 'Aborted' AND ISNULL(id.suspect)
                                      AND p2.dead = 0))
        AND
        l.event = 'Finished'
        /* Get at area code */
        AND SUBSTRING(p1.postal_code, 1, 2) = pg.code
        /* Not already distributed */
        AND (h.nurse IS NULL OR h.nurse=00 OR h.doctor=00)
        /* Has not refused or been aborted */
        AND NOT (h.status = 'Refused' OR h.status = 'Aborted'
        OR h.status = 'Died' OR h.status = 'Other')
ORDER BY
        tvid;
</PRE>

<P>
Some explanations:
<DL COMPACT>

<DT><CODE>CONCAT(p1.id, p1.tvab) + 0 AS tvid</CODE>
<DD>
We want to sort on the concatenated <CODE>id</CODE> and <CODE>tvab</CODE> in
numerical order. Adding <CODE>0</CODE> to the result causes MySQL to
treat the result as a number.
<DT>column <CODE>id</CODE>
<DD>
This identifies a pair of twins. It is a key in all tables.
<DT>column <CODE>tvab</CODE>
<DD>
This identifies a twin in a pair. It has a value of <CODE>1</CODE> or <CODE>2</CODE>.
<DT>column <CODE>ptvab</CODE>
<DD>
This is an inverse of <CODE>tvab</CODE>. When <CODE>tvab</CODE> is <CODE>1</CODE> this is
<CODE>2</CODE>, and vice versa. It exists to save typing and to make it easier for
MySQL to optimize the query.
</DL>

<P>
This query demonstrates, among other things, how to do lookups on a
table from the same table with a join (<CODE>p1</CODE> and <CODE>p2</CODE>). In the example, this
is used to check whether a twin's partner died before the age of 65. If so,
the row is not returned.

</P>
<P>
All of the above exist in all tables with twin-related information. We
have a key on both <CODE>id,tvab</CODE> (all tables), and <CODE>id,ptvab</CODE>
(<CODE>person_data</CODE>) to make queries faster.

</P>
<P>
On our production machine (A 200MHz UltraSPARC), this query returns
about 150-200 rows and takes less than one second.

</P>
<P>
The current number of records in the tables used above:
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><STRONG>Table</STRONG> </TD><TD> <STRONG>Rows</STRONG>
</TR NOSAVE>
<TR><TD><CODE>person_data</CODE> </TD><TD> 71074
</TR NOSAVE>
<TR><TD><CODE>lentus</CODE> </TD><TD> 5291
</TR NOSAVE>
<TR><TD><CODE>twin_project</CODE> </TD><TD> 5286
</TR NOSAVE>
<TR><TD><CODE>twin_data</CODE> </TD><TD> 2012
</TR NOSAVE>
<TR><TD><CODE>informant_data</CODE> </TD><TD> 663
</TR NOSAVE>
<TR><TD><CODE>harmony</CODE> </TD><TD> 381
</TR NOSAVE>
<TR><TD><CODE>postal_groups</CODE> </TD><TD> 100
</TR>
</TABLE>

</P>



<H3><A NAME="Twin_event" HREF="manual.ja_toc.html#Twin_event">3.7.2  Show a Table on Twin Pair Status</A></H3>

<P>
Each interview ends with a status code called <CODE>event</CODE>. The query
shown here is used to display a table over all twin pairs combined by
event. This indicates in how many pairs both twins are finished, in how many
pairs one twin is finished and the other refused, and so on.

</P>

<PRE>
SELECT
        t1.event,
        t2.event,
        COUNT(*)
FROM
        lentus AS t1,
        lentus AS t2,
        twin_project AS tp
WHERE
        /* We are looking at one pair at a time */
        t1.id = tp.id
        AND t1.tvab=tp.tvab
        AND t1.id = t2.id
        /* Just the sceening survey */
        AND tp.survey_no = 5
        /* This makes each pair only appear once */
        AND t1.tvab='1' AND t2.tvab='2'
GROUP BY
        t1.event, t2.event;

</PRE>



<H2><A NAME="Apache" HREF="manual.ja_toc.html#Apache">3.8  Using MySQL with Apache</A></H2>

<P>
<A NAME="IDX428"></A>

</P>
<P>
There are programs that let you authenticate your users from a MySQL
database and also let you log your log files into a MySQL table.

</P>
<P>
You can change the Apache logging format to be easily readable by
MySQL by putting the following into the Apache configuration file:

</P>

<PRE>
LogFormat \
        "\"%h\",%{%Y%m%d%H%M%S}t,%&#62;s,\"%b\",\"%{Content-Type}o\",  \
        \"%U\",\"%{Referer}i\",\"%{User-Agent}i\""
</PRE>

<P>
In MySQL you can do something like this:

</P>

<PRE>
LOAD DATA INFILE '/local/access_log' INTO TABLE table_name
FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' ESCAPED BY '\\'
</PRE>

<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Installing.html">previous</A>, <A HREF="manual.ja_MySQL_Database_Administration.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
