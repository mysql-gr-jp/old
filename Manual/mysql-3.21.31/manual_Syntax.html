  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.texi on 20 June 1998 -->

  <TITLE>MySQL Reference Manual for version 3.21.31. - MySQL 言語リファレンス</TITLE>
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Privilege_system.html">previous</A>, <A HREF="manual_Stabilty.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Syntax" HREF="manual_toc.html#Syntax"><STRONG>MySQL</STRONG> 言語リファレンス</A></H1>

<P>
<A NAME="IDX26"></A>


<H2><A NAME="Base Syntax" HREF="manual_toc.html#Base Syntax">リテラル。文字列と数値をどのように書くか？</A></H2>



<H3><A HREF="manual_toc.html#">文字列</A></H3>

<P>
文字列は ' または " で括られます。

</P>
<P>
\ はエスケープ文字です。次のエスケープ文字が認識されます:
<DL COMPACT>

<DT><CODE>\0</CODE>
<DD>
ASCII 0 文字。
<DT><CODE>\n</CODE>
<DD>
改行文字。
<DT><CODE>\t</CODE>
<DD>
タブ文字。
<DT><CODE>\r</CODE>
<DD>
リターン文字。
<DT><CODE>\b</CODE>
<DD>
バックスペース文字。
<DT><CODE>\'</CODE>
<DD>
<CODE>'</CODE> 文字。
<DT><CODE>\"</CODE>
<DD>
<CODE>"</CODE> 文字。
<DT><CODE>\\</CODE>
<DD>
<CODE>\</CODE> 文字。
<DT><CODE>\%</CODE>
<DD>
<CODE>%</CODE> 文字。これは <CODE>%</CODE> を検索するために、ワイルドカード文字列中
で使用されます。
<DT><CODE>\_</CODE>
<DD>
<CODE>_</CODE> 文字。これは <CODE>_</CODE> を検索するために、ワイルドカード文字列中
で使用されます。
</DL>


<PRE>
' で始まる文字列中の ' は '' として書きます。
" で始まる文字列中の " は "" として書きます。
</PRE>

<P>
どのようにそれが働くかを示すいくつかの select の例。

<PRE>
MySQL&#62; select 'hello', "'hello'", '""hello""', '''h''e''l''l''o''', "hel""lo";
1 rows in set (0.00 sec)

+-------+---------+-----------+-------------+--------+
| hello | 'hello' | ""hello"" | 'h'e'l'l'o' | hel"lo |
+-------+---------+-----------+-------------+--------+
| hello | 'hello' | ""hello"" | 'h'e'l'l'o' | hel"lo |
+-------+---------+-----------+-------------+--------+
</PRE>


<PRE>
mysql&#62; select 'hello', "hello", '""hello""', "'ello", 'e''l''lo', '\'hello';
1 rows in set (0.00 sec)

+-------+-------+-----------+-------+--------+--------+
| hello | hello | ""hello"" | 'ello | e'l'lo | 'hello |
+-------+-------+-----------+-------+--------+--------+
| hello | hello | ""hello"" | 'ello | e'l'lo | 'hello |
+-------+-------+-----------+-------+--------+--------+
</PRE>


<PRE>
mysql&#62; select "This\nIs\nFour\nlines";
1 rows in set (0.00 sec)

+--------------------+
| This
Is
Four
lines |
+--------------------+
| This
Is
Four
lines |
+--------------------+
</PRE>

<P>
<A NAME="IDX27"></A>

</P>
<P>
バイナリデータを BLOB に挿入したい場合、次の文字をエスケープシーケンスで
表す必要があります:
<DL COMPACT>

<DT><CODE>\0</CODE>
<DD>
ASCII 0。"\0"(バックスラッシュと数字 0)に置き換えます 。
<DT><CODE>\</CODE>
<DD>
ASCII 92, バックスラッシュ
<DT><CODE>'</CODE>
<DD>
ASCII 39, 引用符
<DT><CODE>"</CODE>
<DD>
ASCII 33, 二重引用符
</DL>

<P>
<CODE>'</CODE> 内での <CODE>"</CODE> と <CODE>'</CODE> 内での <CODE>"</CODE> はエスケープしては
いけません。

</P>
<P>
C コードを書く場合、<CODE>INSERT</CODE> 節で文字をエスケープするために、C API 
関数 <CODE>mysql_escape_string(char *to,char *from,uint length)</CODE> を使用
できます ('to' は少なくとも from より2倍大きいことに注意してください)。 
perl では <CODE>quote</CODE> 関数を使用できます。

</P>
<P>
上記の特殊文字の一つを持つ可能性のある全ての文字列について、エスケープ関
数を実行すべきです！

</P>


<H3><A HREF="manual_toc.html#">数値</A></H3>

<P>
整数は数字の項目です。浮動小数点は <CODE>.</CODE> で小数を分割します。

</P>
<P>
正当な数値の例: <CODE>1221</CODE>, <CODE>294.42</CODE>, <CODE>-32032.6809e+10</CODE>。

</P>


<H3><A HREF="manual_toc.html#"><CODE>NULL</CODE></A></H3>

<P>
テキストファイル出力形式を使用する時、<CODE>NULL</CODE> は <CODE>\N</CODE> として表
されます。 「<A HREF="manual_Syntax.html#Load">LOAD DATA INFILE 構文</A>」節参照 

</P>



<H3><A NAME="Legal names" HREF="manual_toc.html#Legal names">データベース, テーブル, インデックスそして項目の名前</A></H3>

<P>
データベース、テーブル、インデックスそして項目の名前は、<STRONG>MySQL</STRONG> 
では全て同じ規則に基づきます。

</P>
<P>
名前は、デフォルト文字セットのアルファベットと数字を使用します。これはデ
フォルトでは ISO-8859-1 Latin1 ですが、<STRONG>MySQL</STRONG> コンパイル時に変更
できます。

</P>
<P>
<STRONG>MySQL</STRONG> は、何かが名前か数値かを決定できることが必要なため、次の
特殊な場合が発生します。

</P>

<UL>
<LI>

名前は数字だけではできません。
<LI>

名前は数字で始めることができます。これは多くの他のシステムとは異なります！
<LI>

<CODE>1e</CODE> のような名前を使用することは勧められません。これは <CODE>1e+1</CODE> 
のような表現は、表現 <CODE>1e + 1</CODE> または数値 <CODE>1e+1</CODE> のように解釈さ
れるためです。
</UL>

<P>
名前中に <CODE>.</CODE> や <CODE>@</CODE> のような記号文字は許されません。これらは 
<STRONG>MySQL</STRONG> の拡張で使用されるためです。

</P>
<P>
MySQL では次の構文のどれかで項目を参照できます:

</P>

<UL>
<LI>column

<LI>table.column

<LI>database.table.column

<LI>table@database.column

</UL>

<P>
'column' または 'table.column' を使用する場合、使用されたテーブルの間で
名前がユニークでなければエラーになります！

</P>


<H2><A NAME="Column types" HREF="manual_toc.html#Column types">項目型</A></H2>

<P>
次の項目型がサポートされます:

</P>

<UL>
<LI>

M は最大表示サイズを意味します。
<LI>

L は1行の実際の長さを意味します。
<LI>

M は最大長を意味します。
<LI>

D は10進数を意味します。
</UL>

<P>
<A NAME="IDX28"></A>

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>Name </TD><TD> Description </TD><TD> Size

</TR NOSAVE>
<TR><TD>TINYINT[(M)] [UNSIGNED] [ZEROFILL] </TD><TD>
<A NAME="IDX29"></A>
 
とても小さい整数。符号つきの範囲は -128～127。符号なしの範囲は 0～255。 </TD><TD> 1

</TR NOSAVE>
<TR><TD>SMALLINT[(M)]. [UNSIGNED] [ZEROFILL] </TD><TD>
<A NAME="IDX30"></A>
 
小さい整数。符号つきの範囲は -32768～32767。符号なしの範囲は 0～65535。 </TD><TD> 2

</TR NOSAVE>
<TR><TD>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL] </TD><TD>
<A NAME="IDX31"></A>
 
中間の整数。符号ありの範囲は -8388608～8388607。符号なしの範囲は 0～
16777215。 </TD><TD> 3

</TR NOSAVE>
<TR><TD>INT[(M)] [UNSIGNED] [ZEROFILL] </TD><TD>
<A NAME="IDX32"></A>
 
通常の整数。符号ありの範囲は -2147483648～2147483647。符号なしの範囲は 0～
4294967295。 </TD><TD> 4

</TR NOSAVE>
<TR><TD>BIGINT[(M)] [UNSIGNED] [ZEROFILL] </TD><TD>
<A NAME="IDX33"></A>
 
大きい整数。符号ありの範囲は -9223372036854775808～9223372036854775807。
符号なしの範囲は 0～18446744073709551615。全ての演算は符合付き BIGINT ま
たは DOUBLE で行われるため、符合無しの 9223372036854775807 (63 bits) よ
りも大きな整数をビット関数以外で使用すべきではありません！ </TD><TD> 8

</TR NOSAVE>
<TR><TD>FLOAT(Precision) </TD><TD>
<A NAME="IDX34"></A>
 <A NAME="IDX35"></A>
 
小さい浮動小数点数。Precision は 4 または 8 にできます。FLOAT(4) は単精
度数で、FLOAT(8) は倍精度数です (DOUBLE エントリを参照してください)。こ
の構文は ODBC 互換です。範囲は -3.402823466E+38F～-1.175494351E-38, 0, 
-1.175494351E-38～3.402823466E+38F です。 </TD><TD> 4

</TR NOSAVE>
<TR><TD>FLOAT[(M,D)] </TD><TD>
<A NAME="IDX36"></A>
 <A NAME="IDX37"></A>
 
小さい浮動小数点数。符号なしにはできません。範囲は -3.402823466E+38F～
-1.175494351E-38, 0, -1.175494351E-38～3.402823466E+38F です。 </TD><TD> 4

</TR NOSAVE>
<TR><TD>DOUBLE PRECISION[(M,D)] </TD><TD>
<A NAME="IDX38"></A>
 
通常の浮動小数点数。符号なしにはできません。範囲は
-1.7976931348623157E+308～-2.2250738585072014E-308, 0,
2.2250738585072014E-308～1.7976931348623157E+308 です。 </TD><TD> 8

</TR NOSAVE>
<TR><TD>REAL[(M,D)] </TD><TD> DOUBLE と同じ </TD><TD> 8
<A NAME="IDX39"></A>
 

</TR NOSAVE>
<TR><TD>DECIMAL [(M,D)] </TD><TD>
<A NAME="IDX40"></A>
 
非パック浮動小数点数。符号なしにはできません。現在は double の最大範囲の
範囲です。CHAR 項目のように振舞います。 </TD><TD> M+D

</TR NOSAVE>
<TR><TD>NUMERIC [(M,D)] </TD><TD>
<A NAME="IDX41"></A>
 
DECIMAL と同じ </TD><TD> M+D

</TR NOSAVE>
<TR><TD>TIMESTAMP [(M)] </TD><TD>
<A NAME="IDX42"></A>
 
自動的なタイムスタンプ。多くの TIMESTAMP 項目を持つ場合、最初の一つだけ
が自動的になります。 </TD><TD> 4

</TR NOSAVE>
<TR><TD>DATE </TD><TD>
<A NAME="IDX43"></A>
 
日付情報を格納するための型。"YYYY-MM-DD" 構文を使用しますが、数値または
文字列で更新できます。少なくとも次の構文を理解します:
 'YY-MM-DD', 'YYYY-MM-DD', 'YYMMDD' そして完全なタイムスタンプ
(YYYYMMDDHHMMDD)。範囲は 0000-00-00 から 9999-12-31 です。 </TD><TD> 3

</TR NOSAVE>
<TR><TD>TIME </TD><TD>
<A NAME="IDX44"></A>
 
時刻情報を格納するための型。"HH:MM:SS" 構文を使用しますが、数値または文
字列で更新できます。少なくとも次の形式が理解できます: 'HH:MM:SS', 'HHMMSS',
'HHMM', 'HH'。 </TD><TD> 3

</TR NOSAVE>
<TR><TD>DATETIME </TD><TD>
<A NAME="IDX45"></A>
 
日付と時刻情報を格納するための型。形式 "YYYY-MM-DD HH:MM:SS"。8バイト使
用します。範囲は '0000-01-01 00:00:00'～'9999-12-31 23:59:59' です。 </TD><TD> 8

</TR NOSAVE>
<TR><TD>YEAR </TD><TD>
<A NAME="IDX46"></A>
 
年を格納するための型。形式 "YYYY" または "YY"。1バイト使用します。範囲は 
0, 1901-2155 です。範囲 00-69 の2桁の年は 2000-2069 とみなされ、正しくソー
トされます。(MySQL 3.22 の型) </TD><TD> 1

</TR NOSAVE>
<TR><TD>CHAR(M) [binary] </TD><TD>
<A NAME="IDX47"></A>
 
固定長文字列。常に固有の長さまで空白が埋められます。範囲は 1～255 文字で
す。終りの空白は読み出し時に削除されます。binary キーワードが与えられな
い場合、ソートと比較はケースに依存しません。 </TD><TD> M

</TR NOSAVE>
<TR><TD>VARCHAR(M) [binary] </TD><TD>
<A NAME="IDX48"></A>
 
可変長文字列。その長さで格納されます。全ての終わりの空白は格納時に削除さ
れます。最大範囲は 1～255 文字です。binary キーワードが与えられない場合、
ソートと比較はケースに依存しません。 </TD><TD> L+1

</TR NOSAVE>
<TR><TD>TINYTEXT and TINYBLOB </TD><TD>
<A NAME="IDX49"></A>
 <A NAME="IDX50"></A>
 
最大長 255 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。 </TD><TD> L+1

</TR NOSAVE>
<TR><TD>TEXT and BLOB </TD><TD>
<A NAME="IDX51"></A>
 <A NAME="IDX52"></A>
 
最大長 65535 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。 </TD><TD> L+2

</TR NOSAVE>
<TR><TD>MEDIUMTEXT and MEDIUMBLOB </TD><TD>
<A NAME="IDX53"></A>
 <A NAME="IDX54"></A>
 
最大長 16777216 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。 </TD><TD> L+3

</TR NOSAVE>
<TR><TD>LONGTEXT and LONGBLOB </TD><TD>
<A NAME="IDX55"></A>
 <A NAME="IDX56"></A>
 
最大長 4294967295 文字の <CODE>TEXT</CODE>/<CODE>BLOB</CODE>。 </TD><TD> L+4

</TR NOSAVE>
<TR><TD>ENUM('value','value2',...) </TD><TD>
<A NAME="IDX57"></A>
 
文字列オブジェクト。許可された値セットの一つ（または NULL）のみ持つこと
ができます。 「<A HREF="manual_Syntax.html#Type details">データ型についてさらに詳細</A>」節参照 。 </TD><TD> 1 または 2

</TR NOSAVE>
<TR><TD>SET('value','value2',...) </TD><TD>
<A NAME="IDX58"></A>
 
文字列オブジェクト。許可された値セットの一つまたは複数の値を持つことがで
きます。 「<A HREF="manual_Syntax.html#Type details">データ型についてさらに詳細</A>」節参照 。 </TD><TD> 1-8

</TR>
</TABLE>



<H3><A NAME="Type details" HREF="manual_toc.html#Type details">データ型についてさらに詳細</A></H3>



<H4><A HREF="manual_toc.html#">データベースサイズ情報</A></H4>
<P>
上のテーブルで L はインスタンスの実際の長さを、M は最大長を意味します。そして、
"abcd" の L+1 はデータベース内の 5 バイトを意味します。

</P>
<P>
長さフィールドが L のデータ型を使用した場合、可変長レコード形式を得ます。

</P>


<H4><A HREF="manual_toc.html#">数値型</A></H4>
<P>
全ての整数型はオプションの引数 <CODE>unsigned</CODE> を持つことができます。項目
で正の数値だけを許可したい時や、項目に少し大きな数値範囲を必要な時に、これ
を使用できます。

</P>
<P>
また、全ての整数項目についてのオプションの引数 <CODE>ZEROFILL</CODE> は、項目は最
大長まで 0 で埋められることを意味します。

</P>
<P>
最大表示サイズと小数は、整形と最大項目幅の計算によります。

</P>
<P>
範囲外の整数値を格納した時、<STRONG>MySQL</STRONG> は最大(または最小)の可能な値
を格納します。<CODE>ALTER TABLE</CODE> または <CODE>LOAD DATA INFILE</CODE> 時、これ
らの変換は '警告' として得られます。INSERT と UPDATE も警告を返せるよう
にすることは TODO 上にあります。しかし、これは次のプロトコル変更にスケジュー
ルされています。

</P>
<P>
例えば、<CODE>-999999999999999</CODE> を int 項目に格納する時、値は 
<CODE>-2147483648</CODE> となります。そして <CODE>9999999999999999</CODE> は 
<CODE>2147483647</CODE> となります。

</P>
<P>
そして、<CODE>int</CODE> が符号無しの場合、上の格納される値は <CODE>0</CODE> と
<CODE>4294967296</CODE> になります。

</P>
<P>
同じ規則が全ての他の整数型にも適用されます。

</P>
<P>
割り当てられた領域を超える int(4) 項目のデータを返す時、<STRONG>MySQL</STRONG> 
は 9.99 を返します。オペレーションが <CODE>UPDATE</CODE> の場合は、警告が出さ
れます。

</P>
<P>
<CODE>decimal(4,2)</CODE> のような型は、2桁の小数値を持った最大4文字を意味する
ことに注意して下さい。これは <CODE>-.99</CODE> -&#62; <CODE>9.99</CODE> の範囲を与えます。

</P>
<P>
いくつかの丸めの問題を回避するために、<STRONG>MySQL</STRONG> は浮動小数点の項目に
格納する全てを常に、小数の数に一致するように丸めます。これは、
<CODE>float(8,2)</CODE> 内に格納される <CODE>2.333</CODE> は <CODE>2.33</CODE> として格納
されることを意味します。

</P>
<P>
<A NAME="IDX59"></A>


<H4><A HREF="manual_toc.html#"><CODE>TIMESTAMP</CODE> 型</A></H4>
<P>
1970年12月1日 00:00 から 2106年のいつかまでの範囲を持ち、1秒の精度です。
TIMESTAMP 項目は、<CODE>NULL</CODE> が設定されるか、ステートメント中で項目が更
新されなければ <CODE>INSERT</CODE> と <CODE>UPDATE</CODE> ステートメントで自動的に更
新されます。インデックス(の一部)にできます。注意: 多くの timestamp 項目
が行にある場合は、最初の timestamp 項目だけが自動的に更新されます。任意
の timestamp 項目は <CODE>NULL</CODE> を設定すれば、現在の時刻に設定されます。
表示サイズに依存して、次の形式の一つが得られます: "YYYY-MM-DD HH:MM:SS",
"YY-MM-DD HH:MM:SS", "YYYY-MM-DD" or "YY-MM-DD"。

</P>
<P>
<A NAME="IDX60"></A>
<A NAME="IDX61"></A>


<H4><A HREF="manual_toc.html#"><CODE>TEXT</CODE> と <CODE>BLOB</CODE> 型</A></H4>
<P>
これらは上限無しの可変長を持つことができるオブジェクトです。全ての TEXT 
と BLOB オブジェクトはその長さ(オブジェクトの型に依存して 1 から 4 バイ
ト)と共に格納されます。使用可能な <CODE>TEXT</CODE> と <CODE>BLOB</CODE> の最大長は、
有効なメモリとクライアントバッファに依存します。<CODE>TEXT</CODE> と 
<CODE>BLOB</CODE> の違いは、<CODE>TEXT</CODE> はケースに依存しないでソートと比較され、
<CODE>BLOB</CODE> はケースに依存して(文字コードで)比較されることだけです。
<CODE>TEXT </CODE>と <CODE>BLOB</CODE> オブジェクトはインデックスにはできません。

</P>
<P>
BLOB はバイナリ巨大オブジェクト(binary large object)で、大きなデータを保
持できます。4種類の BLOB があります  「<A HREF="manual_Syntax.html#Column types">項目型</A>」節参照 。通常、BLOB は制
限無しの VARCHAR と見なすことができます。

</P>
<P>
<CODE>TEXT</CODE> は、ソートと比較がケースに依存しない <CODE>BLOB</CODE> です。

</P>
<P>
<CODE>BLOB</CODE>/<CODE>TEXT</CODE> 項目はメッセージバッファより大きくできません。サー
バとクライアントのメッセージバッファを変更する必要があることに注意してく
ださい。 「<A HREF="manual_Performance.html#MySQL parameters"><STRONG>MySQL</STRONG> のバッファサイズの変更方法</A>」節参照 。

</P>
<P>
<CODE>MyODBC</CODE> は <CODE>BLOB</CODE> を <CODE>LONGVARBINARY</CODE> として、そして 
<CODE>TEXT</CODE> を <CODE>LONGVARCHAR</CODE> として定義します。

</P>
<P>
<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 項目の制限:

</P>

<OL>
<LI>

<CODE>BLOB</CODE> または <CODE>TEXT</CODE> はインデックスまたはインデックスの一部に
はできません。
<LI>

<CODE>BLOB</CODE> または <CODE>TEXT</CODE> のソートまたはグループ時には、BLOB の最初
の <CODE>max_sort_length</CODE> (デフォルト 1024) だけが使用されます。この値は、
mysqld デーモン起動時に <CODE>-O</CODE> オプションで変更できます。
<CODE>BLOB</CODE>/<CODE>TEXT</CODE> を含んだ表現でグループできます: <CODE>SELECT
id,SUBSTR(blob,1,100) GROUP BY 2</CODE>
<LI>

<CODE>BLOB</CODE> と <CODE>TEXT</CODE> では、終りの空白は <CODE>CHAR</CODE> や 
<CODE>VARCHAR</CODE> のようにはカットされません。
</OL>

<P>
<A NAME="IDX62"></A>


<H4><A HREF="manual_toc.html#"><CODE>ENUM</CODE> 型</A></H4>
<P>
文字列オブジェクト。許可された値セットの一つだけを持つことができます。格
納される値はケース非依存です。存在しない値を格納しようとすると、"" が格
納されます。数値文脈で使用された場合は、このオブジェクトは値インデックス
を返/格納します。有効な値が 255 個より少ない場合は、このオブジェクトは 1 
バイト、そうでなければ 2バイト占有します (最大で 65535 個の異なる値)。整
数が <CODE>ENUM</CODE> に置かれた場合、最初が番号 1 として数えられる、対応する
文字列を得ることに注意して下さい (0 は間違った enum 値のために予約されて
います)。<CODE>ENUM</CODE> 型でのソートは、enum 内の文字列の順によって行なわれ
ます。<CODE>NOT NULL</CODE> と宣言された場合、デフォルト値は最初の値です。そう
でなければデフォルト値は <CODE>NULL</CODE> です。

</P>
<P>
例えば、項目 <CODE>test ENUM("one","two", "three")</CODE> は次の値の任意を持つ
ことができます:

</P>

<PRE>
NULL
"one"
"two"
"three"
</PRE>

<P>
<A NAME="IDX63"></A>


<H4><A HREF="manual_toc.html#"><CODE>SET</CODE> 型</A></H4>
<P>
文字列オブジェクト。許可された値セットの一つまたは複数を持つことができま
す。各値は ',' で区切られます。数値文脈で使われると、このオブジェクトは
使用された値のビット位置を返し/格納します。このオブジェクトは (異なる値
の数-1)/8+1 を 1,2,3,4 または 8 に丸めたバイトを占有します。64 個以上の
異なる値は持てません。整数が <CODE>SET</CODE> 内に置かれた場合、最初のビットが
最初の文字列に対応するように、対応する文字列が得られることに注意してくだ
さい。<CODE>SET</CODE> 型でのソートは数値として行なわれます。

</P>
<P>
例えば、項目 <CODE>test SET("one","two") NOT NULL</CODE> は次の値を持つことが
できます:

</P>

<PRE>
""
"one"
"two"
"one,two"
</PRE>

<P>
通常、LIKE または FINS_IN_SET() での、SET 項目の SELECT:

</P>

<PRE>
SELECT * from banner where banner_group LIKE '%value%';
SELECT * from banner where FIND_IN_SET('value',banner_group)&#62;0;
</PRE>

<P>
しかし次も働きます:

</P>

<PRE>
SELECT * from banner where banner_group = 'v1,v2';  ;Exact match
SELECT * from banner where banner_group &#38; 1;        ;Is in first group
</PRE>

<P>
<A NAME="IDX64"></A>
<A NAME="IDX65"></A>


<H3><A NAME="Choosing types" HREF="manual_toc.html#Choosing types">正しい項目型の選択</A></H3>

<P>
最も精度の高い型を全ての場合に使用してみて下さい。例えば、1-99999 の整数
には、<CODE>unsigned mediumint</CODE> が最良の型です。

</P>
<P>
良くある問題は、貨幣の値の正確な表現です。<STRONG>MySQL</STRONG> では 
<CODE>DECIMAL</CODE> 型を使用すべきです。これは文字列として格納し、正確さのロ
スは発生しません。正確さが重要でない場合は <CODE>DOUBLE</CODE> 型でも十分良い
です。

</P>
<P>
高精度のため、常に <CODE>BITINT</CODE> に格納される固定小数点型に変換できます。
これは、全ての計算を整数で行なうようにし、結果だけを浮動小数点に変換して
戻します。

</P>
<P>
 「<A HREF="manual_Performance.html#Row format">行形式の種類は？ また VARCHAR/CHAR の使用時は？</A>」節参照 .

</P>
<P>
<A NAME="IDX66"></A>
<A NAME="IDX67"></A>


<H3><A NAME="Indexes" HREF="manual_toc.html#Indexes">項目インデックス</A></H3>

<P>
<CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型を除く <STRONG>MySQL</STRONG> の全ての項目はインデッ
クスを持つことができます。適切な項目でのインデックスの使用は、select の
性能を向上する最良の方法です。

</P>
<P>
<CODE>CHAR</CODE> と <CODE>VARCHAR</CODE> 項目には接頭部にインデックスを持つことができ
ます。次の例は、項目の最初の 10 文字にインデックスを作成する方法を示します。
これは項目全体にインデックスを持つのに比べ、とても速く、そしてより少ないディ
スク領域が必要です。

</P>

<PRE>
CREATE TABLE test (
name CHAR(200) NOT NULL,
KEY index_name (name(10));
</PRE>



<H3><A HREF="manual_toc.html#">複数項目インデックス</A></H3>

<P>
<STRONG>MySQL</STRONG> は異なる項目のセットに一つのインデックスを持つことができま
す。

</P>
<P>
複数項目インデックスは、項目が連結され、ソートされた配列と見なすことがで
きます。これは、インデックス内の最初の項目が知られた量で、他の項目がそうで
ない場合に、クエリが速くなります。

</P>
<P>
次のテーブルを持っていると仮定します:

</P>

<PRE>
CREATE TABLE test (
id INT NOT NULL,
last_name CHAR(30) NOT NULL,
first_name CHAR(30) NOT NULL,
PRIMARY KEY (id),
INDEX name (last_name,first_name));
</PRE>

<P>
インデックス <CODE>name</CODE> は last_name と first_name にまたがったインデッ
クスです。

</P>
<P>
<CODE>name</CODE> インデックスは次のクエリで使用されます:

</P>

<PRE>
SELECT * FROM test WHERE last_name="Widenius";

SELECT * FROM test WHERE last_name="Widenius" AND first_name="Michael";

SELECT * FROM test WHERE last_name="Widenius" AND
                         (first_name="Michael" OR first_name="Monty");

SELECT * FROM test WHERE last_name="Widenius" and
                         first_name &#62;="M" and first_name &#60; "N";
</PRE>

<P>
<CODE>name</CODE> インデックスは次のクエリでは使用されません:

</P>

<PRE>
SELECT * FROM test WHERE first_name="Michael";

SELECT * FROM test WHERE last_name="Widenius" or first_name="Michael";
</PRE>

<P>
<A NAME="IDX68"></A>


<H3><A HREF="manual_toc.html#">異なるデータベースエンジンとの間でテーブル定義を簡単に移植するための型対応</A></H3>
<P>
                                                                     
他の SQL ベンダからのコードの使用をより簡単にサポートするため、
<STRONG>MySQL</STRONG> は次の対応をサポートします:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>binary(num) </TD><TD> char(num) binary
</TR NOSAVE>
<TR><TD>char varying </TD><TD> varchar
</TR NOSAVE>
<TR><TD>float4 </TD><TD> float
</TR NOSAVE>
<TR><TD>float8 </TD><TD> double
</TR NOSAVE>
<TR><TD>int1 </TD><TD> tinyint
</TR NOSAVE>
<TR><TD>int2 </TD><TD> smallint
</TR NOSAVE>
<TR><TD>int3 </TD><TD> mediumint
</TR NOSAVE>
<TR><TD>int4 </TD><TD> int
</TR NOSAVE>
<TR><TD>int8 </TD><TD> bigint
</TR NOSAVE>
<TR><TD>long varbinary </TD><TD> blob
</TR NOSAVE>
<TR><TD>long varchar </TD><TD> text
</TR NOSAVE>
<TR><TD>middleint </TD><TD> mediumint
</TR NOSAVE>
<TR><TD>varbinary(num) </TD><TD> varchar(num) binary
</TR>
</TABLE>



<H2><A NAME="Functions" HREF="manual_toc.html#Functions"><CODE>SELECT</CODE> と <CODE>WHERE</CODE> 節で使用する関数</A></H2>

<P>
<CODE>select_expression</CODE> または <CODE>where_definition</CODE> は次の関数を使用
した任意の表現からなります:

</P>
<P>
次の例では、<CODE>mysql</CODE> プログラムの出力は短くなっています。つまり:

</P>

<PRE>
mysql&#62; select mod(29,9);
1 rows in set (0.00 sec)

+-----------+
| mod(29,9) |
+-----------+
|         2 |
+-----------+
</PRE>

<P>
これは次に変換されています:

</P>

<PRE>
mysql&#62; select mod(29,9);                -&#62;      2
</PRE>

<P>
<A NAME="IDX70"></A>


<H3><A NAME="Grouping functions" HREF="manual_toc.html#Grouping functions">グループ化関数</A></H3>
<DL COMPACT>

<DT><CODE>(</CODE>
<DD>
<A NAME="IDX69"></A>
 <A NAME="IDX71"></A>
 
<A NAME="IDX72"></A>
<DT><CODE>)</CODE>
<DD>
<A NAME="IDX73"></A>
括弧。表現の評価の順を強制します。

<PRE>
mysql&#62; select 1+2*3;                     -&#62;      7
mysql&#62; select (1+2)*3;                   -&#62;      9
</PRE>

</DL>



<H3><A NAME="Arithmetic functions" HREF="manual_toc.html#Arithmetic functions">通常の算術演算</A></H3>
<P>
<A NAME="IDX74"></A>
<DL COMPACT>

<DT><CODE>+</CODE>
<DD>
<A NAME="IDX75"></A>
 
加算
<A NAME="IDX76"></A>
<DT><CODE>-</CODE>
<DD>
減算。
<A NAME="IDX77"></A>
<DT><CODE>*</CODE>
<DD>
乗算
<A NAME="IDX78"></A>
<DT><CODE>/</CODE>
<DD>
除算。0 割りは <CODE>NULL</CODE> を返します。

<PRE>
mysql&#62; select 102/(1-1);                 -&#62;      NULL
</PRE>

</DL>

<P>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>


<H3><A NAME="Bit functions" HREF="manual_toc.html#Bit functions">ビット関数</A></H3>
<P>
これらは最大 64 ビットの範囲を持ちます。<STRONG>MySQL</STRONG> は bigint (64
bit) 演算を使用するためです。
<DL COMPACT>

<DT><CODE>|</CODE>
<DD>
<A NAME="IDX81"></A>
 
ビット演算 OR。

<PRE>
mysql&#62; select 29 | 15;                   -&#62;     31
</PRE>

<A NAME="IDX82"></A>
<DT><CODE>&#38;</CODE>
<DD>
ビット演算 AND。

<PRE>
mysql&#62; select 29 &#38; 15;                   -&#62;      13
</PRE>

<A NAME="IDX83"></A>
<DT><CODE>BIT_COUNT()</CODE>
<DD>
引数のセットされているビットの数。

<PRE>
mysql&#62; select bit_count(29);             -&#62;      4
</PRE>

</DL>

<P>
<A NAME="IDX84"></A>


<H3><A NAME="Logical functions" HREF="manual_toc.html#Logical functions">論理演算</A></H3>
<P>
全ての論理関数は 1 (TRUE) または 0 (FALSE) を返します。
<DL COMPACT>

<DT><CODE>NOT</CODE>
<DD>
<A NAME="IDX85"></A>
 
<A NAME="IDX86"></A>
<DT><CODE>!</CODE>
<DD>
論理否定。引数が 0 なら 1 を返し、そうでなければ 0 を返します。

<PRE>
mysql&#62; select NOT 1;                    -&#62;      0
mysql&#62; select NOT NULL;                 -&#62;      NULL
mysql&#62; select ! (1+1);                  -&#62;      0
mysql&#62; select ! 1+1;                    -&#62;      1
</PRE>

<A NAME="IDX87"></A>
<DT><CODE>OR</CODE>
<DD>
<A NAME="IDX88"></A>
<DT><CODE>||</CODE>
<DD>
論理和。引数のどれかが 0 または NULL でなければ 1 を返します。

<PRE>
mysql&#62; select 1 || 0;                   -&#62;      1
mysql&#62; select 0 || 0;                   -&#62;      0
mysql&#62; select 1 || NULL;                -&#62;      1

</PRE>

<A NAME="IDX89"></A>
<DT><CODE>AND</CODE>
<DD>
<A NAME="IDX90"></A>
<DT><CODE>&#38;&#38;</CODE>
<DD>
論理積。全ての引数が 0 または NULL でなければ 1 を返します。

<PRE>
mysql&#62; select 1 &#38;& NULL;                -&#62;      0
mysql&#62; select 1 &#38;& 0;                   -&#62;      0
</PRE>

</DL>

<P>
<A NAME="IDX91"></A>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>


<H3><A NAME="Comparison functions" HREF="manual_toc.html#Comparison functions">比較演算子</A></H3>
<P>
1 (TRUE), 0 (FALSE) または <CODE>NULL</CODE> を返します。これらの関数は数値と
文字列の両方で働きます。<STRONG>MySQL</STRONG> は比較がどのように行なわれるかを
決定するために、次の規則を使用します:

<UL>
<LI>

比較操作の両方の引数が文字列の場合、文字列として比較されます。
<LI>

両方の引数が整数の場合、整数として比較されます。
<LI>

引数の一方が <CODE>TIMESTAMP</CODE> または <CODE>DATETIME</CODE> 項目で、他の引数が
定数の場合は、定数は比較前に timestamp に変換されます。これはより ODBC 
フレンドリにするためです。
<LI>

他の場合は全て浮動小数点(real)として比較されます。
</UL>

<P>
どちらかまたは両方の引数が <CODE>NULL</CODE> の場合は、比較結果は <CODE>NULL</CODE> 
です。

</P>
<DL COMPACT>

<DT><CODE>=</CODE>
<DD>
<A NAME="IDX94"></A>
 
等しい。

<PRE>
mysql&#62; select 1 = 0;                    -&#62;      0
mysql&#62; select '0' = 0;                  -&#62;      1
mysql&#62; select '0.0' = 0;                -&#62;      1
mysql&#62; select '0.01' = 0;               -&#62;      0
mysql&#62; select '.01' = 0.01;             -&#62;      1
</PRE>

<A NAME="IDX95"></A>
<DT><CODE>&#60;&#62;</CODE>
<DD>
<A NAME="IDX96"></A>
<DT><CODE>!=</CODE>
<DD>
等しくない。

<PRE>
mysql&#62; select '.01' &#60;&#62; '0.01';          -&#62;      1
mysql&#62; select .01 &#60;&#62; '0.01';            -&#62;      0
mysql&#62; select 'zapp' &#60;&#62; 'zappp';        -&#62;      1
</PRE>

<A NAME="IDX97"></A>
<DT><CODE>&#60;=</CODE>
<DD>
より小さいまたは等しい。

<PRE>
mysql&#62; select 0.1 &#60;= 2;                 -&#62;      1
</PRE>

<A NAME="IDX98"></A>
<DT><CODE>&#60;</CODE>
<DD>
より小さい。

<PRE>
mysql&#62; select 2 &#60;= 2;                   -&#62;      1
</PRE>

<A NAME="IDX99"></A>
<DT><CODE>&#62;=</CODE>
<DD>
より大きいまたは等しい。

<PRE>
mysql&#62; select 2 &#62;= 2;                   -&#62;      1
</PRE>

<A NAME="IDX100"></A>
<DT><CODE>&#62;</CODE>
<DD>
より大きい。

<PRE>
mysql&#62; select 2 &#62; 2;                    -&#62;      0
</PRE>

<A NAME="IDX101"></A>
<DT><CODE>ISNULL(A)</CODE>
<DD>
<CODE>A</CODE> が <CODE>NULL</CODE> なら 1 を、そうでなければ 0 を返します。

<PRE>
mysql&#62; select isnull(1+1);              -&#62;      0
mysql&#62; select isnull(1/0);              -&#62;      1
</PRE>

<A NAME="IDX102"></A>
<DT><CODE>A BETWEEN B AND C</CODE>
<DD>
<CODE>A</CODE> が <CODE>B</CODE> 以上かつ <CODE>A</CODE> が <CODE>C</CODE> 以下。全ての引数が同
じ型の場合、<CODE>(A &#62;= B AND A &#60;= C)</CODE> と同じです。比較がどのように行な
われるかを決定するのは最初の引数 (<CODE>A</CODE>) です！ <CODE>A</CODE> が文字列表現
の場合、ケース非依存文字列として比較されます。<CODE>A</CODE> がバイナリ文字列
の場合、バイナリ文字列として比較されます。<CODE>A</CODE> が正数表現の場合、正
数として検索されます。そうでなければ実数として比較されます。

<PRE>
mysql&#62; select 1 between 2 and 3;        -&#62;      0
mysql&#62; select 'b' between 'a' and 'c';  -&#62;      1
mysql&#62; select 2 between 2 and '3';      -&#62;      1
mysql&#62; select 2 between 2 and 'x-3';    -&#62;      0
</PRE>

</DL>

<P>
<A NAME="IDX103"></A>


<H3><A NAME="String comparison functions" HREF="manual_toc.html#String comparison functions">文字列比較関数</A></H3>
<DL COMPACT>

<DT><CODE>expr IN (value,...)</CODE>
<DD>
<A NAME="IDX104"></A>
 
expr が <CODE>IN</CODE> リスト中の値のどれかなら 1 を返し、そうでなければ 0 を
返します。全ての値が定数の場合は、全ての値は expr の型に従って評価、ソー
トされます。項目の検索はバイナリ検索の使用によって行なわれます。これは、
<CODE>IN</CODE> 部内に定数が使用された場合に <CODE>IN</CODE> はとても速いことを意味
します。

<PRE>
mysql&#62; select 2 in (0,3,5,'wefwf');               -&#62;      0
mysql&#62; select 'wefwf' in (0,3,5,'wefwf');         -&#62;      1
</PRE>

<A NAME="IDX105"></A>
<DT><CODE>expr NOT IN (value,...)</CODE>
<DD>
<CODE>NOT (expr IN (value,...))</CODE> と同じ

<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
<DT><CODE>expr LIKE expr</CODE>
<DD>
SQL の簡単な正規表現比較です。1 (TRUE) または 0 (FALSE) を返します。
<CODE>LIKE</CODE> には2つのワイルドカードがあります。

<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>%</CODE> </TD><TD> 任意の数の文字(0文字も含む)に適合します。
</TR NOSAVE>
<TR><TD><CODE>_</CODE> </TD><TD> 厳密に1つの文字に適合します。
</TR NOSAVE>
<TR><TD><CODE>\%</CODE> </TD><TD> 1つの <CODE>%</CODE> に適合します。
</TR NOSAVE>
<TR><TD><CODE>\_</CODE> </TD><TD> 1つの <CODE>_</CODE> に適合します。
</TR>
</TABLE>

<PRE>
mysql&#62; select 'David!' like 'David_';             -&#62;      1
mysql&#62; select 'David!' like 'David\_';            -&#62;      0
mysql&#62; select 'David_' like 'David\_';            -&#62;      1
mysql&#62; select 'David!' like '%D%v%';              -&#62;      1
mysql&#62; select 10 like '1%';                       -&#62;      1
</PRE>

<CODE>LIKE</CODE> は数値表現でも許されます！（拡張）
<LI>expr NOT LIKE expr

<A NAME="IDX108"></A>
 
<CODE>NOT (expr LIKE expr)</CODE> と同じです。
<A NAME="IDX109"></A>
<LI>expr REGEXP expr

<A NAME="IDX110"></A>
<LI>expr RLIKE expr

拡張正規表現に基づいて文字列をチェックします。
 「<A HREF="manual_Regexp.html#Regexp"><STRONG>MySQL</STRONG> 正規表現構文の解説</A>」節参照 . <CODE>RLIKE</CODE>は <CODE>mSQL</CODE> 互換のためです。注意:
<STRONG>MySQL</STRONG> は文字列中で C エスケープ構文 (<CODE>\n</CODE>) を使用するため、
REGEXP 文字列内で使用する <CODE>'\'</CODE> は二重にする必要があります。

<PRE>
mysql&#62; select 'Monty!' regexp 'm%y%%';            -&#62;      0
mysql&#62; select 'Monty!' regexp '.*';               -&#62;      1
mysql&#62; select 'new*\n*line' regexp 'new\\*.\\*line'
</PRE>

<A NAME="IDX111"></A>
<LI>expr NOT REGEXP expr

<CODE>NOT (expr REGEXP expr)</CODE> と同じ。
<A NAME="IDX112"></A>
<LI>STRCMP()

文字列が同じなら 0 を返します。そうでなければ、最初の引数がソート順で小
さければ -1 を返します。そうでなければ 1 を返します。

<PRE>
mysql&#62; select strcmp('text', 'text2');            -&#62; -1
mysql&#62; select strcmp('text2', 'text');            -&#62; 1
mysql&#62; select strcmp('text', 'text');             -&#62; 0
</PRE>

</DL>



<H3><A NAME="Control flow functions" HREF="manual_toc.html#Control flow functions">フロー制御関数</A></H3>
<DL COMPACT>

<DT><CODE>IFNULL(A,B)</CODE>
<DD>
<A NAME="IDX113"></A>
 <A NAME="IDX114"></A>
 
<CODE>A</CODE> が <CODE>NULL</CODE> でない場合は <CODE>A</CODE> を、そうでなければ 
<CODE>B</CODE> を返します。

<PRE>
mysql&#62; select ifnull(1,0);        -&#62; 1
mysql&#62; select ifnull(0,10);       -&#62; 0
mysql&#62; select ifnull(1/0,10);     -&#62; 10
</PRE>

<A NAME="IDX115"></A>
<DT><CODE>IF(A,B,C)</CODE>
<DD>
<CODE>A</CODE> が真 (<CODE>A &#60;&#62; 0</CODE> かつ <CODE>A &#60;&#62; NULL</CODE>) の場合 <CODE>B</CODE> を返
し、そうでなければ <CODE>C</CODE> を返します。A は INTEGER として評価されます。
これは浮動小数点を使用する場合、比較演算も使用すべきであることを意味しま
す。

<PRE>
mysql&#62; select if(1&#62;2,2,3);        -&#62; 3
</PRE>

</DL>

<P>
<A NAME="IDX116"></A>


<H3><A NAME="Mathematical functions" HREF="manual_toc.html#Mathematical functions">数学関数</A></H3>
<P>
すべての数学関数はエラーの場合 <CODE>NULL</CODE> を返します。
<DL COMPACT>

<DT><CODE>-</CODE>
<DD>
<A NAME="IDX117"></A>
 
符号。引数の符号を変更します。

<PRE>
mysql&#62; select - 2;                -&#62; -2
</PRE>

<A NAME="IDX118"></A>
<DT><CODE>ABS()</CODE>
<DD>
絶対値。

<PRE>
mysql&#62; select abs(2);             -&#62; 2
mysql&#62; select abs(-32);           -&#62; 32
</PRE>

<A NAME="IDX119"></A>
<DT><CODE>SIGN()</CODE>
<DD>
引数の符号。-1, 0 または 1 を返します。

<PRE>
mysql&#62; select sign(-32);          -&#62; -1
mysql&#62; select sign(0);            -&#62; 0
mysql&#62; select sign(234);          -&#62; 1
</PRE>

<A NAME="IDX120"></A>
<DT><CODE>MOD()</CODE>
<DD>
<A NAME="IDX121"></A>
<DT><CODE>%</CODE>
<DD>
剰余 (C の % と同様)。

<PRE>
mysql&#62; select mod(234, 10);       -&#62; 4
mysql&#62; select 253 % 7;            -&#62; 1
mysql&#62; select mod(29,9);                -&#62; 2
</PRE>

<A NAME="IDX122"></A>
<DT><CODE>FLOOR()</CODE>
<DD>
x より小さい最大の整数値。

<PRE>
mysql&#62; select floor(1.23);              -&#62; 1
mysql&#62; select floor(-1.23);             -&#62; -2
</PRE>

<A NAME="IDX123"></A>
<DT><CODE>CEILING()</CODE>
<DD>
x より大きい最小の整数値。

<PRE>
mysql&#62; select ceiling(1.23);            -&#62; 2
mysql&#62; select ceiling(-1.23);           -&#62; -1
</PRE>

<A NAME="IDX124"></A>
<DT><CODE>ROUND(N)</CODE>
<DD>
引数 <CODE>N</CODE> を整数に丸めます。

<PRE>
mysql&#62; select round(-1.23);             -&#62; -1
mysql&#62; select round(-1.58);             -&#62; -2
mysql&#62; select round(1.58);              -&#62; 2
</PRE>

<A NAME="IDX125"></A>
<DT><CODE>ROUND(Number,Decimals)</CODE>
<DD>
引数 <CODE>Number</CODE> を <CODE>Decimals</CODE> 桁の少数に丸めます。

<PRE>
mysql&#62; select ROUND(1.298, 1);          -&#62; 1.3
</PRE>

<A NAME="IDX126"></A>
<DT><CODE>EXP(N)</CODE>
<DD>
<CODE>e</CODE> (自然対数の基数) の <CODE>N</CODE> 乗の値を返します。

<PRE>
mysql&#62; select exp(2);                   -&#62; 7.389056
mysql&#62; select exp(-2);                  -&#62; 0.135335
</PRE>

<A NAME="IDX127"></A>
<DT><CODE>LOG(X)</CODE>
<DD>
<CODE>X</CODE> の自然対数を返します。

<PRE>
mysql&#62; select log(2);             -&#62; 0.693147
mysql&#62; select log(-2);            -&#62; NULL
</PRE>

<A NAME="IDX128"></A>
<DT><CODE>LOG10(X)</CODE>
<DD>
<CODE>X</CODE> の 10基数の対数を返します。

<PRE>
mysql&#62; select log10(2);           -&#62; 0.301030
mysql&#62; select log10(100);                 -&#62; 2.000000
mysql&#62; select log10(-100);                -&#62; NULL
</PRE>

<A NAME="IDX129"></A>
<DT><CODE>POW(X,Y)</CODE>
<DD>
<A NAME="IDX130"></A>
<DT><CODE>POWER(X,Y)</CODE>
<DD>
<CODE>X</CODE> の <CODE>Y</CODE> 乗の値を返します。

<PRE>
mysql&#62; select pow(2,2);           -&#62; 4.000000
mysql&#62; select pow(2,-2);                  -&#62; 0.250000
</PRE>

<A NAME="IDX131"></A>
<DT><CODE>sqrt(X)</CODE>
<DD>
<CODE>X</CODE> の非負の平方根を返します。

<PRE>
mysql&#62; select sqrt(4);            -&#62; 2.000000
mysql&#62; select sqrt(20);           -&#62; 4.472136
</PRE>

<A NAME="IDX132"></A>
<DT><CODE>PI()</CODE>
<DD>
PI の値を返します。

<PRE>
mysql&#62; select PI();               -&#62; 3.141593
</PRE>

<A NAME="IDX133"></A>
<DT><CODE>COS(X)</CODE>
<DD>
<CODE>X</CODE> のコサインを返します。<CODE>X</CODE> はラジアンで与えられます。

<PRE>
mysql&#62; select cos(PI());                  -&#62; -1.000000
</PRE>

<A NAME="IDX134"></A>
<DT><CODE>SIN(X)</CODE>
<DD>
<CODE>X</CODE> のサインを返します。<CODE>X</CODE> はラジアンで与えられます。

<PRE>
mysql&#62; select sin(PI());                  -&#62; 0.000000
</PRE>

<A NAME="IDX135"></A>
<DT><CODE>TAN(X)</CODE>
<DD>
<CODE>X</CODE> のタンジェントを返します。<CODE>X</CODE> はラジアンで与えられます。

<PRE>
mysql&#62; select tan(PI()+1);                -&#62; 1.557408
</PRE>

<A NAME="IDX136"></A>
<DT><CODE>ACOS(X)</CODE>
<DD>
Return the arc cosine of <CODE>X</CODE>; that is the value whose cosine is
<CODE>X</CODE>. If <CODE>X</CODE> is not in the range -1 to 1 <CODE>NULL</CODE> is
returned.

<PRE>
mysql&#62; select ACOS(1);                  -&#62; 0.000000
mysql&#62; select ACOS(1.0001);             -&#62; NULL
mysql&#62; select ACOS(0);          -&#62; 1.570796
</PRE>

<A NAME="IDX137"></A>
<DT><CODE>ASIN(X)</CODE>
<DD>
<CODE>X</CODE> のアークサインを返します。すなわちサインが <CODE>X</CODE> になる値で
す。<CODE>X</CODE> が -1 から 1 の範囲にない場合 <CODE>NULL</CODE> が返されます。

<PRE>
mysql&#62; select ASIN(0.2);                -&#62; 0.201358
mysql&#62; select ASIN('foo');              -&#62; 0.000000
</PRE>

<A NAME="IDX138"></A>
<DT><CODE>ATAN(X)</CODE>
<DD>
<CODE>X</CODE> のアークタンジェントを返します。すなわちタンジェントが <CODE>X</CODE> 
になる値です。

<PRE>
mysql&#62; select ATAN(2);          -&#62; 1.107149
mysql&#62; select ATAN(-2);         -&#62; -1.107149
</PRE>

<A NAME="IDX139"></A>
<DT><CODE>ATAN2(X,Y)</CODE>
<DD>
2つの値 <CODE>X</CODE> と <CODE>Y</CODE> のアークタンジェントを返します。<CODE>Y /
X</CODE> のアークタンジェントの計算と同様ですが、両方の引数の符号が結果の 
quadrant を決定するために使用されます。

<PRE>
mysql&#62; select ATAN(-2,2);               -&#62; -0.785398
mysql&#62; select ATAN(PI(),0);             -&#62; 1.570796
</PRE>

<A NAME="IDX140"></A>
<DT><CODE>COT(N)</CODE>
<DD>
<CODE>N</CODE> のコタンジェントを返します。

<PRE>
mysql&#62; select COT(12);          -&#62; -1.57267341
mysql&#62; select COT(0);           -&#62; NULL
</PRE>

<A NAME="IDX141"></A>
<DT><CODE>RAND([X])</CODE>
<DD>
浮動小数点の乱数 <CODE>0 &#60;= x &#60;= 1.0</CODE> を返します。正数表現 <CODE>X</CODE> はオ
プションでシード値として使用されます。

<PRE>
mysql&#62; SELECT RAND();           -&#62; 0.5925
mysql&#62; SELECT RAND(20);         -&#62; 0.1811
mysql&#62; SELECT RAND(20);         -&#62; 0.1811
mysql&#62; SELECT RAND();           -&#62; 0.2079
mysql&#62; SELECT RAND();           -&#62; 0.7888
</PRE>

RAND() 値を持つ項目は ORDER BY できません。ORDER BY は項目を複数回評価す
るためです。
<A NAME="IDX142"></A>
<DT><CODE>MIN(X,Y...)</CODE>
<DD>
引数の最小値。2個以上の引数が必要です。でなければ、これは <CODE>GROUP
BY</CODE> 関数です。引数は数値として比較されます。レコードが見つからない場合は 
<CODE>NULL</CODE> が返されます。

<PRE>
mysql&#62; SELECT MIN(2,0);                         -&#62; 0
mysql&#62; SELECT MIN(34,3,5,767);                  -&#62; 3
mysql&#62; SELECT MIN(a) from table where 1=0;      -&#62; NULL
</PRE>

<A NAME="IDX143"></A>
<DT><CODE>MAX(X,Y...)</CODE>
<DD>
引数の最大値。2個以上の引数が必要です。でなければ、これは <CODE>GROUP
BY</CODE> 関数です。引数は数値として比較されます。レコードが見つからない場合は
<CODE>NULL</CODE> が返されます。

<PRE>
mysql&#62; SELECT MAX(34,3,5,767);                  -&#62; 767
mysql&#62; SELECT MAX(2,0,4,5,34);                  -&#62; 34
mysql&#62; SELECT MAX(a) from table where 1=0;      -&#62; NULL
</PRE>

<A NAME="IDX144"></A>
<DT><CODE>DEGREES(N)</CODE>
<DD>
ラジアンから度に変換された <CODE>N</CODE> を返します。

<PRE>
mysql&#62; select DEGREES(PI());                    -&#62; 180.000000
</PRE>

<A NAME="IDX145"></A>
<DT><CODE>RADIANS(N)</CODE>
<DD>
度からラジアンに変換された <CODE>N</CODE> を返します。

<PRE>
mysql&#62; select RADIANS(90);                      -&#62; 1.570796
</PRE>

<A NAME="IDX146"></A>
<DT><CODE>TRUNCATE(Number, Decimals)</CODE>
<DD>
<CODE>Number</CODE> を <CODE>Decimals</CODE> 桁の少数に切り捨てます。

<PRE>
mysql&#62; select TRUNCATE(1.223,1);                -&#62; 1.2
mysql&#62; select TRUNCATE(1.999,1);                -&#62; 1.9
mysql&#62; select TRUNCATE(1.999,0);                -&#62; 1
</PRE>

</DL>

<P>
<A NAME="IDX147"></A>


<H3><A NAME="String functions" HREF="manual_toc.html#String functions">文字列関数</A></H3>
<DL COMPACT>

<DT><CODE>ASCII(S)</CODE>
<DD>
<A NAME="IDX148"></A>
 
<CODE>S</CODE> の左端の文字の ASCII コード値を返します。<CODE>S</CODE> が 
<CODE>NULL</CODE> の場合は <CODE>NULL</CODE> を返します。

<PRE>
mysql&#62; SELECT ascii(2);                         -&#62; 50
mysql&#62; SELECT ascii('dx');                      -&#62; 100
</PRE>

<A NAME="IDX149"></A>
<DT><CODE>CHAR(X,...)</CODE>
<DD>
引数の ASCII コード値によって与えられた文字からなる文字列を返します。
<CODE>NULL</CODE> は飛ばされます。

<PRE>
mysql&#62; SELECT char(77,121,83,81,'76');          -&#62; 'MySQL'
</PRE>

<A NAME="IDX150"></A>
<DT><CODE>CONCAT(X,Y...)</CODE>
<DD>
文字列を結合します。2個以上の引数を必要とします。

<PRE>
mysql&#62; SELECT CONCAT('My', 'S', 'QL');          -&#62; 'MySQL'
</PRE>

<A NAME="IDX151"></A>
<DT><CODE>LENGTH(S)</CODE>
<DD>
<A NAME="IDX152"></A>
<DT><CODE>OCTET_LENGTH(S)</CODE>
<DD>
<A NAME="IDX153"></A>
<DT><CODE>CHAR_LENGTH(S)</CODE>
<DD>
<A NAME="IDX154"></A>
<DT><CODE>CHARACTER_LENGTH(S)</CODE>
<DD>
文字列の長さ。

<PRE>
mysql&#62; SELECT length('text');                   -&#62; 4
mysql&#62; SELECT octet_length('text');             -&#62; 4
</PRE>

<A NAME="IDX155"></A>
<DT><CODE>LOCATE(A,B)</CODE>
<DD>
<A NAME="IDX156"></A>
<DT><CODE>POSITION(B IN A)</CODE>
<DD>
<CODE>B</CODE> 内にある <CODE>A</CODE> 文字列の位置を返します。最初の位置は 1 です。
<CODE>B</CODE> 内に <CODE>A</CODE> がない時は 0 を返します。

<PRE>
mysql&#62; select locate('bar', 'foobarbar');         -&#62; 4
mysql&#62; select locate('xbar', 'foobar');           -&#62; 0
</PRE>

<A NAME="IDX157"></A>
<DT><CODE>INSTR(A,B)</CODE>
<DD>
文字列 <CODE>A</CODE> 内の最初の文字列 <CODE>B</CODE> の位置を返します。これは引数を
交換した <CODE>LOCATE</CODE> と同じです。

<PRE>
mysql&#62; select instr('foobarbar', 'bar');         -&#62; 4
mysql&#62; select instr('xbar', 'foobar');           -&#62; 0
</PRE>

<A NAME="IDX158"></A>
<DT><CODE>LOCATE(A,B,C)</CODE>
<DD>
文字列 <CODE>B</CODE> の <CODE>C</CODE> 位置から、文字列 <CODE>A</CODE> の位置を返します。

<PRE>
mysql&#62; select locate('bar', 'foobarbar',5);        -&#62; 7
</PRE>

<A NAME="IDX159"></A>
<DT><CODE>LEFT(str,length)</CODE>
<DD>
文字列の最初から length 個の文字を得ます。

<PRE>
mysql&#62; select left('foobarbar', 5);             -&#62; 'fooba'
</PRE>

<A NAME="IDX160"></A>
<DT><CODE>RIGHT(A,B)</CODE>
<DD>
<A NAME="IDX161"></A>
<DT><CODE>SUBSTRING(A FROM B)</CODE>
<DD>
文字列 <CODE>A</CODE> の最後から <CODE>B</CODE> 個の文字を得ます。

<PRE>
mysql&#62; select right('foobarbar', 5);            -&#62; 'arbar'
mysql&#62; select substring('foobarbar' from 5);    -&#62; 'arbar'
</PRE>

<A NAME="IDX162"></A>
<DT><CODE>LTRIM(str)</CODE>
<DD>
文字列の最初から空白文字を削除します。

<PRE>
mysql&#62; select ltrim('  barbar');                -&#62; 'barbar'
</PRE>

<A NAME="IDX163"></A>
<DT><CODE>RTRIM(str)</CODE>
<DD>
文字列の最後から空白文字を削除します。

<PRE>
mysql&#62; select rtrim('barbar   ');             -&#62; 'barbar'
</PRE>

<A NAME="IDX164"></A>
<DT><CODE>TRIM([[ BOTH | LEADING | TRAILING] [ A ] FROM ] B)</CODE>
<DD>
全ての <CODE>A</CODE> プレフィックスまたはサフィックスを <CODE>B</CODE> から削除した
文字列を返します。<CODE>BOTH</CODE>, <CODE>LEADING</CODE> そして <CODE>TRAILING</CODE> が
使用されない場合、<CODE>BOTH</CODE> が適用されます。<CODE>A</CODE> が与えられないと、
空白が削除されます。

<PRE>
mysql&#62; select trim('  bar   ');                      -&#62; 'bar'
mysql&#62; select trim(leading 'x' from 'xxxbarxxx');    -&#62; 'barxxx'
mysql&#62; select trim(both 'x' from 'xxxbarxxx');       -&#62; 'bar'
mysql&#62; select trim(trailing 'xyz' from 'barxxyz');   -&#62; 'barx'
</PRE>

<A NAME="IDX165"></A>
<DT><CODE>SOUNDEX(S)</CODE>
<DD>
Gets a soundex string from <CODE>S</CODE>. Two strings that sound 'about the
same' should have identical soundex strings. A 'standard' soundex string
is 4 characters long, but this function returns an arbitrary long
string. One can use <CODE>SUBSTRING</CODE> on the result to get a 'standard'
soundex string.  All non alpha characters are ignored in the given
string. All characters outside the A-Z range are treated as vocals.

<PRE>
mysql&#62; select soundex('Hello');                 -&#62; 'H400'
mysql&#62; select soundex('B-A�ttre');                -&#62; 'B360'$)B
mysql&#62; select soundex('Quadratically');         -&#62; 'Q36324'
</PRE>

<A NAME="IDX166"></A>
<DT><CODE>SUBSTRING(A, B, C)</CODE>
<DD>
<A NAME="IDX167"></A>
<DT><CODE>SUBSTRING(A FROM B FOR C)</CODE>
<DD>
<A NAME="IDX168"></A>
<DT><CODE>MID(A, B, C)</CODE>
<DD>
<CODE>A</CODE> の <CODE>B</CODE> 位置から <CODE>C</CODE> 文字の文字列を返します。
<CODE>FROM</CODE> の違いは ANSI SQL 92 構文です。

<PRE>
mysql&#62; select substring('Quadratically',5,6);          -&#62; ratica
</PRE>

<A NAME="IDX169"></A>
<DT><CODE>SUBSTRING_INDEX(String, Delimiter, Count)</CODE>
<DD>
<CODE>String</CODE> から、<CODE>Delimiter</CODE> で <CODE>Count</CODE> 個に区切られた文字
列を返します。<CODE>Count</CODE> が正の場合は文字列は左から検索され、
<CODE>Count</CODE> が負の場合は文字列は右から検索されます。

<PRE>
mysql&#62; select substring_index('www.tcx.se', '.', 2);   -&#62; 'www.tcx'
mysql&#62; select substring_index('www.tcx.se', '.', -2);  -&#62; 'tcx.se'
</PRE>

<A NAME="IDX170"></A>
<DT><CODE>SPACE(N)</CODE>
<DD>
<CODE>N</CODE> 個の空白文字を返します。

<PRE>
mysql&#62; select SPACE(6);         -&#62; '      '
</PRE>

<A NAME="IDX171"></A>
<DT><CODE>REPLACE(A, B, C)</CODE>
<DD>
文字列 <CODE>A</CODE> 内の全ての文字列 <CODE>B</CODE> を <CODE>C</CODE> に置き換えます。

<PRE>
mysql&#62; select replace('www.tcx.se', 'w', 'Ww');  -&#62; 'WwWwWw.tcx.se'
</PRE>

<A NAME="IDX172"></A>
<DT><CODE>REPEAT(String, Count)</CODE>
<DD>
<CODE>String</CODE> を <CODE>Count</CODE> 回繰り返します。<CODE>Count &#60;= 0</CODE> の場合は
空の文字列を返します。<CODE>String</CODE> または <CODE>Count</CODE> が <CODE>NULL</CODE> 
または、<CODE>LENGTH(string)*count &#62; max_allowed_size</CODE> の場合は 
<CODE>NULL</CODE> を返します。

<PRE>
mysql&#62; select repeat('MySQL', 3);                -&#62; 'MySQLMySQLMySQL'
</PRE>

<A NAME="IDX173"></A>
<DT><CODE>REVERSE(String)</CODE>
<DD>
文字列中の全ての文字を反転します。

<PRE>
mysql&#62; select reverse('abc');  -&#62; 'cba'
</PRE>

<A NAME="IDX174"></A>
<DT><CODE>INSERT(Org, Start, Length, New)</CODE>
<DD>
<CODE>Org</CODE> 中の <CODE>Start</CODE> 位置から <CODE>Length</CODE> 長の文字列を 
<CODE>New</CODE> で置き換えます。<CODE>Org</CODE> 内の最初の位置は1です。

<PRE>
mysql&#62; select insert('Quadratic', 3, 4, 'What');   -&#62; 'QuWhattic'
</PRE>

<A NAME="IDX175"></A>
<DT><CODE>INTERVAL(N, N1, N2, N3...)</CODE>
<DD>
この関数が機能するためには <CODE>Nn</CODE> &#62; <CODE>N3</CODE> &#62; <CODE>N2</CODE> &#62; <CODE>N1</CODE>
が要求されます。これは(とても速い)バイナリサーチが使用されるからです。
<CODE>N</CODE> &#60; <CODE>N1</CODE> の場合は 0 を、<CODE>N</CODE> &#60; <CODE>N2</CODE> の場合は 1 を
(以後同様…)返します。全ての引数は数値としてテストされます。

<PRE>
mysql&#62; select INTERVAL(23, 1, 15, 17, 30, 44, 200);     -&#62; 3
mysql&#62; select INTERVAL(10, 1, 10, 100, 1000);           -&#62; 2
mysql&#62; select INTERVAL(22, 23, 30, 44, 200);            -&#62; 0
</PRE>

<A NAME="IDX176"></A>
<DT><CODE>ELT(N, A1, A2, A3...)</CODE>
<DD>
<CODE>N</CODE> = 1 なら <CODE>A1</CODE> を、<CODE>N</CODE> = 2 なら <CODE>A2</CODE> を返します。
<CODE>N</CODE> が 1 より小さい場合、または引数の数より大きい場合は <CODE>NULL</CODE> 
が返されます。

<PRE>
mysql&#62; select elt(1, 'ej', 'Heja', 'hej', 'foo');  -&#62; 'ej'
mysql&#62; select elt(4, 'ej', 'Heja', 'hej', 'foo');  -&#62; 'foo'
</PRE>

<A NAME="IDX177"></A>
<DT><CODE>FIELD(S, S1, S2, S3...)</CODE>
<DD>
<CODE>S1</CODE>, <CODE>S2</CODE>, <CODE>S3</CODE>... リスト内の <CODE>S</CODE> のインデックスを
返します。<CODE>ELT()</CODE> の逆です。S が見つからなければ 0 を返します。

<PRE>
mysql&#62; select FIELD('ej', 'Hej', 'ej', 'Heja', 'hej', 'foo');       -&#62; 2
mysql&#62; select FIELD('fo', 'Hej', 'ej', 'Heja', 'hej', 'foo');       -&#62; 0
</PRE>

<A NAME="IDX178"></A>
<DT><CODE>FIND_IN_SET(string,string of strings)</CODE>
<DD>
'string' が 'string of strings' 中にあれば、値 1 から N を返します。'string
of strings' は、それぞれの異なる値が ',' で分割された文字列です。最初の
引数が定数文字列で２番目が SET 型の項目の場合、FIND_IN_SET はビット演算
を使用して最適化されます！

<PRE>
mysql&#62; SELECT FIND_IN_SET('b','a,b,c,d')		-&#62; 2
</PRE>

最初の引数が ',' を含む場合は、この関数は当然働きません。
<A NAME="IDX179"></A>
<DT><CODE>LCASE(A)</CODE>
<DD>
<A NAME="IDX180"></A>
<DT><CODE>LOWER(A)</CODE>
<DD>
<CODE>A</CODE> を現在の文字セット,dmappings (デフォルト Latin1) にしたがって小
文字に変換します。

<PRE>
mysql&#62; select lcase('QUADRATICALLY');           -&#62; 'quadratically'
</PRE>

<A NAME="IDX181"></A>
<DT><CODE>UCASE(A)</CODE>
<DD>
<A NAME="IDX182"></A>
<DT><CODE>UPPER(A)</CODE>
<DD>
<CODE>A</CODE> を大文字に変換します。

<PRE>
mysql&#62; select ucase('Hej');             -&#62; 'HEJ'
</PRE>

</DL>

<P>
<A NAME="IDX183"></A>


<H3><A NAME="Date and time functions" HREF="manual_toc.html#Date and time functions">日付と時刻関数</A></H3>

<P>
1つ以上の日付関数を使用する例:

</P>
<P>
date_field が最新の30日である全てのレコードを選択します。

<PRE>
SELECT something FROM table WHERE TO_DAYS(NOW()) - TO_DAYS(date_field) &#60;= 30;
</PRE>

<P>
<CODE>Date</CODE> 表現は date 文字列、datetime 文字列、timestamp([6 | 8 | 14]) 
または、<CODE>YYMMDD</CODE> や <CODE>YYYYMMDD</CODE> の形式の数値です。

</P>
<P>
date 表現では、年は 2 または 4 桁の数値です。2 桁は 1970-2069 の範囲と見
なされます。Date 100-199 は年の演算をより簡単にするため、2000-2999 に変
換されます！ 特殊な日付 '0000-00-00' は 0000-00-00 として格納され、取り
出されます。

</P>
<P>
数値に日付関数を使用する場合、数値の長さが 4, 8 または &#62;= 14 なら年が4桁
と見なされます。他の全てのケースでは年は与えられた数値の最初の2桁と見な
されます。安全側におくため、日付を数値(文字列でなく)で使用する時は、常に
4桁の日付を使用すべきです！ そうでなければ、2000年で問題が発生します。数
値 002001 が日付関数に送られた時、日付 '20002001' の代わりに '2001' にな
ります。'002001' はもちろん正しく働きます！

</P>
<P>
<CODE>Time</CODE> 表現は date 文字列、datetime 文字列、timestamp([6 | 8 | 14]) 
または、<CODE>HHMMSS</CODE> や <CODE>YYYYMMDDHHMMSS</CODE> 形式の数値です。

</P>
<DL COMPACT>

<DT><CODE>DAYOFWEEK(date expr)</CODE>
<DD>
<A NAME="IDX184"></A>
 
<CODE>Date</CODE> の曜日を得ます (0 = 日曜日, 1 = 月曜日, 2 = 火曜日 ..) 
これは ODBC 標準に従います。

<PRE>
mysql&#62; select dayofweek('1998-02-03');		-&#62; 3
</PRE>

<A NAME="IDX185"></A>
<DT><CODE>WEEKDAY(date expr)</CODE>
<DD>
<CODE>Date</CODE> の曜日を得ます (0 = 月曜日, 1 = 火曜日 ..)

<PRE>
mysql&#62; select WEEKDAY('1997-10-04 22:23:00');	-&#62; 5
mysql&#62; select WEEKDAY('1997-11-05');            -&#62; 2
</PRE>

<A NAME="IDX186"></A>
<DT><CODE>DAYOFMONTH(date expr)</CODE>
<DD>
月の日を返します (1-31)

<PRE>
mysql&#62; select DAYOFMONTH('1998-02-03');		-&#62; 3
</PRE>

<A NAME="IDX187"></A>
<DT><CODE>DAYOFYEAR(date expr)</CODE>
<DD>
年の日を返します (1-366)

<PRE>
mysql&#62; select DAYOFYEAR('1998-02-03');		-&#62; 34
</PRE>

<A NAME="IDX188"></A>
<DT><CODE>MONTH(date expr)</CODE>
<DD>
月を返します (1-12)

<PRE>
mysql&#62; select MONTH('1998-02-03');		-&#62; 02
</PRE>

<A NAME="IDX189"></A>
<DT><CODE>DAYNAME(date expr)</CODE>
<DD>
曜日の名前を返します。

<PRE>
mysql&#62; select dayname("1998-02-05");            -&#62; Thursday
</PRE>

<A NAME="IDX190"></A>
<DT><CODE>MONTHNAME(date expr)</CODE>
<DD>
月の名前を返します。

<PRE>
mysql&#62; select monthname("1998-02-05");          -&#62; February
</PRE>

<A NAME="IDX191"></A>
<DT><CODE>QUARTER(date expr)</CODE>
<DD>
Returns quarter (1-4).

<PRE>
mysql&#62; select QUARTER('98-04-01');		-&#62; 2
</PRE>

<A NAME="IDX192"></A>
<DT><CODE>WEEK(date expr)</CODE>
<DD>
日曜日が年の最初の日である位置上の週を返します (1-53)。

<PRE>
mysql&#62; select WEEK('98-02-20');			-&#62; 7
</PRE>

<A NAME="IDX193"></A>
<DT><CODE>YEAR(date expr)</CODE>
<DD>
年を返します (1000-9999)。

<PRE>
mysql&#62; select YEAR('98-02-03');			-&#62; 1998
</PRE>

<A NAME="IDX194"></A>
<DT><CODE>HOUR(time expr)</CODE>
<DD>
時を返します (0-23)

<PRE>
mysql&#62; select HOUR('10:05:03');			-&#62; 10
</PRE>

<A NAME="IDX195"></A>
<DT><CODE>MINUTE(time expr)</CODE>
<DD>
分を返します (0-59)。

<PRE>
mysql&#62; select MINUTE('98-02-03 10:05:03');	-&#62; 5
</PRE>

<A NAME="IDX196"></A>
<DT><CODE>SECOND(time expr)</CODE>
<DD>
秒を返します (1000-9999)。

<PRE>
mysql&#62; select SECOND('10:05:03');		-&#62; 3
</PRE>

<A NAME="IDX197"></A>
<DT><CODE>PERIOD_ADD(P, N)</CODE>
<DD>
<CODE>N</CODE> 月を期間 <CODE>P</CODE> (型 <CODE>YYMM</CODE> または <CODE>YYYYMM</CODE>) に追加
します。<CODE>YYYYMM</CODE> を返します。

<PRE>
mysql&#62; select PERIOD_ADD(9801,2);               -&#62; 199803
</PRE>

<A NAME="IDX198"></A>
<DT><CODE>PERIOD_DIFF(A, B)</CODE>
<DD>
期間 <CODE>A</CODE> と <CODE>B</CODE> の差の月を返します。<CODE>A</CODE> と <CODE>B</CODE> は形
式 <CODE>YYMM</CODE> または <CODE>YYYYMM</CODE> です。

<PRE>
mysql&#62; select PERIOD_DIFF(9802,199703);         -&#62; 11
</PRE>

<A NAME="IDX199"></A>
<DT><CODE>TO_DAYS(Date)</CODE>
<DD>
<CODE>Date</CODE> を daynumber (0年からの日数) に変換します。<CODE>Date</CODE> は 
<CODE>DATE</CODE> 文字列、<CODE>DATETIME</CODE> 文字列、<CODE>TIMESTAMP([6 | 8 |
14])</CODE>、<CODE>YYMMDD</CODE> または <CODE>YYYYMMDD</CODE> 形式の数値です。

<PRE>
mysql&#62; select TO_DAYS(9505);                    -&#62; 733364
mysql&#62; select TO_DAYS('1997-10-07);             -&#62; 729669
</PRE>

<A NAME="IDX200"></A>
<DT><CODE>FROM_DAYS()</CODE>
<DD>
daynumber を DATE に変換します。

<PRE>
mysql&#62; select from_days(729669);                -&#62; 1997-10-07       
</PRE>

<A NAME="IDX201"></A>
<DT><CODE>DATE_FORMAT(Date, Format)</CODE>
<DD>
<CODE>Format</CODE> 文字列にしたがって <CODE>Date</CODE> (date または timestamp) を
整形します。次の整形コマンドが知られています:
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD>M </TD><TD> 月名
</TR NOSAVE>
<TR><TD>W </TD><TD> 曜日
</TR NOSAVE>
<TR><TD>D </TD><TD> 英語サフィックス付き月の日
</TR NOSAVE>
<TR><TD>Y </TD><TD> 4桁の年
</TR NOSAVE>
<TR><TD>y </TD><TD> 2桁の年
</TR NOSAVE>
<TR><TD>a </TD><TD> 省略された曜日名 (Sun..Sat)
</TR NOSAVE>
<TR><TD>d </TD><TD> 月の日, 数値
</TR NOSAVE>
<TR><TD>m </TD><TD> 月, 数値
</TR NOSAVE>
<TR><TD>b </TD><TD> 省略された月名 (Jan.Dec)
</TR NOSAVE>
<TR><TD>j </TD><TD> 年の日 (001..366)
</TR NOSAVE>
<TR><TD>H </TD><TD> 時 (00..23)
</TR NOSAVE>
<TR><TD>k </TD><TD> 時 ( 0..23)
</TR NOSAVE>
<TR><TD>h </TD><TD> 時 (01..12)
</TR NOSAVE>
<TR><TD>I </TD><TD> 時 (01..12)
</TR NOSAVE>
<TR><TD>l </TD><TD> 時 ( 1..12)
</TR NOSAVE>
<TR><TD>i </TD><TD> 分, 数値
</TR NOSAVE>
<TR><TD>r </TD><TD> 時刻, 12時間 (hh:mm:ss [AP]M)
</TR NOSAVE>
<TR><TD>T </TD><TD> 時刻, 24時間 (hh:mm:ss)
</TR NOSAVE>
<TR><TD>S </TD><TD> 秒 (00..59)
</TR NOSAVE>
<TR><TD>s </TD><TD> 秒 (00..59)
</TR NOSAVE>
<TR><TD>p </TD><TD> AM または PM
</TR NOSAVE>
<TR><TD>w </TD><TD> 週の日 (0=日曜日..)
</TR NOSAVE>
<TR><TD>% </TD><TD> 一つの % は無視されます。% のためには %% を使用してください (将来の拡張のため)。
</TR>
</TABLE>
他の全ての文字は結果にコピーされます。

<PRE>
mysql&#62; select date_format('1997-10-04 22:23:00', '%W %M %Y %h:%i:%s');
        -&#62; 'Saturday October 1997 22:23:00'
mysql&#62; select date_format('1997-10-04 22:23:00', '%D %y %a %d %m %b %j %H %k %I %r %T %S %w');
        -&#62; '4th 97 Sat 04 10 Oct 277 22 22 10 10:23:00 PM 22:23:00 00 6'
</PRE>

しばらくは <CODE>%</CODE> はオプションです。<STRONG>MySQL</STRONG> の将来のバージョン
では、<CODE>%</CODE> は必要となります。
<LI>TIME_FORMAT(time expr, format)

<A NAME="IDX202"></A>
 
これは上記の DATE_FORMAT のように使用されますが、format オプションでは、
時,分,秒だけを操作できます。他のオプションは NULL 値または 0 を与えます。
<A NAME="IDX203"></A>
<LI>WEEKDAY(Date)

<CODE>DATE</CODE> の曜日を得ます (0 = 月曜日, 1 = 火曜日)。<CODE>Date</CODE> は date 
文字列、datetime 文字列、timestamp([6 | 8 | 14])、<CODE>YYMMDD</CODE> または 
<CODE>YYYYMMDD</CODE> 形式の数値です。

<PRE>
mysql&#62; select WEEKDAY('1997-10-04 22:23:00');           -&#62; 5
mysql&#62; select WEEKDAY('1997-11-05');                    -&#62; 2
</PRE>

<A NAME="IDX204"></A>
<LI>CURDATE()

<A NAME="IDX205"></A>
<LI>CURRENT_DATE

今日の日付を返します。形式は、<CODE>CURDATE()</CODE> が数値または文字列のどち
らの文脈で使用されたかに依存して <CODE>YYYYMMDD</CODE> または 
<CODE>'YYYY-MM-DD'</CODE> です。

<PRE>
mysql&#62; select CURDATE();                -&#62; '1997-12-15'
mysql&#62; select CURDATE()+0;              -&#62; 19971215
</PRE>

<A NAME="IDX206"></A>
<LI>CURTIME()

<A NAME="IDX207"></A>
<LI>CURRENT_TIME

現在の時刻を <CODE>HHMMSS</CODE> または <CODE>'HH:MM:SS'</CODE> の形式で返します。こ
れは <CODE>CURTIME()</CODE> が数値または文字列のどちらの文脈で使用されたかに依
存します。

<PRE>
mysql&#62; select CURTIME();                -&#62; '23:50:20'
mysql&#62; select CURTIME()+0;              -&#62; 235026
</PRE>

<A NAME="IDX208"></A>
<LI>NOW()

<A NAME="IDX209"></A>
<LI>SYSDATE()

<A NAME="IDX210"></A>
<LI>CURRENT_TIMESTAMP

現在の時刻を返します。形式は、<CODE>NOW()</CODE> が数値または文字列のどちらの
文脈で使用されたかに依存して <CODE>YYYYMMDDHHMMSS</CODE> または 
<CODE>'YYYY-MM-DD HH:MM:SS'</CODE> です。

<PRE>
mysql&#62; select NOW();            -&#62; '1997-12-15 23:51:26'
mysql&#62; select NOW()+0;          -&#62; 19971215235131
</PRE>

<A NAME="IDX211"></A>
<LI>UNIX_TIMESTAMP([date expression])

引数なしで呼び出された場合は、UNIX timestamp (GMT 1970.01.01 00:00:00 か
らの秒数) です。通常は、<CODE>TIMESTAMP</CODE> 項目を引数として呼び出し、項目
値を秒数で返します。<CODE>Date</CODE> はローカル時刻での date 文字列、datetime 
文字列、または YYMMDD または YYYYMMDD 形式の数値です。

<PRE>
mysql&#62; select UNIX_TIMESTAMP();                         -&#62; 882226357
mysql&#62; select UNIX_TIMESTAMP('1997-10-04 22:23:00');    -&#62; 875996580
</PRE>

<A NAME="IDX212"></A>
<LI>FROM_UNIXTIME(Unix_timestamp)

文脈(数値/文字列)に依存して、<CODE>YYYY-MM-DD HH:MM:SS</CODE> または 
<CODE>YYYYMMDDHHMMSS</CODE> 形式の timestamp 文字列を返します。

<PRE>
mysql&#62; select FROM_UNIXTIME(875996580);   -&#62; '1997-10-04 22:23:00'
</PRE>

<A NAME="IDX213"></A>
<LI>FROM_UNIXTIME(Unix_timestamp, Format_string)

Format_string に従って整形された timestamp 文字列を返します。整形文字列
は次を含みます:
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>M</CODE> </TD><TD> 月, 文字列
</TR NOSAVE>
<TR><TD><CODE>W</CODE> </TD><TD> 日 (週の), 文字列
</TR NOSAVE>
<TR><TD><CODE>D</CODE> </TD><TD> 日 (月の), 数値+英語サフィックス
</TR NOSAVE>
<TR><TD><CODE>Y</CODE> </TD><TD> 年, 数値, 4 桁
</TR NOSAVE>
<TR><TD><CODE>y</CODE> </TD><TD> 年, 数値, 2 桁
</TR NOSAVE>
<TR><TD><CODE>m</CODE> </TD><TD> 月, 数値
</TR NOSAVE>
<TR><TD><CODE>d</CODE> </TD><TD> 日 (月の), 数値
</TR NOSAVE>
<TR><TD><CODE>h</CODE> </TD><TD> 時, 数値
</TR NOSAVE>
<TR><TD><CODE>i</CODE> </TD><TD> 分, 数値
</TR NOSAVE>
<TR><TD><CODE>s</CODE> </TD><TD> 秒, 数値
</TR NOSAVE>
<TR><TD><CODE>w</CODE> </TD><TD> 日 (週の), 数値
</TR NOSAVE>
<TR><TD>その他 </TD><TD> 他の文字はそのままコピーされます。
</TR>
</TABLE>

<PRE>
mysql&#62; select FROM_UNIXTIME(UNIX_TIMESTAMP(), 'Y D M h:m:s x');
        -&#62; '1997 23rd December 03:12:30 x'
</PRE>

<LI>SEC_TO_TIME(Seconds)

<A NAME="IDX214"></A>
 
文脈に依存して <CODE>H:MM:SS</CODE> または <CODE>HMMSS</CODE> 形式で、引数の時, 分, 
秒を返します。

<PRE>
mysql&#62; select SEC_TO_TIME(2378);                -&#62; '00:39:38'
mysql&#62; select SEC_TO_TIME(2378)+0;              -&#62; 3938
</PRE>

<A NAME="IDX215"></A>
<LI>TIME_TO_SEC(Time)

<CODE>Time</CODE> を秒に変換します。

<PRE>
mysql&#62; select TIME_TO_SEC('22:23:00');  -&#62; 80580
mysql&#62; select TIME_TO_SEC('00:39:38');  -&#62; 2378
</PRE>

</DL>



<H3><A NAME="Miscellaneous functions" HREF="manual_toc.html#Miscellaneous functions">その他の関数</A></H3>

<DL COMPACT>

<DT><CODE>DATABASE()</CODE>
<DD>
<A NAME="IDX216"></A>
 <A NAME="IDX217"></A>
 
現在のデータベース名を返します。

<PRE>
mysql&#62; select DATABASE();               -&#62; 'test'
</PRE>

<A NAME="IDX218"></A>
<DT><CODE>USER()</CODE>
<DD>
<A NAME="IDX219"></A>
<DT><CODE>SYSTEM_USER()</CODE>
<DD>
<A NAME="IDX220"></A>
<DT><CODE>SESSION_USER()</CODE>
<DD>
現在のユーザ名を返します。

<PRE>
mysql&#62; select USER();                   -&#62; 'davida'
</PRE>

<A NAME="IDX221"></A>
<DT><CODE>PASSWORD(String)</CODE>
<DD>
プレーンテキストのパスワード <CODE>String</CODE> からパスワード文字列を計算し
ます。パスワードを 'user' 承認テーブル内に格納するために使用する必要があ
ります。

<PRE>
mysql&#62; select PASSWORD('badpwd');       -&#62; '7f84554057dd964b'
</PRE>

<A NAME="IDX222"></A>
<DT><CODE>ENCRYPT(String[, Salt])</CODE>
<DD>
UNIX の <CODE>crypt()</CODE> コマンドで <CODE>String</CODE> を暗号化します。
<CODE>Salt</CODE> は2文字の文字列です。<CODE>crypt()</CODE> が見使わない場合は常に 
<CODE>NULL</CODE> が返されます。

<PRE>
</PRE>

<A NAME="IDX223"></A>
<DT><CODE>LAST_INSERT_ID()</CODE>
<DD>
最後に auto_increment 項目に設定された自動的に生成された値を返します。
 「<A HREF="manual_Clients.html#mysql_insert_id">最後に挿入された行のユニーク ID をどのように得られるか？</A>」節参照 。

<PRE>
mysql&#62; select LAST_INSERT_ID();         -&#62; 1
</PRE>

<A NAME="IDX224"></A>
<DT><CODE>FORMAT(Nr, Num)</CODE>
<DD>
'#,###,###.##' のような形式(小数部 <CODE>Num</CODE> 桁)で数値 <CODE>Nr</CODE> を整形
します。

<PRE>
mysql&#62; select FORMAT(12332.33, 2);      -&#62; '12,332.33'
</PRE>

<A NAME="IDX225"></A>
<DT><CODE>VERSION</CODE>
<DD>
<STRONG>MySQL</STRONG> サーバのバージョンを返します。

<PRE>
mysql&#62; select version();                -&#62; '3.21.16-beta-log'
</PRE>

<A NAME="IDX226"></A>
<DT><CODE>GET_LOCK(String,timeout)</CODE>
<DD>
'timeout' 秒のタイムアウトで、'String' と名付けられたロックの獲得を試み
ます。ロックを獲得した場合は 1, タイムアウトの場合は 0, エラーの場合(メ
モリ不足やスレッドが <CODE>mysqladmin kill</CODE> で殺された場合など)は NULL 
が返ります。<CODE>RELEASE_LOCK</CODE> の実行、新しい <CODE>GET_LOCK</CODE> の実行、
スレッドの終了の場合に、ロックは解放されます。この関数はアプリケーション
ロックやレコードロックのシミュレートのために使用できます。

<PRE>
mysql&#62; select get_lock("automaticly released",10);     -&#62; 1
mysql&#62; select get_lock("test",10);		       -&#62; 1
mysql&#62; select release_lock("test");                    -&#62; 1
mysql&#62; select release_lock("automaticly released")     -&#62; NULL
</PRE>

<A NAME="IDX227"></A>
<DT><CODE>RELEASE_LOCK(String)</CODE>
<DD>
このスレッドが <CODE>GET_LOCK</CODE> で獲得したロックを解放します。ロックが解
放された場合は 1, このスレッドによってロックされていない場合は 0, 'String' 
が存在しない場合は NULL が返ります。
</DL>

<P>
<A NAME="IDX228"></A>


<H3><A NAME="Group by functions" HREF="manual_toc.html#Group by functions"><CODE>GROUP BY</CODE> 節の関数</A></H3>

<DL COMPACT>

<DT><CODE>COUNT(Expr)</CODE>
<DD>
<A NAME="IDX229"></A>
 
非 <CODE>NULL</CODE> の行の数を数えます。<CODE>count(*)</CODE> は、<CODE>SELECT</CODE> 中
に他の項目が使用されなければ、非常に速く返るように最適化されています。

<PRE>
select count(*) from student;
select count(if(length(name)&#62;3,1,NULL)) from student;
</PRE>

<A NAME="IDX230"></A>
<DT><CODE>AVG(expr)</CODE>
<DD>
expr の平均値。
<A NAME="IDX231"></A>
<DT><CODE>MIN(expr)</CODE>
<DD>
<A NAME="IDX232"></A>
<DT><CODE>MAX(expr)</CODE>
<DD>
expr の最小/最大値。<CODE>min()</CODE> と <CODE>max()</CODE> が文字列引数を取ると、
最小/最大の文字列値を返します。
<A NAME="IDX233"></A>
<DT><CODE>SUM(expr)</CODE>
<DD>
expr の合計。
<A NAME="IDX234"></A>
<DT><CODE>STD(expr)</CODE>
<DD>
<A NAME="IDX235"></A>
<DT><CODE>STDDEV(expr)  (Oracle format)</CODE>
<DD>
表現の標準誘導(standard derivative)。これは <CODE>ANSI SQL</CODE> に対する拡張
です。
<A NAME="IDX236"></A>
<DT><CODE>BIT_OR(expr)</CODE>
<DD>
expr 内の全てのビットの論理 <CODE>OR</CODE>。64 ビットの精度で計算されます。
<A NAME="IDX237"></A>
<DT><CODE>BIT_AND(expr)</CODE>
<DD>
expr 内の全てのビットの論理 <CODE>AND</CODE>。64 ビットの精度で計算されます。
</DL>

<P>
MySQL は <CODE>GROUP BY</CODE> 使用を拡張します。<CODE>SELECT</CODE> 表現内で
<CODE>GROUP BY</CODE> 部に現れない項目または計算を使用できます。これは 'このグルー
プのための全ての可能な値' を表しています。この使用により、必要ない項目で
のソートとグループが避けられるので、高い性能が得られます。例えば、次のク
エリでは b.name でグループする必要はありません:

</P>

<PRE>
SELECT a.id,b.name,COUNT(*) from a,b WHERE a.id=b.id GROUP BY a.id
</PRE>

<P>
ANSI SQL では、次のクエリでは <CODE>GROUP BY</CODE> 内に customer.name を追加
する必要があります。<STRONG>MySQL</STRONG> では name は冗長です。

</P>

<PRE>
SELECT order.custid,customer.name,max(payments) from order,customer
WHERE order.custid = customer.custid GROUP BY order.custid;
</PRE>

<P>
<CODE>GROUP BY</CODE> または <CODE>ORDER BY</CODE> 節で表現を使用できないことに注意
してください。他の方法として表現の別名を使用でき、問題の解決としてこれを
使用できます:

</P>

<PRE>
SELECT id,FLOOR(value/100) AS val FROM table_name GROUP BY id,val ORDER BY val
</PRE>

<P>
<A NAME="IDX238"></A>


<H2><A NAME="Create database" HREF="manual_toc.html#Create database">Create database 構文</A></H2>


<PRE>
CREATE DATABASE database_name
</PRE>

<P>
データベースを与えられた名前で作成します。名前は文字、数字または 
<CODE>'_'</CODE> 文字だけを含むことができ、文字または <CODE>_</CODE> で始まらないと
いけません。データベース名の最大長は 64 文字です。<STRONG>MySQL</STRONG> 内の全
てのデータベースはディレクトリです。そのため、CREATE DATABASE は、
<STRONG>MySQL</STRONG> データベースディレクトリ内にディレクトリを作成するだけで
す。<CODE>mysqladmin</CODE> でもデータベースを作成することができます。
 「<A HREF="manual_Tools.html#Programs">様々な <STRONG>MySQL</STRONG> プログラムの概要</A>」節参照 

</P>
<P>
<A NAME="IDX239"></A>


<H2><A NAME="Drop database" HREF="manual_toc.html#Drop database">Drop database 構文</A></H2>


<PRE>
DROP DATABASE database_name
</PRE>

<P>
データベース内の全てのテーブルを破棄し、データベースを削除します。<STRONG>この
コマンドはとても注意して行なってください！</STRONG> <CODE>DROP DATABASE</CODE> はディ
レクトリからいくつのファイルが削除されたかを返します。通常これはテーブル数 * 3 
です。<CODE>mysqladmin</CODE> でもデータベースを破棄することができます。
 「<A HREF="manual_Tools.html#Programs">様々な <STRONG>MySQL</STRONG> プログラムの概要</A>」節参照 

</P>
<P>
<A NAME="IDX240"></A>


<H2><A NAME="Create table" HREF="manual_toc.html#Create table">CREATE TABLE 構文</A></H2>


<PRE>
CREATE TABLE table_name ( create_definition,... )

create_definition:
  column_name type [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT]
                   [ PRIMARY KEY ] [reference_definition]
  or	PRIMARY KEY ( index_column_name,... )
  or	KEY [index_name] KEY( index_column_name,...)
  or	INDEX [index_name] ( index_column_name,...)
  or	UNIQUE [index_name] ( index_column_name,...)
  or    FOREIGN KEY index_name ( index_column_name,...) [reference_definition]
  or	CHECK (expr)

type:
        TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  or    SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  or    MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  or    INT[(length)] [UNSIGNED] [ZEROFILL]
  or    INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  or    BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  or    REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or	FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or	DECIMAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or	NUMERIC[(length,decimals)] [UNSIGNED] [ZEROFILL]
  or    CHAR(length) [BINARY],
  or    VARCHAR(length) [BINARY],
  or    DATE
  or    TIME
  or    TIMESTAMP
  or    DATETIME
  or    TINYBLOB
  or    BLOB
  or    MEDIUMBLOB
  or    LONGBLOB
  or    TINYTEXT
  or    TEXT
  or    MEDIUMTEXT
  or    ENUM(value1,value2,value3...)
  or    SET(value1,value2,value3...)

index_column_name:
        column_name [ (length) ]

reference_definition:
        REFERENCES table_name [( index_column_name,...)]
                   [ MATCH FULL | MATCH PARTIAL]
                   [ ON DELETE reference_option]
                   [ ON UPDATE reference_option]

reference_option:
        RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT
</PRE>

<P>
 「<A HREF="manual_Syntax.html#Column types">項目型</A>」節参照 

</P>
<P>
FOREIGN KEY, CHECK そして REFERENCE 構文は互換のためだけにあります。（他
の SQL サーバからのコードより簡単に移行し、リファレンス付きのテーブルを
生成するようなアプリケーションを実行するため）。これらは実際には何もしま
せん。 「<A HREF="manual_Compatibility.html#Missing functions"><STRONG>MySQL</STRONG> に無い機能</A>」節参照 

</P>
<P>
項目が DEFAULT の値を持たず、NOT NULL として宣言されていない場合は、デフォ
ルト値は NULL です。

</P>
<P>
項目が DEFAULT の値を持たず、NOT NULL として宣言されている場合は、MySQL 
は自動的にその項目にデフォルト値を割り当てます。

</P>

<UL>
<LI>

ZEROFILL は、数値が最大長まで 0 が先頭につくことを意味します。
<CODE>INT(5) ZEROFILL</CODE> は、値 5 は <CODE>00005</CODE> として取り出されます。
<LI>

<CODE>BINARY</CODE> は、その項目がケース依存で比較されることを意味します。デフォ
ルトは全ての文字列は ISO-8859-1 Latin1 に従ってケース非依存で比較されま
す。<CODE>BINARY</CODE> は 'sticky' です。つまり、<CODE>BINARY</CODE> とマークされた
項目が表現中で使われると、表現全体が <CODE>BINARY</CODE> 比較されます。
<LI>

KEY は INDEX の同義語です。
<LI>

UNIQUE は <STRONG>MySQL</STRONG> では distinct 値だけを持つことができるキーです。
古い行に適合するキーを持つ新しい行を追加しようとするとエラーになります。
<LI>

PRIMARY KEY はユニークキーです。テーブルには一つだけの PRIMARY KEY を持
つことができます。
<LI>

インデックスに名前をつけなければ、インデックスは最初の key_column と同じ
名前を得ます。ただしユニークにするためにオプションで _# がつけられます。
<LI>

インデックス項目 timestamp 項目 NULL になりません。これらの項目への NULL 
属性は黙って削除されます。
<LI>

<CODE>column_name(length)</CODE> 構文では、<CODE>string</CODE> 項目の一部にだけイン
デックスを指定できます。これはインデックスファイルをとても小さくできます。
<LI>

数値項目は追加属性 AUTO_INCREMENT を持てます。これは、項目値が NULL また
は 0 として挿入する度に自動的に最大値+1 を獲得します。
 「<A HREF="manual_Clients.html#mysql_insert_id">最後に挿入された行のユニーク ID をどのように得られるか？</A>」節参照 
<LI>

timestamp と auto_increment 項目に NULL を挿入できます。この結果は現在の
時刻/次の値です。
<LI>

BLOB 項目はインデックスにはできません。
<LI>

BLOB 上でグループ化すると、最初の 'max_sort_length' バイトだけが使われま
す。 「<A HREF="manual_Compatibility.html#BLOB Limitations"><CODE>BLOB</CODE> と <CODE>TEXT</CODE> 型の制限</A>」節参照 。
<LI>

削除されたレコードはリンクリスト内にあり、その後の挿入は古い位置を再使用
します。ファイルをより小さくするには、<CODE>isamchk</CODE> ユーティリティをテー
ブルの再編成をするために使用できます。
<LI>

各 null 項目は 1 bit 余計に使用され、一番近いバイトに丸められます。
<LI>

最大レコード長は次のように計算できます: 1 + 項目長の合計 + null項目数/8
+ 可変長項目数。
<LI>

生成後に属性が黙って変更される場合があります: 長さ 1 または 2 の
<CODE>VARCHAR</CODE> 項目は <CODE>CHAR</CODE> に変更されます。<CODE>VARCHAR</CODE> 項目が
一つ使用されると、2 より長い全ての <CODE>CHAR</CODE> 項目は <CODE>VARCHAR</CODE> に
変更されます。これはどんな方法で項目を使用するかに影響しません;
<STRONG>MySQL</STRONG> では、<CODE>VARCHAR</CODE> は文字を格納する方法が違うだけです。
領域を節約し、テーブルをより速くするために、<CODE>MySQL</CODE> はこの変換を行
います。 「<A HREF="manual_Performance.html#Row format">行形式の種類は？ また VARCHAR/CHAR の使用時は？</A>」節参照 
<LI>

<CODE>INSERT</CODE>/<CODE>UPDATE</CODE> では、全ての文字列(<CODE>CHAR</CODE> と 
<CODE>VARCHAR</CODE>)は CREATE で与えられた最大長で切断または最大長まで埋めら
れます。終りの全ての空白も自動的に削除されます。例えば 
<CODE>VARCHAR(10)</CODE> は、項目は最大 10 文字の長さの文字列を含むことができま
す。
<LI>

何か/0 は <CODE>NULL</CODE> 値になります。
<LI>

正規表現関数 (<CODE>REGEXP</CODE> と <CODE>RLIKE</CODE>) はISO8859-1 (Latin1) を文字
の型の決定に使用します。
</UL>

<P>
<A NAME="IDX241"></A>


<H2><A NAME="Alter table" HREF="manual_toc.html#Alter table">ALTER TABLE 構文</A></H2>


<PRE>
ALTER [IGNORE] TABLE table_name alter_spec [, alter_spec ...]

alter_specification:
	ADD [COLUMN] create_definition [AFTER column_namn | FIRST]
or	CHANGE [COLUMN] old_column_name create_definition
or	ALTER [COLUMN] column_name { SET DEFAULT literal | DROP DEFAULT }
or	ADD INDEX [index_name] ( index_column_name,...)
or	ADD UNIQUE [index_name] ( index_column_name,...)
or	DROP [COLUMN] column_name
or	DROP PRIMARY KEY
or	DROP INDEX key_name
or	RENAME [AS] new_table_name
</PRE>


<UL>
<LI>

<CODE>ALTER TABLE</CODE> は次のように働きます。一時的なテーブルを作成し、全て
の情報をそこにコピーし、それから古いテーブルが削除され、新しいテーブルが
リネームされます。全ての更新は自動的に新しいテーブルにリダイレクトされる
ので、更新が失敗することなく行われます。<CODE>ALTER TABLE</CODE> が動作中は、
古いテーブルは他のクライアントに読み込み可能です。テーブルの更新/テーブ
ルへの書き込みは止められ、新しいテーブルの準備ができた後にだけ実行されます。
<LI>

<CODE>IGNORE</CODE> が指定されない場合、新しいテーブル内に複数のユニークキーが
存在すると、コピーは失敗し巻き戻され(roll back)ます。重複する場合、最初
に見つかった行が使用されます。これは <STRONG>MySQL</STRONG> 拡張です。
<LI>

<CODE>CHANGE column_name</CODE>, <CODE>DROP column_name</CODE> そして <CODE>DROP
INDEX</CODE> は ANSI SQL92 への <STRONG>MySQL</STRONG> 拡張です。
<LI>

オプションの単語 <CODE>COLUMN</CODE> は純粋にゴミの単語で、省略できます。
<LI>

<CODE>ADD</CODE> と <CODE>CHANGE</CODE> は <CODE>CREATE TABLE</CODE> と同じ 
create_definition を使います。 「<A HREF="manual_Syntax.html#Create table">CREATE TABLE 構文</A>」節参照 。
<LI>

<STRONG>MySQL</STRONG> 3.22 では <CODE>ADD</CODE> ... <CODE>AFTER</CODE> column_name または
<CODE>FIRST</CODE> を使用して、テーブル内の位置を指定して項目を追加できます。
デフォルトは項目の最後です。
<LI>

<CODE>ALTER COLUMN</CODE> は項目に新しいデフォルト値を設定または古いデフォルト値
を削除します。
<LI>

<CODE>DROP INDEX</CODE> はインデックスを削除します。これは <STRONG>MySQL</STRONG> の拡
張です。
<LI>

<STRONG>MySQL</STRONG> の <CODE>FOREIGN KEY</CODE> 構文は互換のためだけに存在します。
 「<A HREF="manual_Compatibility.html#Missing functions"><STRONG>MySQL</STRONG> に無い機能</A>」節参照 
<LI>

いくつかのインデックスの一部である column_name を破棄すると、このインデッ
クス部は削除されます。全てのインデックス部が削除されると、インデックスが
削除されます。
<LI>

<CODE>DROP PRIMARY KEY</CODE> は <CODE>PRIMARY</CODE> と名付けられたインデックスを破
棄します。または、そのようなインデックスが存在しなければ、テーブルの最初
の <CODE>UNIQUE</CODE> インデックスを破棄します。
<LI>

<CODE>CHANGE</CODE> はデータをできるだけ良い新しい形式に変換を試みます。
<LI>

<CODE>mysql_info(MYSQL*)</CODE> で、いくつのレコードがコピーされ、いくつのレコー
ドが複数インデックスのために削除されたかを取り出せます。
<LI>

<CODE>ALTER TABLE</CODE> を使用するためには、select, insert, delete, update,
create, drop 特権がテーブルに必要です。
<LI>

<CODE>ALTER TABLE table_name RENAME AS new_name</CODE> を他のオプション無しに
使用する場合は、<STRONG>MySQL</STRONG> はテーブルのリネームを速く行なうだけです。
</UL>

<P>
ALTER TABLE のいくつかの使用例:

</P>

<PRE>
CREATE TABLE t1 (a INTEGER,b CHAR(10));
INSERT INTO t1 VALUES(1,"testing");
ALTER TABLE t1 RENAME t2;
ALTER TABLE t2 CHANGE a a TINYINT NOT NULL, CHANGE b c CHAR(20);
ALTER TABLE t2 ADD d TIMESTAMP;
ALTER TABLE t2 ADD INDEX (d), ADD PRIMARY KEY (a);
ALTER TABLE t2 DROP COLUMN c;
ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT, ADD INDEX (c);
DROP TABLE t2;
</PRE>

<P>
<A NAME="IDX242"></A>


<H2><A NAME="Delete table" HREF="manual_toc.html#Delete table">DROP TABLE 構文</A></H2>

<P>
<CODE>DROP TABLE table_name [, table_name...]</CODE>

</P>
<P>
一つまたはそれ以上のテーブルを削除します。全てのデータと定義は<EM>削除</EM>され
ます。このコマンドはそれを簡単に行ないます！

</P>
<P>
<A NAME="IDX243"></A>


<H2><A NAME="Delete" HREF="manual_toc.html#Delete">DELETE 構文</A></H2>

<P>
<CODE>DELETE FROM table_name WHERE where_definition</CODE>

</P>
<P>
影響されたレコード数を返します。

</P>
<P>
<CODE>WHERE</CODE> 節なしで削除を行った場合、テーブルが再生成されます。これは
各行を削除するよりもとても速いです。この場合、影響されたレコードは 0 と
してコマンドが返ります。<STRONG>MySQL</STRONG> は削除された行の数を返しません。
テーブル定義ファイル <CODE>table_name.frm</CODE> が正しい限り、テーブルを再生
成できることを確かめるために、データファイルをオープンすることはなしに、
再生成が行われるためです。

</P>
<P>
<A NAME="IDX244"></A>


<H2><A NAME="Select" HREF="manual_toc.html#Select">SELECT 構文</A></H2>

<P>
<CODE>SELECT [STRAIGHT_JOIN] [DISTINCT | ALL] select_expression,... [INTO OUTFILE 'file_name' ...] [ FROM table_references [WHERE where_definition ] [GROUP BY column,...] [HAVING where_definition] [ ORDER BY column [ASC | DESC] ,..] [LIMIT [offset,] rows] [PROCEDURE procedure_name]] </CODE>

</P>
<P>
使用される全てのキーワードは厳密に上記の順の必要があります。例えば
<CODE>HAVING</CODE> 節は <CODE>GROUP BY</CODE> の後で <CODE>ORDER BY</CODE> 節の前に来なけ
ればいけません。

</P>
<P>
必要に応じて(Perl のように)、自動的に文字列は数値に、数値は文字列に変換
されます。比較操作 (<CODE>(=, &#60;&#62;, &#60;=, &#60;, &#62;=, &#62;)</CODE>) では、引数が数値の場合
引数は数値として比較されます。そうでない場合は引数は文字列として比較され
ます。全ての文字列比較はデフォルトでは ISO8859-1 (英語でも優秀に働くスカ
ンジナビア文字セット) によるケース非依存です。

</P>

<PRE>
select 1 &#62; '6x';        -&#62;      0

select 7 &#62; '6x';        -&#62;      1

select 0 &#62; 'x6';        -&#62;      0 

select 0 = 'x6';        -&#62;      1
</PRE>


<UL>
<LI>

項目名は、その項目名が unique である場合、table プレフィックスを持つ必要
はありません。
<LI>

select 表現は別名を与えられます。別名はその項目名となり、そしてソートと
グループ時に、または <CODE>HAVING</CODE> 節内で使用できます。

<PRE>
select concat(last_name,' ',first_name) as name from table order by name
</PRE>

<LI>

table_references は結合するテーブルのリストです。これは <CODE>LEFT OUTER
JOIN</CODE> 参照も含みます。 「<A HREF="manual_Syntax.html#Join">Join 構文</A>」節参照 
<LI>

<CODE>LIKE</CODE> 表現では、% と _ は '\' を前に置くことで、ワイルドカードの意
味をなくし、リテラルの % と _ になります。
<LI>

DATE は文字列で次の構文の一つです:

<UL>
<LI>

YYMMDD        (年は YY &#60; 70 の場合 2000 年とみなされます。)
<LI>

YYYYMMDD
<LI>

YY.MM.DD	ここで '.' は任意の非数字のセパレータにできます。
<LI>

YYYY.MM.DD	ここで '.' は任意の非数字のセパレータにできます。
</UL>

<LI>

<CODE>IFNULL()</CODE> と <CODE>IF()</CODE> は、使用に応じて数値または文字列値を返し
ます。
<LI>

<CODE>ORDER</CODE> と <CODE>GROUP</CODE> の項目は、項目名, 項目別名 または <CODE>SELECT</CODE> 
節内の項目番号として、与えられます。
<LI>

<CODE>HAVING</CODE> 節は、select_expressions 中の任意の項目または別名を持つこと
ができます。最後に適用され、直前の項目がクライアントに最適化されずに送ら
れます。WHERE 節内に置くべき項目には使わないで下さい。次は(まだ)できませ
ん:


<PRE>
<CODE>SELECT user,MAX(salary) FROM users GROUP BY user HAVING max(salary)&#62;10</CODE>
</PRE>

次のように変更して下さい:


<PRE>
<CODE>SELECT user,MAX(salary) AS sum FROM users GROUP BY user HAVING sum &#62; 10</CODE>
</PRE>

<LI>

<CODE>STRAIGHT_JOIN</CODE> は、<CODE>FROM</CODE> 節で与えられた順番通りにテーブルを結合す
るように、オプティマイザに強制します。オプティマイザがテーブルを最適でない順に
結合する場合、より速く行なうクエリを得るためにこれを使用することができま
す。 「<A HREF="manual_Syntax.html#Explain">EXPLAIN 構文。SELECT についての情報を得る</A>」節参照 
<LI>

LIMIT は1つまたは2つの数値引数を取ります。

<UL>
<LI>

引数が1つの場合、引数は結果の最大行数を示します。
<LI>

引数が2つの場合、最初の引数は返された行の始めからのオフセットを示し、2番
目は最大行数です。
</UL>

<LI>

INTO OUTFILE 'filename' はファイルに与えられたセットを書き出します。ファ
イルは事前に存在していてはいけません。 「<A HREF="manual_Syntax.html#Load">LOAD DATA INFILE 構文</A>」節参照 。
</UL>

<P>
<A NAME="IDX245"></A>
<A NAME="IDX246"></A>


<H2><A NAME="Join" HREF="manual_toc.html#Join">Join 構文</A></H2>

<P>
<STRONG>MySQL</STRONG> は次の <CODE>JOIN</CODE> 構文をサポートします:

</P>

<PRE>
table_reference, table_reference
table_reference [CROSS] JOIN table_reference
table_reference LEFT [OUTER] JOIN table_reference ON conditional-expr
table_reference LEFT [OUTER] JOIN table_reference USING (column-commalist)
table_reference NATURAL LEFT [OUTER] JOIN table_reference
{ oj table_reference LEFT OUTER JOIN table_reference ON conditional-expr }
</PRE>

<P>
最後の例は ODBC 構文です。

</P>

<UL>
<LI>

table reference は <CODE>table_reference AS alias</CODE> または 
<CODE>table_reference alias</CODE> で別名をつけられます。
<LI>

<CODE>,</CODE> と <CODE>JOIN</CODE> は意味的には同じです。これは使用されたテーブル間
の完全な結合を行います。通常は、テーブルをどのようにリンクするかを 
<CODE>WHERE</CODE> 条件中で記述します。
<LI>

<CODE>ON</CODE> conditional は任意の <CODE>WHERE</CODE> 条件です。<CODE>LEFT JOIN</CODE> 
の右のテーブルに適合するレコードがない場合、全ての項目が NULL に設定され
た行が右のテーブルとして使用されます。
<LI>

<CODE>USING</CODE> column-list は両方のテーブルに存在する項目のリストです。
<CODE>A LEFT JOIN B USING (C1,C2,C3...)</CODE> は、意味的には <CODE>ON</CODE>
expression <CODE> A.C1=B.C1 AND A.C2=B.C2 AND A.C3=B.C3...</CODE> と同じと定義
されます。
<LI>

2つのテーブルの <CODE>NATURAL LEFT JOIN</CODE> は意味的には、両方のテーブルに
存在する全ての項目名を持つ <CODE>USING</CODE> と同じと定義されます。
<LI>

最後の <CODE>LEFT JOIN</CODE> 構文は ODBC との互換のためだけに存在します。
</UL>

<P>
<A NAME="IDX247"></A>


<H2><A NAME="Insert" HREF="manual_toc.html#Insert">INSERT 構文</A></H2>


<PRE>
	INSERT INTO table [ (column_name,...) ] VALUES (expression,...)
or	INSERT INTO table [ (column_name,...) ] SELECT ...
</PRE>

<P>
expression は column_name リスト(または column_name リストが与えられない
場合はテーブル)の前の項目を使用します。

</P>
<P>
次は、複数行の <CODE>INSERT</CODE> ステートメントを保持します:

<UL>
<LI>

クエリには <CODE>ORDER BY</CODE> 節を含めることはできません。
<LI>

<CODE>INSERT</CODE> ステートメントのターゲットテーブルは、クエリの FROM 節に現れるこ
とができません。
<LI>

<CODE>INSERT INTO ... SELECT ...</CODE> を使用する場合、C API 関数 
<CODE>mysql_info()</CODE> で次の情報文字列を得ることができます。

<CODE>Records: 100 Duplicates: 0 Warnings: 0</CODE> Duplicates はいくつかのイ
ンデックスが重複したために書き出されなかった行数です。Warnings は NOT
NULL と宣言されているのに NULL が設定された項目数です。これらはそのデフォ
ルト値が設定されます。

この場合、挿入しているのと同じテーブルからの SELECT は ANSI SQL で禁じら
れています。同じ実行で挿入された行を SELECT が見つける場合に、問題となり
ます。sub select 使用時には、状況は簡単にとても混乱します！
<LI>

TIMESTAMP の値に NULL 以外の何かが設定された場合は、TIMESTAMP の値は結果
のテーブルにコピーされます。
<LI>

AUTO_INCREMENT 項目は普通に働きます。
</UL>

<P>
<A NAME="IDX248"></A>


<H2><A NAME="Replace" HREF="manual_toc.html#Replace">REPLACE 項目</A></H2>


<PRE>
	REPLACE INTO table [ (column_name,...) ] VALUES (expression,...)
or	REPLACE INTO table [ (column_name,...) ] SELECT ...
</PRE>

<P>
これは正確に <CODE>INSERT</CODE> と似た動きをします。テーブル内に同じユニークキーを
持つ古いレコードがいくつかある場合に、古いレコード(一つまたは複数)がこの
レコードが挿入される前に削除されることが異なります。
 「<A HREF="manual_Syntax.html#Insert">INSERT 構文</A>」節参照 .

</P>
<P>
<A NAME="IDX249"></A>


<H2><A NAME="Load" HREF="manual_toc.html#Load">LOAD DATA INFILE 構文</A></H2>

<P>
<CODE>LOAD DATA INFILE</CODE> 'text_file_name.text' [<CODE>REPLACE</CODE> |
<CODE>IGNORE</CODE>] <CODE>INTO</CODE> <CODE>TABLE</CODE> table_name [<CODE>FIELDS</CODE>
[<CODE>TERMINATED BY</CODE> ',' [<CODE>OPTIONALLY</CODE>] <CODE>ENCLOSED BY</CODE> '"'
<CODE>ESCAPED BY</CODE> '\\' ]] [<CODE>LINES TERMINATED BY</CODE> '\n'] [(Field1,
Field2...)]

</P>
<P>
これはサーバに置かれたテキストファイルから行を読み込むために使用され、と
ても高速です。サーバ - クライアントプロトコルはまだ接続上のファイルをサ
ポートしていません。クライアント上にだけファイルがある場合は、<CODE>LOAD
DATA INFILE</CODE> を使用する前に、可能ならば圧縮して <STRONG>rcp</STRONG> や 
<STRONG>ftp</STRONG> でサーバにコピーしてください。テキストファイルへの全てのパ
スはデータベースディレクトリへの相対です。

</P>
<P>
テキストファイルにデータを書き込むには、
<CODE>SELECT ...  INTO OUTFILE 'interval.txt' fields terminated by ','
enclosed by '"' escaped by '\\' lines terminated by '\n' FROM ....</CODE>
構文を使用します。

</P>
<P>
通常、テキストファイル型オプションには何も記述するべきではありません。デ
フォルトは <CODE>tab</CODE> 文字で区切られた項目のコンパクトテキストファイルで、
全ての行は改行で終ります。項目内のタブ, 改行と <CODE>\</CODE> は <CODE>\</CODE> が前
に置かれます。NULL は \N として読まれ、書かれます。

</P>
<P>
<CODE>FIELDS TERMINATED BY</CODE> のデフォルト値は <CODE>\t</CODE> です。

</P>
<P>
<CODE>FIELDS [OPTIONALLY] ENCLOSED BY</CODE> のデフォルト値は <CODE>''</CODE> です。

</P>
<P>
<CODE>FIELDS ESCAPED BY</CODE> のデフォルト値は <CODE>'\\'</CODE> です。

</P>
<P>
<CODE>LINES TERMINATED BY</CODE> のデフォルト値は <CODE>'\n'</CODE> です。

</P>
<P>
<CODE>FIELDS TERMINATED BY</CODE> と <CODE>LINES TERMINATED BY</CODE> は1文字以上に
できます。

</P>
<P>
<CODE>LINES TERMINATED BY</CODE> が空文字列で <CODE>FIELDS TERMINATED BY</CODE> が空
でなければ、行も <CODE>FIELDS TERMINATED BY</CODE> で終端されます。

</P>
<P>
<CODE>FIELDS TERMINATED BY</CODE> と <CODE>FIELDS ENCLOSED BY</CODE> の両方が空文字
列 (<CODE>''</CODE>) なら、固定行形式("境界なし" 読み込み形式)を与えます。固定
行サイズでは、NULL 値は空白文字列として出力されます。
        
<CODE>ENCLOSED BY</CODE> 内で <CODE>OPTIONALLY</CODE> を記述すると、<CODE>SELECT ... 
INTO</CODE> 記述で、文字列は <CODE>ENCLOSED BY</CODE> で囲まれます。

</P>
<P>
二重の <CODE>ENCLOSED BY</CODE> 文字は、<CODE>ENCLOSED BY</CODE> で始まる文字列から
削除されます。例えば <CODE>ENCLOSED BY '"'</CODE> では:

<PRE>
"The ""BIG"" boss"  -&#62; The "BIG" boss
The "BIG" boss	    -&#62; The "BIG" boss
</PRE>

<P>
<CODE>ESCAPED BY</CODE> が空でなければ、次の文字はエスケープ文字が前に置かれま
す: <CODE>ESCAPED BY</CODE>, <CODE>ASCII 0</CODE>, そして <CODE>FIELDS TERMINATED
BY</CODE>, <CODE>FIELDS ENCLOSED BY</CODE> と <CODE>LINES TERMINATED BY</CODE> 内の最初の
文字。

</P>
<P>
<CODE>FIELDS ENCLOSED BY</CODE> が空でなければ、<CODE>NULL</CODE> は <CODE>NULL</CODE> 値
として読まれます。<CODE>FIELDS ESCAPED BY</CODE> が空でなければ <CODE>\N</CODE> も 
<CODE>NULL</CODE> 値として読まれます。

</P>
<P>
<CODE>REPLACE</CODE> が使用されると、新しい行は同じユニークインデックスを持つ
全ての行を置き換えます。<CODE>IGNORE</CODE> が使用されると、同じユニークキーを
持つレコードが既に存在していた場合、行はスキップされます。上記オプション
がなければエラーになります。重複インデックスのエラーになった場合、テキス
トファイルの残りは無視されます。

</P>
<P>
<CODE>LOAD DATA</CODE> がサポートされないいくつかのケース:

<UL>
<LI>

固定サイズ行 (<CODE>FIELDS TERMINATED BY</CODE> と <CODE>FIELDS ENCLOSED BY</CODE> 
の両方が空) と BLOB 項目。
<LI>

区切り記号のいくつかが他のプレフィックスである場合。
<LI>

<CODE>FIELDS ESCAPED BY</CODE> が空で、データが <CODE>LINES TERMINATED BY</CODE> ま
たは <CODE>FIELDS TERMINATED BY</CODE> が続く <CODE>FIELDS ENCLOSED BY</CODE> を含ん
でいる。
</UL>

<P>
全ての行はテーブルに読み込まれます。行の項目が少ない場合は、残りの項目に
はデフォルト値が設定されます。<CODE>TIMESTAMP</CODE> 項目は、NULL 値がその列に
与えられた場合、または項目リストが使用された時に <CODE>TIMESTAMP</CODE> 項目が、
その項目リストにない場合に、現在の時刻を設定します (最後のケースでは、最
初の <CODE>TIMESTAMP</CODE> 項目だけを保持します)。

</P>
<P>
セキュリティ上の理由により、テキストファイルはデータベースディレクトリ内
にあるか全員に読み込み可能でなければいけません。<CODE>LOAD DATA INFLIE</CODE> 
を使用したい各ユーザは、user 特権テーブルの 'File_priv' 項目も 'Y' でな
ければなりません！  「<A HREF="manual_Privilege_system.html#Privileges">特権システムがどのように働くか？</A>」節参照 

</P>
<P>
<CODE>LOAD DATA INFILE</CODE> は全ての入力を文字列としてみるため、<CODE>enum</CODE> 
または <CODE>set</CODE> 項目には、<CODE>INSERT</CODE> ステートメントで使用できるよう
には、数値は使用できません。全ての <CODE>enum</CODE> と <CODE>set</CODE> は文字列で
与えられる必要があります！

</P>
<P>
エスケープ構文についてのこれ以上の情報は  「<A HREF="manual_Syntax.html#Base Syntax">リテラル。文字列と数値をどのように書くか？</A>」節参照 。

</P>
<P>
<CODE>LOAD DATA</CODE> 問い合わせが行なわれた時、次の情報文字列が C API 関数 
<CODE>mysql_info()</CODE> で得られます。

</P>
<P>
<CODE>Records: 1  Deleted: 0  Skipped: 0  Warnings: 0</CODE>

</P>
<P>
Warnings は、精度の損失なしで置かれなかった項目、読み込んだテキスト行か
ら値を得なかった項目(行が短かすぎると発生)、与えられた項目に適合できるさ
らなるデータを持つ行で増加します。warning はまた time, date, timestamp 
または datetime 項目が 0 に設定された時にも与えられます。

</P>
<P>
全ての項目をロードする例:

</P>

<PRE>
LOAD DATA INFILE 'persondata.text' INTO TABLE persondata;
</PRE>

<P>
 「<A HREF="manual_Performance.html#Table efficiency">私のテーブルをできるだけ速く/小さく扱う方法は？</A>」節参照 

</P>
<P>
<A NAME="IDX250"></A>


<H2><A NAME="Update" HREF="manual_toc.html#Update">UPDATE 構文</A></H2>


<PRE>
UPDATE table SET column=expression,... WHERE where_definition
</PRE>

<P>
全ての更新は左から右に行なわれます。expression 内で項目をアクセスすると、
更新は項目の現在の値(与えられた値またはデフォルト値)を使用します。

</P>

<PRE>
UPDATE persondata SET count=count+1
</PRE>

<P>
<CODE>UPDATE</CODE> ステートメントはいくつの行が実際に変更されたかを返します。
<STRONG>MySQL</STRONG> 3.22 では <CODE>mysql_info()</CODE> は適合した行数と更新された
行数と、更新中にいくつの警告を得たかを返します。

</P>
<P>
<A NAME="IDX251"></A>
<A NAME="IDX252"></A>
<A NAME="IDX253"></A>
<A NAME="IDX254"></A>
<A NAME="IDX255"></A>
<A NAME="IDX256"></A>
<A NAME="IDX257"></A>
<A NAME="IDX258"></A>


<H2><A NAME="Show" HREF="manual_toc.html#Show">SHOW 構文。テーブルや項目などについての情報を得る</A></H2>


<PRE>
	SHOW DATABASES [LIKE wild]
or 	SHOW TABLES [FROM database] [LIKE wild]
or	SHOW COLUMNS FROM table [FROM database] [LIKE wild]
or	SHOW INDEX FROM table [FROM database]
or	SHOW STATUS
or	SHOW VARIABLES [LIKE wild]
</PRE>

<P>
データベース、テーブル、項目についての情報を与えます。<CODE>LIKE wild</CODE> 
部が使用された場合、<CODE>wild</CODE> 文字列は通常の SQL ワイルドカード (% と _) 
です。<CODE>FIELDS</CODE> は <CODE>COLUMNS</CODE> の別名として使用され、<CODE>KEYS</CODE> 
は <CODE>INDEXES</CODE> の別名として使用されます。

</P>
<P>
<CODE>STATUS</CODE> は、<CODE>mysqladmin status</CODE> と同様に、サーバからのステー
タス情報を与えます。出力は次とは異なるかもしれません:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>Uptime</CODE> </TD><TD> <CODE>Running_threads</CODE> </TD><TD> <CODE>Questions</CODE> </TD><TD> <CODE>Reloads</CODE> </TD><TD> <CODE>Open_tables</CODE>
</TR NOSAVE>
<TR><TD>119 </TD><TD> 1 </TD><TD> 4 </TD><TD> 1 </TD><TD> 3
</TR>
</TABLE>

<CODE>VARIABLES</CODE> は <STRONG>MySQL</STRONG> システム変数のいくつかの値を示します。
これらの変数の多くは、<CODE>mysqld</CODE> への様々なオプションで変更できます！



<H2><A NAME="Explain" HREF="manual_toc.html#Explain">EXPLAIN 構文。SELECT についての情報を得る</A></H2>


<PRE>
	EXPLAIN SELECT select_options
</PRE>

<P>
テーブルをどのようにどの順で結合するのかの情報を与えます。<CODE>EXPLAIN</CODE> の助
けで、レコードを見つけるためにキーを使用するより速い select を得るために、
さらなるインデックスをテーブルに追加すべき時を見ることができます。また、オプティ
マイザが最適な順でテーブルを結合するかどうかを見ることもできます。select への 
<CODE>STRAIGHT_JOIN</CODE> オプションで、特定の結合順序の使用をオプティマイザ
に強制することができます。

</P>
<P>
様々な結合タイプ:

</P>
<DL COMPACT>

<DT><CODE>system</CODE>
<DD>
<A NAME="IDX259"></A>
 
テーブルは1レコードだけを持ちます (= システムテーブル) 
<DT><CODE>const</CODE>
<DD>
テーブルは、多くても1つの適合するレコード(問い合わせの開始時に読まれる)を持ち
ます。このテーブル内の全ての項目は、オプティマイザの休止によって定数と見なされま
す。
<DT><CODE>eq_ref</CODE>
<DD>
前のテーブルの各組合せについて、一つの行がこのテーブルから読まれます。
<DT><CODE>ref</CODE>
<DD>
前のテーブルの各組合せについて、適合するインデックスの全ての行がこのテー
ブルから読まれます。
<DT><CODE>range</CODE>
<DD>
与えられたインデックス範囲内の行だけがインデックスを通じて取り出されます。
拡張項目はどのインデックスが使用されたかを知らせます。
<DT><CODE>all</CODE>
<DD>
前のテーブルの各組合せについて、完全なテーブル scan が行なわれます。
</DL>

<P>
これは <CODE>EXPLAIN</CODE> の助けで最適化された join の例です。

</P>

<PRE>
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn,
        tt.ProjectReference, tt.EstimatedShipDate,
        tt.ActualShipDate, tt.ClientID,
        tt.ServiceCodes, tt.RepetitiveID,
        tt.CurrentProcess, tt.CurrentDPPerson,
        tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
        et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1,
        do
        WHERE tt.SubmitTime Is Null and tt.ActualPC =
        et.EMPLOYID and tt.AssignedPC =
        et_1.EMPLOYID and tt.ClientID =
        do.CUSTNMBR;
</PRE>

<P>
<CODE>EXPLAIN</CODE> は次を返します:

</P>

<PRE>
table   type    possible_keys   key     key_len ref     rows    Extra
et      ALL     PRIMARY NULL    NULL    NULL    74
do      ALL     PRIMARY NULL    NULL    NULL    2135
et_1    ALL     PRIMARY NULL    NULL    NULL    74
tt      ALL     AssignedPC,ClientID,ActualPC    NULL    NULL    NULL   3872
        range checked for each record (key map: 35)
</PRE>

<P>
この場合 <STRONG>MySQL</STRONG> は全てのテーブルに完全な結合を行っています！ 各
テーブル内の行の数の製品が検討されるので、これはかなり長い時間かかります！ 
全てのテーブルが 1000 レコード持っていた場合、<STRONG>MySQL</STRONG> は 1000^4 =
1000000000000 行を調べないといけません。テーブルがもっと大きいと、どれく
らいの時間かかるか想像できます...。

</P>
<P>
この場合、最初の間違いは <STRONG>MySQL</STRONG> はまだ、異なった宣言がされた項目
のインデックスを能率的に使用しないことです: (varchar() と char() はこの
文脈では異なりません)

</P>
<P>
この場合、<CODE>tt.ActualPC</CODE> は <CODE>char(10)</CODE> で <CODE>et.EMPLOYID</CODE> は 
<CODE>char(15)</CODE> です。

</P>
<P>
修正:

</P>

<PRE>
mysql&#62; alter table tt change ActualPC ActualPC varchar(15);
</PRE>

<P>
そして上の EXPLAIN は次を示します:

</P>

<PRE>
table   type    possible_keys   key     key_len ref     rows    Extra
tt      ALL     AssignedPC,ClientID,ActualPC    NULL    NULL    NULL   3872
        where used
do      ALL     PRIMARY NULL    NULL    NULL    2135
        range checked for each record (key map: 1)
et_1    ALL     PRIMARY NULL    NULL    NULL    74
        range checked for each record (key map: 1)
et     eq_ref  PRIMARY PRIMARY 15      tt.ActualPC    1
</PRE>

<P>
これは完全ではありませんが、かなりましです。このバージョンは数秒で実行さ
れます。

</P>
<P>
さらに、

</P>

<PRE>
mysql&#62; alter table tt change AssignedPC AssignedPC varchar(15),
                      change ClientID Clientid     varchar(15);
</PRE>

<P>
<CODE>EXPLAIN</CODE> から次が得られます:

</P>

<PRE>
table   type    possible_keys   key     key_len ref     rows    Extra
et      ALL     PRIMARY NULL    NULL    NULL    74
tt      ref     AssignedPC,ClientID,ActualPC    ActualPC        15
        et.EMPLOYID   52      where used
et_1    eq_ref  PRIMARY PRIMARY 15      tt.AssignedPC  1
do      eq_ref  PRIMARY PRIMARY 15      tt.Clientid    1
</PRE>

<P>
Which is 'almost' as good as it can get.  The problem is that
<STRONG>MySQL</STRONG> assumes that <CODE>tt.AcutalPC</CODE> is evenly distributed which
isn't the case in the tt.

</P>
<P>
Fortunately it is easy to tell <STRONG>MySQL</STRONG> about this:

</P>

<PRE>
shell&#62; isamchk --analyze PATH_TO_MYSQL_DATABASE/tt
shell&#62; mysqladmin refresh
</PRE>

<P>
And now the join is 'perfect':

</P>

<PRE>
table   type    possible_keys   key     key_len ref     rows    Extra
tt      ALL     AssignedPC,ClientID,ActualPC    NULL    NULL    NULL
        3872     where used
et      eq_ref  PRIMARY PRIMARY 15      tt.ActualPC    1
et_1    eq_ref  PRIMARY PRIMARY 15      tt.AssignedPC  1
do      eq_ref  PRIMARY PRIMARY 15      tt.Clientid    1
</PRE>

<P>
<A NAME="IDX260"></A>
<A NAME="IDX261"></A>


<H2><A NAME="Describe" HREF="manual_toc.html#Describe">DESCRIBE 構文。項目についての情報を得る</A></H2>

<P>
<CODE>(DESCRIBE | DESC) table [column]</CODE>

</P>
<P>
項目についての情報を与えます。このコマンドは Oracle の互換のためにありま
す。 「<A HREF="manual_Syntax.html#Show">SHOW 構文。テーブルや項目などについての情報を得る</A>」節参照 。項目は項目名または文字列です。文字列はワイルドカードを
含めます。

</P>
<P>
<A NAME="IDX262"></A>
<A NAME="IDX263"></A>


<H2><A NAME="Lock tables" HREF="manual_toc.html#Lock tables"><CODE>LOCK TABLES</CODE> 構文</A></H2>


<PRE>
LOCK TABLES table_name [AS alias] READ|WRITE [, table_name READ|WRITE]
...
UNLOCK TABLES
</PRE>

<P>
このスレッドのためにテーブルをロックします。スレッドがテーブルに READ ロッ
クを持つ場合、そのスレッド(と他の全てのスレッド)はテーブルからの読み込み
だけができます。スレッドがテーブルに WRITE ロックを持つ場合、このスレッ
ドだけがテーブルの READ と WRITE ができます。全てのスレッドはそれらが全
てのロックを得るまで待ちます(タイムアウト無し)。

</P>
<P>
<CODE>LOCK TABLES</CODE> を使用するとき、使用しようとする全てのテーブルをロッ
クすべきです！ このポリシーはテーブルロックをデッドロックフリーにするこ
とを確かにします。

</P>

<PRE>
LOCK TABLES trans READ, customer AS c WRITE
SELECT SUM(value) FROM trans WHERE customer_id= #some_id#;
UPDATE customer SET total_value=#value_from_last_statement# WHERE
customer_id=#some_id#
UNLOCK TABLES
</PRE>

<P>
全てのテーブルは、他の <CODE>LOCK TABLES</CODE> を発行した時、またはサーバへの
接続がクローズされた場合、自動的にアンロックされます。

</P>
<P>
通常はテーブルをロックする必要はありません。とにかくテーブルをロックした
い時にはいくつかの場合があります:

</P>

<UL>
<LI>

テーブルの束で多くの操作を実行しようとする場合、使用しようとしているテー
ブルをロックするととても速くなります。もちろん、他のスレッドは READ ロッ
クされたテーブルの更新はできませんし、他のスレッドは WRITE ロックされた
テーブルを読むことはできません。
<LI>

<CODE>MySQL</CODE> はトランザクション環境をサポートしないため、他のスレッドが
読み込み都更新の間に来ないことを保証したい場合は、lock tables を使用する
必要があります。例えば前の例は安全のためには <CODE>LOCK TABLES</CODE> を必要と
します！ <CODE>LOCK TABLES</CODE> を使用しない場合、SELECT と UPDATE ステート
メントの間に、誰かが新しい 'trans' 行を挿入する変更ができます。
<LI>

増加更新 (<CODE>UPDATE customer set value=value+new_value</CODE>) または 
LAST_INSERT_ID() 関数の使用により、多くの場合 <CODE>LOCK TABLES</CODE> を回避
できます。
</UL>

<P>
いくつかの場合、ユーザレベルロック: GET_LOCK() と RELEASE_LOCK() の使用
によっても解決できます。これらのロックはサーバ内のハッシュテーブル内に保
持され、高速のため pthread_mutex で実装されました。
 「<A HREF="manual_Syntax.html#Miscellaneous functions">その他の関数</A>」節参照 

</P>
<P>
<A NAME="IDX264"></A>


<H2><A NAME="Set option" HREF="manual_toc.html#Set option">SET OPTION 構文</A></H2>


<PRE>
SET [OPTION] SQL_VALUE_OPTION=value, ...
</PRE>

<P>
使用されたオプションは実際には現在のセッション全体に対して残ります。

</P>
<P>
様々なオプション:

</P>
<DL COMPACT>

<DT><CODE>SQL_SELECT_LIMIT=value</CODE>
<DD>
全ての select で返されるレコードの最大数。select が limit 節を持っていた
場合、それはこのステートメントを上書きします。新しい接続のデフォルト値は 
'無制限' です。
<DT><CODE>SQL_BIG_TABLES= 0 | 1</CODE>
<DD>
1 に設定した場合、全ての一時テーブルはメモリの代わりにディスク上に格納さ
れます。これは少し遅くなりますが、大きな一時テーブルを要求する大きな 
select で、エラー <CODE>The table ### is full</CODE> になることはありません。
新しい接続のデフォルト値は 0 です(メモリ一時テーブルを使用します)。
<DT><CODE>SQL_BIG_SELECTS= 0 | 1</CODE>
<DD>
1 に設定した場合、とても長い時間が掛かるであろう select を行なおうとする
と、<STRONG>MySQL</STRONG> は abort します。これは、間違った <CODE>WHERE</CODE> ステー
トメントが発行された時に有用です。<CODE>max_join_size</CODE> 行以上を検討する
ような <CODE>SELECT</CODE> が大きなクエリと定義されます。新しい接続のデフォル
ト値は 0 です(これは全ての SELECT を許します)。
<DT><CODE>CHARACTER SET character_set_name | DEFAULT</CODE>
<DD>
これはクライアントからのそしてクライアントへの全ての文字列を与えられたマッ
ピングにマップします。現在 character_set_name のオプションは 
<CODE>cp1251_koi8</CODE> だけですが、ファイル 
<CODE>mysql_source_directory/sql/convert.cc</CODE> を編集することにより、新し
いマッピングを簡単に追加できます。デフォルトマッピングを戻すには
character_set_name として <CODE>DEFAULT</CODE> を使用します。
<DT><CODE>SQL_LOG_OFF= 0 | 1</CODE>
<DD>
1 に設定した場合、クライアントがプロセスリスト特権を持っていると、このク
ライアントのための標準ログへのロギングは行われません。これは更新ログには
影響しません！
<DT><CODE>TIMESTAMP= timestamp_value | DEFAULT</CODE>
<DD>
このクライアントの時刻を設定します。これは、行をリストアするための更新ロ
グを使用する場合、オリジナルタイムスタンプを得るために使用されます。
<DT><CODE>LAST_INSERT_ID= #</CODE>
<DD>
LAST_INSERT_ID() から返される値を設定します。これは、テーブルを更新する
コマンド内で LAST_INSERT_ID() を使用した時、更新ログに格納されます。
</DL>

<P>
<A NAME="IDX265"></A>


<H2><A NAME="Grant" HREF="manual_toc.html#Grant">GRANT 構文(互換関数)</A></H2>


<PRE>
GRANT (ALL PRIVILEGES | (SELECT, INSERT, UPDATE, DELETE,
 REFERENCES (column list), USAGE))
 ON table TO user,... [WITH GRANT OPTION]
</PRE>

<P>
このコマンドは何も行ないません。これが <STRONG>MySQL</STRONG> にあるのは互換性の
ためだけです。（他の SQL サーバからのコードの移行をより簡単にするため）。
<STRONG>MySQL</STRONG> の特権は <STRONG>MySQL</STRONG> 承認テーブルで操作されます。
 「<A HREF="manual_Privilege_system.html#Privileges">特権システムがどのように働くか？</A>」節参照 

</P>
<P>
<A NAME="IDX266"></A>
<A NAME="IDX267"></A>
<A NAME="IDX268"></A>


<H2><A NAME="Create Index" HREF="manual_toc.html#Create Index">CREATE INDEX 構文(互換関数)</A></H2>

<P>
<CODE>CREATE [UNIQUE] INDEX index_name ON table_name ( column_name[(length)],... )</CODE>

</P>
<P>
バージョンが 3.22 よりも前の MySQL では、この関数は何も行ないません。こ
れはインデックスを生成する <CODE>ALTER TABLE</CODE> 呼び出しにマップされていま
す。 「<A HREF="manual_Syntax.html#Alter table">ALTER TABLE 構文</A>」節参照 

</P>
<P>
通常、全てのインデックスは <CODE>CREATE TABLE</CODE> と同時に生成できます。
 「<A HREF="manual_Syntax.html#Create table">CREATE TABLE 構文</A>」節参照 

</P>
<P>
<CODE>(col1, col2)</CODE> は2つの項目からなる複合インデックスを作成します。イ
ンデックスは与えられた項目の結合のように見えます。<CODE>CREATE TABLE</CODE> 中
で <CODE>INDEX(col1,col2)</CODE> の代わりに <CODE>INDEX(col1)</CODE>,
<CODE>INDEX(col2)</CODE> を使えば、一つの複合インデックスの代わりに二つの別々
のキーが代わりに得られます。

</P>

<PRE>
SELECT * FROM table WHERE col1=# AND col2=#
</PRE>

<P>
<CODE>(col1,col2)</CODE> のインデックスの場合は、正しい行が直接 fetch されます。
<CODE>(col1)</CODE>, <CODE>(col2)</CODE> の場合は、どちらのインデックスの方がより少
ない行を見つかるかをオプティマイザが決定し、このインデックスが行を fetch 
するために使用されます。

</P>
<P>
テーブルがインデックス <CODE>(col1,col2,col3...)</CODE> を持っている場合は、こ
の頭の方がオプティマイザによって行を見つけるために使用されます。これは、
次のような検索能力をあなたに与えることを意味します: <CODE>(col1)</CODE> そして 
<CODE>(col1,col2)</CODE> そして <CODE>(col1,col2,col3)</CODE>...

</P>
<P>
<STRONG>MySQL</STRONG> は、インデックスを通して行を配置するために、インデックス
の一部分を使用することはできません。

</P>
<P>
<CODE>(col1,col2,col3)</CODE> 定義では:

</P>

<PRE>
SELECT * FROM table WHERE col1=#
SELECT * FROM table WHERE col2=#
SELECT * FROM table WHERE col2=# and col3=#
</PRE>

<P>
最初のクエリだけがインデックスを使用します。

</P>
<P>
<CODE>LIKE</CODE> 引数がワイルド文字で始まらない定数文字列の場合、
<STRONG>MySQL</STRONG> はインデックスも使用します:

</P>
<P>
次はインデックスを使用します:

</P>

<PRE>
SELECT * from table WHERE key_column like "Patrick%";
SELECT * from table WHERE key_column like "Pat%_ck%";
</PRE>

<P>
上のケースでは、<CODE>Patrick &#60;= key_column &#60; Patric1</CODE> と <CODE>Pat &#60;=
key_column &#60; Pau</CODE> の行だけが考慮されます。

</P>
<P>
次の select はインデックスを使用しません:

<PRE>
SELECT * from table WHERE key_column like "%Patrick%";
SELECT * from table WHERE key_column like other_column;
</PRE>

<P>
<CODE>column_name(length)</CODE> 構文で <CODE>string</CODE> 項目でだけ一部のインデッ
クスを記述できます。これはインデックスファイルをより小さくします。

</P>

<PRE>
CREATE INDEX part_of_name ON customer (name(10))
</PRE>

<P>
多くの名前は最初の10文字が異なることは全く普通なので、上の定義は名前の検
索を遅くしませんが、多くのディスクを節約し、挿入を速くします！

</P>
<P>
<A NAME="IDX269"></A>


<H2><A NAME="Drop Index" HREF="manual_toc.html#Drop Index">DROP INDEX 構文(互換関数)</A></H2>

<P>
<CODE>DROP INDEX index_name</CODE>

</P>
<P>
この関数はバージョン 3.22 より前の <CODE>MySQL</CODE> では何も行いません。これ
は <CODE>INDEX</CODE> または <CODE>UNIQUE</CODE> 定義を破棄する <CODE>ALTER TABLE</CODE> 
呼び出しにマップされています。 「<A HREF="manual_Syntax.html#Alter table">ALTER TABLE 構文</A>」節参照 

</P>
<P>
<A NAME="IDX270"></A>


<H2><A NAME="Comments" HREF="manual_toc.html#Comments">Comment 構文</A></H2>

<P>
<STRONG>MySQL</STRONG> は <CODE># から行末まで</CODE> と <CODE>/* 複数行 */</CODE> コメント
形式をサポートします。

</P>

<PRE>
select 1+1;	# This comment is to the end of line
select 1 /* in-line-comment */ + 1;
select 1+
/*
This will be ignored
*/
1;
</PRE>

<P>
<STRONG>MySQL</STRONG> は <CODE>--</CODE> ANSI SQL 形式コメントをサポートしません。
 「<A HREF="manual_Compatibility.html#Missing comments">コメント開始としての --</A>」節参照 。

</P>

<P>
<A NAME="IDX271"></A>
<A NAME="IDX272"></A>
<A NAME="IDX273"></A>


<H2><A NAME="UDF functions" HREF="manual_toc.html#UDF functions">CREATE FUNCTION 構文</A></H2>


<PRE>
CREATE FUNCTION &#60;function_name&#62; RETURNS [string|real|integer]
       SONAME &#60;name_of_shared_library&#62;

DROP FUNCTION &#60;function_name&#62;
</PRE>

<P>
ユーザ定義可能関数 (UDF:User definable functions) は、<CODE>ABS()</CODE> と 
<CODE>concat()</CODE> のようなネイティブ <STRONG>MySQL</STRONG> 関数として機能する新し
い関数を <STRONG>MySQL</STRONG> に拡張する方法です。UDF は C または C++ で書かれ、
OS で動的ロードが機能することを要求します。ソース配布は、５つの新しい関
数を定義するファイル <TT>`udf_example.cc'</TT> を含んでいます。

</P>
<P>
関数名、型、共有ライブラリは 'mysql' データベース内の新しいシステムテー
ブル 'func' に保存されます。新しい関数の作成を可能にするためには、データ
ベース 'mysql' に書き込み権が必要です。<STRONG>MySQL</STRONG> を 
--skip-grant-tables で開始する場合は、UDF 初期化もスキップされます。

</P>
<P>
各定義関数は xxxx_init 関数と xxx_deinit 関数を持ちます。init 関数は関数
のためにメモリを割り当て、結果の最大長(文字列関数)、小数点の桁数(double 
関数)、結果が null 値になるかどうかについて main 関数に知らせます。

</P>
<P>
関数が 'error' 引数を 1 に設定する場合、その関数はそれ以上呼ばれず、
mysqld はこの関数のインスタンスを呼び出す全てについて NULL を返します。

</P>
<P>
関数への全ての文字列引数は、バイナリデータの操作をできるように、文字列の
ポインタ + 長さとして与えられます。全ての関数はスレッドセーフでないとい
けないことを知っていてください。これは変更されるようなグローバル変数また
は静的変数の割り当ては許されないことを意味します！ メモリを必要とする場
合は、init 関数内で割り当て、__deinit 関数でこれを解放すべきです。

</P>
<P>
動的ロードファイルは共有可能としてコンパイルされるべきです (次のようなも
の: <CODE>gcc -shared -o udf_example.so myfunc.cc</CODE>)。次を行うことで正し
い全てのスイッチを簡単に得ることができます: <CODE>cd sql ; make
udf_example.o</CODE> 書き込みを行うコンパイル行を取り出し、行末近くの '-c' を
削除して、コンパイル行の最後に -o udf_example.so を追加してください。結
果のライブラリ (udf_example.so) は ld によって検索されるどこかのディレク
トリ、例えば /usr/lib にコピーしてください。

</P>
<P>
サンプル関数に関するいくつかの注意:

</P>

<UL>
<LI>

関数 <CODE>metaphon</CODE> は文字列引数の metaphon 文字列を返します。
これは soundex 文字列に似たものですが、さらに英語に tune されます。
<LI>

関数 <CODE>myfunc_double</CODE> は、引数の全ての文字コードの合計を、全ての引数
の長さの合計で割った値を返します。
<LI>

関数 <CODE>myfunc_int</CODE> は全ての引数の長さの合計を返します。
<LI>

関数 <CODE>lookup</CODE> はホスト名の IP 番号を返します。
<LI>

関数 <CODE>reverse_lookup</CODE> は IP 番号のホスト名を返します。
この関数は文字列 "xxx.xxx.xxx.xxx" または4桁の数値で呼ばれます。
</UL>

<P>
ライブラリがインストールされた後、<CODE>mysqld</CODE> に新しい関数を次のコマン
ドで知らせる必要があります:

</P>

<PRE>
CREATE FUNCTION metaphon RETURNS STRING SONAME "udf_example.so";
CREATE FUNCTION myfunc_double RETURNS REAL SONAME "udf_example.so";
CREATE FUNCTION myfunc_int RETURNS INTEGER SONAME "udf_example.so";
CREATE FUNCTION lookup RETURNS STRING SONAME "udf_example.so";
CREATE FUNCTION reverse_lookup RETURNS STRING SONAME "udf_example.so";
</PRE>

<P>
関数は一度だけ作成されます。
関数は次のようにして削除できます:

</P>

<PRE>
DROP FUNCTION metaphon;
DROP FUNCTION myfunc_double;
DROP FUNCTION myfunc_int;
DROP FUNCTION lookup;
DROP FUNCTION reverse_lookup;
</PRE>

<P>
<CODE>CREATE FUNCTION</CODE> と <CODE>DROP FUNCTION</CODE> は <CODE>func</CODE> テーブルを
更新します。全てのアクティブな関数はサーバの再起動ごとにリロードされます
(--skip-grant-tables が与えられない場合)。

</P>
<P>
<A NAME="IDX274"></A>


<H2><A NAME="Reserved words" HREF="manual_toc.html#Reserved words"><STRONG>MySQL</STRONG> は予約語について厳密か？</A></H2>

<P>
よくある問題は、<CODE>timestamp</CODE> や <CODE>group</CODE>、<STRONG>MySQL</STRONG> に埋め
込まれているデータ型や関数の名前を項目名として持つテーブルの作成を試みる
ことをくいとめます。それを行なうことは許されています(例えば、<CODE>ABS</CODE> 
は項目名として許されます)が、名前が項目名でもある関数使用時には、関数名
と <CODE>'('</CODE> の間に空白は許されません。

</P>
<P>
次は <STRONG>MySQL</STRONG> での明白な予約語です。これらのほとんどは (例えば)
<CODE>group</CODE> は ANSI SQL92 では項目名やテーブル名としては禁じられてます。
いくつかは <STRONG>MySQL</STRONG> が必要とするためで、(現在) Yacc パーサを使用し
ています:

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>action</CODE> </TD><TD> <CODE>add</CODE> </TD><TD> <CODE>all</CODE> </TD><TD> <CODE>alter</CODE>
</TR NOSAVE>
<TR><TD><CODE>and</CODE> </TD><TD> <CODE>as</CODE> </TD><TD> <CODE>asc</CODE> </TD><TD> <CODE>auto_increment</CODE>
</TR NOSAVE>
<TR><TD><CODE>between</CODE> </TD><TD> <CODE>bigint</CODE> </TD><TD> <CODE>bit</CODE> </TD><TD> <CODE>binary</CODE>
</TR NOSAVE>
<TR><TD><CODE>blob</CODE> </TD><TD> <CODE>both</CODE> </TD><TD> <CODE>by</CODE> </TD><TD> <CODE>cascade</CODE>
</TR NOSAVE>
<TR><TD><CODE>char</CODE> </TD><TD> <CODE>character</CODE> </TD><TD> <CODE>change</CODE> </TD><TD> <CODE>check</CODE>
</TR NOSAVE>
<TR><TD><CODE>column</CODE> </TD><TD> <CODE>columns</CODE> </TD><TD> <CODE>create</CODE> </TD><TD> <CODE>data</CODE>
</TR NOSAVE>
<TR><TD><CODE>database</CODE> </TD><TD> <CODE>databases</CODE> </TD><TD> <CODE>date</CODE> </TD><TD> <CODE>datetime</CODE>
</TR NOSAVE>
<TR><TD><CODE>day</CODE> </TD><TD> <CODE>day_hour</CODE> </TD><TD> <CODE>day_minute</CODE> </TD><TD> <CODE>day_second</CODE>
</TR NOSAVE>
<TR><TD><CODE>dayofweek</CODE> </TD><TD> <CODE>dec</CODE> </TD><TD> <CODE>decimal</CODE> </TD><TD> <CODE>default</CODE>
</TR NOSAVE>
<TR><TD><CODE>delete</CODE> </TD><TD> <CODE>desc</CODE> </TD><TD> <CODE>describe</CODE> </TD><TD> <CODE>distinct</CODE>
</TR NOSAVE>
<TR><TD><CODE>double</CODE> </TD><TD> <CODE>drop</CODE> </TD><TD> <CODE>escaped</CODE> </TD><TD> <CODE>enclosed</CODE>
</TR NOSAVE>
<TR><TD><CODE>enum</CODE> </TD><TD> <CODE>explain</CODE> </TD><TD> <CODE>fields</CODE> </TD><TD> <CODE>float</CODE>
</TR NOSAVE>
<TR><TD><CODE>float4</CODE> </TD><TD> <CODE>float8</CODE> </TD><TD> <CODE>foreign</CODE> </TD><TD> <CODE>from</CODE>
</TR NOSAVE>
<TR><TD><CODE>for</CODE> </TD><TD> <CODE>full</CODE> </TD><TD> <CODE>grant</CODE> </TD><TD> <CODE>group</CODE>
</TR NOSAVE>
<TR><TD><CODE>having</CODE> </TD><TD> <CODE>hour</CODE> </TD><TD> <CODE>hour_minute</CODE> </TD><TD> <CODE>hour_second</CODE>
</TR NOSAVE>
<TR><TD><CODE>ignore</CODE> </TD><TD> <CODE>in</CODE> </TD><TD> <CODE>index</CODE> </TD><TD> <CODE>infile</CODE>
</TR NOSAVE>
<TR><TD><CODE>insert</CODE> </TD><TD> <CODE>int</CODE> </TD><TD> <CODE>integer</CODE> </TD><TD> <CODE>interval</CODE>
</TR NOSAVE>
<TR><TD><CODE>int1</CODE> </TD><TD> <CODE>int2</CODE> </TD><TD> <CODE>int3</CODE> </TD><TD> <CODE>int4</CODE>
</TR NOSAVE>
<TR><TD><CODE>int8</CODE> </TD><TD> <CODE>into</CODE> </TD><TD> <CODE>is</CODE> </TD><TD> <CODE>join</CODE>
</TR NOSAVE>
<TR><TD><CODE>key</CODE> </TD><TD> <CODE>keys</CODE> </TD><TD> <CODE>leading</CODE> </TD><TD> <CODE>left</CODE>
</TR NOSAVE>
<TR><TD><CODE>like</CODE> </TD><TD> <CODE>lines</CODE> </TD><TD> <CODE>limit</CODE> </TD><TD> <CODE>lock</CODE>
</TR NOSAVE>
<TR><TD><CODE>load</CODE> </TD><TD> <CODE>long</CODE> </TD><TD> <CODE>longblob</CODE> </TD><TD> <CODE>longtext</CODE>
</TR NOSAVE>
<TR><TD><CODE>match</CODE> </TD><TD> <CODE>mediumblob</CODE> </TD><TD> <CODE>mediumtext</CODE> </TD><TD> <CODE>mediumint</CODE>
</TR NOSAVE>
<TR><TD><CODE>middleint</CODE> </TD><TD> <CODE>minute</CODE> </TD><TD> <CODE>minute_second</CODE> </TD><TD> <CODE>month</CODE>
</TR NOSAVE>
<TR><TD><CODE>natural</CODE> </TD><TD> <CODE>numeric</CODE> </TD><TD> <CODE>no</CODE> </TD><TD> <CODE>not</CODE>
</TR NOSAVE>
<TR><TD><CODE>null</CODE> </TD><TD> <CODE>on</CODE> </TD><TD> <CODE>option</CODE> </TD><TD> <CODE>optionally</CODE>
</TR NOSAVE>
<TR><TD><CODE>or</CODE> </TD><TD> <CODE>order</CODE> </TD><TD> <CODE>outer</CODE> </TD><TD> <CODE>outfile</CODE>
</TR NOSAVE>
<TR><TD><CODE>partial</CODE> </TD><TD> <CODE>precision</CODE> </TD><TD> <CODE>primary</CODE> </TD><TD> <CODE>procedure</CODE>
</TR NOSAVE>
<TR><TD><CODE>privileges</CODE> </TD><TD> <CODE>read</CODE> </TD><TD> <CODE>real</CODE> </TD><TD> <CODE>references</CODE>
</TR NOSAVE>
<TR><TD><CODE>rename</CODE> </TD><TD> <CODE>regexp</CODE> </TD><TD> <CODE>repeat</CODE> </TD><TD> <CODE>replace</CODE>
</TR NOSAVE>
<TR><TD><CODE>restrict</CODE> </TD><TD> <CODE>rlike</CODE> </TD><TD> <CODE>select</CODE> </TD><TD> <CODE>set</CODE>
</TR NOSAVE>
<TR><TD><CODE>show</CODE> </TD><TD> <CODE>smallint</CODE> </TD><TD> <CODE>sql_big_tables</CODE> </TD><TD> <CODE>sql_big_selects</CODE>
</TR NOSAVE>
<TR><TD><CODE>sql_select_limit</CODE> </TD><TD> <CODE>sql_log_off</CODE> </TD><TD> <CODE>straight_join</CODE> </TD><TD> <CODE>starting</CODE>
</TR NOSAVE>
<TR><TD><CODE>table</CODE> </TD><TD> <CODE>tables</CODE> </TD><TD> <CODE>terminated</CODE> </TD><TD> <CODE>text</CODE>
</TR NOSAVE>
<TR><TD><CODE>time</CODE> </TD><TD> <CODE>timestamp</CODE> </TD><TD> <CODE>tinyblob</CODE> </TD><TD> <CODE>tinytext</CODE>
</TR NOSAVE>
<TR><TD><CODE>tinyint</CODE> </TD><TD> <CODE>trailing</CODE> </TD><TD> <CODE>to</CODE> </TD><TD> <CODE>use</CODE>
</TR NOSAVE>
<TR><TD><CODE>using</CODE> </TD><TD> <CODE>unique</CODE> </TD><TD> <CODE>unlock</CODE> </TD><TD> <CODE>unsigned</CODE>
</TR NOSAVE>
<TR><TD><CODE>update</CODE> </TD><TD> <CODE>usage</CODE> </TD><TD> <CODE>values</CODE> </TD><TD> <CODE>varchar</CODE>
</TR NOSAVE>
<TR><TD><CODE>varying</CODE> </TD><TD> <CODE>varbinary</CODE> </TD><TD> <CODE>with</CODE> </TD><TD> <CODE>write</CODE>
</TR NOSAVE>
<TR><TD><CODE>where</CODE> </TD><TD> <CODE>year</CODE> </TD><TD> <CODE>year_month</CODE> </TD><TD> <CODE>zerofill</CODE>
</TR>
</TABLE>

次のシンボル(上の表から)は ANSI SQL では許されませんが、<STRONG>MySQL</STRONG> 
では項目名/テーブル名として許されます。これらの名前のいくつかはとても自
然な名前で、多くの人が既に使用しているからです。


<UL>
<LI>ACTION

<LI>BIT

<LI>DATE

<LI>ENUM

<LI>NO

<LI>TEXT

<LI>TIME

<LI>TIMESTAMP

</UL>

<P><HR><P>
Go to the <A HREF="manual_Introduction.html">first</A>, <A HREF="manual_Privilege_system.html">previous</A>, <A HREF="manual_Stabilty.html">next</A>, <A HREF="manual_Concept_Index.html">last</A> section, <A HREF="manual_toc.html">table of contents</A>.
 </BODY>
 </HTML>
