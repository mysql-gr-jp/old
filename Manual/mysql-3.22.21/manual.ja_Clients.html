<html><head>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 1 December 1999 -->

  <title>MySQL Reference Manual for version 3.22.21. - 20  MySQL クライアントツールと API</title>
  </head>
  <body bgcolor="#FFFFFF" text="#000000" link="#101090" vlink="#7030B0">
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_Common_problems.html">previous</a>, <a href="manual.ja_Comparisons.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
<p></p><hr><p>


</p><h1><a name="Clients" href="manual.ja_toc.html#Clients">20  <strong>MySQL</strong> クライアントツールと API</a></h1>



<h2><a name="C" href="manual.ja_toc.html#C">20.1  <strong>MySQL</strong> C API</a></h2>

<p>
C API コードは <strong>MySQL</strong> とともに配布されます。これは 
<code>libmysqlclient</code> ライブラリに含まれ、C プログラムからデータベースへ
のアクセスを許します。

</p>
<p>
MySQL ソースディストリビューション内のクライアントの多くは C で書かれています。C API の使
用法を示す例を探すなら、これらのクライアントを調べてください。

</p>
<p>
他のクライアント API の多く(Java を除く全て)は、<strong>MySQL</strong> サーバと
の通信にこのライブラリを使用します。そのため、例えば、他のクライアントプ
ログラムで使用されるのと同じ環境変数の多くの利点を得ることができます。そ
れらはライブラリから参照されるからです。これらの変数のリストについては 
 「<a href="manual.ja_Tools.html#Programs">12.1  様々な <strong>MySQL</strong> プログラムの概要</a>」節 を参照して下さい。

</p>
<p>
クライアントは最大通信バッファサイズを持ちます。最初に割り当てられるバッ
ファのサイズ(16K バイト)は自動的に最大サイズ(デフォルトは 24M)まで増加し
ます。バッファサイズは必要に応じて増加するため、単純にデフォルトの最大制
限を増加しても、さらに内部で資源を使用することはありません。このサイズチェッ
クは主に間違ったクエリと通信パケットのためのチェックです。

</p>
<p>
通信バッファは一つの SQL ステートメント(クライアントからサーバへの通信)と、
返されるデータ(サーバからクライアントへの通信)の１レコードを含むのに
十分大きくなくてはいけません。各スレッドの
通信バッファは、任意のレコードやクエリを処理するために、指定された制限まで動的
に増大します。例えば、最大 16M のデータを含む <code>BLOB</code> 値がある場合、
少なくとも 16M を通信バッファ制限として持つ必要があります(サーバとクライ
アントの両方で)。
クライアントのデフォルトの最大値は 24M ですが、サーバの最大値のデフォルトは
1M です。これはサーバ起動時に、<code>max_allowed_packet</code> パラメータの
値を変更することにより、増やすことが出来ます。
 「<a href="manual.ja_Performance.html#Server_parameters">10.2.3  サーバーパラメーターのチューニング</a>」節参照.

</p>
<p>
<strong>MySQL</strong> サーバは、各クエリ後に各通信バッファを 
<code>net_buffer_length</code> バイトに縮小します。
クライアントでは、接続に割り当てられたバッファのサイズは、接続が閉じられるまで減少しません。
クライアントメモリは接続がクローズされた時に調整されます。

</p>
<p>
スレッドプログラミングを行なう場合は、<strong>MySQL</strong> C API を 
<code>--with-thread-safe-client</code> 付きでコンパイルすべきです。これは C
API を接続毎のスレッド安全にします。次の場合に限り、２つのスレッドは同じ接
続を共有できます:

</p>
<dl compact="">

<dt>
</dt><dd>
２つのスレッドが同じ接続上で同時に <strong>MySQL</strong> にクエリを送信することは
できません。特に <code>mysql_query()</code> と <code>mysql_store_result()</code> の間
で、他のスレッドが同じ接続を使用しないことを確実にする必要があります。
</dd><dt>
</dt><dd>
多くのスレッドが <code>mysql_store_result()</code> で取り出された別々の結果セッ
トにアクセスできます。
</dd><dt>
</dt><dd>
<code>mysql_use_result</code> を使用する場合、結果セットがクローズされるまで、他
のスレッドが同じ接続上で何も尋ねないことを確実にする必要があります。
</dd></dl>



<h2><a name="C_API_datatypes" href="manual.ja_toc.html#C_API_datatypes">20.2  C API データ型</a></h2>
<dl compact="">

<dt><code>MYSQL</code>
</dt><dd>
<a name="IDX716"></a>
 
この構造体は一つのデータベース接続のハンドルを表わします。これはほとんど全て
の <strong>MySQL</strong> 関数に使用されます。

<a name="IDX717"></a>
</dd><dt><code>MYSQL_RES</code>
</dt><dd>
この構造体はレコードを返すクエリ(<code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code>, <code>EXPLAIN</code>)の結果を表わ
します。クエリから返される情報は、この節の残りでは<em>結果セット</em>と呼
ばれます。

<a name="IDX718"></a>
</dd><dt><code>MYSQL_ROW</code>
</dt><dd>
これはデータの１レコードの安全な型表現です。これは現在バイト文字列の配列として実
装されています。(フィールド値がバイナリデータを含むことがある場合、これを NULL 
終端文字列として扱うことはできません。そのような値は内部に NULL バイトを含
むことがあるからです。) <code>mysql_fetch_row()</code> の呼び出しによりレコードが獲得
されます。

<a name="IDX719"></a>
</dd><dt><code>MYSQL_FIELD</code>
</dt><dd>
この構造体はフィールドについての情報、つまりフィールドの名前、型、サイズ
等を含んでいます。このメンバは後でさらに詳細に説明されています。
<code>mysql_fetch_field()</code> を繰り返し呼び出すことにより、各フィールドの 
<code>MYSQL_FIELD</code> 構造体を得ることができます。
フィールド値はこの構造体の一部ではありません; それは <code>MYSQL_ROW</code> 構造
体に含まれています。

<a name="IDX720"></a>
</dd><dt><code>MYSQL_FIELD_OFFSET</code>
</dt><dd>
これは、<strong>MySQL</strong> フィールドリストへのオフセットの安全な型表現です。
(<code>mysql_field_seek()</code> で使用されます。)オフセットはレコード内のフィールド
番号で、0 から始まります。

<a name="IDX721"></a>
<a name="IDX722"></a>
</dd><dt><code>my_ulonglong</code>
</dt><dd>
レコード数と <code>mysql_affected_rows()</code>,
<code>mysql_num_rows()</code> そして <code>mysql_insert_id()</code> に使用される型です。
この型は <code>0</code> から <code>1.84e19</code> の範囲を与えます。

システムによっては、<code>my_ulonglong</code> 型の値を表示しようとしても、動作
しないことがあります。この値を表示するには、<code>unsigned long</code> に変換
し、<code>%lu</code> 出力書式を使用してください。例:

<pre>printf (Number of rows: %lu\n", (unsigned long) mysql_num_rows(result));
</pre>

</dd></dl>

<p>
<code>MYSQL_FIELD</code> 構造体は次のメンバを含みます:

</p>
<dl compact="">

<dt><code>char * name</code>
</dt><dd>
フィールドの名前。null終端文字列。

</dd><dt><code>char * table</code>
</dt><dd>
このフィールドを含むテーブルの名前。計算されたフィールドでない場合のみ有
効です。計算されたフィールドでは、<code>table</code> 値は空文字列です。

</dd><dt><code>char * def</code>
</dt><dd>
このフィールドのデフォルト値。null終端文字列。
これは <code>mysql_list_fields()</code> 使用時にだけ設定されます。

</dd><dt><code>enum enum_field_types type</code>
</dt><dd>
フィールドの型。
<code>type</code> 値は次の一つです:

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>型の値</strong> </td><td> <strong>型の意味</strong>
</td></tr>
<tr><td><code>FIELD_TYPE_TINY</code> </td><td> <code>TINYINT</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_SHORT</code> </td><td> <code>SMALLINT</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_LONG</code> </td><td> <code>INTEGER</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_INT24</code> </td><td> <code>MEDIUMINT</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_LONGLONG</code> </td><td> <code>BIGINT</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_DECIMAL</code> </td><td> <code>DECIMAL</code> または <code>NUMERIC</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_FLOAT</code> </td><td> <code>FLOAT</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_DOUBLE</code> </td><td> <code>DOUBLE</code> または <code>REAL</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_TIMESTAMP</code> </td><td> <code>TIMESTAMP</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_DATE</code> </td><td> <code>DATE</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_TIME</code> </td><td> <code>TIME</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_DATETIME</code> </td><td> <code>DATETIME</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_YEAR</code> </td><td> <code>YEAR</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_STRING</code> </td><td> 文字列 (<code>CHAR</code> または <code>VARCHAR</code>) フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_BLOB</code> </td><td> <code>BLOB</code> または <code>TEXT</code> フィールド (最大長を確定するには <code>max_length</code> を使用して下さい)
</td></tr>
<tr><td><code>FIELD_TYPE_SET</code> </td><td> <code>SET</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_ENUM</code> </td><td> <code>ENUM</code> フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_NULL</code> </td><td> <code>NULL</code>型 フィールド
</td></tr>
<tr><td><code>FIELD_TYPE_CHAR</code> </td><td> 非推奨; <code>FIELD_TYPE_TINY</code> を代わりに使用してください
</td></tr>
</tbody></table>

<code>IS_NUM()</code> マクロで、フィールドが数値タイプかどうかをテストできます。
フィールドが数値の場合、<code>type</code> メンバを <code>IS_NUM()</code> に渡すと
TRUE と評価します:


<pre>if (IS_NUM(field-&gt;type))
    printf("Field is numeric\n");
</pre>

</dd><dt><code>unsigned int length</code>
</dt><dd>
フィールドの幅。これはテーブル定義で指定されたものです。

</dd><dt><code>unsigned int max_length</code>
</dt><dd>
結果セットのフィールドの最大幅(実際の結果セットの中のレコードの最長フィールド値
の長さ)。<code>mysql_store_result()</code> または <code>mysql_list_fields()</code> を
使用する場合は、これはフィールドの最大幅になります。
<code>mysql_use_result()</code> を使用する場合は、この変数の値は 0 になります。

</dd><dt><code>unsigned int flags</code>
</dt><dd>
フィールドの種々のビットフラグ。<code>flags</code> 値は 0 または次のビットの一つ
以上の組み合わせです:

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フラグの値</strong> </td><td> <strong>フラグの意味</strong>
</td></tr>
<tr><td><code>NOT_NULL_FLAG</code> </td><td> フィールドは <code>NULL</code> にできない
</td></tr>
<tr><td><code>PRI_KEY_FLAG</code> </td><td> フィールドはプライマリキーの一部である
</td></tr>
<tr><td><code>UNIQUE_KEY_FLAG</code> </td><td> フィールドはユニークキーの一部である
</td></tr>
<tr><td><code>MULTIPLE_KEY_FLAG</code> </td><td> フィールドは非ユニークキーの一部である
</td></tr>
<tr><td><code>UNSIGNED_FLAG</code> </td><td> フィールドは <code>UNSIGNED</code> 属性を持っている
</td></tr>
<tr><td><code>ZEROFILL_FLAG</code> </td><td> フィールドは <code>ZEROFILL</code> 属性を持っている
</td></tr>
<tr><td><code>BINARY_FLAG</code> </td><td> フィールドは <code>BINARY</code> 属性を持っている
</td></tr>
<tr><td><code>AUTO_INCREMENT_FLAG</code> </td><td> フィールドは <code>AUTO_INCREMENT</code> 属性を持っている
</td></tr>
<tr><td><code>ENUM_FLAG</code> </td><td> フィールドは <code>ENUM</code> である (非推奨)
</td></tr>
<tr><td><code>BLOB_FLAG</code> </td><td> フィールドは <code>BLOB</code> または <code>TEXT</code> である (非推奨)
</td></tr>
<tr><td><code>TIMESTAMP_FLAG</code> </td><td> フィールドは <code>TIMESTAMP</code> である (非推奨)
</td></tr>
</tbody></table>

<code>BLOB_FLAG</code>, <code>ENUM_FLAG</code>, <code>TIMESTAMP_FLAG</code> の使用は推奨さ
れません。これらは型の属性ではなくフィールドの型を示すからです。代わり
に <code>field-&gt;type</code> を <code>FIELD_TYPE_BLOB</code>, <code>FIELD_TYPE_ENUM</code>,
<code>FIELD_TYPE_TIMESTAMP</code> に対してテストする方をお勧めします。

次の例は <code>flags</code> 値の典型的な使用を示しています:


<pre>if (field-&gt;flags &amp; NOT_NULL_FLAG)
    printf("Field can't be null\n");
</pre>

<code>flags</code> 値の真偽状態を調べるために、次の便利なマクロを使用でき
ます:

<table border="" width="100%" nosave="">
<tbody><tr><td><code>IS_NOT_NULL(flags)</code> </td><td> このフィールドが <code>NOT NULL</code> として定義されていれば真
</td></tr>
<tr><td><code>IS_PRI_KEY(flags)</code> </td><td> このフィールドがプライマリキーならば真
</td></tr>
<tr><td><code>IS_BLOB(flags)</code> </td><td> このフィールドが <code>BLOB</code> または <code>TEXT</code> ならば真 (非推奨; 代わりに <code>field-&gt;type</code> をテストして下さい)
</td></tr>
</tbody></table>

</dd><dt><code>unsigned int decimals</code>
</dt><dd>
数値フィールドの小数部桁数。
</dd></dl>



<h2><a name="C_API_function_overview" href="manual.ja_toc.html#C_API_function_overview">20.3  C API 関数概要</a></h2>

<p>
C API には次に一覧された関数が存在します。これらの関数は次の節でかな
り詳細に説明されています。
 「<a href="manual.ja_Clients.html#C_API_functions">20.4  C API 関数説明</a>」節参照。

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>mysql_affected_rows()</strong> </td><td>
最後の <code>UPDATE</code>, <code>DELETE</code>, <code>INSERT</code> クエリによって影響さ
れたレコード数を返します。

</td></tr>
<tr><td><strong>mysql_close()</strong> </td><td>
サーバ接続をクローズします。

</td></tr>
<tr><td><strong>mysql_connect()</strong> </td><td>
<strong>MySQL</strong> サーバに接続します。この関数は推奨されません; 代わりに
<code>mysql_real_connect()</code> を使用してください。

</td></tr>
<tr><td><strong>mysql_change_user()</strong> </td><td>
接続中ののユーザとデータベースを変更します。

</td></tr>
<tr><td><strong>mysql_create_db()</strong> </td><td>
データベースを生成します。この関数は推奨されません; 代わりに SQL コマン
ド <code>CREATE DATABASE</code> を使用してください。

</td></tr>
<tr><td><strong>mysql_data_seek()</strong> </td><td>
クエリ結果セット中の任意のレコードにシークします。

</td></tr>
<tr><td><strong>mysql_debug()</strong> </td><td>
与えられた文字列で <code>DBUG_PUSH</code> を行ないます。

</td></tr>
<tr><td><strong>mysql_drop_db()</strong> </td><td>
データベースを破棄します。この関数は推奨されません; 代わりに SQL コマン
ド <code>DROP DATABASE</code> を使用してください。

</td></tr>
<tr><td><strong>mysql_dump_debug_info()</strong> </td><td>
サーバに、デバッグ情報をログに書き出させます。

</td></tr>
<tr><td><strong>mysql_eof()</strong> </td><td>
結果セットの最後のレコードが読まれたかどうかを判定します。この関数は推奨されませ
ん; 代わりに <code>mysql_errno()</code> または <code>mysql_error()</code> を使用して下
さい。

</td></tr>
<tr><td><strong>mysql_errno()</strong> </td><td>
最後の <strong>MySQL</strong> 関数からのエラー番号を返します。

</td></tr>
<tr><td><strong>mysql_error()</strong> </td><td>
最後の <strong>MySQL</strong> 関数からのエラーメッセージを返します。

</td></tr>
<tr><td><strong>mysql_escape_string()</strong> </td><td>
SQL ステートメント内で使用するために文字列中の特殊文字をエスケープします。

</td></tr>
<tr><td><strong>mysql_fetch_field()</strong> </td><td>
テーブルの次のフィールドの型を返します。

</td></tr>
<tr><td><strong>mysql_fetch_field_direct()</strong> </td><td>
テーブルの、番号で指定されたフィールドの型を返します。

</td></tr>
<tr><td><strong>mysql_fetch_fields()</strong> </td><td>
全てのフィールド構造体の配列を返します。

</td></tr>
<tr><td><strong>mysql_fetch_lengths()</strong> </td><td>
現在のレコード中の全てのフィールドの長さを返します。

</td></tr>
<tr><td><strong>mysql_fetch_row()</strong> </td><td>
結果セットから次のレコードを取り出します。

</td></tr>
<tr><td><strong>mysql_field_seek()</strong> </td><td>
指定されたフィールド上にフィールドカーソルを置きます。

</td></tr>
<tr><td><strong>mysql_field_count()</strong> </td><td>
最後のクエリの結果のフィールドの数を返します。

</td></tr>
<tr><td><strong>mysql_field_tell()</strong> </td><td>
最後の <code>mysql_fetch_field()</code> で使用されたフィールドカーソルの位置を返
します。

</td></tr>
<tr><td><strong>mysql_free_result()</strong> </td><td>
結果セットによって使用されたメモリを解放します。

</td></tr>
<tr><td><strong>mysql_get_client_info()</strong> </td><td>
クライアントバージョン情報を返します。

</td></tr>
<tr><td><strong>mysql_get_host_info()</strong> </td><td>
接続を説明する文字列を返します。

</td></tr>
<tr><td><strong>mysql_get_proto_info()</strong> </td><td>
接続に使用されるプロトコルバージョンを返します。

</td></tr>
<tr><td><strong>mysql_get_server_info()</strong> </td><td>
サーバのバージョン番号を返します。

</td></tr>
<tr><td><strong>mysql_info()</strong> </td><td>
最後に実行されたクエリについての情報を返します。

</td></tr>
<tr><td><strong>mysql_init()</strong> </td><td>
<code>MYSQL</code> 構造体を獲得または初期化します。

</td></tr>
<tr><td><strong>mysql_insert_id()</strong> </td><td>
<code>AUTO_INCREMENT</code> フィールドに最後に生成された ID を返します。

</td></tr>
<tr><td><strong>mysql_kill()</strong> </td><td>
指定されたスレッドを殺します。

</td></tr>
<tr><td><strong>mysql_list_dbs()</strong> </td><td>
簡易正規表現に適合するデータベース名を返します。

</td></tr>
<tr><td><strong>mysql_list_fields()</strong> </td><td>
簡易正規表現に適合するフィールド名を返します。

</td></tr>
<tr><td><strong>mysql_list_processes()</strong> </td><td>
現在のサーバスレッドのリストを返します。

</td></tr>
<tr><td><strong>mysql_list_tables()</strong> </td><td>
簡易正規表現に適合するテーブル名を返します。

</td></tr>
<tr><td><strong>mysql_num_fields()</strong> </td><td>
結果セット中のフィールド数を返します。

</td></tr>
<tr><td><strong>mysql_num_rows()</strong> </td><td>
結果セット中のレコード数を返します。

</td></tr>
<tr><td><strong>mysql_options()</strong> </td><td>
<code>mysql_connect()</code> のための接続オプションを設定します。

</td></tr>
<tr><td><strong>mysql_ping()</strong> </td><td>
サーバへの接続が動作しているかどうかをチェックします。
必要であれば再接続します。

</td></tr>
<tr><td><strong>mysql_query()</strong> </td><td>
NULL 終端文字列として記述された SQL クエリを実行します。

</td></tr>
<tr><td><strong>mysql_real_connect()</strong> </td><td>
<strong>MySQL</strong> サーバに接続します。

</td></tr>
<tr><td><strong>mysql_real_query()</strong> </td><td>
数えられた文字列として記述された SQL クエリを実行します。

</td></tr>
<tr><td><strong>mysql_reload()</strong> </td><td>
権限テーブルを再読み込みするようにサーバに指示します。

</td></tr>
<tr><td><strong>mysql_row_seek()</strong> </td><td>
結果セット内のあるレコードへシークします。<code>mysql_row_tell()</code> から返される値を
使用します。

</td></tr>
<tr><td><strong>mysql_row_tell()</strong> </td><td>
レコードカーソルの位置を返します。

</td></tr>
<tr><td><strong>mysql_select_db()</strong> </td><td>
データベースに接続します。

</td></tr>
<tr><td><strong>mysql_shutdown()</strong> </td><td>
データベースサーバをシャットダウンします。

</td></tr>
<tr><td><strong>mysql_stat()</strong> </td><td>
文字列でサーバ状態を返します。

</td></tr>
<tr><td><strong>mysql_store_result()</strong> </td><td>
クライアントに完全な結果セットを取り出します。

</td></tr>
<tr><td><strong>mysql_thread_id()</strong> </td><td>
現在のスレッド ID を返します。

</td></tr>
<tr><td><strong>mysql_use_result()</strong> </td><td>
各レコードの動的結果セットを初期化します。
</td></tr>
</tbody></table>

<p>
サーバへ接続するには、接続ハンドラを初期化するために <code>mysql_init()</code> 
を呼びだし、それから <code>mysql_real_connect()</code> をそのハンドラで呼びだし
ます (ホスト名、ユーザ名、パスワードのような他の情報に加えて)。その接続で
の処理が終了した時は、接続を終了させるために <code>mysql_close()</code> を呼びだ
します。

</p>
<p>
接続が有効な間は、クライアントは <code>mysql_query()</code> または 
<code>mysql_real_query()</code> を使用して SQL クエリをサーバに送信できます。こ
の２つの違いは、<code>mysql_query()</code> は NULL終端文字列としてクエリが記述さ
れることを期待するのに対し、<code>mysql_real_query()</code> は数えられた文字列を
期待することです。文字列がバイナリデータ(NULバイトを含みことがある)を含む
場合は、<code>mysql_real_query()</code> を使用する必要があります。

</p>
<p>
非<code>SELECT</code> クエリ(例えば、<code>INSERT</code>, <code>UPDATE</code>,
<code>DELETE</code>)では、どれくらいのレコードが影響(変更)されたかを
<code>mysql_affected_rows()</code> を呼び出すことで見つけ出すことができます。

</p>
<p>
<code>SELECT</code> クエリでは、選択されたレコードを結果セットとして取り出します。
(注意: いくつかのステートメントは、レコードを返すという点で 
<code>SELECT</code>に似ています。それは <code>SHOW</code>, <code>DESCRIBE</code>,
<code>EXPLAIN</code> です。これらは <code>SELECT</code> ステートメントと同じ方法で扱わ
れるべきです。)

</p>
<p>
クライアントが結果セットを処理するには２つの方法があります。一つ目は、
<code>mysql_store_result()</code> を呼び出すことで、結果セット全体を一度にすべて
取り出すことです。この関数はサーバからクエリによって返されるすべてのレコー
ドを取得し、それをクライアントに格納します。二つ目は、
<code>mysql_use_result()</code> を呼び出すことで、レコードごとの結果セット取り出
しを初期化することです。この関数は取り出しを初期化しますが、実際にはサーバ
から何のレコードも得ません。

</p>
<p>
どちらの場合でも、<code>mysql_fetch_row()</code> を呼び出してレコードにアクセス
します。<code>mysql_store_result()</code> では、<code>mysql_fetch_row()</code> は既に
サーバから取得してあるレコードにアクセスします。
<code>mysql_use_result()</code> では、<code>mysql_fetch_row()</code> は実際にサーバか
らレコードを取り出します。各レコードのデータ値のサイズについての情報は 
<code>mysql_fetch_lengths()</code> を呼び出すことで得られます。

</p>
<p>
結果セットでの処理が終った後は、<code>mysql_free_result()</code> を呼び出し、そ
れが使用していたメモリを解放して下さい。

</p>
<p>
この２つの取り出し機構は相補的なものです。クライアントプログラムは、必要に
よってもっとも適切なアプローチを選択すべきです。慣例的に、クライアントは一
般に <code>mysql_store_result()</code> を使用する傾向にあります。

</p>
<p>
<code>mysql_store_result()</code> の利点は、すべてのレコードをクライアントに取っ
て来るため、連続してレコードをアクセスできるだけでなく、結果セット中の現在
のレコード位置を変更するために、<code>mysql_data_seek()</code> や 
<code>mysql_row_seek()</code> を使用して、結果セットの中を後や前に移動することが
できます。また、<code>mysql_num_rows()</code> を呼び出すことで、レコード数を見つ
けることもできます。一方、<code>mysql_store_result()</code> の必要メモリは、大き
な結果セットではとても高く、out-of-memory 状態に遭遇する可能性が高くなりま
す。

</p>
<p>
<code>mysql_use_result()</code> の利点は、一度に一つのレコードだけを保持するため、
クライアントが結果セットに要求するメモリが少ないことです（そして、割当のオー
バーヘッドも少ないので、<code>mysql_use_result()</code> はより速くなります）。不
利な点は、サーバの拘束を避けるため、各レコードを素早く処理する必要があるこ
と、結果セット中でレコードのランダムアクセスができないこと（レコードを順番
にアクセスすることしかできません）、そして、すべてのレコードを取り出さない
限り、結果セット中にいくつのレコードがあるかを知ることができないことです。
さらに、あなたが探している情報を、検索の途中で見つけることができて、問題が
解決したとしても、すべてのレコードを取り出さ<em>なければなりません</em>。

</p>
<p>
API はクライアントがクエリが <code>SELECT</code> であるかどうかを知ることなしに、
（必要時だけレコードを取り出す）クエリに適切に応答できるようにします。
それぞれの <code>mysql_query()</code>（または <code>mysql_real_query()</code>）の後で、
<code>mysql_store_result()</code> を呼び出すことで、これが可能です。結果セットの
呼び出しが成功すると、クエリは <code>SELECT</code> であり、レコードを読むことが
できます。結果セット呼び出しが失敗した場合は、結果が実際に期待されたもので
あるかどうかを確定するために、<code>mysql_field_count()</code> を呼び出してくだ
さい。<code>mysql_field_count()</code> が 0 を返す場合は、クエリはデータを返しま
せん（クエリが <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> 等であることを
示します）。つまりレコードが返ることを期待できません。
<code>mysql_field_count()</code> が 0 でない場合は、クエリはレコードを返すべきな
のに、返さなかったということです。これはクエリが <code>SELECT</code> で失敗した
ということを示します。これをどのように行なうことができるかの例は、
<code>mysql_field_count()</code> の説明を参照してください。

</p>
<p>
<code>mysql_store_result()</code> と <code>mysql_use_result()</code> はどちらも、結果
セットを作るフィールドについての情報（フィールドの数、その名前や型など）を
獲得することができます。<code>mysql_fetch_field()</code> を繰り返し呼び出すこと
で順番に、または、<code>mysql_fetch_field_direct()</code> を呼び出すことでレコー
ド内のフィールド番号で、レコード内のフィールド情報にアクセスすることができ
ます。現在のフィールドカーソル位置は <code>mysql_field_seek()</code> を呼び出す
ことで変更できます。フィールドカーソルの設定は、その後の 
<code>mysql_fetch_field()</code> 呼び出しに影響します。
<code>mysql_fetch_fields()</code> を呼び出すことで、一度にすべてのフィールドの情
報を得ることもできます。

</p>
<p>
エラーの検出、報告については、<code>mysql_errno()</code> と 
<code>mysql_error()</code> 関数の方法によって、<strong>MySQL</strong> はエラー情報へのア
クセスを提供します。これらは、最後に呼び出された成功または失敗し得る関数に
ついてのエラーコードとエラーメッセージを返し、エラーがいつ何で発生したかを
確定することができます。

</p>


<h2><a name="C_API_functions" href="manual.ja_toc.html#C_API_functions">20.4  C API 関数説明</a></h2>

<p>
以下の説明では、<code>NULL</code> の引数または戻り値は C プログラミング言語で
の <code>NULL</code> を意味します。<strong>MySQL</strong> <code>NULL</code> 値ではありません。
 
関数は通常ポインタか整数の値を返します。しかし関数説明に記述がある場合、
ポインタを返す関数は、成功を示すために非 <code>NULL</code> 値を返し、エラーを示すた
めに <code>NULL</code> を返します。整数を返す関数は、成功を示すために 0 を返し、
エラーを示すために非0を返します。``非0'' は関数説明が他に述べていない限
り、その意味になることに注意してください; 関数説明が他に述べている場合、
これらに対して 0 以外の固有の値をテストしないでください:

</p>

<pre>if (result)                   /* 正しい */
    ... error ...

if (result &lt; 0)               /* 間違い */
    ... error ...

if (result == -1)             /* 間違い */
    ... error ...
</pre>

<p>
関数がエラーを返すとき、関数説明の <strong>エラー</strong> 節が起り得るエラーの
種類を一覧しています。<code>mysql_errno()</code> の呼び出しによってどれが発生
したかを見つけ出すことができます。エラーを表現する文字列は 
<code>mysql_error()</code> の呼び出しによって得られます。

</p>
<p>
<a name="IDX723"></a>


</p><h3><a name="mysql_affected_rows" href="manual.ja_toc.html#mysql_affected_rows">20.4.1  <code>mysql_affected_rows()</code></a></h3>

<p>
<code>my_ulonglong mysql_affected_rows(MYSQL *mysql)</code>

</p>

<h4>20.4.1.1  説明</h4>

<p>
最後の <code>UPDATE</code>, <code>DELETE</code>, <code>INSERT</code> クエリによって影響さ
れた(変更された)行数を返します。<code>UPDATE</code>, <code>DELETE</code>, <code>INSERT</code> ステート
メントでの <code>mysql_query()</code> 直後に呼び出します。<code>SELECT</code> ステート
メントでは、これは <code>mysql_num_rows()</code> に似た動きをします。

</p>
<p>
<code>mysql_affected_rows()</code> は現在マクロとして実装されています。

</p>

<h4>20.4.1.2  戻り値</h4>

<p>
0 より大きい整数は影響された行数または取り出された行数を示します。クエリ
の <code>WHERE</code> 節に適合したレコードがない場合またはクエリがまだ実行され
ていない場合は 0 です。クエリがエラーを返したか、<code>SELECT</code> クエリに
ついて <code>mysql_store_result()</code> が呼ばれる前に
<code>mysql_affected_rows()</code> が呼ばれた場合は -1 です。

</p>

<h4>20.4.1.3  エラー</h4>

<p>
無し。

</p>

<h4>20.4.1.4  例</h4>


<pre>mysql_query(&amp;mysql,"UPDATE products SET cost=cost*1.25 WHERE group=10");
printf("%d products updated",mysql_affected_rows(&amp;mysql));
</pre>

<p>
<a name="IDX724"></a>


</p><h3><a name="mysql_close" href="manual.ja_toc.html#mysql_close">20.4.2  <code>mysql_close()</code></a></h3>

<p>
<code>void mysql_close(MYSQL *mysql)</code>

</p>

<h4>20.4.2.1  説明</h4>
<p>
前にオープンされた接続をクローズします。ハンドルが <code>mysql_init()</code> ま
たは <code>mysql_connect()</code> で自動的に割り当てられた場合、
<code>mysql_close()</code> は <code>mysql</code> で示される接続ハンドルの解放も行ない
ます。

</p>

<h4>20.4.2.2  戻り値</h4>

<p>
無し。

</p>

<h4>20.4.2.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。

</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。

</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。

</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX725"></a>


</p><h3><a name="mysql_connect" href="manual.ja_toc.html#mysql_connect">20.4.3  <code>mysql_connect()</code></a></h3>

<p>
<code>MYSQL *mysql_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd)</code>

</p>

<h4>20.4.3.1  説明</h4>

<p>
この関数は推奨されません。代わりに <code>mysql_real_connect()</code> の使用を
お勧めします。

</p>
<p>
<code>mysql_connect()</code> は <code>host</code> 上で動作している <strong>MySQL</strong> デー
タベースエンジンへの接続の確立を試みます。<code>mysql_get_client_info()</code> 
を除く他のすべての API 関数を実行する前に<code>mysql_connect()</code> が成功終了
している必要があります。

</p>
<p>
パラメータの意味は <code>mysql_connect()</code> の対応するパラメータと同じですが、
接続パラメータは <code>NULL</code> にできることが異なります。この場合 C API は接
続構造体に自動的にメモリを割り当て、<code>mysql_close()</code> 呼び出し時にそれ
を解放します。このアプローチの不利な点は接続が失敗した場合にエラーメッセー
ジを取り出すことができないことです。（<code>mysql_errno()</code> または 
<code>mysql_error()</code> からエラー情報を得るには、正しい <code>MYSQL</code> ポイン
タを提供する必要があります。）

</p>

<h4>20.4.3.2  戻り値</h4>

<p>
<code>mysql_real_connect()</code> と同じ

</p>

<h4>20.4.3.3  エラー</h4>

<p>
<code>mysql_real_connect()</code> と同じ

</p>
<p>
<a name="IDX726"></a>


</p><h3><a name="mysql_change_user" href="manual.ja_toc.html#mysql_change_user">20.4.4  <code>mysql_change_user()</code></a></h3>

<p>
<code>my_bool mysql_change_user(MYSQL *mysql, const char *user, const
char *password, const char *db)</code>

</p>

<h4>20.4.4.1  説明</h4>

<p>
ユーザを変更し、<code>mysql</code> で示された接続上で、<code>db</code> で示されたデー
タベースがデフォルト（現在の）データベースになります。その後のクエリでは、
明示的なデータベースの指定を含んでいないテーブル参照について、このデータベー
スがデフォルトになります。

</p>
<p>
この関数は <strong>MySQL</strong> 3.23.3 で導入されました。

</p>
<p>
<code>mysql_change_user()</code> は接続されたユーザが認証されない場合、またはデー
タベースを使用する権限を持っていない場合に失敗します。この場合、ユーザとデー
タベースは変更されません。

</p>
<p>
デフォルトデータベースを持ちたくない場合、<code>db</code> パラメータを 
<code>NULL</code> に設定できます。

</p>

<h4>20.4.4.2  戻り値</h4>

<p>
成功時 0。エラーが発生した場合は非0。

</p>

<h4>20.4.4.3  エラー</h4>

<p>
<code>mysql_real_connect()</code> から得られるものと同じです。

</p>
<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd><dt><code>ER_UNKNOWN_COM_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバはこのコマンドを実装していない（おそらく古いサーバ）。
</dd><dt><code>ER_ACCESS_DENIED_ERROR</code>
</dt><dd>
ユーザまたはパスワードが間違っている。
</dd><dt><code>ER_BAD_DB_ERROR</code>
</dt><dd>
データベースが存在しない。
</dd><dt><code>ER_DBACCESS_DENIED_ERROR</code>
</dt><dd>
ユーザがデータベースへのアクセス権を持っていない。
</dd><dt><code>ER_WRONG_DB_NAME</code>
</dt><dd>
データベース名が長過ぎる。
</dd></dl>


<h4>20.4.4.4  例</h4>


<pre>if (mysql_change_user(&amp;mysql, "user", "password", "new_database"))
{
   fprintf(stderr, "Failed to change user.  Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<p>
<a name="IDX727"></a>


</p><h3><a name="mysql_create_db" href="manual.ja_toc.html#mysql_create_db">20.4.5  <code>mysql_create_db()</code></a></h3>

<p>
<code>int mysql_create_db(MYSQL *mysql, const char *db)</code>

</p>

<h4>20.4.5.1  説明</h4>
<p>
<code>db</code> 引数によって指定されたデータベースを作成します。

</p>
<p>
この関数は推奨されません。代わりに <code>mysql_query()</code> を使って、SQL
<code>CREATE DATABASE</code> ステートメントを発行することをお勧めします。

</p>

<h4>20.4.5.2  戻り値</h4>

<p>
データベースの作成が成功した場合は0。エラーが発生した場合は非0。

</p>

<h4>20.4.5.3  エラー</h4>
<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。

</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。

</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。

</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>


<h4>20.4.5.4  例</h4>


<pre>if(mysql_create_db(&amp;mysql, "my_database"))
{
   fprintf(stderr, "Failed to create new database.  Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<p>
<a name="IDX728"></a>


</p><h3><a name="mysql_data_seek" href="manual.ja_toc.html#mysql_data_seek">20.4.6  <code>mysql_data_seek()</code></a></h3>

<p>
<code>void mysql_data_seek(MYSQL_RES *result, unsigned int offset)</code>

</p>

<h4>20.4.6.1  説明</h4>
<p>
クエリ結果セット中の任意のレコードにシークします。これは、結果セット構造体
がクエリのすべての結果を持っていることを要求します。そのため、
<code>mysql_data_seek()</code> は <code>mysql_store_result()</code> と共にだけ使用され、
<code>mysql_use_result()</code> と共には使用できません。

</p>
<p>
オフセットの値は <code>0</code> から <code>mysql_num_rows(result)-1</code> でなくては
なりません。

</p>

<h4>20.4.6.2  戻り値</h4>

<p>
無し。

</p>

<h4>20.4.6.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX729"></a>


</p><h3><a name="mysql_debug" href="manual.ja_toc.html#mysql_debug">20.4.7  <code>mysql_debug()</code></a></h3>

<p>
<code>void mysql_debug(char *debug)</code>

</p>

<h4>20.4.7.1  説明</h4>
<p>
与えられた文字列で <code>DBUG_PUSH</code> を行ないます。<code>mysql_debug()</code> 
はFred Fish debug library を使用します。この関数を使用するためには、デバッ
グをサポートするように、クライアントライブラリをコンパイルする必要があり
ます。
 「<a href="manual.ja_Porting.html#Debugging_server">G.1  MySQL server のデバッグ</a>」節参照.  「<a href="manual.ja_Porting.html#Debugging_client">G.2  Debugging a MySQL client</a>」節参照.

</p>

<h4>20.4.7.2  戻り値</h4>

<p>
無し。

</p>

<h4>20.4.7.3  エラー</h4>
<p>
無し。

</p>

<h4>20.4.7.4  例</h4>

<p>
次に示した呼び出しは、クライアントライブラリが、クライアントマシン上の 
<tt>`/tmp/client.trace'</tt> にトレースファイルを生成します:

</p>

<pre>mysql_debug("d:t:O,/tmp/client.trace");
</pre>

<p>
<a name="IDX730"></a>


</p><h3><a name="mysql_drop_db" href="manual.ja_toc.html#mysql_drop_db">20.4.8  <code>mysql_drop_db()</code></a></h3>

<p>
<code>int mysql_drop_db(MYSQL *mysql, const char *db)</code>

</p>

<h4>20.4.8.1  説明</h4>
<p>
<code>db</code> 引数によって指定されたデータベースを破棄します。

</p>
<p>
この関数は推奨されません。代わりに <code>mysql_query()</code> を使って、SQL
<code>DROP DATABASE</code> ステートメントを発行することをお勧めします。

</p>

<h4>20.4.8.2  戻り値</h4>

<p>
データベースの破棄が成功した場合は0。エラーが発生した場合は非0。

</p>

<h4>20.4.8.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>


<h4>20.4.8.4  例</h4>


<pre>if(mysql_drop_db(&amp;mysql, "my_database"))
  fprintf(stderr, "Failed to drop the database: Error: %s\n",
          mysql_error(&amp;mysql));
</pre>

<p>
<a name="IDX731"></a>


</p><h3><a name="mysql_dump_debug_info" href="manual.ja_toc.html#mysql_dump_debug_info">20.4.9  <code>mysql_dump_debug_info()</code></a></h3>

<p>
<code>int mysql_dump_debug_info(MYSQL *mysql)</code>

</p>

<h4>20.4.9.1  説明</h4>

<p>
いくつかのデバッグ情報をログにダンプするようにサーバに指示します。この動
作をするためには、接続されたユーザが <strong>process</strong> 権を持っていなけ
ればなりません。

</p>

<h4>20.4.9.2  戻り値</h4>

<p>
コマンドが成功した場合は0。コマンドが失敗した場合は非0。

</p>

<h4>20.4.9.3  エラー</h4>
<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX732"></a>


</p><h3><a name="mysql_eof" href="manual.ja_toc.html#mysql_eof">20.4.10  <code>mysql_eof()</code></a></h3>

<p>
<code>my_bool mysql_eof(MYSQL_RES *result)</code>

</p>

<h4>20.4.10.1  説明</h4>

<p>
この関数は推奨されません。<code>mysql_errno()</code> か <code>mysql_error()</code> が
代わりに使用できます。

</p>
<p>
<code>mysql_eof()</code> は結果セットの最後のレコードが読まれたかどうかを調べま
す。

</p>
<p>
<code>mysql_store_result()</code> の呼び出しが成功して、結果セットを入手した場合、
クライアントは一つのオペレーションですべてのセットを受け取ります。この場合、
<code>mysql_fetch_row()</code> から返される <code>NULL</code> は、常に結果セットの終端
に達したことを意味し、<code>mysql_eof()</code> を呼ぶ必要はありません。

</p>
<p>
一方、結果セット取り出しの初期化のために <code>mysql_use_result()</code> を使用
する場合、セットのレコードは <code>mysql_fetch_row()</code> を繰り返し呼ぶことに
より、ひとつずつサーバから獲得されます。この処理中に接続上でエラーが発生し
得るため、<code>mysql_fetch_row()</code> からの戻り値 <code>NULL</code> は、通常必ずし
も結果セットの終端に達したことを意味しません。この場合 
<code>mysql_eof()</code> を使用して、何が起こったかを検出できます。結果セットの
終端に達した場合は <code>mysql_eof()</code> は非0値を返し、エラーが発生した場合
は 0 を返します。

</p>
<p>
歴史的に <code>mysql_eof()</code> は標準 <strong>MySQL</strong> エラー関数 
<code>mysql_errno()</code> と <code>mysql_error()</code> 以前に遡ります。これらのエラー
関数は同じ情報を提供するので、これらの使用が <code>mysql_eof()</code> よりも好ま
れます。<code>mysql_eof()</code> は現在推奨されません。（実際、これらは多くの情
報を提供します。エラー関数はエラーが発生した時のエラーの理由を示しますが、
<code>mysql_eof()</code> は真偽値だけを返します。）

</p>

<h4>20.4.10.2  戻り値</h4>

<p>
エラーが発生した場合は0。結果セットの終端に達した場合は非0。

</p>

<h4>20.4.10.3  エラー</h4>
<p>
無し。

</p>

<h4>20.4.10.4  例</h4>

<p>
次の例は <code>mysql_eof</code> の使用方法を示します:

</p>

<pre>mysql_query(&amp;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&amp;mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(!mysql_eof(result))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
}
</pre>

<p>
しかし、標準 <strong>MySQL</strong> エラー関数で同じ効果を得ることができます:

</p>

<pre>mysql_query(&amp;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&amp;mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(mysql_errno(&amp;mysql))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
}
</pre>

<p>
<a name="IDX733"></a>


</p><h3><a name="mysql_errno" href="manual.ja_toc.html#mysql_errno">20.4.11  <code>mysql_errno()</code></a></h3>

<p>
<code>unsigned int mysql_errno(MYSQL *mysql)</code>

</p>

<h4>20.4.11.1  説明</h4>

<p>
<code>mysql</code> によって指定された接続上で、最後に呼び出された API 関数の成否のエラーコー
ドを返します。戻り値0はエラーが発生しなかったことを意味します。クライア
ントエラーメッセージ番号は <tt>`errmsg.h'</tt> にリストされています。サーバ
エラーメッセージ番号は <tt>`mysqld_error.h'</tt> にリストされています。

</p>

<h4>20.4.11.2  戻り値:</h4>

<p>
エラーコード値。エラーが発生していない場合は0。

</p>

<h4>20.4.11.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX734"></a>


</p><h3><a name="mysql_error" href="manual.ja_toc.html#mysql_error">20.4.12  <code>mysql_error()</code></a></h3>

<p>
<code>char *mysql_error(MYSQL *mysql)</code>

</p>

<h4>20.4.12.1  説明</h4>

<p>
<code>mysql</code> によって指定された接続上で、 <code>mysql_error()</code> は
最後に呼び出された API 関数の成否を、エラーメッセージとして返します。
エラー発生しなかった場合は空文字列 (<code>""</code>) が返されます。
これは次の２つのテストが同じであることを意味します:

</p>

<pre>if(mysql_errno(&amp;mysql))
{
    // an error occurred
}

if(mysql_error(&amp;mysql)[0] != '\0')
{
    // an error occurred
}
</pre>

<p>
クライアントエラーメッセージの言語は <strong>MySQL</strong> クラ
イアントライブラリの再コンパイルで変更できます。現在はいくつかの言語で書かれた
クライアントエラーメッセージを選択できます。
 「<a href="manual.ja_Server.html#Languages">9.1  <strong>MySQL</strong> がサポートしている言語は？</a>」節参照.

</p>

<h4>20.4.12.2  戻り値</h4>

<p>
エラーを表わす文字列。
エラーが発生していない場合は空文字列。

</p>

<h4>20.4.12.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX735"></a>


</p><h3><a name="mysql_escape_string" href="manual.ja_toc.html#mysql_escape_string">20.4.13  <code>mysql_escape_string()</code></a></h3>

<p>
<code>unsigned int mysql_escape_string(char *to, const char *from, unsigned int length)</code>

</p>

<h4>20.4.13.1  説明</h4>

<p>
<code>from</code> の文字列を、SQL ステートメントでサーバに送ることができるよう
にエスケープされた SQL 文字列に変換します。結果は <code>to</code> に入り、終端 
null 文字を追加します。
変換される文字列は <samp>`NUL'</samp> (ASCII 0), <samp>`\n'</samp>, <samp>`\r'</samp>, <samp>`\'</samp>,
<samp>`''</samp>, <samp>`"'</samp>, Control-Z です。( 「<a href="manual.ja_Reference.html#Literals">7.1  リテラル:文字列と数値をどのように書くか？</a>」節参照).

</p>
<p>
<code>from</code> で示される文字列
は<code>length</code> バイト長でなければなりません。
<code>to</code> バッファには少なくとも <code>length*2+1</code> バイト長を割り当てる
必要があります。（最悪の場合、それぞれの文字が２バイトに変換されることがあ
り、さらに終端 null バイトのための場所が必要です。）
<code>mysql_escape_string()</code> が復帰するとき、<code>to</code> 
の内容は <code>NUL</code> 終端文字列になります。
戻り値は変換された文字列の長さです。終端 null 文字は含みません。

</p>


<h4>20.4.13.2  例</h4>


<pre>char query[1000],*end;

end = strmov(query,"INSERT INTO test_table values(");
*end++ = '\'';
end += mysql_escape_string(end,"What's this",11);
*end++ = '\'';
*end++ = ',';
*end++ = '\'';
end += mysql_escape_string(end,"binary data: \0\r\n",16);
*end++ = '\'';
*end++ = ')';

if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query)))
{
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<p>
上記の <code>strmov()</code> 関数は <code>mysqlclient</code> ライブラリに含まれてい
て、<code>strcpy()</code> のように働きますが、最初の引数の終りの null へのポイ
ンタを返します。

</p>

<h4>20.4.13.3  戻り値</h4>

<p>
<code>to</code> へ置かれた値の長さ。終端 null 文字は含みません。

</p>

<h4>20.4.13.4  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX736"></a>


</p><h3><a name="mysql_fetch_field" href="manual.ja_toc.html#mysql_fetch_field">20.4.14  <code>mysql_fetch_field()</code></a></h3>

<p>
<code>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)</code>

</p>

<h4>20.4.14.1  説明</h4>

<p>
結果セットの一つのフィールドの定義を <code>MYSQL_FIELD</code> 構造体として返しま
す。結果セット内の全てのフィールドについて情報を取り出すには、この関数を繰
り返し呼んでください。<code>mysql_fetch_field()</code> はフィールドが残っていな
いと <code>NULL</code> を返します。

</p>
<p>
<code>mysql_fetch_field()</code> は、新しい <code>SELECT</code> クエリを実行するたびに、
最初のフィールドについての情報を返すようにリセットされます。
<code>mysql_fetch_field()</code> で返されるフィールドは 
<code>mysql_field_seek()</code> の呼び出しにも影響をうけます。

</p>
<p>
テーブルを <code>SELECT</code> するために <code>mysql_query()</code> を呼び、しかしま
だ <code>mysql_store_result()</code> を呼んでいない場合、
<code>mysql_fetch_field()</code> を <code>BLOB</code> フィールドの長さの問い合わせに使
用すると、<strong>MySQL</strong> はデフォルトの blob 長 (8K bytes) を返します。
(8K サイズになるのは、<strong>MySQL</strong> は <code>BLOB</code> の最大長を知らないから
です。これはいつかコンフィグ可能になるべきです。) 一度結果セットを取り出せ
ば、<code>field-&gt;max_length</code> は指定したクエリ内でのこのフィールドの最大値
の長さを含みます。

</p>

<h4>20.4.14.2  戻り値</h4>

<p>
現在のフィールドの <code>MYSQL_FIELD</code> 構造体。フィールドが残っていない場合は 
<code>NULL</code>。

</p>

<h4>20.4.14.3  エラー</h4>
<p>
無し。

</p>

<h4>20.4.14.4  例</h4>


<pre>MYSQL_FIELD *field;

while((field = mysql_fetch_field(result)))
{
    printf("field name %s\n", field-&gt;name);
}
</pre>

<p>
<a name="IDX737"></a>


</p><h3><a name="mysql_fetch_fields" href="manual.ja_toc.html#mysql_fetch_fields">20.4.15  <code>mysql_fetch_fields()</code></a></h3>

<p>
<code>MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)</code>

</p>

<h4>20.4.15.1  説明</h4>

<p>
結果セットのすべての <code>MYSQL_FIELD</code> 構造体の配列を返します。各構造体は
結果セットの一つのフィールドのフィールド定義を提供します。

</p>

<h4>20.4.15.2  戻り値</h4>

<p>
結果セットの全ての項目の <code>MYSQL_FIELD</code> 構造体の配列。

</p>

<h4>20.4.15.3  エラー</h4>
<p>
無し。

</p>

<h4>20.4.15.4  例</h4>


<pre>unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *fields;

num_fields = mysql_num_fields(result);
fields = mysql_fetch_fields(result);
for(i = 0; i &lt; num_fields; i++)
{
   printf("Field %u is %s\n", i, fields[i].name);
}
</pre>

<p>
<a name="IDX738"></a>


</p><h3><a name="mysql_fetch_field_direct" href="manual.ja_toc.html#mysql_fetch_field_direct">20.4.16  <code>mysql_fetch_field_direct()</code></a></h3>

<p>
<code>MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES *result, unsigned int fieldnr)</code>

</p>

<h4>20.4.16.1  説明</h4>

<p>
結果セット中のフィールドを示すフィールド番号 <code>fieldnr</code> が与えられ、そ
のフィールドのフィールド定義を <code>MYSQL_FIELD</code> 構造体として返します。こ
の関数は任意のフィールドについての定義を取り出すことに使用できます。
<code>fieldnr</code> の値は 0 から <code>mysql_num_fields(result)-1</code> の範囲にす
べきです。

</p>

<h4>20.4.16.2  戻り値</h4>

<p>
指定されたフィールドの <code>MYSQL_FIELD</code> 構造体。

</p>

<h4>20.4.16.3  エラー</h4>
<p>
無し。

</p>

<h4>20.4.16.4  例</h4>


<pre>unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *field;

num_fields = mysql_num_fields(result);
for(i = 0; i &lt; num_fields; i++)
{
    field = mysql_fetch_field_direct(result, i);
    printf("Field %u is %s\n", i, field-&gt;name);
}
</pre>

<p>
<a name="IDX739"></a>


</p><h3><a name="mysql_fetch_lengths" href="manual.ja_toc.html#mysql_fetch_lengths">20.4.17  <code>mysql_fetch_lengths()</code></a></h3>

<p>
<code>unsigned long *mysql_fetch_lengths(MYSQL_RES *result)</code>

</p>

<h4>20.4.17.1  説明</h4>

<p>
結果セット中の現在のレコードのフィールドの長さを返します。フィールドの値をコピーする場合、
この長さ情報は最適化にも有用です。<code>strlen()</code> の呼び出しを回避できる
ためです。
さらに、結果セットがバイナリデータを持つ場合は、データのサイズを特定するためにこの関数を<em>使わなければなりません</em>。
なぜなら <code>strlen()</code> は NULL 文字を含むフィールドについての結果を正しく返さないからです。

</p>
<p>
空フィールドの長さと <code>NULL</code> 値を含むフィールドの長さは 0 です。この２
つのケースを区別する方法については、<code>mysql_fetch_row()</code> の説明を参照
して下さい。

</p>

<h4>20.4.17.2  戻り値</h4>

<p>
各フィールドのサイズ (終端 NUL 文字は含みません)を提供する unsigned long 
整数の配列。
エラーが発生した場合は <code>NULL</code>。

</p>

<h4>20.4.17.3  エラー</h4>
<p>
<code>mysql_fetch_lengths()</code> は結果セットの現在のレコードについてだけ有効
です。<code>mysql_fetch_row()</code> を呼び出す前、または結果の全てのレコードを
取り出した後にこれを呼んだ場合、<code>NULL</code> が返されます。

</p>

<h4>20.4.17.4  例</h4>


<pre>MYSQL_ROW row;
unsigned long *lengths;
unsigned int num_fields;
unsigned int i;

row = mysql_fetch_row(result);
if (row)
{
    num_fields = mysql_num_fields(result);
    lengths = mysql_fetch_lengths(result);
    for(i = 0; i &lt; num_fields; i++)
    {
         printf("Column %u is %lu bytes in length.\n", i, lengths[i]);
    }
}
</pre>

<p>
<a name="IDX740"></a>


</p><h3><a name="mysql_fetch_row" href="manual.ja_toc.html#mysql_fetch_row">20.4.18  <code>mysql_fetch_row()</code></a></h3>

<p>
<code>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)</code>

</p>

<h4>20.4.18.1  説明</h4>

<p>
結果セットの次のレコードを取り出します。<code>mysql_store_result()</code> の後に使用すると、
これ以上取り出すレコードがない時は、<code>NULL</code> を返します。
<code>mysql_use_result()</code> の後に使用するなら、
これ以上取り出すレコードがない場合やエラーが発生した場合に <code>NULL</code> を返します。

</p>
<p>
レコード内の値の数は <code>mysql_num_fields(result)</code> によって与えられます。
<code>row</code> が <code>mysql_fetch_row()</code> の呼び出しからの戻り値を保持する場
合、値へのポインタは <code>row[0]</code> から 
<code>row[mysql_num_fields(result)-1</code> としてアクセスされます。レコード内の 
<code>NULL</code> 値は<code>NULL</code> ポインタによって示されます。

</p>
<p>
レコードのフィールド値の長さは、<code>mysql_fetch_lengths()</code> の呼び出しで
獲得できます。空フィールドと <code>NULL</code> を含むフィールドはどちらも長さ 
0 を持ちます; フィールド値のポインタをチェックすることで、これらを区別でき
ます。ポインタが <code>NULL</code> の場合、フィールドは <code>NULL</code> です; そうで
なければフィールドは空です。

</p>

<h4>20.4.18.2  戻り値</h4>

<p>
次のレコードの <code>MYSQL_ROW</code> 構造体、エラーが発生したか、もう取り出すレ
コードがない場合は <code>NULL</code>。

</p>

<h4>20.4.18.3  エラー</h4>

<dl compact="">

<dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>


<h4>20.4.18.4  例</h4>


<pre>MYSQL_ROW row;
unsigned int num_fields;
unsigned int i;

num_fields = mysql_num_fields(result);
while ((row = mysql_fetch_row(result)))
{
   unsigned long *lengths;
   lengths = mysql_fetch_lengths(result);
   for(i = 0; i &lt; num_fields; i++)
   {
       printf("[%.*s] ", (int) lengths[i], row[i] ? row[i] : "NULL");
   }
   printf("\n");
}
</pre>

<p>
<a name="IDX741"></a>


</p><h3><a name="mysql_field_count" href="manual.ja_toc.html#mysql_field_count">20.4.19  <code>mysql_field_count()</code></a></h3>

<p>
<code>unsigned int mysql_field_count(MYSQL *mysql)</code>

</p>
<p>
3.22.24 より前の <code>MySQL</code> バージョンを使用している場合、
<code>unsigned int mysql_num_fields(MYSQL *mysql)</code> を代わりに使用すべきで
す。

</p>

<h4>20.4.19.1  説明</h4>

<p>
接続上の最後のクエリのフィールド数を返します。

</p>
<p>
この関数は通常 <code>mysql_store_result()</code> が <code>NULL</code> を返した時（そし
てこのように結果セットポインタを持っていない時）に使用されます。この場合、
<code>mysql_store_result()</code> が空でない結果を提供すべきかどうかを調べるため
に、<code>mysql_field_count()</code> を呼び出すことができます。これは、クエリが 
<code>SELECT</code>（または <code>SELECT</code>に似た）ステートメントであるかを知るこ
と無しに、クライアントプログラムに、適切な行動をとらせることができます。下
に示される例は、これをどのように行なうことができるかを説明しています。

</p>
<p>
 「<a href="manual.ja_Clients.html#NULL_mysql_store_result">20.4.51  <code>mysql_query()</code> が成功を返した後、<code>mysql_store_result()</code> が <code>NULL</code> を返す時があるのは何故？</a>」節参照.

</p>

<h4>20.4.19.2  戻り値</h4>

<p>
結果セット中のフィールド番号を表す unsigned integer。

</p>

<h4>20.4.19.3  エラー</h4>
<p>
無し。

</p>

<h4>20.4.19.4  例</h4>


<pre>MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&amp;mysql,query_string))
{
    // error
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&amp;mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if(mysql_field_count(&amp;mysql) == 0)
        {
            // query does not return data
            // (it was not a SELECT)
            num_rows = mysql_affected_rows(&amp;mysql);
        }
        else // mysql_store_result() should have returned data
        {
            fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
        }
    }
}
</pre>

<p>
別の方法は、<code>mysql_field_count(&amp;mysql)</code> 呼び出しを 
<code>mysql_errno(&amp;mysql)</code> に置き換えることです。この場合、ステートメント
が <code>SELECT</code> かどうかを <code>mysql_field_count()</code> の値から推測するの
ではなく、直接 <code>mysql_store_result()</code> からのエラーをチェックします。

</p>
<p>
<a name="IDX742"></a>


</p><h3><a name="mysql_field_seek" href="manual.ja_toc.html#mysql_field_seek">20.4.20  <code>mysql_field_seek()</code></a></h3>

<p>
<code>MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET offset)</code>

</p>

<h4>20.4.20.1  説明</h4>

<p>
与えられたオフセットにフィールドカーソルを設定します。次の 
<code>mysql_fetch_field()</code> の呼び出しはそのオフセットに対応したフィールドを取
り出します。

</p>
<p>
レコードの最初にシークするには、0 の <code>offset</code> 値を渡してください。

</p>

<h4>20.4.20.2  戻り値</h4>

<p>
フィールドカーソルの前の値。

</p>

<h4>20.4.20.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX743"></a>


</p><h3><a name="mysql_field_tell" href="manual.ja_toc.html#mysql_field_tell">20.4.21  <code>mysql_field_tell()</code></a></h3>

<p>
<code>MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)</code>

</p>

<h4>20.4.21.1  説明</h4>

<p>
最後の <code>mysql_fetch_field()</code> に使用したフィールドカーソルの位置を返
します。この値は <code>mysql_field_seek()</code> への引数として使用できます。

</p>

<h4>20.4.21.2  戻り値</h4>

<p>
フィールドカーソルの現在のオフセット。

</p>

<h4>20.4.21.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX744"></a>


</p><h3><a name="mysql_free_result" href="manual.ja_toc.html#mysql_free_result">20.4.22  <code>mysql_free_result()</code></a></h3>

<p>
<code>void mysql_free_result(MYSQL_RES *result)</code>

</p>

<h4>20.4.22.1  説明</h4>

<p>
<code>mysql_store_result()</code>, <code>mysql_use_result()</code>,
<code>mysql_list_dbs()</code> 等によって結果セットに割り当てられたメモリを解放
します。結果セットで何かを行なった時、<code>mysql_free_result()</code> を呼び
出してそれが使用したメモリを解放する必要があります。

</p>

<h4>20.4.22.2  戻り値</h4>

<p>
無し。

</p>

<h4>20.4.22.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX745"></a>


</p><h3><a name="mysql_get_client_info" href="manual.ja_toc.html#mysql_get_client_info">20.4.23  <code>mysql_get_client_info()</code></a></h3>

<p>
<code>char *mysql_get_client_info(void)</code>

</p>

<h4>20.4.23.1  説明</h4>

<p>
クライアントライブラリバージョンを表わす文字列を返します。

</p>

<h4>20.4.23.2  戻り値</h4>

<p>
<strong>MySQL</strong> クライアントライブラリバージョンを表わす文字列。

</p>

<h4>20.4.23.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX746"></a>


</p><h3><a name="mysql_get_host_info" href="manual.ja_toc.html#mysql_get_host_info">20.4.24  <code>mysql_get_host_info()</code></a></h3>

<p>
<code>char *mysql_get_host_info(MYSQL *mysql)</code>

</p>

<h4>20.4.24.1  説明</h4>

<p>
使用中の接続タイプを表わす文字列を返します。サーバのホスト名を含みます。

</p>

<h4>20.4.24.2  戻り値</h4>

<p>
サーバホスト名と接続タイプを表わす文字列。

</p>

<h4>20.4.24.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX747"></a>


</p><h3><a name="mysql_get_proto_info" href="manual.ja_toc.html#mysql_get_proto_info">20.4.25  <code>mysql_get_proto_info()</code></a></h3>

<p>
<code>unsigned int mysql_get_proto_info(MYSQL *mysql)</code>

</p>

<h4>20.4.25.1  説明</h4>

<p>
現在の接続に使用されているプロトコルバージョンを返します。

</p>

<h4>20.4.25.2  Return values</h4>

<p>
現在の接続に使用されているプロトコルバージョンを表わす符号無し整数値。

</p>

<h4>20.4.25.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX748"></a>


</p><h3><a name="mysql_get_server_info" href="manual.ja_toc.html#mysql_get_server_info">20.4.26  <code>mysql_get_server_info()</code></a></h3>

<p>
<code>char *mysql_get_server_info(MYSQL *mysql)</code>

</p>

<h4>20.4.26.1  説明</h4>

<p>
サーバのバージョン番号を表わす文字列を返します。

</p>

<h4>20.4.26.2  戻り値</h4>

<p>
サーバのバージョン番号を表わす文字列。

</p>

<h4>20.4.26.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX749"></a>


</p><h3><a name="mysql_info" href="manual.ja_toc.html#mysql_info">20.4.27  <code>mysql_info()</code></a></h3>

<p>
<code>char * mysql_info(MYSQL *mysql)</code>

</p>

<h4>20.4.27.1  説明</h4>

<p>
最も最近に実行されたクエリについての情報を文字列で返します。が、
以下に挙げる構文に限ります。
他の構文では<code>mysql_info()</code> は <code>NULL</code> を返します。
文字列の形式
はクエリの型によって様々です。次に説明します (数値は例です; 文字列はクエ
リに適した値を含みます):

</p>
<dl compact="">

<dt><code>INSERT INTO ... SELECT ...</code>
</dt><dd>
String format: <code>Records: 100 Duplicates: 0 Warnings: 0</code>
</dd><dt><code>INSERT INTO ... VALUES (...),(...),(...)...</code>
</dt><dd>
String format: <code>Records: 3  Duplicates: 0  Warnings: 0</code>
</dd><dt><code>LOAD DATA INFILE ...</code>
</dt><dd>
String format: <code>Records: 1 Deleted: 0 Skipped: 0 Warnings: 0</code>
</dd><dt><code>ALTER TABLE</code>
</dt><dd>
String format: <code>Records: 3 Duplicates: 0 Warnings: 0</code>
</dd><dt><code>UPDATE</code>
</dt><dd>
String format: <code>Rows matched: 40 Changed: 40 Warnings: 0</code>
</dd></dl>

<p>
注意: 複数の値リストがステートメント中に記述された場合にだけ、
<code>mysql_info()</code> は、<code>INSERT ... VALUES</code> ステートメントに非
<code>NULL</code>値を返します。

</p>

<h4>20.4.27.2  戻り値</h4>

<p>
最も最近に実行されたクエリについての追加情報を表わす文字列。クエリに有効
な情報がない場合は <code>NULL</code> ポインタ。

</p>

<h4>20.4.27.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX750"></a>


</p><h3><a name="mysql_init" href="manual.ja_toc.html#mysql_init">20.4.28  <code>mysql_init()</code></a></h3>

<p>
<code>MYSQL * mysql_init(MYSQL *mysql)</code>

</p>

<h4>20.4.28.1  説明</h4>

<p>
<code>mysql_real_connect()</code> に適した <code>MYSQL</code> オブジェクトの割り当て
または初期化を行ないます。引数が <code>NULL</code> ポインタの場合、関数は新し
いオブジェクトを割り当てて初期化し返します。そうでなければオブジェクトは
初期化され、オブジェクトのアドレスが返されます。新しいオブジェクトが割り
当てられた場合、<code>mysql_close()</code> はこのオブジェクトを解放します。

</p>

<h4>20.4.28.2  戻り値</h4>

<p>
初期化された <code>MYSQL*</code> ハンドル、または新しいオブジェクトを割り当て
るのに十分なメモリがなかった場合は <code>NULL</code> ポインタ。

</p>

<h4>20.4.28.3  エラー</h4>
<p>
メモリ不足の場合は <code>NULL</code> が返されます。

</p>
<p>
<a name="IDX751"></a>


</p><h3><a name="mysql_insert_id" href="manual.ja_toc.html#mysql_insert_id">20.4.29  <code>mysql_insert_id()</code></a></h3>

<p>
<code>my_ulonglong mysql_insert_id(MYSQL *mysql)</code>

</p>

<h4>20.4.29.1  説明</h4>

<p>
前のクエリによって <code>AUTO_INCREMENT</code> フィールドに生成された ID を返します。
<code>AUTO_INCREMENT</code> フィールドを含むテーブルに <code>INSERT</code> クエリを
実行した後で、この関数を使用してください。

</p>
<p>
注意: 前のクエリが <code>AUTO_INCREMENT</code> 値を生成しなかった場合、
<code>mysql_insert_id()</code> は <code>0</code> を返します。後のために値を保存する必
要がある場合、値を生成するクエリの直後に <code>mysql_insert_id()</code> を呼び出
すことに気をつけてください。

</p>
<p>
また、SQL <code>LAST_INSERT_ID()</code> 常に最後に生成された 
<code>AUTO_INCREMENT</code> 値を含み、クエリ間でリセットされないことに注意して下
さい。その関数の値はサーバ内で保守されるからです。

</p>

<h4>20.4.29.2  戻り値</h4>

<p>
前のクエリによって更新された <code>AUTO_INCREMENT</code> フィールドの値。接続上
の前のクエリがない場合、クエリが <code>AUTO_INCREMENT</code> 値を更新しなかった
場合には 0 が返ります。

</p>

<h4>20.4.29.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX752"></a>


</p><h3><a name="mysql_kill" href="manual.ja_toc.html#mysql_kill">20.4.30  <code>mysql_kill()</code></a></h3>

<p>
<code>int mysql_kill(MYSQL *mysql, unsigned long pid)</code>

</p>

<h4>20.4.30.1  説明</h4>

<p>
<code>pid</code> で指定されたスレッドを殺すようにサーバに頼みます。

</p>

<h4>20.4.30.2  戻り値</h4>

<p>
成功時0。失敗時非0。

</p>

<h4>20.4.30.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX753"></a>


</p><h3><a name="mysql_list_dbs" href="manual.ja_toc.html#mysql_list_dbs">20.4.31  <code>mysql_list_dbs()</code></a></h3>

<p>
<code>MYSQL_RES *mysql_list_dbs(MYSQL *mysql, const char *wild)</code>

</p>

<h4>20.4.31.1  説明</h4>

<p>
サーバ上の、<code>wild</code> 引数で指定された簡易正規表現に適合する、データベー
ス名からなる結果セットを返します。<code>wild</code> はワイルドカード文字 
<samp>`%'</samp> または <samp>`_'</samp> を含むことができます。また、全てのデータベース
に適合するように <code>NULL</code> ポインタにできます。<code>mysql_list_dbs()</code> 
の呼び出しはクエリ <code>SHOW databases [LIKE wild]</code> を実行するのと同様
です。

</p>
<p>
<code>mysql_free_result()</code> で結果セットを解放する必要があります。

</p>

<h4>20.4.31.2  戻り値</h4>

<p>
成功時 <code>MYSQL_RES</code> 結果セット。失敗した場合は <code>NULL</code>。

</p>

<h4>20.4.31.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_OUT_OF_MEMORY</code>
</dt><dd>
メモリ不足。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX754"></a>


</p><h3><a name="mysql_list_fields" href="manual.ja_toc.html#mysql_list_fields">20.4.32  <code>mysql_list_fields()</code></a></h3>

<p>
<code>MYSQL_RES *mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)</code>

</p>

<h4>20.4.32.1  説明</h4>

<p>
与えられたテーブル内の、<code>wild</code> 引数で指定された簡易正規表現に適合する
フィールド名からなる結果セットを返します。<code>wild</code> はワイルドカー
ド文字 <samp>`%'</samp> または <samp>`_'</samp> を含むことができます。また、全てのフィー
ルドに適合するように <code>NULL</code> ポインタにできます。
<code>mysql_list_fields()</code> はクエリ <code>SHOW COLUMNS FROM table [LIKE
wild]</code> を実行するのと同様です。

</p>
<p>
注意: <code>mysql_list_fields()</code> の代わりに <code>SHOW COLUMNS FROM
tbl_name</code> の使用を勧めます。

</p>
<p>
<code>mysql_free_result()</code> で結果セットを解放する必要があります。

</p>

<h4>20.4.32.2  戻り値</h4>

<p>
成功時 <code>MYSQL_RES</code> 結果セット。エラーが発生した場合は <code>NULL</code>。

</p>

<h4>20.4.32.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX755"></a>


</p><h3><a name="mysql_list_processes" href="manual.ja_toc.html#mysql_list_processes">20.4.33  <code>mysql_list_processes()</code></a></h3>

<p>
<code>MYSQL_RES *mysql_list_processes(MYSQL *mysql)</code>

</p>

<h4>20.4.33.1  説明</h4>

<p>
現在のサーバスレッドを示す結果セットを返します。これは <code>mysqladmin
processlist</code> や <code>SHOW PROCESSLIST</code> クエリで
報告されるものと同じ種類の情報です。

</p>
<p>
<code>mysql_free_result()</code> で結果セットを解放する必要があります。

</p>

<h4>20.4.33.2  戻り値</h4>

<p>
成功時 <code>MYSQL_RES</code> 結果セット。失敗した場合は <code>NULL</code>。

</p>

<h4>20.4.33.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX756"></a>


</p><h3><a name="mysql_list_tables" href="manual.ja_toc.html#mysql_list_tables">20.4.34  <code>mysql_list_tables()</code></a></h3>

<p>
<code>MYSQL_RES *mysql_list_tables(MYSQL *mysql, const char *wild)</code>

</p>

<h4>20.4.34.1  説明</h4>

<p>
<code>wild</code> 引数で指定された簡易正規表現に適合する、現在のデータベース
内のテーブル名からなる結果セットを返します。<code>wild</code> はワイルドカード
文字 <samp>`%'</samp> または <samp>`_'</samp> を含むことができます。また、全てのテーブル
に適合するように <code>NULL</code> ポインタにできます。
<code>mysql_list_tables()</code> はクエリ <code>SHOW tables [LIKE wild]</code> を実
行するのと同様です。

</p>
<p>
<code>mysql_free_result()</code> で結果セットを解放する必要があります。

</p>

<h4>20.4.34.2  戻り値</h4>

<p>
成功時 <code>MYSQL_RES</code> 結果セット。失敗した場合は <code>NULL</code>。

</p>

<h4>20.4.34.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX757"></a>
<a name="IDX758"></a>


</p><h3><a name="mysql_num_fields" href="manual.ja_toc.html#mysql_num_fields">20.4.35  <code>mysql_num_fields()</code></a></h3>

<p>
<code>unsigned int mysql_num_fields(MYSQL_RES *result)</code>

</p>
<p>
または

</p>
<p>
<code>unsigned int mysql_num_fields(MYSQL *mysql)</code>

</p>
<p>
二番目の形式は <strong>MySQL</strong> 3.23 以上では動作しません。<code>MYSQL*</code> 引
数を通す場合は、代わりに <code>unsigned int mysql_field_count(MYSQL*mysql)</code>
を使用しなくてはいけません。

</p>

<h4>20.4.35.1  説明</h4>

<p>
結果セット中のフィールド数を返します。

</p>
<p>
注意: 結果セットへのポインタまたは接続ハンドルのいずれかからフィールドの数
を得ることができます。<code>mysql_store_result()</code> または 
<code>mysql_user_result()</code> が <code>NULL</code> を返した（つまり結果セットポイン
タが無い）場合、接続ハンドルを使用します。この場合、
<code>mysql_field_count()</code> を呼び出して、<code>mysql_store_result()</code> が空
でない結果を提供すべきかどうかを決定できます。これにより、クライアントプロ
グラムはクエリが <code>SELECT</code>（または <code>SELECT</code> に似た）ステートメン
トだったかどうかを知ることなしに、適切な行動を取ることができます。以下に示
す例はこれをどのように行なうかを説明しています。

</p>
<p>
 「<a href="manual.ja_Clients.html#NULL_mysql_store_result">20.4.51  <code>mysql_query()</code> が成功を返した後、<code>mysql_store_result()</code> が <code>NULL</code> を返す時があるのは何故？</a>」節参照.

</p>

<h4>20.4.35.2  戻り値</h4>

<p>
結果セット中のフィールド数を表わす符号無し整数。

</p>

<h4>20.4.35.3  エラー</h4>
<p>
無し。

</p>

<h4>20.4.35.4  例</h4>


<pre>MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&amp;mysql,query_string))
{
    // error
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&amp;mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if (mysql_errno(&amp;mysql))
	{
           fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
	}
        else if (mysql_field_count(&amp;mysql) == 0)
        {
            // query does not return data
            // (it was not a SELECT)
            num_rows = mysql_affected_rows(&amp;mysql);
        }
    }
}
</pre>

<p>
（結果セットが返るべきクエリであることを知っている場合の）方法は、
<code>mysql_errno(&amp;mysql)</code> コールを <code>mysql_field_count(&amp;mysql)</code> が 
0 かどうかのチェックに置き換えることです。これは何かが悪い場合にだけ起こり
ます。

</p>
<p>
<a name="IDX759"></a>


</p><h3><a name="mysql_num_rows" href="manual.ja_toc.html#mysql_num_rows">20.4.36  <code>mysql_num_rows()</code></a></h3>

<p>
<code>my_ulonglong mysql_num_rows(MYSQL_RES *result)</code>

</p>

<h4>20.4.36.1  説明</h4>

<p>
結果セット中のレコード数を返します。

</p>
<p>
<code>mysql_num_rows()</code> の使用は、結果セットを返すのに 
<code>mysql_store_result()</code> か <code>mysql_use_result()</code> のどちらを使用す
るかに依存します。<code>mysql_store_result()</code> を使用する場合、
<code>mysql_num_rows()</code> はすぐに呼ぶことができます。
<code>mysql_use_result()</code> を使用する場合、結果セットの全てのレコードが取り
出されるまで、<code>mysql_num_rows()</code> は正しい値を返しません。

</p>

<h4>20.4.36.2  戻り値</h4>

<p>
結果セットのレコード数。

</p>

<h4>20.4.36.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX760"></a>


</p><h3><a name="mysql_options" href="manual.ja_toc.html#mysql_options">20.4.37  <code>mysql_options()</code></a></h3>

<p>
<code>int mysql_options(MYSQL *mysql, enum mysql_option option, const char *arg)</code>

</p>

<h4>20.4.37.1  説明</h4>

<p>
特別な接続オプションを設定し、接続の振舞いに影響を与えるために使用できます。
この関数は複数のオプションを設定するために複数回呼ぶことができます。

</p>
<p>
<code>mysql_options()</code> は <code>mysql_init()</code> の後で、
<code>mysql_connect()</code> や <code>mysql_real_connect()</code> の前に呼ばれなければ
なりません。

</p>
<p>
<code>option</code> 引数は設定したいオプションです; <code>arg</code> 引数はオプション
に対する値です。オプションが整数の場合、<code>arg</code> は整数値へのポインタで
す。

</p>
<p>
有効なオプション値:

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>オプション</strong> </td><td> <strong>引数型</strong> </td><td> <strong>機能</strong>
</td></tr>
<tr><td><code>MYSQL_OPT_CONNECT_TIMEOUT</code> </td><td> <code>unsigned int *</code> </td><td> 接続タイムアウト（秒）。
</td></tr>
<tr><td><code>MYSQL_OPT_COMPRESS</code> </td><td> 使用しない </td><td> 圧縮クライアント／サーバプロトコルを使用する。
</td></tr>
<tr><td><code>MYSQL_OPT_NAMED_PIPE</code> </td><td> 使用しない </td><td> NT 上の <strong>MySQL</strong> サーバへの接続に名前付パイプを使用する。
</td></tr>
<tr><td><code>MYSQL_INIT_COMMAND</code> </td><td> <code>char *</code> </td><td> <strong>MySQL</strong> サーバへの接続時に実行するコマンド。再接続時に自動的に再実行される。
</td></tr>
<tr><td><code>MYSQL_READ_DEFAULT_FILE</code> </td><td> <code>char *</code> </td><td> <tt>`my.cnf'</tt> の代わりに指定されたオプションファイルからオプションを読み込む。
</td></tr>
<tr><td><code>MYSQL_READ_DEFAULT_GROUP</code> </td><td> <code>char *</code> </td><td> <tt>`my.cnf'</tt> または <code>MYSQL_READ_DEFAULT_FILE</code> で指定されたファイルから指定されたグループのオプションを読み込む。
</td></tr>
</tbody></table>

<p>
注意: <code>MYSQL_READ_DEFAULT_FILE</code> と <code>MYSQL_READ_DEFAULT_GROUP</code> を
使用する場合、<code>client</code> グループが常に読まれます。

</p>
<p>
オプションファイル中に指定されるグループは次のオプションを含むことができま
す:

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><code>compress</code> </td><td> 圧縮クライアント／サーバプロトコルを使用する。
</td></tr>
<tr><td><code>database</code> </td><td> 接続命令中でデータベースが指定されない場合、このデータベースに接続する。
</td></tr>
<tr><td><code>debug</code> </td><td> デバッグオプション
</td></tr>
<tr><td><code>host</code> </td><td> デフォルトホスト名
</td></tr>
<tr><td><code>init-command</code> </td><td> <strong>MySQL</strong> サーバへの接続時に実行するコマンド。再接続時に自動的に再実行される。
</td></tr>
<tr><td><code>password</code> </td><td> デフォルトパスワード
</td></tr>
<tr><td><code>pipe</code> </td><td> NT 上の <strong>MySQL</strong> サーバへの接続に名前付パイプを使用する。
</td></tr>
<tr><td><code>port</code> </td><td> デフォルトポート番号
</td></tr>
<tr><td><code>return-found-rows</code> </td><td> <code>UPDATE</code> 使用時、<code>mysql_info()</code> が更新された行の代わりに見つかった行を返すようにする。
</td></tr>
<tr><td><code>socket</code> </td><td> デフォルトソケット番号
</td></tr>
<tr><td><code>timeout</code> </td><td> 接続タイムアウト（秒）。
</td></tr>
<tr><td><code>user</code> </td><td> デフォルトユーザ
</td></tr>
</tbody></table>

<p>
オプションファイルについてのさらなる情報は、 「<a href="manual.ja_Installing.html#Option_files">4.15.4  オプションファイル ( <code>my.cnf</code> )</a>」節 を参照して
下さい。

</p>

<h4>20.4.37.2  戻り値</h4>

<p>
成功の場合は0。未知のオプションを使用した場合は非0。

</p>

<h4>20.4.37.3  例</h4>


<pre>MYSQL mysql;

mysql_init(&amp;mysql);
mysql_options(&amp;mysql,MYSQL_OPT_COMPRESS,0);
mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,"odbc");
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&amp;mysql));
}
</pre>

<p>
上記は、圧縮クライアント／サーバプロトコルを使用し、<code>my.cnf</code> ファイル
中の <code>odbc</code> セクションから追加オプションを読むように、クライアントに
要求します。

</p>
<p>
<a name="IDX761"></a>


</p><h3><a name="mysql_ping" href="manual.ja_toc.html#mysql_ping">20.4.38  <code>mysql_ping()</code></a></h3>

<p>
<code>int mysql_ping(MYSQL *mysql)</code>

</p>

<h4>20.4.38.1  説明</h4>

<p>
サーバへの接続が動作しているかどうかをチェックします。ダウンしている場合
は、自動的に再接続を試みます。

</p>
<p>
この関数は、長い間静かにしているクライアントが、サーバが接続をクローズし
たかどうかをチェック（と再接続）するために使用できます。

</p>

<h4>20.4.38.2  戻り値</h4>

<p>
サーバが生きている場合0。他の値はエラーを示します。

</p>

<h4>20.4.38.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX762"></a>


</p><h3><a name="mysql_query" href="manual.ja_toc.html#mysql_query">20.4.39  <code>mysql_query()</code></a></h3>

<p>
<code>int mysql_query(MYSQL *mysql, const char *query)</code>

</p>

<h4>20.4.39.1  説明</h4>
<p>
NULL 終端文字列 <code>query</code> で示される SQL クエリを実行します。クエリはひ
とつの SQL ステートメントでなければなりません。終端のセミコロン
(<samp>`;'</samp>)や <code>\g</code> をステートメントに追加すべきではありません。

</p>
<p>
<code>mysql_query()</code> はバイナリデータを含むクエリには使用できません（バ
イナリデータは <samp>`\0'</samp> 文字を含むことがあります。これはクエリ文字列の
最後として解釈されます）。この場合、<code>mysql_real_query()</code> を代わりに
使用してください。

</p>

<h4>20.4.39.2  戻り値</h4>

<p>
クエリが成功した場合は0。クエリが失敗した場合は非0。

</p>

<h4>20.4.39.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX763"></a>


</p><h3><a name="mysql_real_connect" href="manual.ja_toc.html#mysql_real_connect">20.4.40  <code>mysql_real_connect()</code></a></h3>

<p>
<code>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host,
                          const char *user, const char *passwd, const char *db,
                          unsigned int port, const char *unix_socket,
                          unsigned int client_flag)</code>

</p>

<h4>20.4.40.1  説明</h4>

<p>
<code>host</code> 上で動作している <strong>MySQL</strong> データベースエンジンへの接続
の確立を試みます。
<code>mysql_get_client_info()</code> 以外の他の API 関数を実行する前に、
<code>mysql_real_connect()</code> が成功している必要があります。

</p>
<p>
<code>mysql_real_connect()</code> を呼び出す前に、<code>MYSQL</code> 構造体を獲得ま
たは初期化するために <code>mysql_init()</code> を呼ぶ必要があることに注意して
ください。

</p>

<ul>
<li>

最初のパラメータは既存の <code>MYSQL</code> 構造体のアドレスです。
<code>mysql_real_connect()</code> を呼ぶ前に、<code>MYSQL</code> 構造体の初期化のため
に <code>mysql_init()</code> を呼ぶ必要があります。後述の例を参照してください。

</li><li>

<code>host</code> の値はホスト名か IP アドレスのどちらでも可能です。
<code>host</code> が <code>NULL</code> または文字列 <code>"localhost"</code> の場合はロー
カルホストへの接続とみなされます。OS がソケットをサポートする場合(Unix)
または名前つきパイプをサポートする場合(Win32)、サーバへの TCP/IP 接続の
代わりに使用されます。

</li><li>

<code>user</code> パラメータはユーザの <strong>MySQL</strong> ログイン ID が入っています。
<code>user</code> が <code>NULL</code> の場合、現在のユーザとみなされます。Windows
ODBC 下では、現在のユーザは明示的に指定されなければなりません。Unix 下で
は現在のログイン名が適用されます。
Windows ODBC では, カレントのユーザー名を与えなければなりません。
 「<a href="manual.ja_ODBC.html#ODBC_administrator">16.4  ODBC 管理プログラムの各種項目を埋めるには？</a>」節参照.

</li><li>

<code>passwd</code> パラメータは <code>user</code> のパスワードが入っています。
もし <code>passwd</code> が <code>NULL</code> の場合、空白のパスワードフィールドを持つ 
<code>user</code> テーブル内のレコードだけが適合チェックされます。このような方
法で、パスワードが記述されたかどうかによってユーザが異なる特権を得るよう
に、データベース管理者が <strong>MySQL</strong> 特権システムを設定することができ
ます。

注意: <code>mysql_connect()</code> を呼び出す前に <code>passwd</code> を暗号化しない
でください。パスワードの暗号化はクライアント API で自動的に処理されます。

</li><li>

<code>db</code> が <code>NULL</code> でない場合、接続はこの値をデフォルトデータベー
スにセットします。

</li><li>

<code>port</code> が 0 でない場合、値は TCP/IP 接続のポート番号として使用され
ます。<code>host</code> パラメータが接続のタイプを決定することに注意してくださ
い。

</li><li>

<code>unix_socket</code> が <code>NULL</code> でない場合、文字列は使用されるソケット
または名前つきパイプを記述します。<code>host</code> パラメータが接続のタイプを
決定することに注意してください。

</li><li>

client_flag の値は通常 0 ですが、とても特殊な状況のため次のフラグの組み
合わせを設定できます:

<table border="" width="100%" nosave="">
<tbody><tr><td><strong>フラグ名</strong> </td><td> <strong>フラグの意味</strong>
</td></tr>
<tr><td><code>CLIENT_FOUND_ROWS</code> </td><td> 影響された行数ではなく見つかった行数を返します
</td></tr>
<tr><td><code>CLIENT_NO_SCHEMA</code> </td><td> <code>db_name.tbl_name.col_name</code> を許しません。これは ODBC のためです; その構文を使用した場合、パーサがエラーを生成します。これはいくつかの ODBC プログラムのバグのトラップに役立ちます。
</td></tr>
<tr><td><code>CLIENT_COMPRESS</code> </td><td> 圧縮プロトコルを使用します
</td></tr>
<tr><td><code>CLIENT_ODBC</code> </td><td> クライアントが ODBC クライアント。これは <code>mysqld</code> をさらに ODBC-フレンドリに変更します。
</td></tr>
</tbody></table>
</li></ul>

<p>
<code>mysql_real_connect()</code> の最初の引数に <code>NULL</code> ポインタを記述す
ることもできます。これは C API が接続構造体のメモリを割り当て、
<code>mysql_close()</code> 呼び出し時に自動的に解放されます。この方法の不利な
点は、接続が失敗した場合に <code>mysql_real_connect()</code> からのエラーメッ
セージを取り出すことができないことです。

</p>
<p>
最初の引数が <code>NULL</code> ポインタでない場合は、存在する <code>MYSQL</code> 構
造体のアドレスであるべきです。

</p>

<h4>20.4.40.2  戻り値</h4>

<p>
接続が成功した場合は <code>MYSQL*</code> 接続ハンドルです。接続が失敗した場合
は C <code>NULL</code> ポインタです。
接続に成功すると、最初のパラメータが {NULL} でない場合、戻り値はそのパラ
メータの値と同じです。

</p>

<h4>20.4.40.3  エラー</h4>

<dl compact="">

<dt><code>CR_CONN_HOST_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバへの接続に失敗した。

</dd><dt><code>CR_CONNECTION_ERROR</code>
</dt><dd>
ローカル <strong>MySQL</strong> サーバへの接続に失敗した。

</dd><dt><code>CR_IPSOCK_ERROR</code>
</dt><dd>
IP ソケットの生成に失敗した。

</dd><dt><code>CR_OUT_OF_MEMORY</code>
</dt><dd>
メモリ不足。

</dd><dt><code>CR_SOCKET_CREATE_ERROR</code>
</dt><dd>
Unix ソケットの生成に失敗した。

</dd><dt><code>CR_UNKNOWN_HOST</code>
</dt><dd>
ホスト名の IP  アドレスを見つけるのに失敗した。

</dd><dt><code>CR_VERSION_ERROR</code>
</dt><dd>
異なるプロトコルバージョンを使用するクライアントライブラリでサーバへの接
続を試みた結果のプロトコルミスマッチ。これは、とても古いクライアントライ
ブラリを使用して、<code>--old-protocol</code> オプション付きで開始していない新
しいサーバに接続する場合に発生します。

</dd><dt><code>CR_NAMEDPIPEOPEN_ERROR;</code>
</dt><dd>
Win32 上の名前つきパイプの生成に失敗した。

</dd><dt><code>CR_NAMEDPIPEWAIT_ERROR;</code>
</dt><dd>
Win32 上の名前つきパイプの wait に失敗した。

</dd><dt><code>CR_NAMEDPIPESETSTATE_ERROR;</code>
</dt><dd>
Win32 上のパイプハンドラの獲得に失敗した。
</dd></dl>


<h4>20.4.40.4  例</h4>


<pre>MYSQL mysql;

mysql_init(&amp;mysql);
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&amp;mysql));
}
</pre>

<p>
<a name="IDX764"></a>


</p><h3><a name="mysql_real_query" href="manual.ja_toc.html#mysql_real_query">20.4.41  <code>mysql_real_query()</code></a></h3>

<p>
<code>int mysql_real_query(MYSQL *mysql, const char *query, unsigned int length)</code>

</p>

<h4>20.4.41.1  説明</h4>

<p>
<code>query</code> で示される SQL クエリを実行します。これは <code>length</code> バ
イト長です。クエリはひとつの SQL ステートメントでなければなりません。終端
のセミコロン(<samp>`;'</samp>)や <code>\g</code> をステートメントに追加すべきではありま
せん。

</p>
<p>
バイナリデータを含むクエリは <code>mysql_real_query()</code> を使
用<em>しなければなりません</em>。バイナリデータは <samp>`\0'</samp> 文字を含むこと
があるからです。
また、<code>mysql_real_query()</code> は <code>mysql_query()</code> よりも速いです。
クエリの <code>strlen()</code> を呼ばないからです。

</p>

<h4>20.4.41.2  戻り値</h4>

<p>
クエリが成功した場合は0。クエリが失敗した場合は非0。

</p>

<h4>20.4.41.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX765"></a>


</p><h3><a name="mysql_reload" href="manual.ja_toc.html#mysql_reload">20.4.42  <code>mysql_reload()</code></a></h3>

<p>
<code>int mysql_reload(MYSQL *mysql)</code>

</p>

<h4>20.4.42.1  説明</h4>

<p>
<strong>MySQL</strong> サーバに、アクセス権テーブルを再読み込みするように依頼し
ます。接続されたユーザは <strong>reload</strong> 特権を持つ必要があります。

</p>
<p>
この関数は推奨されません。代わりに、SQL <code>FLUSH PRIVILEGES</code> ステートメ
ントを発行する <code>mysql_query()</code> の使用が推奨されます。

</p>

<h4>20.4.42.2  戻り値</h4>

<p>
成功時0。失敗時非0。

</p>

<h4>20.4.42.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX766"></a>


</p><h3><a name="mysql_row_seek" href="manual.ja_toc.html#mysql_row_seek">20.4.43  <code>mysql_row_seek()</code></a></h3>

<p>
<code>MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET offset)</code>

</p>

<h4>20.4.43.1  説明</h4>
<p>
レコードカーソルをクエリ結果セット中の絶対レコードに設定します。これは、結
果セット構造体がクエリのすべての結果を持っていることを要求します。そのため、
<code>mysql_row_seek()</code> は <code>mysql_store_result()</code> と共にだけ使用でき、
<code>mysql_use_result()</code> と共には使用できません。

</p>
<p>
オフセットは <code>mysql_row_tell()</code> または <code>mysql_row_seek()</code> 呼びだ
しからの戻り値であるべきです。この値は単純なレコード番号ではありません;レ
コード番号を使用して結果セット内のレコードにシークしたい場合は、
<code>mysql_data_seek()</code> を代わりに使用してください。

</p>

<h4>20.4.43.2  戻り値</h4>

<p>
レコードカーソルの前の値。この値はその後の <code>mysql_row_seek()</code> 呼びだ
しに渡すことができます。

</p>

<h4>20.4.43.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX767"></a>


</p><h3><a name="mysql_row_tell" href="manual.ja_toc.html#mysql_row_tell">20.4.44  <code>mysql_row_tell()</code></a></h3>

<p>
<code>MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)</code>

</p>

<h4>20.4.44.1  説明</h4>

<p>
最後の <code>mysql_fetch_row()</code> についてレコードカーソルの現在の位置を返します。
この値は <code>mysql_row_seek()</code> への引数として使用できます。

</p>
<p>
<code>mysql_row_tell()</code> は <code>mysql_store_result()</code> の後にだけ使用すべ
きで、<code>mysql_use_result()</code> の後には使用すべきではありません。

</p>

<h4>20.4.44.2  戻り値</h4>

<p>
行カーソルの現在のオフセット。

</p>

<h4>20.4.44.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX768"></a>


</p><h3><a name="mysql_select_db" href="manual.ja_toc.html#mysql_select_db">20.4.45  <code>mysql_select_db()</code></a></h3>

<p>
<code>int mysql_select_db(MYSQL *mysql, const char *db)</code>

</p>

<h4>20.4.45.1  説明</h4>

<p>
<code>mysql</code> で示される現在の接続に、デフォルト(現在の)データベースとし
て <code>db</code> で示されるデータベースを使用するように指示します。以降のク
エリでは、明示的にデータベースを指定しないテーブル参照について、このデー
タベースがデフォルトになります。

</p>
<p>
接続されたユーザがデータベースを使用する権限を持っていると証明されなけれ
ば、<code>mysql_select_db()</code> は失敗します。

</p>

<h4>20.4.45.2  戻り値</h4>

<p>
成功時0。失敗時非0。

</p>

<h4>20.4.45.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX769"></a>


</p><h3><a name="mysql_shutdown" href="manual.ja_toc.html#mysql_shutdown">20.4.46  <code>mysql_shutdown()</code></a></h3>

<p>
<code>int mysql_shutdown(MYSQL *mysql)</code>

</p>

<h4>20.4.46.1  説明</h4>

<p>
データベースサーバにシャットダウンするように要求します。接続されたユーザ
は <strong>shutdown</strong> 特権を持っている必要があります。

</p>

<h4>20.4.46.2  戻り値</h4>

<p>
成功時0。失敗時非0。

</p>

<h4>20.4.46.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX770"></a>


</p><h3><a name="mysql_stat" href="manual.ja_toc.html#mysql_stat">20.4.47  <code>mysql_stat()</code></a></h3>

<p>
<code>char *mysql_stat(MYSQL *mysql)</code>

</p>

<h4>20.4.47.1  説明</h4>

<p>
<code>mysqladmin status</code> で提供されるのと同様の情報を文字列として返しま
す。これは秒での uptime と、実行中のスレッド数、問い合わせ数、再読み込み
数、オープンテーブル数を含みます。

</p>

<h4>20.4.47.2  戻り値</h4>

<p>
サーバ状態を表わす文字列。エラーが発生した場合 <code>NULL</code>。

</p>

<h4>20.4.47.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX771"></a>


</p><h3><a name="mysql_store_result" href="manual.ja_toc.html#mysql_store_result">20.4.48  <code>mysql_store_result()</code></a></h3>

<p>
<code>MYSQL_RES *mysql_store_result(MYSQL *mysql)</code>

</p>

<h4>20.4.48.1  説明</h4>

<p>
データを取り出すクエリ(<code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code>,
<code>EXPLAIN</code>)が成功する毎に、<code>mysql_store_result()</code> または 
<code>mysql_use_result()</code> を呼び出す必要があります。

</p>
<p>
<code>mysql_store_result()</code> はクエリのすべての結果をクライアントへ読み込み、
<code>MYSQL_RES</code> 構造体を割り当て、この構造体に結果を配置します。

</p>
<p>
返されるレコードが無い場合、空の結果セットが返されます。 (空の結果セットは 
<code>NULL</code> 戻り値とは異なります。)

</p>
<p>
一度 <code>mysql_store_result()</code> を呼び出したら、結果セット中にいくつのレ
コードがあるかを見つけるために、<code>mysql_num_rows()</code> を呼び出すことがで
きます。

</p>
<p>
結果セットからレコードを取り出すために <code>mysql_fetch_row()</code> を呼び出す
ことができます。また、結果セット内の現在のレコード位置を設定／取得するため
に <code>mysql_row_seek()</code> と <code>mysql_row_tell()</code> を呼び出すことができ
ます。

</p>
<p>
一度結果セットで行なうと、<code>mysql_free_result()</code> を呼び出す必要があ
ります。

</p>
<p>
 「<a href="manual.ja_Clients.html#NULL_mysql_store_result">20.4.51  <code>mysql_query()</code> が成功を返した後、<code>mysql_store_result()</code> が <code>NULL</code> を返す時があるのは何故？</a>」節参照.

</p>

<h4>20.4.48.2  戻り値</h4>

<p>
結果の <code>MYSQL_RES</code> 結果構造体。エラーがある場合 <code>NULL</code>。

</p>

<h4>20.4.48.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_OUT_OF_MEMORY</code>
</dt><dd>
メモリ不足。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>

<p>
<a name="IDX772"></a>


</p><h3><a name="mysql_thread_id" href="manual.ja_toc.html#mysql_thread_id">20.4.49  <code>mysql_thread_id()</code></a></h3>

<p>
<code>unsigned long mysql_thread_id(MYSQL *mysql)</code>

</p>

<h4>20.4.49.1  説明</h4>

<p>
現在の接続のスレッド ID を返します。この値は、スレッドを殺すための
<code>mysql_kill()</code> への引数として使用できます。

</p>
<p>
接続が失われて、<code>mysql_ping()</code> で再接続した場合、スレッド ID は変更さ
れます。これはスレッド ID を後で使うために取得して格納すべきではないことを
意味します。必要な時にそれを取得すべきです。

</p>

<h4>20.4.49.2  戻り値</h4>

<p>
現在の接続のスレッド ID。

</p>

<h4>20.4.49.3  エラー</h4>
<p>
無し。

</p>
<p>
<a name="IDX773"></a>


</p><h3><a name="mysql_use_result" href="manual.ja_toc.html#mysql_use_result">20.4.50  <code>mysql_use_result()</code></a></h3>

<p>
<code>MYSQL_RES *mysql_use_result(MYSQL *mysql)</code>

</p>

<h4>20.4.50.1  説明</h4>

<p>
データを取り出すクエリ(<code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code>,
<code>EXPLAIN</code>)が成功する毎に、 <code>mysql_store_result()</code> または 
<code>mysql_use_result()</code> を呼び出す必要があります。

</p>
<p>
<code>mysql_use_result()</code> は結果セット検索を開始しますが,
<code>mysql_store_result()</code> のように、実際にクライアントに結果セットを読み
取りません. 代わりに、各レコードは <code>mysql_fetch_row()</code> 呼びだしが行な
われることにより、個々に取り出されます。
<code>mysql_use_result()</code> はクエリの結果を、一時テーブルやローカルバッファ
に格納すること無く、サーバから直接読み込みます。これは 
<code>mysql_store_result()</code> よりもいくらか速く、少ないメモリを使用します。
この場合、クライアントは現在の行と接続バッファ
( <code>max_allowed_packet</code> bytes まで増加する ) のメモリだけを割り当てます。

</p>
<p>
一方、クライアント側で各行に
ついて多くの処理を行なう場合や、ユーザが <code>^S</code> (スクロール停止) を入
力できるような画面に出力を送る場合は、<code>mysql_use_result()</code> を使用す
べきではありません。これはサーバと連携しており、他のスレッドが
データが取り出されるテーブルを更新する事を邪魔します。

</p>
<p>
<code>mysql_use_result()</code> 使用時、<code>NULL</code> 値を取り出すまで 
<code>mysql_fetch_row()</code> を実行する必要があります。そうしないと、次のク
エリは前のクエリから結果を取り出します。これを忘れると、C API はエラー 
<code>Commands out of sync; You can't run this command now</code> を与えます！

</p>
<p>
<code>mysql_use_result()</code> から返される結果では、
<code>mysql_data_seek()</code>, <code>mysql_row_seek()</code>,
<code>mysql_row_tell()</code>, <code>mysql_num_rows()</code>,
<code>mysql_affected_rows()</code> を使用できません。
また、<code>mysql_use_result()</code> が終了するまで他のクエリの発行もできませ
ん。(全ての行をフェッチした後に、フェッチされた行数を知るために 
<code>mysql_num_rows</code> を呼び出すことができます。)

</p>
<p>
一度結果セットで行なうと、<code>mysql_free_result()</code> を呼び出す必要があ
ります。

</p>

<h4>20.4.50.2  戻り値</h4>

<p>
結果の <code>MYSQL_RES</code> 結果構造体。エラーがある場合 <code>NULL</code>。

</p>

<h4>20.4.50.3  エラー</h4>

<dl compact="">

<dt><code>CR_COMMANDS_OUT_OF_SYNC</code>
</dt><dd>
不当な順にコマンドが実行された。
</dd><dt><code>CR_OUT_OF_MEMORY</code>
</dt><dd>
メモリ不足。
</dd><dt><code>CR_SERVER_GONE_ERROR</code>
</dt><dd>
<strong>MySQL</strong> サーバがいなくなった。
</dd><dt><code>CR_SERVER_LOST</code>
</dt><dd>
サーバへの接続がクエリ中に失われた。
</dd><dt><code>CR_UNKNOWN_ERROR</code>
</dt><dd>
未知のエラーが発生した。
</dd></dl>



<h3><a name="NULL_mysql_store_result" href="manual.ja_toc.html#NULL_mysql_store_result">20.4.51  <code>mysql_query()</code> が成功を返した後、<code>mysql_store_result()</code> が <code>NULL</code> を返す時があるのは何故？</a></h3>

<p>
<code>mysql_query()</code> の呼び出しが成功した後に 
<code>mysql_store_result()</code> が <code>NULL</code> を返すことがあります。これが
起こったとき、次の条件のどれかの発生を意味します:

</p>

<ul>
<li>

<code>malloc()</code> が失敗した (例えば、結果セットが大き過ぎた場合)。

</li><li>

データが読めなかった (接続のエラー)。

</li><li>

クエリがデータを返さなかった (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>)。
</li></ul>

<p>
ステートメントが空でない結果を提供するかどうかは 
<code>mysql_field_count()</code> の呼び出しによっていつでもチェックできます。
<code>mysql_field_count()</code> が 0 を返す場合、結果は空で最後のクエリは値を
返さないステートメントです (例えば、<code>INSERT</code> や <code>DELETE</code>)。
<code>mysql_field_count()</code> が非 0 値を返す場合、ステートメントは空でない
結果を提供します。
例は<code>mysql_field_count()</code> 関数の説明を参照してください。

</p>
<p>
<code>mysql_error()</code> または <code>mysql_errno()</code> を呼び出すことによって
エラーのテストもできます。

</p>


<h3><a name="Query_results" href="manual.ja_toc.html#Query_results">20.4.52  クエリから得られる結果は何か？</a></h3>

<p>
クエリによって返される結果セットに加えて、次の情報も得ることができます:

</p>

<ul>
<li>

<code>mysql_affected_rows()</code> は、<code>INSERT</code>, <code>UPDATE</code> または 
<code>DELETE</code> を行なった時の最後のクエリで、影響された行数を返します。
<code>WHERE</code> 節がない <code>DELETE</code> が使用されて、テーブルが切り詰められ
た場合は例外です。これはとても速いです！ この場合、
<code>mysql_affected_rows()</code> は影響された行数を 0 と返します。

</li><li>

<code>mysql_num_rows()</code> は結果セットのレコード数を返します。
<code>mysql_store_result()</code> では、<code>mysql_num_rows()</code> は 
<code>mysql_store_result()</code> が復帰したすぐ後に呼び出すことができます。
<code>mysql_use_result()</code> では、<code>mysql_num_rows()</code> は 
<code>mysql_fetch_row()</code> ですべてのレコードを取り出した後にだけ呼ぶ出すこ
とができます。

</li><li>

<code>mysql_insert_id()</code> は、<code>AUTO_INCREMENT</code> インデックスを持つテー
ブルに行を挿入した最後のクエリによって生成された ID を返します。
 「<a href="manual.ja_Clients.html#mysql_insert_id">20.4.29  <code>mysql_insert_id()</code></a>」節参照.

</li><li>

いくつかのクエリ (<code>LOAD DATA INFILE...</code>, <code>INSERT INTO ... 
SELECT ...</code>, <code>UPDATE</code>) は追加情報を返します。結果は 
<code>mysql_info()</code> で返されます。
返す文字列の形式については、<code>mysql_info()</code> の説明を参照してください。
<code>mysql_info()</code> は追加情報がない場
合は <code>NULL</code> ポインタを返します。
</li></ul>



<h3><a name="Getting_unique_ID" href="manual.ja_toc.html#Getting_unique_ID">20.4.53  最後に挿入された行のユニーク ID をどのように得られるか？</a></h3>

<p>
<code>AUTO_INCREMENT</code> 属性を持つ項目を含むテーブルにレコードを挿入する場
合、<code>mysql_insert_id()</code> 関数で与えられた ID を得ることができます。

</p>
<p>
<code>mysql_query()</code> に渡すクエリ文字列内の<code>LAST_INSERT_ID()</code> 関数
を使用することでも、ID を取り出すことができます。

</p>
<p>
次のコードを実行することで、<code>AUTO_INCREMENT</code> インデックスが使用され
たかどうかチェックできます。これは、クエリが <code>AUTO_INCREMENT</code> イン
デックスを伴う <code>INSERT</code> だったかどうかもチェックできます:

</p>

<pre>if (mysql_error(&amp;mysql)[0] == 0 &amp;&amp;
    mysql_num_fields(result) == 0 &amp;&amp;
    mysql_insert_id(&amp;mysql) != 0)
{
    used_id = mysql_insert_id(&amp;mysql);
}
</pre>

<p>
生成された最後の ID は接続毎にサーバ内で維持されています。他のクライアント
によって変更はされません。他の <code>AUTO_INCREMENT</code> 項目を非マジック値 
(すなわち、<code>NULL</code> でなく <code>0</code> でない値) で更新する場合でも、それは変更
されません。

</p>
<p>
また、他のテーブルにその ID を挿入しようとする場合、次で行なうことができます:

</p>

<pre>INSERT INTO foo (auto,text)
    VALUES(NULL,'text');              # generate ID by inserting NULL
INSERT INTO foo2 (id,text)
    VALUES(LAST_INSERT_ID(),'text');  # use ID in second table
</pre>



<h3><a name="C_API_linking_problems" href="manual.ja_toc.html#C_API_linking_problems">20.4.54  C API でのリンクの問題</a></h3>

<p>
C API でリンクする時、いくつかのシステム上では次のエラーになります:

</p>

<pre>gcc -g -o client test.o -L/usr/local/lib/mysql -lmysqlclient -lsocket -lnsl

Undefined        first referenced
 symbol          in file
floor            /usr/local/lib/mysql/libmysqlclient.a(password.o)
ld: fatal: Symbol referencing errors. No output written to client
</pre>

<p>
これは、あなたのシステム上では、コンパイル/リンク行の最後に、math ライブ
ラリ (<code>-lm</code>) を含める必要があることを意味します。

</p>


<h3><a name="Thread-safe_clients" href="manual.ja_toc.html#Thread-safe_clients">20.4.55  スレッド安全クライアントを作る方法</a></h3>

<p>
クライアントは `ほとんど' スレッド安全です。一番大きな問題は 
<tt>`net.c'</tt> (ソケットから読み込みをするサブルーチンを含むファイル) が割
り込み安全でないことです。これは、サーバからの長い読み込みを中断できるよ
うに、自身のアラームを持ちたいだろうという考慮で行なわれました。

</p>
<p>
標準クライアントライブラリはスレッドオプションでコンパイルされていません。

</p>
<p>
スレッド安全クライアントを得るためには、<code>-lmysys</code>, <code>-lstring</code>,
<code>-ldbug</code> ライブラリとサーバが使用する <code>net_serv.o</code> を使用しま
す。

</p>
<p>
スレッドクライアントを使用する時、<tt>`thr_alarm.c'</tt> ルーチンを大いに使
用できます。<code>mysys</code> ライブラリからのルーチンを使用する場合、覚えて
おかなければならないことは <code>my_init()</code> を最初に呼ぶことだけです！

</p>
<p>
<code>mysql_real_connect()</code> を除く全ての関数は現在スレッド安全です。スレッ
ド安全クライアントライブラリをコンパイルし、それをスレッド安全なマナーで使
用するための方法を、次の注意で説明します。(この 
<code>mysql_real_connect()</code> についての注意は、実際には 
<code>mysql_connect()</code> にも有効です。しかし <code>mysql_connect()</code> は推奨
されませんので、とにかく <code>mysql_real_connect()</code> を使用すべきです。)

</p>
<p>
<code>mysql_real_connect()</code> をスレッド安全にするためには、クライアントを次の
コマンドで再コンパイルする必要があります:

</p>

<pre>shell&gt; CPPFLAGS=-DTHREAD_SAFE_CLIENT ./configure ...
</pre>

<p>
標準クライアントのリンク時に未定義シンボルのためいくつかのエラーが出るで
しょう。これはデフォルトでは pthread ライブラリが含まれていないためです。

</p>

<p>
結果の <tt>`libmysqlclient.a'</tt> ライブラリはスレッド安全です。これの意味す
ることは、同じ接続ハンドル(<code>mysql_real_connect()</code> で返される)に、同時
に２つのスレッドからクエリを行なわない限り、クライアントコードはスレッド安
全ということです; クライアント／サーバプロトコルは、与えられた接続上で同時
に一つの要求だけを許します。複数のスレッドから同じ接続を使用したい場合は、
<code>mysql_query()</code> と <code>mysql_store_result()</code> の組み合わせのまわりで 
mutex lock を行なう必要があります。一度 <code>mysql_store_result()</code> の用意
ができると、ロックは解放でき、他のスレッドが同じ接続にクエリを行なうことが
できます。(他の言葉で言うと、正しいロックプロトコルを使用する限り、別のス
レッドは、<code>mysql_store_result()</code> で生成される別の <code>MYSQL_RES</code> ポ
インタを使用できます。) POSIX スレッドでプログラムを行なう場合、
<code>pthread_mutex_lock()</code> と <code>pthread_mutex_unlock()</code> を、mutex
lock の確立と解放に使用できます。

</p>
<p>
<code>mysql_store_result()</code> でなく <code>mysql_use_result()</code> を使用する場
合、<code>mysql_use_result()</code> の回りと <code>mysql_fetch_row()</code> 呼び出しに
ロックが必要です。しかし、スレッド化クライアントに本当に一番良いのは、
<code>mysql_use_result()</code> を使用しないことです。

</p>


<h2><a name="Perl" href="manual.ja_toc.html#Perl">20.5  <strong>MySQL</strong> Perl API</a></h2>

<p>
This section documents the Perl <code>DBI</code> interface.  The former interface
was called <code>mysqlperl</code>.
<code>DBI</code>/<code>DBD</code> が Perl インターフェースとして現在推奨されているので、
<code>mysqlperl</code> に関してはここでは述べない。

</p>



<h3><a name="DBI_with_DBD" href="manual.ja_toc.html#DBI_with_DBD">20.5.1  <code>DBI</code> with <code>DBD::mysql</code></a></h3>

<p>
<code>DBI</code> は多くのデーターベースとの一般的なインターフェースである。
これは、多くのデーターベースと動作するスクリプトを変更なしに書けることを意味する。
そのためには、それぞれのデータベース用のデータベースドライバ (DBD) が必要である。
<strong>MySQL</strong> では、そのドライバは <code>DBD::mysql</code> である。

</p>
<p>
Perl5 DBI に関する詳細は、<code>DBI</code>ウェッブページを参照のこと：

</p><pre><a href="http://www.symbolstone.org/technology/perl/DBI/index.html">http://www.symbolstone.org/technology/perl/DBI/index.html</a>
</pre>

<p>
Object Oriented Programming (OOP) に関する詳細は、Perl OOP ページを参照のこと：

</p><pre><a href="http://language.perl.com/info/documentation.html">http://language.perl.com/info/documentation.html</a>
</pre>

<p>
Installation instructions for <strong>MySQL</strong> Perl support are given in
 「<a href="manual.ja_Installing.html#Perl_support">4.10  Perl のインストールについて</a>」節.

</p>
<p>
<a name="IDX774"></a>


</p><h4><a name="Perl_DBI_Class" href="manual.ja_toc.html#Perl_DBI_Class">20.5.1.1  The <code>DBI</code> interface</a></h4>

<p>
<strong>Portable DBI methods</strong>

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><code>connect</code> </td><td> データベースサーバと接続する
</td></tr>
<tr><td><code>disconnect</code> </td><td> データベースサーバとの接続を切る
</td></tr>
<tr><td><code>prepare</code> </td><td> SQL文を設定する
</td></tr>
<tr><td><code>execute</code> </td><td> 設定されたSQL文を実行する
</td></tr>
<tr><td><code>do</code> </td><td> SQL文を設定し、実行する
</td></tr>
<tr><td><code>quote</code> </td><td> 挿入するためのクォート文字、または <code>BLOB</code> 値
</td></tr>
<tr><td><code>fetchrow_array</code> </td><td> フィールドの配列として次の行を取り出す
</td></tr>
<tr><td><code>fetchrow_arrayref</code> </td><td> フィールドの配列参照として次の行を取り出す
</td></tr>
<tr><td><code>fetchrow_hashref</code> </td><td> ハッシュテーブルへの参照として次の行を取り出す
</td></tr>
<tr><td><code>fetchall_arrayref</code> </td><td> 配列の配列として全データを取り出す
</td></tr>
<tr><td><code>finish</code> </td><td> 命令を終了し、リソースからシステムを切り離す
</td></tr>
<tr><td><code>rows</code> </td><td> 影響のあった行の数を返す
</td></tr>
<tr><td><code>data_sources</code> </td><td> ローカルホスト上で利用できるデータベースの配列を返す
</td></tr>
<tr><td><code>ChopBlanks</code> </td><td> <code>fetchrow_*</code> メソッドが空白を取り除くかどうかを管理する
</td></tr>
<tr><td><code>NUM_OF_PARAMS</code> </td><td> 設定された命令文中の placeholder の数
</td></tr>
<tr><td><code>NULLABLE</code> </td><td> どのカラムに <code>NULL</code> 値があるか？
</td></tr>
<tr><td><code>trace</code> </td><td> Perform tracing for debugging
</td></tr>
</tbody></table>

<p>
<strong>MySQL 固有メソッド</strong>

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><code>insertid</code> </td><td> 最後の <code>AUTO_INCREMENT</code> 値
</td></tr>
<tr><td><code>is_blob</code> </td><td> どのカラムが <code>BLOB</code> か？
</td></tr>
<tr><td><code>is_key</code> </td><td> どのカラムがキーか？
</td></tr>
<tr><td><code>is_num</code> </td><td> どのカラムが数値型か？
</td></tr>
<tr><td><code>is_pri_key</code> </td><td> どのカラムがプライマリキーか？
</td></tr>
<tr><td><code>is_not_null</code> </td><td> どのカラムが <code>NULL</code> 値か？　<code>NULLABLE</code> 参照。
</td></tr>
<tr><td><code>length</code> </td><td> 利用可能なカラムサイズの最大値
</td></tr>
<tr><td><code>max_length</code> </td><td> 実際に存在しているカラムサイズの最大値
</td></tr>
<tr><td><code>NAME</code> </td><td> カラム名
</td></tr>
<tr><td><code>NUM_OF_FIELDS</code> </td><td> 返されたフィールドの数
</td></tr>
<tr><td><code>table</code> </td><td> 返されたセットのテーブル名
</td></tr>
<tr><td><code>type</code> </td><td> 全てのカラムの型
</td></tr>
<tr><td><code>_CreateDB</code> </td><td> データベースを作成する
</td></tr>
<tr><td><code>_DropDB</code> </td><td> データベースを削除する。 <strong>＊＊＊このメソッドは危険である＊＊＊</strong>
</td></tr>
</tbody></table>

<p>
以下の節に、より詳細な Perl メソッドの解説がある。
Variables used for method return values have these meanings:

</p>
<dl compact="">

<dt><code>$dbh</code>
</dt><dd>
Database handle

</dd><dt><code>$sth</code>
</dt><dd>
Statement handle

</dd><dt><code>$rc</code>
</dt><dd>
Return code (often a status)

</dd><dt><code>$rv</code>
</dt><dd>
Return value (often a row count)
</dd></dl>

<p>
<strong>汎用 DBI メソッド</strong>

</p>
<dl compact="">

<dt><code>connect($data_source, $username, $password)</code>
</dt><dd>
<a name="IDX775"></a>
 <a name="IDX776"></a>
 
データソースとのデータベース接続をするために <code>connect</code> を使う。
<code>$data_source</code> 値は <code>DBI:driver_name:</code> ではじめること。
<code>DBD::mysql</code> ドライバーを用いた <code>connect</code> の使用例：

<pre>$dbh = DBI-&gt;connect("DBI:mysql:$database", $user, $password);
$dbh = DBI-&gt;connect("DBI:mysql:$database:$hostname",
                    $user, $password);
$dbh = DBI-&gt;connect("DBI:mysql:$database:$hostname:$port",
                    $user, $password);
</pre>

ユーザー名またはパスワードが未設定の場合、 &lt;<code>DBI</code> は環境変数である
 <code>DBI_USER</code> と <code>DBI_PASS</code> をそれぞれ使う。
ホスト名を指定しない場合は、<code>'localhost'</code> がデフォルトとなる。
ポート番号を指定しない場合は、<strong>MySQL</strong> ポート（3306）
がデフォルトとなる。

As of <code>Msql-Mysql-modules</code> version 1.2009,
the <code>$data_source</code> value allows certain modifiers:

<dl compact="">

<dt><code>mysql_read_default_file=file_name</code>
</dt><dd>
Read <tt>`filename'</tt> as an option file.  For information on option files,
see  「<a href="manual.ja_Installing.html#Option_files">4.15.4  オプションファイル ( <code>my.cnf</code> )</a>」節.

</dd><dt><code>mysql_read_default_group=group_name</code>
</dt><dd>
The default group when reading an option file is normally the
<code>[client]</code> group.  By specifying the <code>mysql_read_default_group</code>
option, the default group becomes the <code>[group_name]</code> group.

</dd><dt><code>mysql_compression=1</code>
</dt><dd>
Use compressed communication between the client and server (<strong>MySQL</strong>
3.22.3 or later).

</dd><dt><code>mysql_socket=/path/to/socket</code>
</dt><dd>
Specify the pathname of the Unix socket that is used to connect
to the server (<strong>MySQL</strong> 3.21.15 or later).
</dd></dl>

Multiple modifiers may be given; each must be preceded by a semicolon.

For example, if you want to avoid hardcoding the user name and password into
a <code>DBI</code> script, you can take them from the user's <tt>`~/.my.cnf'</tt>
option file instead by writing your <code>connect</code> call like this:


<pre>$dbh = DBI-&gt;connect("DBI:mysql:$database"
                . ";mysql_read_default_file=$ENV{HOME}/.my.cnf",
                $user, $password);
</pre>

This call will read options defined for the <code>[client]</code> group in the
option file.  If you wanted to do the same thing, but use options specified
for the <code>[perl]</code> group as well, you could use this:


<pre>$dbh = DBI-&gt;connect("DBI:mysql:$database"
                . ";mysql_read_default_file=$ENV{HOME}/.my.cnf"
                . ";mysql_read_default_group=perl",
                $user, $password);
</pre>

<a name="IDX777"></a>
<a name="IDX778"></a>
</dd><dt><code>disconnect</code>
</dt><dd>
<code>disconnect</code> メソッドは、データベースとのデータベースハンドルを切断する。
プログラムを終了する直前に呼び出されるのが典型的である。
例：

<pre>$rc = $dbh-&gt;disconnect;
</pre>

<a name="IDX779"></a>
<a name="IDX780"></a>
</dd><dt><code>prepare($statement)</code>
</dt><dd>
データベースエンジンで実行するためのSQL文を設定し、<code>execute</code> メソッドで
使用出来るステートメントハンドル <code>($sth)</code> を返す。
the <code>execute</code> method.
Typically you handle <code>SELECT</code> statements (and <code>SELECT</code>-like statements
such as <code>SHOW</code>, <code>DESCRIBE</code> and <code>EXPLAIN</code>) by means of
<code>prepare</code> and <code>execute</code>.
例：

<pre>$sth = $dbh-&gt;prepare($statement)
    or die "Can't prepare $statement: $dbh-&gt;errstr\n";
</pre>

<a name="IDX781"></a>
<a name="IDX782"></a>
</dd><dt><code>execute</code>
</dt><dd>
<code>execute</code> メソッドは、設定されたSQL文を実行する。非 <code>SELECT</code> 文のときは、
影響のあった行の数を返す。If no rows are affected, <code>execute</code> returns <code>"0E0"</code>,
which Perl treats as zero but regards as true. 
<code>SELECT</code> 文のときは、SQL要求を開始するのみである。
データを操作する <code>fetch_*</code> メソッドの内の一つを記述する必要がある。
例：

<pre>$rv = $sth-&gt;execute
          or die "can't execute the query: $sth-&gt;errstr;
</pre>

<a name="IDX783"></a>
<a name="IDX784"></a>
</dd><dt><code>do($statement)</code>
</dt><dd>
<code>do</code> メソッドはSQL文を設定・実行し、影響のあった行の数を返す。
このメソッドは、「非 select」文、すなわち、高度（ドライバーの限界のため）で設定できない文、
一度の実行（inserts, deletes など）で済む文のときに一般的に用いられる。
例：

<pre>$rv = $dbh-&gt;do($statement)
        or die "Can't execute $statement: $dbh- &gt;errstr\n";
</pre>

<a name="IDX785"></a>
<a name="IDX786"></a>
<a name="IDX787"></a>
<a name="IDX788"></a>
</dd><dt><code>quote($string)</code>
</dt><dd>
<code>quote</code> メソッドは、文字列中にエスケープ文字があるときに用いられ、
クォート文字を文の外側に付加する。
例：

<pre>$sql = $dbh-&gt;quote($string)
</pre>

<a name="IDX789"></a>
<a name="IDX790"></a>
</dd><dt><code>fetchrow_array</code>
</dt><dd>
このメソッドはデータの次の行を取り出し、フィールドの値の配列として返す。
例：

<pre>while(@row = $sth-&gt;fetchrow_array) {
        print qw($row[0]\t$row[1]\t$row[2]\n);
}
</pre>

<a name="IDX791"></a>
<a name="IDX792"></a>
</dd><dt><code>fetchrow_arrayref</code>
</dt><dd>
このメソッドはデータの次の行を取り出し、フィールドの値の配列への参照として返す。
例：

<pre>while($row_ref = $sth-&gt;fetchrow_arrayref) {
        print qw($row_ref-&gt;[0]\t$row_ref-&gt;[1]\t$row_ref-&gt;[2]\n);
}
</pre>

<a name="IDX793"></a>
<a name="IDX794"></a>
</dd><dt><code>fetchrow_hashref</code>
</dt><dd>
このメソッドはデータの行を取り出し、名前・値のペアのフィールドを含んだ
ハッシュテーブルへの参照を返す。このメソッドは、上で示した配列参照
（訳注：<code>fetchrow_arrayref</code>）よりもかなり効率的ではない。例：

<pre>while($hash_ref = $sth-&gt;fetchrow_hashref) {
        print qw($hash_ref-&gt;{firstname}\t$hash_ref-&gt;{lastname}\t\
                $hash_ref- &gt; title}\n);
}
</pre>

<a name="IDX795"></a>
<a name="IDX796"></a>
</dd><dt><code>fetchall_arrayref</code>
</dt><dd>
このメソッドは、SQL文より返されたデータ（の行）の全てを得るために使う。
このメソッドは、各行への参照の配列の配列への参照を返す。
入れ子のループを使ってデータを利用・表示する。例：

<pre>my $table = $sth-&gt;fetchall_arrayref
                or die "$sth-&gt;errstr\n";
my($i, $j);
for $i ( 0 .. $#{$table} ) {
        for $j ( 0 .. $#{$table-&gt;[$i]} ) {
                print "$table-&gt;[$i][$j]\t";
        }
        print "\n";
}
</pre>

<a name="IDX797"></a>
<a name="IDX798"></a>
</dd><dt><code>finish</code>
</dt><dd>
そのステートメントハンドルからそれ以上データを取り出さないことを示す。ステートメントハンドルや、つかんでいたシステムリソースを解放するためにこのメソッドを呼び出す。例：

<pre>$rc = $sth-&gt;finish;
</pre>

<a name="IDX799"></a>
<a name="IDX800"></a>
</dd><dt><code>rows</code>
</dt><dd>
最後の命令により、（データの更新、削除、などで）影響のあった行の数を返す。
このメソッドは <code>do</code> あるいは 非 <code>SELECT</code> <code>execute</code> 文を
実行した後に、たいてい使われる。例：
Example:

<pre>$rv = $sth-&gt;rows;
</pre>

<a name="IDX801"></a>
<a name="IDX802"></a>
</dd><dt><code>NULLABLE</code>
</dt><dd>
配列の各要素に対し、ブール値の配列への参照を返す。
TRUE であればそのカラムに <code>NULL</code> 値が含まれていることを示す。例：
Example:

<pre>$null_possible = $sth-&gt;{NULLABLE};
</pre>

<a name="IDX803"></a>
<a name="IDX804"></a>
</dd><dt><code>NUM_OF_FIELDS</code>
</dt><dd>
この属性は、<code>SELECT</code> 文や <code>SHOW FIELDS</code> 文によって返された
フィールドの数を示している。命令文が結果を返したかどうかをチェックするのに、
これを使うことが出来る：０値は、<code>INSERT</code>, <code>DELETE</code> または
 <code>UPDATE</code> のような非 <code>SELECT</code> 文を示している。例：
Example:

<pre>$nr_of_fields = $sth-&gt;{NUM_OF_FIELDS};
</pre>

<a name="IDX805"></a>
<a name="IDX806"></a>
</dd><dt><code>data_sources($driver_name)</code>
</dt><dd>
このメソッドは、<code>'localhost'</code> ホスト上の <strong>MySQL</strong> サーバで
利用可能なデータベースの名前を含んだ配列を返す。例：

<pre>@dbs = DBI-&gt;data_sources("mysql");
</pre>

<a name="IDX807"></a>
<a name="IDX808"></a>
</dd><dt><code>ChopBlanks</code>
</dt><dd>
この属性は、 <code>fetchrow_*</code> メソッドが返り値から前後の空白を
除去するかどうかを決定する。例：

<pre>$sth-&gt;{'ChopBlanks'} =1;
</pre>

<a name="IDX809"></a>
<a name="IDX810"></a>
</dd><dt><code>trace($trace_level)</code>
</dt><dd>
</dd><dt><code>trace($trace_level, $trace_filename)</code>
</dt><dd>
The <code>trace</code> method enables or disables tracing.  When invoked as a
<code>DBI</code> class method, it affects tracing for all handles.  When invoked as
a database or statement handle method, it affects tracing for the given
handle (and any future children of the handle).  Setting <code>$trace_level</code>
to 2 provides detailed trace information.  Setting <code>$trace_level</code> to 0
disables tracing.  Trace output goes to the standard error output by
default.  If <code>$trace_filename</code> is specified, the file is opened in
append mode and output for <em>all</em> traced handles is written to that
file.  Example:

<pre>DBI-&gt;trace(2);                # trace everything
DBI-&gt;trace(2,"/tmp/dbi.out"); # trace everything to /tmp/dbi.out
$dth-&gt;trace(2);               # trace this database handle
$sth-&gt;trace(2);               # trace this statement handle
</pre>

<a name="IDX811"></a>
<a name="IDX812"></a>
You can also enable <code>DBI</code> tracing by setting the <code>DBI_TRACE</code>
environment variable.  Setting it to a numeric value is equivalent to calling
<code>DBI-&gt;(value)</code>.  Setting it to a pathname is equivalent to calling
<code>DBI-&gt;(2,value)</code>.

</dd></dl>

<p>
<strong>MySQL 固有メソッド</strong>

</p>
<p>
The methods shown below are <strong>MySQL</strong>-specific and not part of the
<code>DBI</code> standard.  Several of them are now deprecated:
<code>is_blob</code>, <code>is_key</code>, <code>is_num</code>, <code>is_pri_key</code>,
<code>is_not_null</code>, <code>length</code>, <code>max_length</code>, and <code>table</code>.
Where <code>DBI</code>-standard alternatives exist, they are noted below.

</p>
<dl compact="">

<dt><code>insertid</code>
</dt><dd>
<a name="IDX813"></a>
 <a name="IDX814"></a>
 <a name="IDX815"></a>
 
<strong>MySQL</strong> の特徴である <code>AUTO_INCREMENT</code> を使うとき、
新しい自動繰り上がり値がここに記憶される。例：
Example:

<pre>$new_id = $sth-&gt;{insertid};
</pre>

As an alternative, you can use <code>$dbh-&gt;{'mysql_insertid'}</code>.

<a name="IDX816"></a>
<a name="IDX817"></a>
</dd><dt><code>is_blob</code>
</dt><dd>
配列の各要素に対し、ブール値の配列への参照を返す。TRUE であれば
そのカラムが <code>BLOB</code> 値であることを示す。例：

<pre>$keys = $sth-&gt;{is_blob};
</pre>

<a name="IDX818"></a>
<a name="IDX819"></a>
</dd><dt><code>is_key</code>
</dt><dd>
配列の各要素に対し、ブール値の配列への参照を返す。TRUE であれば
そのカラムがキーであることを示す。
例：

<pre>$keys = $sth-&gt;{is_key};
</pre>

<a name="IDX820"></a>
<a name="IDX821"></a>
</dd><dt><code>is_num</code>
</dt><dd>
配列の各要素に対し、ブール値の配列への参照を返す。TRUE であれば
そのカラムが数値型であることを示す。
例：

<pre>$nums = $sth-&gt;{is_num};
</pre>

<a name="IDX822"></a>
<a name="IDX823"></a>
</dd><dt><code>is_pri_key</code>
</dt><dd>
配列の各要素に対し、ブール値の配列への参照を返す。TRUE であれば
そのカラムがプライマリーキーであることを示す。
例：

<pre>$pri_keys = $sth-&gt;{is_pri_key};
</pre>

<a name="IDX824"></a>
<a name="IDX825"></a>
</dd><dt><code>is_not_null</code>
</dt><dd>
配列の各要素に対し、ブール値の配列への参照を返す。FALSE であれば
そのカラムが <code>NULL</code> 値を含むことを示す。
例：

<pre>$not_nulls = $sth-&gt;{is_not_null};
</pre>

<code>is_not_null</code> is deprecated;
前述の <code>NULLABLE</code> 属性を使用するほうが望ましい。それが DBI の標準である。

<a name="IDX826"></a>
<a name="IDX827"></a>
<a name="IDX828"></a>
<a name="IDX829"></a>
</dd><dt><code>length</code>
</dt><dd>
</dd><dt><code>max_length</code>
</dt><dd>
それぞれのメソッドは、カラムサイズの配列への参照を返す。<code>length</code> 配列は、
（テーブル記述で定義された）各カラムの利用可能最大値を示す。
<code>max_length</code> 配列は、テーブル中に実際に存在している最大値を示す。例：


<pre>$lengths = $sth-&gt;{length};
$max_lengths = $sth-&gt;{max_length};
</pre>

<a name="IDX830"></a>
<a name="IDX831"></a>
</dd><dt><code>NAME</code>
</dt><dd>
カラム名の配列への参照を返す。
例：

<pre>$names = $sth-&gt;{NAME};
</pre>

<a name="IDX832"></a>
<a name="IDX833"></a>
</dd><dt><code>table</code>
</dt><dd>
テーブル名の配列への参照を返す。
例：

<pre>$tables = $sth-&gt;{table};
</pre>

<a name="IDX834"></a>
<a name="IDX835"></a>
</dd><dt><code>type</code>
</dt><dd>
カラムの型の配列への参照を返す。
例：

<pre>$types = $sth-&gt;{type};
</pre>

</dd></dl>



<h3><a name="DBI-info" href="manual.ja_toc.html#DBI-info">20.5.2  <code>DBI</code>/<code>DBD</code> に関するそれ以上の情報</a></h3>

<p>
<code>DBI</code> に関するそれ以上の情報は <code>perldoc</code> コマンドで得られる。

</p>

<pre>perldoc DBI
perldoc DBI::FAQ
perldoc DBD::mysql
</pre>

<p>
他のフォーマットに変換するツール、<code>pod2man</code>, <code>pod2html</code> なども
使うことが出来る。

</p>
<p>
そしてもちろん、<code>DBI</code> の最新情報は <code>DBI</code> ウェッブページで見ることが出来る：

</p><pre><a href="http://www.symbolstone.org/technology/perl/DBI/index.html">http://www.symbolstone.org/technology/perl/DBI/index.html</a>
</pre>



<h2><a name="Eiffel" href="manual.ja_toc.html#Eiffel">20.6  <strong>MySQL</strong> Eiffel wrapper</a></h2>

<p>
The <strong>MySQL</strong> <a href="http://www.mysql.com/Contrib/">Contrib directory</a>
contains an Eiffel wrapper written by Michael Ravits

</p>
<p>
You can also find this at:
<a href="http://www.netpedia.net/hosting/newplayer/">http://www.netpedia.net/hosting/newplayer/</a>

</p>


<h2><a name="Java" href="manual.ja_toc.html#Java">20.7  <strong>MySQL</strong> Java connectivity (JDBC)</a></h2>

<p>
There are 2 supported JDBC drivers for MySQL (the twz and mm driver).
You can find a copy of these at <a href="http://www.mysql.com/Contrib">http://www.mysql.com/Contrib</a>.
For documentation consult any JDBC documentation and the
drivers own documentation for <strong>MySQL</strong> specific features.

</p>


<h2><a name="PHP" href="manual.ja_toc.html#PHP">20.8  <strong>MySQL</strong> PHP API</a></h2>

<p>
PHP is a server-side, HTML embedded scripting language that may be used to
create dynamic web pages.  It contains support for accessing several
databases, including <strong>MySQL</strong>.  PHP may be run as a separate program,
or compiled as a module for use with the Apache web server.

</p>
<p>
The distribution and documentation are available at the
<a href="http://www.php.net/"> PHP website</a>.

</p>


<h2><a name="Cplusplus" href="manual.ja_toc.html#Cplusplus">20.9  <strong>MySQL</strong> C++ APIs</a></h2>

<p>
Two API's is available in the <strong>MySQL</strong>
<a href="http://www.mysql.com/Contrib/">Contrib directory</a>.

</p>


<h2><a name="Python" href="manual.ja_toc.html#Python">20.10  <strong>MySQL</strong> Python APIs</a></h2>

<p>
The <strong>MySQL</strong> <a href="http://www.mysql.com/Contrib/">Contrib directory</a>
contains a Python
interface written by Joseph Skinner.

</p>
<p>
You can also use the Python interface to iODBC to access a
<strong>MySQL</strong> server.
<a href="http://starship.skyport.net/~lemburg/">mxODBC</a>

</p>


<h2><a name="TCL" href="manual.ja_toc.html#TCL">20.11  <strong>MySQL</strong> TCL APIs</a></h2>

<p>
<a href="http://www.binevolve.com/~tdarugar/tcl-sql/"> TCL at binevolve</a>.
The
<a href="http://www.mysql.com/Contrib">Contrib directory</a> contains a TCL
interface that is based on msqltcl 1.50.

</p>
<p></p><hr><p>
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_Common_problems.html">previous</a>, <a href="manual.ja_Comparisons.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
 
 
</p></body></html>