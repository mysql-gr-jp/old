  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 1 December 1999 -->

  <TITLE>MySQL Reference Manual for version 3.22.21. - 18  問題とよくあるエラー</TITLE>
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Common_programs.html">previous</A>, <A HREF="manual.ja_Common_problems.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Problems" HREF="manual.ja_toc.html#Problems">18  問題とよくあるエラー</A></H1>



<H3><A NAME="Crashing" HREF="manual.ja_toc.html#Crashing">18.0.1  <STRONG>MySQL</STRONG> がクラッシュする場合に行うこと</A></H3>

<P>
全ての <STRONG>MySQL</STRONG> バージョンはリリースの前に多くのプラットフォームで
テストされます。 これは <STRONG>MySQL</STRONG> にいかなるバグもないということを
意味しますが、発見するのが困難で、わずかなバグがあるかもしれません。
もし問題があった場合、何がシステムをクラッシュしているかを見つけようとする事は、
問題を早く修正するためのより良い機会でもあります。

</P>
<P>
まず最初に, その問題で <CODE>mysqld</CODE> デーモンが死ななければならないかどうかか, また
はその問題がクライアントで処理しなければならないかどうかを調べるべきです。
<CODE>mysqladmin version</CODE> を実行することにより、 <CODE>mysqld</CODE> サーバーが
どれぐらい稼働していたかわかります。 もし <CODE>mysqld</CODE> が死んでいたなら、
を実行することによってあるのかをチェックすることができます. mysqldが死んだなら、
その原因を <TT>`mysql-data-directory/'hostname'.err'</TT> で見つけれるかもしれません。

</P>
<P>
何かがクラッシュする理由を知るのは非常に難しいので、まず、他の人で動くも
のがあなたでクラッシュするのかどうかをチェックしてください。次のことを行っ
てください。

</P>

<UL>
<LI>

<CODE>mysqld</CODE> デーモンを <CODE>mysqladmin shutdown</CODE> で停止し, 全てのテーブルで
<CODE>myisamchk --silent --force */*.MYI</CODE> を実行し、そして <CODE>mysqld</CODE> デーモンを
再起動します.  これはきれいな状態から開始することになります。
 「<A HREF="manual.ja_Maintenance.html#Maintenance">13  Maintaining a <STRONG>MySQL</STRONG> installation</A>」節参照.

<LI>

<CODE>mysqld --log</CODE> を使用し、ログの情報から特定のクエリがサーバーをキルしているかを
見つけ出してください。 95% のバグは特定のクエリに関係があります！
通常これは、 <STRONG>MySQL</STRONG> が再起動される前の、ログファイルの最後のクエリの一つです。

これを、以下の手順で確認することも出来ます：


<UL>
<LI>

<STRONG>MySQL</STRONG> デーモンを ( <CODE>mysqladmin shutdown</CODE> で) 停止。
<LI>

<STRONG>MySQL</STRONG> データベースディレクトリをバックアップ。
<LI>

全てのテーブルが正しいのかを、<CODE>myisamchk -s */*.MYI</CODE> でチェック。
もしテーブルが壊れているようなら、
<CODE>myisamchk -r path-to-table.MYI</CODE> でそれを修正。
<LI>

ログファイルを <STRONG>MySQL</STRONG> データディレクトリから削除 (か 移動)。
<LI>

<CODE>safe_mysql --log</CODE> でサーバー起動。
<LI>

<CODE>mysqld</CODE> が死んだら、特定のクエリで問題が起こるかを、
バックアップからデータを戻し、 <CODE>mysql &#60; mysql-log-file</CODE> としてテストします。
もちろん、 <CODE>safe_mysqld --data=path-to-backup-directory</CODE> として
他の <STRONG>MySQL</STRONG> サーバーを標準の <STRONG>MySQL</STRONG> データディレクトリとは
違うディレクトリに指定しておいて起動し、最後のテストを行うことも可能です。
</UL>

<LI>

ベンチマークを試しましたか？ これは <STRONG>MySQL</STRONG> をより良くテストしま
す。あなたのアプリケーションをシミュレートするコードを追加することもでき
ます。ベンチマークはソース配布では <STRONG>MySQL</STRONG> インストールディレクト
リ配下の <TT>`bench'</TT> ディレクトリに、バイナリ配布では <TT>`sql-bench'</TT> 
ディレクトリに見つけられます。

<LI>

<CODE>fork_test.pl</CODE> と <CODE>fork2_test.pl</CODE> を試します。

<LI>

エラーがないか、<TT>`mysql-data-directory/'hostname'.err'</TT> ファイルを確認します。

<LI>

デバッグ用に <STRONG>MySQL</STRONG> をコンフィグすると、何かが悪くなる場合にエラー
を見つけ出すのがより簡単になります。<CODE>configure</CODE> に 
<CODE>--with-debug</CODE> オプションをつけて <STRONG>MySQL</STRONG> を再コンフィグし、
再コンパイルしてください。 「<A HREF="manual.ja_Porting.html#Debugging_server">G.1  MySQL server のデバッグ</A>」節参照.

<LI>

デバッグ用に <STRONG>MySQL</STRONG> をコンフィグすると、いくつかのエラーを検出で
きる安全なメモリ割り当てを含めます。これは何が起きているかについての多く
の出力も提供します。

<LI>

あなたの OS の最新のパッチを適用しましたか？

<LI>

<CODE>--skip-locking</CODE> オプションを <CODE>mysqld</CODE> に使用してください。い
くつかのシステム上では、<CODE>lockd</CODE> ロックマネージャは正しく動きません;
<CODE>--skip-locking</CODE> オプションは <CODE>mysqld</CODE> に外部ロッキングを使用
しないように伝えます。(これは同じデータ上で2つの <CODE>mysqld</CODE> サーバを
動すことができず、<CODE>myisamchk</CODE> の使用時に注意しなければいけないことを
意味します。しかし、テストとしてこのオプションを試すことは指示できます。)

<LI>

<CODE>mysqld</CODE> が動いているのに応答がないように見えた時 
<CODE>mysqladmin -u root processlist</CODE> を試しましたか？ 時々 
<CODE>mysqld</CODE> はそう思えても死んでいません。問題は全ての接続が使用中であ
ることか、いくつかの内部ロック問題があることです。<CODE>mysqladmin
processlist</CODE> は通常これらの場合でも接続を作ることができ、現在の接続数と
それらの状態についての有用な情報を提供できます。

<LI>

別のウィンドウで、統計出力のためにコマンド <CODE>mysqladmin -i 5 status</CODE> 
をクエリ中、行ってください。

<LI>

次を試してください:

<OL>
<LI>

<CODE>gdb</CODE> (または他のデバッガ) から <CODE>mysqld</CODE> を開始してください。

<LI>

あなたのテストスクリプトを実行してください。

<LI>

<CODE>mysqld</CODE> がコアダンプした時、<CODE>back</CODE> (またはあなたのデバッガの 
backtrace コマンド) を行ってください。
</OL>

<LI>

<STRONG>MySQL</STRONG> にクラッシュまたは間違った振る舞いをさせるあなたのアプリ
ケーションのシミュレートを Perl スクリプトで試みてください。

<LI>

または通常のバグレポートを送ってください。 「<A HREF="manual.ja_Questions.html#Bug_reports">2.3  バグや問題を報告する方法</A>」節参照。しかし通常
よりもさらに詳細にしてください。<STRONG>MySQL</STRONG> は多くの人のために働いて
いるため、クラッシュはあなたのコンピュータだけに存在する何か(例えば、あ
なたの特別なシステムライブラリに関連したエラー)から生じていると思われま
す。
<LI>

もし可変長のレコードを扱うテーブルで問題があった場合、
もし、<CODE>BLOB/TEXT</CODE> フィールドは使用しておらず、<CODE>VARCHAR</CODE> フィールド
だけ使用しているなら、全ての <CODE>VARCHAR</CODE> フィールドを
 <CODE>ALTER TABLE</CODE> で <CODE>CHAR</CODE> に変更してみてください。
これは <STRONG>MySQL</STRONG> に固定長レコードを使用させるようにします。
固定長レコードは少し余分な領域をとりますが、よりエラーに対して
強くなります。

現在の可変長のレコードのコードは TCX で少なくとも３年以上問題なく
使用されています。 しかし可変長のレコードはよりエラーの傾向があり、
上記の事柄を試すことは良いアイデアです！
</UL>



<H2><A NAME="Common_errors" HREF="manual.ja_toc.html#Common_errors">18.1  <STRONG>MySQL</STRONG>使用時のよくあるいくつかのエラー</A></H2>



<H3><A NAME="Gone_away" HREF="manual.ja_toc.html#Gone_away">18.1.1  <CODE>MySQL server has gone away</CODE> エラー</A></H3>

<P>
このセクションは <CODE>Lost connection to server
during query</CODE> エラーに関することもカバーします。

</P>
<P>
<CODE>MySQL server has gone away</CODE> エラーのもっとも一般的な理由は、サーバ
がタイムアウトで接続をクローズしたことです。デフォルトでは、何も起きない
場合、サーバは 8 時間後に接続をクローズします。
この時間は mysqld 起動時の <CODE>wait_timeout</CODE> 変数に与えることにより、変更できます。

</P>
<P>
<CODE>mysqladmin version</CODE> を実行することで <STRONG>MySQL</STRONG> が死んでいるかどうか、
また uptime はどれぐらいか、チェックできます。

</P>
<P>
スクリプトの場合は、自動的に再接続するためにクライアントからクエリを再発
行する必要があります。

</P>
<P>
この場合、通常これらのエラーコードを得ます:
(OS 依存です):

</P>
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR><TD><CODE>CR_SERVER_GONE_ERROR</CODE> </TD><TD> クライアントがサーバーに問い合わせを送ることができなかった
</TR NOSAVE>
<TR><TD><CODE>CR_SERVER_LOST</CODE> </TD><TD> クライアントがサーバーに書き込みを行ったときにはエラーは無かったけれども、問い合わせに対して完全に回答が返ってこない
</TR>
</TABLE>

<P>
間違っているか大きすぎるクエリをサーバに送った場合にもこのエラーが発生し
ます。<CODE>mysqld</CODE> が間違ったブロックを得た場合、クライアントの何かが間違った
と見なし、接続をクローズします。大きなクエリが必要な場合、例えば大きな 
<CODE>BLOB</CODE> で働かせる場合は、<CODE>mysqld</CODE> をオプション <CODE>-O max_query_size=#</CODE>
(デフォルト 1M) で起動することでクエリ制限を増加できます。拡張メモリ
は要求によって割り当てられます。そのため、<CODE>mysqld</CODE> は大きなクエリを発行し
た時や大きな結果行を返す必要のある時だけ、多くのメモリを使用します！

</P>



<H3><A NAME="Can_not_connect_to_server" HREF="manual.ja_toc.html#Can_not_connect_to_server">18.1.2  <CODE>Can't connect to [local] MySQL server</CODE> エラー</A></H3>

<P>
<STRONG>MySQL</STRONG> クライアントは  <CODE>mysqld</CODE> サーバに2つの異なる方法で接続できま
す: Unix ソケット, これはファイルシステム上のファイル(デフォルト 
<TT>`/tmp/mysql.sock'</TT>)を通して接続します。または TCP/IP, これはポート番
号を通して接続します。Unix ソケットは TCP/IP よりも速いですが、サーバと
同じコンピュータから接続する時しか使えません。Unix ソケットは、ホスト名
を指定しない場合か、特別なホスト名 <CODE>localhost</CODE> を指定した場合に使用され
ます。

</P>
<P>
(2002) <CODE>Can't connect to ...</CODE> エラーは、通常、<STRONG>MySQL</STRONG> サーバーが
システム上に走っていないか、あなたが、間違ったソケットファイルや
TCP/IP ポートを使用して <CODE>mysqld</CODE> に接続しようとする場合におきます。

</P>
<P>
Start by check 
サーバー上に <CODE>mysqld</CODE> というプロセスが走っているか ( <CODE>ps</CODE> を使用して)
確認することから開始してください！
 「<A HREF="manual.ja_Installing.html#Starting_server">4.15.2  <STRONG>MySQL</STRONG> サーバー起動時の問題</A>」節参照.

</P>
<P>
<CODE>mysqld</CODE> プロセスが走っているなら、違う接続を試すことでサーバーを
確認することができます（もちろん、ポート番号とソケットのパスはあなたが
セットアップしたものとは違うでしょう）：

</P>

<PRE>
shell&#62; mysqladmin version
shell&#62; mysqladmin variables
shell&#62; mysqladmin -h `hostname` version variables
shell&#62; mysqladmin -h `hostname` --port=3306 version
shell&#62; mysqladmin -h 'ip for your host' version
shell&#62; mysqladmin --socket=/tmp/mysql.sock version
</PRE>

<P>
<CODE>hostname</CODE> コマンドはフォワードクオートでなくバッククオテーションで
囲んでいることに注意してください； これは <CODE>ホスト名</CODE> (カレントのホスト名) 
を <CODE>mysqladmin</CODE> コマンドに与えます。

</P>
<P>
<CODE>Can't connect to local MySQL server</CODE> エラーが起こりうる理由として：

</P>

<UL>
<LI><CODE>mysqld</CODE> is not running.

<LI>MIT-pthreads を使用するシステム上で実行している。

ネイティブスレッドを持たないシステム上で実行している場合 <CODE>mysqld</CODE> は  MIT-pthreads パッケージを使用します。
 「<A HREF="manual.ja_Installing.html#Which_OS">4.2  <STRONG>MySQL</STRONG> がサポートする OS</A>」節参照.
MIT-pthreads スレッドはソケットをサポートしません。
そのため、サーバに接続する時は常にホスト名を与える必要があります。
サーバーへの接続をチェックするために、以下を試してください：

<PRE>
shell&#62; mysqladmin -h `hostname` version
</PRE>

<LI>誰かが <CODE>mysqld</CODE> が使用する unix ソケット を削除した (default <TT>`/tmp/mysqld.sock'</TT>).

だれかが <CODE>cron</CODE> で <STRONG>MySQL</STRONG> ソケットを削除しているかもしれません。(例えば <TT>`/tmp'</TT> ディレクトリから古いファイルを削除するようなクローンで)。
いつでも <CODE>mysqladmin version</CODE> を実行して
<CODE>mysqladmin</CODE> が使用するソケットが本当に存在するかをチェックできます。
この場合の修正は、<TT>`mysqld.sock'</TT> を消さないように <CODE>cron</CODE> を変更するか、またはソケットをどこか他の場所に移すことです。

<STRONG>MySQL</STRONG> を ./configure する場合にソケットを指定するには以下のようにします:

<PRE>
shell&#62; ./configure --with-unix-socket-path=/path/to/socket
</PRE>

また、<CODE>safe_mysqld</CODE> を <CODE>--socket=/path/to/socket</CODE> オプションを指定して起動しても構いませんし、
<CODE>MYSQL_UNIX_PORT</CODE> 環境変数をセットして <STRONG>MySQL</STRONG> クライアントを実行してもかまいません。

<LI><CODE>--socket=/path/to/socket</CODE> オプションで <CODE>mysqld</CODE> サーバーを起動できます。

もしサーバーのソケットのパスを変えた場合、<STRONG>MySQL</STRONG> クライアントに、新しいパスを教えなければなりません。
この場合、 <CODE>MYSQL_UNIX_PORT</CODE> 環境変数に設定することにより可能です。
ソケットのテストをする場合、以下のようにします：


<PRE>
shell&#62; mysqladmin --socket=/path/to/socket version
</PRE>

<LI>

Linux を使用していてスレッドが一つ死んだとき（コアダンプした）。
この場合、他の <CODE>mysqld</CODE> スレッドをキルしなければなりません。
たとえば、<CODE>mysql_zap</CODE> スクリプトを、新しく <STRONG>MySQL</STRONG> サーバーを
起動する前に実行します。  「<A HREF="manual.ja_Problems.html#Crashing">18.0.1  <STRONG>MySQL</STRONG> がクラッシュする場合に行うこと</A>」節参照.
</UL>

<P>
もし <CODE>Can't connect to MySQL server on some_hostname</CODE> エラーの場合,
何が問題なのかを見つけるために、以下の手順を踏みます：

</P>

<UL>
<LI>

もし <CODE>telnet your-host-name tcp-ip-port-number</CODE> を実行すると
サーバーがアップするなら、 <CODE>RETURN</CODE> を何回かたたいてください。
もしこのポートで <STRONG>MySQL</STRONG> サーバーが走っているなら、
走っている <STRONG>MySQL</STRONG> サーバーのバージョンナンバーを含んだ
レスポンスが得られるはずです。
もし <CODE>telnet: Unable to connect to remote host: Connection refused</CODE> のような
エラーになったならば、このポートを使用しているサーバーはありません。

<LI>

ローカルのマシンの <CODE>mysqld</CODE> デーモンに接続してみてください。
<CODE>mysqld</CODE> が使用するように指定された TCP/IP ポートをチェックしてください。
（<CODE>mysqladmin variables</CODE> で得られる <CODE>port</CODE> 変数）

<LI>

<CODE>mysqld</CODE> サーバーが <CODE>--skip-networking</CODE> オプションで起動されていないか
確認してください。
</UL>



<H3><A NAME="Blocked_host" HREF="manual.ja_toc.html#Blocked_host">18.1.3  <CODE>Host '...' is blocked</CODE> エラー</A></H3>

<P>
以下のエラーの場合：

</P>

<PRE>
Host 'hostname' is blocked because of many connection errors.
Unblock with 'mysqladmin flush-hosts'
</PRE>

<P>
これは <CODE>mysqld</CODE> が多くの <CODE>'hostname'</CODE> ホストからの接続エラー(<CODE>max_connect_errors</CODE>)
を受けた場合に発生します。
この <CODE>max_connect_errors</CODE> 大量発生後、<CODE>mysqld</CODE> は何か(クラッカーによるサーバーへのアタックなど)が起こったと判断し、このホストからの接続をいっさい拒否するようにします。
これを解除するには、<CODE>mysqladmin flush-hosts</CODE> コマンドを実行します。

</P>
<P>
デフォルトでは、10回の接続エラーが発生した場合に、<CODE>mysqld</CODE> はそのホストを拒否します。
この値は以下のようにして簡単に変更できます：

</P>

<PRE>
shell&#62; safe_mysqld -O max_connect_errors=10000 &#38;
</PRE>

<P>
もしこのエラーがあるホストに対して発生するならば、まず最初にそのホストからの TCP/IP 接続に不具合がないかチェックしてください。
もし TCP/IP 接続が動作していないようなら、 <CODE>max_connect_errors</CODE> 値を増やすことはよくないことです！

</P>


<H3><A NAME="Out_of_memory" HREF="manual.ja_toc.html#Out_of_memory">18.1.4  <CODE>Out of memory</CODE> エラー</A></H3>

<P>
クエリを行って、次のエラーのようなものを得た場合:

</P>

<PRE>
mysql: Out of memory at line 42, 'malloc.c'
mysql: needed 8136 byte (8k), memory in use: 12481367 bytes (12189k)
ERROR 2008: MySQL client ran out of memory
</PRE>

<P>
エラーは <STRONG>MySQL</STRONG> クライアント <CODE>mysql</CODE> に関係することに注意してください。エ
ラーの理由は単純で、クライアントが結果全体を格納するのに十分なメモリを持っ
ていないことです。

</P>
<P>
この問題を解決するにあたり、まず最初にクエリーが正しいか確認してください。
そのクエリーは大量の結果を返すものでしょうか？
もしそうなら、<CODE>mysql --quick</CODE> を使用してください。
これは結果を取り出すために <CODE>mysql_use_result()</CODE> を使用します。
これはクライアントのロード不足を補います(サーバーより多い領域は取れません)。

</P>


<H3><A NAME="Packet_too_large" HREF="manual.ja_toc.html#Packet_too_large">18.1.5  <CODE>Packet too large</CODE> エラー</A></H3>

<P>
<STRONG>MySQL</STRONG> クライアントが <CODE>max_allowed_packet</CODE> よりも大きなブロックを <CODE>mysqld</CODE> サーバーから得た時、<CODE>Packet too large</CODE> エラーを発します。

</P>
<P>
<CODE>mysql</CODE> クライアントを使用する場合、<CODE>mysql --set-variable=max_allowed_packet=8M</CODE>
 でクライアントを開始することで、バッファを大きく設定できます。

</P>
<P>
もし(<CODE>DBI</CODE> のように)最大パケットサイズを指定できないクライアントを使用している場合、
パケットサイズを指定してサーバーを立ち上げ直します。
これは <CODE>mysqld</CODE> のオプションの <CODE>max_allowed_packet</CODE> に大きな値を設定することで行います。
例えば、 <CODE>BLOB</CODE> 型の許容範囲いっぱいのデータをテーブルに入れる場合、
<CODE>--set-variable=max_allowed_packet=24M</CODE> オプションを指定してサーバーを起動する必要があります。

</P>
<P>
<A NAME="IDX683"></A>


<H3><A NAME="Full_table" HREF="manual.ja_toc.html#Full_table">18.1.6  <CODE>The table is full</CODE> エラー</A></H3>

<P>
このエラーはメモリ内一時テーブルが <CODE>tmp_table_size</CODE> よりも大きくなっ
た時に発生します。この問題を回避するために、<CODE>mysqld</CODE> のオプション <CODE>-O
tmp_table_size=#</CODE> で増加、または、SQL オプション <CODE>SQL_BIG_TABLES</CODE> 
を問題のクエリの前に使用できます。 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.25  <CODE>SET OPTION</CODE> 構文</A>」節参照.

</P>
<P>
<CODE>mysqld</CODE> を <CODE>--big-tables</CODE> オプション指定して起動します。
これは全てのクエリーに対して <CODE>SQL_BIG_TABLES</CODE> を使用するのと同じです。

</P>
<P>
<A NAME="IDX684"></A>


<H3><A NAME="Commands_out_of_sync" HREF="manual.ja_toc.html#Commands_out_of_sync">18.1.7  <CODE>Commands out of sync</CODE> error in client</A></H3>

<P>
<CODE>Commands out of sync; You can't run this command now</CODE> をクライアン
トコード中で得た場合、クライアント関数を間違った順番で呼び出しました！

</P>
<P>
これは例えば、<CODE>mysql_use_result()</CODE> を使用していて、<CODE>mysql_free_result()</CODE>
を行う前に新しいクエリの実行を試みた場合に発生します。これはまた、データ
を返す２つのクエリの実行を、間に <CODE>mysql_use_result()</CODE> や 
<CODE>mysql_store_result()</CODE> 無しで試みた場合にも発生します。

</P>



<H3><A NAME="Ignoring_user" HREF="manual.ja_toc.html#Ignoring_user">18.1.8  <CODE>Ignoring user</CODE> エラー</A></H3>

<P>
以下のエラーの場合：

</P>
<P>
<CODE>Found wrong password for user: 'some_user@some_host'; Ignoring user</CODE>

</P>
<P>
これは <CODE>mysqld</CODE> の開始または 'reload' 時に <CODE>user</CODE> テーブル内に正しいパスワー
ドを持たないエントリを見つけたことを意味します。
これは単にエントリが許可システムに拒否されているだけです。

</P>
<P>
起こり得ることとその解決:

</P>

<UL>
<LI>

新しいバージョンの <CODE>mysqld</CODE> を、古いバージョン用の <CODE>user</CODE> テーブルで走らせているのかもしれません。
<CODE>mysqlshow mysql user</CODE> を行うことによってこれを検証できます。
パスワードフィールドが 16 文字よりも短いかどうかをチェックしてください。
もしそうなら、これを修正するために、<CODE>scripts/add_long_password</CODE> スクリプトを実行してください。

<LI>

ユーザーが古いパスワード(最大8文字) を使用していて、<CODE>mysqld</CODE> を <CODE>--old-protocol</CODE> オプションで起動していないのかもしれません。
新しいパスワードで <CODE>user</CODE> テーブル内のユーザを更新するか、<CODE>--old-protocol</CODE>
付きで <CODE>mysqld</CODE> を再起動してください。

<LI>

<A NAME="IDX685"></A>
<CODE>user</CODE> テーブルのパスワードを、<CODE>PASSWORD()</CODE> 関数を使用しないで登録したのかもしれません。
この場合、<CODE>user</CODE> テーブルのパスワードを、<CODE>mysql</CODE> を使用して更新します。
<CODE>PASSWORD()</CODE> 関数は以下のようにして使用します：


<PRE>
mysql&#62; update user set password=PASSWORD('your password')
           where user='XXX';
</PRE>

</UL>



<H3><A NAME="Cannot_find_table" HREF="manual.ja_toc.html#Cannot_find_table">18.1.9  <CODE>Table 'xxx' doesn't exist</CODE> error</A></H3>

<P>
もし <CODE>Table 'xxx' doesn't exist</CODE> か <CODE>Can't find file: 'xxx' (errno: 2)</CODE>
 エラーが出た場合、使用しているデータベースに  <CODE>xxx</CODE> という名前のテーブルが
見付からなかったことを示します

</P>
<P>
データベースとテーブルの保存に、<STRONG>MySQL</STRONG> はディレクトリとファイルを使用し、
データベースとテーブルの名前は<STRONG>ケース依存</STRONG>です!
(Win32 ではデータベースとテーブル名はケース非依存です。
クエリ中のテーブルに対する問い合わせは全て、同じケースで書かなくてはなりません！)

</P>
<P>
<CODE>SHOW TABLES</CODE> を使用してデータベースのテーブルを確認できます.  「<A HREF="manual.ja_Reference.html#SHOW">7.21  <CODE>SHOW</CODE> 構文 (テーブルやフィールドなどについての情報を得る)</A>」節参照.

</P>
<P>
<A NAME="IDX686"></A>
<A NAME="IDX687"></A>


<H2><A NAME="Full_disk" HREF="manual.ja_toc.html#Full_disk">18.2  <STRONG>MySQL</STRONG> はフルディスクをどのように扱うか？</A></H2>

<P>
ディスクフルが起きた場合 <STRONG>MySQL</STRONG> は次のことを行います:

</P>

<UL>
<LI>

現在の行を書くのに十分な領域があるかどうかを1分毎に1回チェックします。十
分なディスクがある場合は、何も起きなかったように継続します。
<LI>

6分毎にログファイルにディスクフルを警告するエントリを書き出します。
</UL>

<P>
この問題の場合、以下のようにします：

</P>

<UL>
<LI>

継続するためには、全てのレコードを挿入するのに十分な領域を解放する必要が
あります。
<LI>

スレッドをアボートするためには、<CODE>mysqladmin kill</CODE> をスレッドに送る
必要があります。スレッドは次に(1分)ディスクをチェックした時にアボートし
ます。
<LI>

他のスレッドが ``disk full'' が発生したテーブルで待たされることに注意して
ください。多くの ``locked'' スレッドがある場合、disk full を待つ一つのスレッ
ドを kill することで、他のスレッドの継続を許します。
</UL>



<H2><A NAME="Multiple_sql_commands" HREF="manual.ja_toc.html#Multiple_sql_commands">18.3  テキストファイルから SQL コマンドを実行</A></H2>

<P>
<CODE>mysql</CODE> クライアントは以下のようにして対話的に使用します：

</P>

<PRE>
shell&#62; mysql database
</PRE>

<P>
しかし SQL コマンドをファイルに書いておき、それを <CODE>mysql</CODE> に読み込ませることができます。
テキストファイル <TT>`text_file'</TT> に実行したいコマンドを書いておき、
以下のようにして <CODE>mysql</CODE> を起動します：

</P>

<PRE>
shell&#62; mysql database &#60; text_file
</PRE>

<P>
テキストファイルの先頭に <CODE>USE db_name</CODE> 構文を書くこともできます。
この場合、データベース名をコマンドラインに与える必要は無く、以下のようにできます：

</P>

<PRE>
shell&#62; mysql &#60; text_file
</PRE>

<P>
 「<A HREF="manual.ja_Tools.html#Programs">12.1  様々な <STRONG>MySQL</STRONG> プログラムの概要</A>」節参照.

</P>



<H2><A NAME="Temporary_files" HREF="manual.ja_toc.html#Temporary_files">18.4  <STRONG>MySQL</STRONG> が一時ファイルを格納する場所</A></H2>

<P>
<STRONG>MySQL</STRONG> は一時ファイルを格納する場所として <CODE>TMPDIR</CODE> 環境変数の値を
使用します。<CODE>TMPDIR</CODE> を設定していなければ、<STRONG>MySQL</STRONG> はシステムのデフォ
ルトを使用します。通常は <TT>`/tmp'</TT> または <TT>`/usr/tmp'</TT> です。<CODE>TMPDIR</CODE> が小さ
すぎる場合、<CODE>safe_mysqld</CODE> を編集して、十分な領域がある他のディレクトリを指
すように <CODE>TMPDIR</CODE> を設定すべきです！
<CODE>--tmpdir</CODE> オプションを <CODE>mysqld</CODE> に与えることで、一時ファイルディレクトリを指定することも可能です。

</P>
<P>
<STRONG>MySQL</STRONG> は全ての一時ファイルを ``隠しファイル'' として生成します。
これは <CODE>mysqld</CODE> が終了した場合に、一時ファイルが削除されないことを確実にし
ます。隠しファイルを使用する '悪い' 側面は、小さすぎる一時ディスクを一杯
にする大きな一時ファイルを見つけられないことです。

</P>
<P>
ソート時 (<CODE>ORDER BY</CODE> または <CODE>GROUP BY</CODE>)、<STRONG>MySQL</STRONG> は通常一つまたは二つ
の一時ファイルを使用します。必要な最大のディスク容量は:

</P>

<PRE>
(length of what is sorted + sizeof(database pointer))
* number of matched rows
* 2
</PRE>

<P>
<CODE>sizeof(database_pointer)</CODE> は通常４ですが、将来本当に大きなテーブル
のために大きくなることもあります。

</P>
<P>
いくつかの <CODE>SELECT</CODE> クエリは一時的な SQL テーブルも生成します。これらは隠
しファイルではなく、<TT>`SQL_*'</TT> という名前です。

</P>
<P>
<CODE>ALTER TABLE</CODE> , <CODE>OPTIMIZE TABLE</CODE> は一時テーブルをオリジナルテーブルと同じディレクトリ
内に生成します。

</P>



<H2><A NAME="Problems_with_mysql.sock" HREF="manual.ja_toc.html#Problems_with_mysql.sock">18.5  <TT>`/tmp/mysql.sock'</TT> を削除から守る方法</A></H2>

<P>
もし誰かに <STRONG>MySQL</STRONG> のソケットファイル <TT>`/tmp/mysql.sock'</TT> が消されるなら、
ほとんどの Unix がそうであるように、 <TT>`/tmp'</TT> に <CODE>sticky</CODE> ビットをたてて保護します。
<CODE>root</CODE> でログインして、以下のようにします：

</P>

<PRE>
shell&#62; chmod +t /tmp
</PRE>

<P>
これはファイルのオーナーとスーパーユーザー(<CODE>root</CODE>) のみが、
 <TT>`/tmp'</TT> のファイルを消すことができます。

</P>
<P>
<CODE>sticky</CODE> ビットが立っているか確認するには、 <CODE>ls -ld /tmp</CODE> を行います。
パーミッションの最後のビットが <CODE>t</CODE> ならば、セットされています。

</P>


<H2><A NAME="Error_Access_denied" HREF="manual.ja_toc.html#Error_Access_denied">18.6  <CODE>Access denied</CODE> エラー</A></H2>

<P>
 「<A HREF="manual.ja_Privilege_system.html#Privileges">6.5  特権システムはどのように動くか？</A>」節参照.　 「<A HREF="manual.ja_Privilege_system.html#Access_denied">6.12  何故 <CODE>Access denied</CODE> エラーになるのか</A>」節参照.

</P>



<H2><A NAME="Changing_MySQL_user" HREF="manual.ja_toc.html#Changing_MySQL_user">18.7  一般ユーザで <STRONG>MySQL</STRONG> を動かす方法</A></H2>

<P>
<CODE>mysqld</CODE> (<STRONG>MySQL</STRONG> サーバ) は誰でも開始し実行することができます。
<CODE>mysqld</CODE> をユーザ <CODE>user_name</CODE> で実行するように変更するためには、次を行なう必要が
あります:

</P>

<OL>
<LI>

サーバーを止めます (use <CODE>mysqladmin shutdown</CODE>).

<LI>

<CODE>user_name</CODE> が読み書きできるように、データベースディレクトリとその中のファイルのパーミッションを変更します。(これは Unix <CODE>root</CODE> ユーザーで実行する必要があるでしょう)：


<PRE>
shell&#62; chown -R user_name /path/to/mysql/datadir
</PRE>

<STRONG>MySQL</STRONG> データベースディレクトリのディレクトリーやファイルがシンボリックリンクの場合、
これらリンクの先のディレクトリとファイルも変更します。<CODE>chown -R</CODE> はシンボリックリンク先を変更してくれません。

<LI>

ユーザ <CODE>user_name</CODE> でサーバを起動します。または <STRONG>MySQL</STRONG> 3.22 以降を使用する
場合は、<CODE>mysqld</CODE> を Unix <CODE>root</CODE> で起動し <CODE>--user=user_name</CODE> スイッチを使用します。
<CODE>mysqld</CODE> は、接続を許可する前に、与えられた Unix user <CODE>user_name</CODE> で実行するように切り替えます。

<LI>

システム再起動時、 <CODE>mysql.server</CODE> を使用して <CODE>mysqld</CODE> を起動する場合、ユーザ 
<CODE>user_name</CODE> への <CODE>su</CODE> を行なうようにまたは <CODE>--user</CODE> スイッチを使用して <CODE>mysqld</CODE> を起動するように <CODE>mysql.server</CODE> を 変更すべきです。
(No changes to <CODE>safe_mysqld</CODE> are necessary.)
</OL>

<P>
この時点で、あなたの <CODE>mysqld</CODE> プロセスは Unix user <CODE>user_name</CODE> で正常に動作します。

</P>
<P>
一つのことは変わりません。それは特権許可テーブルです。デフォルト 
(パーミッションテーブルインストールスクリプト<CODE>mysql_install_db</CODE>実行後の権限) では、<CODE>mysql</CODE>データベースへのアクセスやデータベースの作成、破棄はユーザ <STRONG>MySQL</STRONG> user <CODE>root</CODE> だけです。
これを変更しないと、それはそのままです。
<CODE>root</CODE> 以外のUnix userでログインしている時でも、あなたは 
<STRONG>MySQL</STRONG> <CODE>root</CODE> user としてアクセスは可能です - ただプログラムに <CODE>-u root</CODE> をクライアントプログラムにオプション指定するだけです。

</P>
<P>
<STRONG>MySQL</STRONG> に <CODE>root</CODE> としてアクセスするには、
コマンドラインで <CODE>-u root</CODE> を使用するだけでいいことに注意してください。
Unix <CODE>root</CODE> user や <STRONG>MySQL</STRONG> を走らせている Unix ユーザーである必要は<EM>ない</EM>ことに注意してください。
<STRONG>MySQL</STRONG> のアクセスパーミッションと<STRONG>MySQL</STRONG> のユーザは、
UNIX ユーザとは完全に別のものです。UNIX ユーザに関係するのは、クライアン
トに <CODE>-u</CODE> オプションを使用しない場合だけです。この場合、クライアントは
<STRONG>MySQL</STRONG> へのログインを、あなたの UNIX ログイン名で試みます。

</P>
<P>
あなたの UNIX マシンそれ自身が安全でない場合は、少なくとも <STRONG>MySQL</STRONG> ア
クセステーブルの <STRONG>MySQL</STRONG> <CODE>root</CODE> ユーザにはパスワードを設定すべきです。
どこかの誰かが <CODE>mysql -u root db_name</CODE> を行ない、彼が望むことの全てを実行できてしまうからです。

</P>



<H2><A NAME="Resetting_permissions" HREF="manual.ja_toc.html#Resetting_permissions">18.8  忘れたパスワードをリセットする</A></H2>

<P>
もし <STRONG>MySQL</STRONG> の <CODE>root</CODE> ユーザーのパスワードを忘れた場合、
これを以下のようにして入れ直すことが可能です。

</P>

<OL>
<LI>

<CODE>mysqld</CODE> サーバーを <CODE>kill</CODE> で落とす。
(<CODE>kill -9</CODE> ではありません！)
PID 番号は通常 <STRONG>MySQL</STRONG> データディレクトリに <CODE>.pid</CODE> ファイルとして
書かれています：


<PRE>
kill `cat /mysql-data-directory/hostname.pid`
</PRE>

 
これを、 UNIX <CODE>root</CODE> ユーザーか、<STRONG>MySQL</STRONG> サーバーを実行した
ユーザーで行います。
 
<LI>

<CODE>mysqld</CODE> を <CODE>--skip-grant-tables</CODE> オプションで起動。

<LI>

<CODE>mysql -h hostname mysql</CODE> で<CODE>mysqld</CODE> サーバーに接続し、
<CODE>GRANT</CODE> コマンドでパスワードを変更します。  「<A HREF="manual.ja_Reference.html#GRANT">7.26  <CODE>GRANT</CODE> と <CODE>REVOKE</CODE> 構文</A>」節参照.
<CODE>mysqladmin -h hostname -u user password 'new password'</CODE> 
でも変更可能です。

<LI>

許可テーブルを読み込みます：
<CODE>mysqladmin -h hostname flush-privileges</CODE> か、SQL 文の
<CODE>FLUSH PRIVILEGES</CODE> を実行します。
</OL>



<H2><A NAME="File_permissions" HREF="manual.ja_toc.html#File_permissions">18.9  ファイルパーミッションの問題</A></H2>

<P>
ファイルパーミッションの問題がある場合、
例えば、テーブルの生成時に <CODE>mysql</CODE> が次を出力する場合:

</P>

<PRE>
ERROR: Can't find file: 'path/with/filename.frm' (Errcode: 13)
</PRE>

<P>
<A NAME="IDX688"></A>
<A NAME="IDX689"></A>
これは <CODE>UMASK</CODE> 環境変数が <CODE>mysqld</CODE> 起動時に間違ってセットされていると考えられます。
デフォルトの umask は <CODE>0660</CODE> です. 
これは以下のようにして <CODE>safe_mysqld</CODE> 立ち上げ時に変更できます:

</P>

<PRE>
shell&#62; UMASK=384  # = 600 in octal
shell&#62; export UMASK
shell&#62; /path/to/safe_mysqld &#38;
</PRE>



<H2><A NAME="Not_enough_file_handles" HREF="manual.ja_toc.html#Not_enough_file_handles">18.10  File not found</A></H2>

<P>
<CODE>ERROR '...' not found (Errcode: 23)</CODE>, <CODE>Can't open file: ... (errno: 24)</CODE>
 や <CODE>errcode 23</CODE> <CODE>errno 24</CODE> のエラーを <STRONG>MySQL</STRONG> から得た場合、
これは <STRONG>MySQL</STRONG> に十分なファイル記述子が割り当てられなかったことを意味します。
<CODE>perror #</CODE> はさらに読みやすい形式のエラーメッセージを与えます:

</P>

<PRE>
shell&#62; perror 23
File table overflow
shell&#62; perror 24
Too many open files
</PRE>

<P>
これは <CODE>mysqld</CODE> が多くのファイルを開こうとしたことに起因します。
<CODE>mysqld</CODE> に一度に開くファイル数を多く開かないようしたり、あるいは、
<CODE>mysqld</CODE> が扱えるファイル記述子の数を与えたりできます。

</P>
<P>
<CODE>mysqld</CODE> が一度に開くファイルの数を少なくするには、<CODE>-O table_cache=32</CODE> オプション(デフォルトは64)を <CODE>safe_mysqld</CODE> に与えることで可能です。
また、<CODE>max_connections</CODE> の値(デフォルトは90)を少なくするならば、開くファイル数も少なくできます。

</P>
<P>
<A NAME="IDX690"></A>
<CODE>mysqld</CODE> が取り扱えるファイル記述子の数を変更するには、 <CODE>safe_mysqld</CODE> を編集します。
この中に <CODE>ulimit -n 256</CODE> がコメントアウトされています。
このコメントをはずし(<CODE>'#'</CODE>文字を消す)、256 を <CODE>mysqld</CODE> が扱う数に変更してください。

</P>
<P>
<CODE>ulimit</CODE> はオペレーティングシステムの制限内でしかファイル記述子の数を指定できません。
もし OS の制限以上にファイル記述子のオープン数を増やしたい場合、
お使いのオペレーティングシステムのドキュメントを見て対処してください。

</P>
<P>
<CODE>tcsh</CODE> を使用している場合は <CODE>ulimit</CODE> は動かないことに注意してください！
<CODE>tcsh</CODE> は現在の制限をあなたが問い合わせても、違った値を報告するでしょう。
この場合、<CODE>safe_mysqld</CODE> は <CODE>sh</CODE> で起動すべきです！

</P>



<H2><A NAME="Using_DATE" HREF="manual.ja_toc.html#Using_DATE">18.11  <CODE>DATE</CODE> フィールド使用時の問題</A></H2>

<P>
日付 <CODE>DATE</CODE> の形式は <CODE>'YYYY-MM-DD'</CODE> です。ANSI SQL に従って実際には他のは許されま
せん。更新または <CODE>SELECT</CODE> 文中の WHERE 節内ではこの形式を使用すべきです。すなわち:

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE date &#62;= '1997-05-05';
</PRE>

<P>
利便のため <STRONG>MySQL</STRONG> は、日付が数値の文脈で使用されると、日付を自動的に数
値に変換します。これにより、更新と <CODE>TIMESTAMP</CODE>, <CODE>DATE</CODE> または 
<CODE>DATETIME</CODE> フィールドでの <CODE>WHERE</CODE> 時に、わりと自由に日付を指定することができます。
(この記述を許すため、句読記号を日付のセパレーターとして使用します。
例えば、<CODE>'1998-08-15'</CODE> と <CODE>'1998#08#15'</CODE> は同一です.)
もしろんセパレーターのない記述(例：<CODE>'19980815'</CODE>)も日付として変換してくれます。

</P>
<P>
特別な日付 <CODE>'0000-00-00'</CODE> は <CODE>'0000-00-00'</CODE> として格納され取り出されます。
<STRONG>MyODBC</STRONG> を通して <CODE>'0000-00-00'</CODE> 日付を使用する時、<STRONG>MyODBC</STRONG> 2.50.12 以上では自
動的に <CODE>NULL</CODE> に変換されます。ODBC はこの日付の種類を扱えないためです。

</P>
<P>
これは次が動くことを意味します:

</P>

<PRE>
mysql&#62; INSERT INTO tbl_name (idate) VALUES (19970505);
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('19970505');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('97-05-05');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('1997.05.05');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('1997 05 05');
mysql&#62; INSERT INTO tbl_name (idate) VALUES ('0000-00-00');

mysql&#62; SELECT idate FROM tbl_name WHERE idate &#62;= '1997-05-05';
mysql&#62; SELECT idate FROM tbl_name WHERE idate &#62;= 19970505;
mysql&#62; SELECT mod(idate,100) FROM tbl_name WHERE idate &#62;= 19970505;
mysql&#62; SELECT idate FROM tbl_name WHERE idate &#62;= '19970505';
</PRE>

<P>
次は動きません:

</P>

<PRE>
mysql&#62; SELECT idate FROM tbl_name WHERE STRCMP(idate,'19970505')=0;
</PRE>

<P>
<CODE>STRCMP()</CODE> は文字列関数で、<CODE>idate</CODE> を文字に変換して、文字比較を行います。
<CODE>'19970505'</CODE> は日付には変換してくれず、日付の比較も行いません。

</P>
<P>
<STRONG>MySQL</STRONG> は日付が正しいかどうかをチェックしないことに注意してくだ
さい。間違った日付(例えば <CODE>'1998-2-31'</CODE>)を格納すると、その間違った日付が格納
されます。日付が全体的に不可能な場合、<CODE>0</CODE> が <CODE>DATE</CODE> フィールドに格納されます。
これは主に速度の問題で、日付のチェックはサーバではなくアプリケーションでと我々
は考えています。

</P>
<P>
<A NAME="IDX691"></A>
<A NAME="IDX692"></A>
<A NAME="IDX693"></A>


<H2><A NAME="Timezone_problems" HREF="manual.ja_toc.html#Timezone_problems">18.12  Timezone problems</A></H2>

<P>
もし <CODE>SELECT NOW()</CODE> があなたのローカル時間ではなく GMT を返すなら、
 <CODE>TZ</CODE> 環境変数をローカルのTimezone に設定しなくてはなりません。
環境変数の設定は、サーバーを実行する前に行われなくてはなりません。
たとえば、<CODE>safe_mysqld</CODE> や <CODE>mysql.server</CODE> スクリプトで
行います。

</P>

<P>
<A NAME="IDX694"></A>
<A NAME="IDX695"></A>
<A NAME="IDX696"></A>


<H2><A NAME="Case_sensitivity" HREF="manual.ja_toc.html#Case_sensitivity">18.13  検索時のケース依存</A></H2>

<P>
デフォルトでは <STRONG>MySQL</STRONG> フィールドはケース非依存です (しかし、ケース非依
存にならないいくつかの文字セットはありますsuch as <CODE>czech</CODE>)。
これは、<CODE>col_name LIKE 'a%'</CODE>
で検索した場合、<CODE>A</CODE> または <CODE>a</CODE> で始まる全てのフィールドを得ることを
意味します。検索をケース依存にしたいのなら、始まりをチェックするには
<CODE>INDEX(column, "A")=0</CODE> のようなことを、また、文字列全体が同じかどう
かには <CODE>STRCMP(column, "A") = 0</CODE> を使用してください。

</P>
<P>
単純な比較操作 <CODE>&#62;=, &#62;, =, &#60;, &#60;=</CODE>、ソートそしてグループ化は、文字 ``sort value''
上で行われます。同じソート値の文字 (like E, e and 'e)は同じ文字と
して扱われます！

</P>
<P>
<CODE>LIKE</CODE> 比較は各文字の大文字で行われます
(E == e but E &#60;&#62; 'e)

</P>
<P>
<CODE>column</CODE> をいつでもケース依存で扱いたい場合は、それを <CODE>BINARY</CODE> 
として宣言してください。 「<A HREF="manual.ja_Reference.html#CREATE_TABLE">7.7  <CODE>CREATE TABLE</CODE>構文</A>」節参照.

</P>
<P>
big5 エンコーディングと呼ばれる中国語データを使用している場合は、全ての
文字項目を <CODE>BINARY</CODE> にしてください。これは、big5 エンコーディング文
字のソート順が ascii コードが基になっているため、機能します。

</P>

<P>
<A NAME="IDX697"></A>
<A NAME="IDX698"></A>


<H2><A NAME="Problems_with_NULL" HREF="manual.ja_toc.html#Problems_with_NULL">18.14  <CODE>NULL</CODE> 値での問題</A></H2>

<P>
SQL の初心者のありがちな混乱は、<CODE>NULL</CODE> 値が空文字列  <CODE>''</CODE> と同じ物だと考えるこ
とです。これは正しくありません！ 例えば、次のステートメントは全く別のも
のです:

</P>

<PRE>
mysql&#62; INSERT INTO my_table (phone) VALUES (NULL);
mysql&#62; INSERT INTO my_table (phone) VALUES ("");
</PRE>

<P>
両方の文とも <CODE>phone</CODE> フィールドに値を挿入していますが、
初めのは <CODE>NULL</CODE> 値を挿入し、二番目のは空文字列を挿入しています。
初めのは ``電話番号を知らない'' と見なされ、二番目のは ``彼女は電話を
持っていない'' と見なされます。

</P>
<P>
SQL では、  <CODE>NULL</CODE> は他の全ての値(たとえ  <CODE>NULL</CODE> でも)と比較した時に、常に偽に
なる値です。 <CODE>NULL</CODE> を含む式は、特に断りがなければ、常に  <CODE>NULL</CODE> 値を生成しま
す。次の項目は全て  <CODE>NULL</CODE> を返します:

</P>

<PRE>
mysql&#62; SELECT NULL,1+NULL,CONCAT('Invisible',NULL);
</PRE>

<P>
<CODE>NULL</CODE> 値がセットされている項目を検索する場合、
 <CODE>=NULL</CODE> テストを行わないでください。
これは <CODE>expr = NULL</CODE> が FALSE なので、なんの行も返しません。
例えば以下の例：

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE phone = NULL;
</PRE>

<P>
<CODE>NULL</CODE> 値を持つフィールドを検索したい場合は、<CODE>IS NULL</CODE> テストを使用しなくてはいけま
せん。次は <CODE>NULL</CODE> 電話番号と空の電話番号を見つける方法を示しています:

</P>

<PRE>
mysql&#62; SELECT * FROM my_table WHERE phone IS NULL;
mysql&#62; SELECT * FROM my_table WHERE phone = "";
</PRE>

<P>
<STRONG>MySQL</STRONG> では、他の多くの SQL サーバのように、<CODE>NULL</CODE> 値を持つ
インデックスフィールドを持てません。これらのフィールドは <CODE>NOT NULL</CODE> と宣言しな
くてはいけません。
インデックスフィールドには、<CODE>NULL</CODE> を設定することはできません。

</P>
<P>
<A NAME="IDX699"></A>
<CODE>LOAD DATA INFILE</CODE> でデータを読み込むときは、空のフィールドは <CODE>''</CODE> で更新されます。
項目を <CODE>NULL</CODE> 値にしたい場合は、テキストファイル中に <CODE>\N</CODE> を使用すべきです。
リテラルとしての <CODE>'NULL'</CODE> 語が、ある状況下で使用されています。
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">7.16  <CODE>LOAD DATA INFILE</CODE>構文</A>」節参照.

</P>
<P>
<CODE>ORDER BY</CODE> 使用時, <CODE>NULL</CODE> 値は最初に提示されます.
<CODE>DESC</CODE> を使用して降順にソートする時、<CODE>NULL</CODE> 値は最後になります。
<CODE>GROUP BY</CODE> 使用時, 全ての <CODE>NULL</CODE> 値は等しいと見なされます。

</P>
<P>
<CODE>NULL</CODE> 処理を手助けするため、次の関数を使用できます:
<CODE>IS NULL</CODE>, <CODE>IS NOT NULL</CODE>, <CODE>IFNULL()</CODE>.

</P>
<P>
<A NAME="IDX700"></A>
<A NAME="IDX701"></A>
<A NAME="IDX702"></A>
<A NAME="IDX703"></A>
いくつかの項目型では、<CODE>NULL</CODE> 値はハンドルとして扱われます。
もしテーブル内の最初の <CODE>TIMESTAMP</CODE> 項に <CODE>NULL</CODE> を挿入するなら、
現在の日付と時刻が挿入されます。もし <CODE>AUTO_INCREMENT</CODE> 項に<CODE>NULL</CODE> 値を挿入するなら、
次のシーケンス番号が挿入されます。

</P>
<P>
<A NAME="IDX704"></A>


<H2><A NAME="Problems_with_alias" HREF="manual.ja_toc.html#Problems_with_alias">18.15  <CODE>alias</CODE> の問題</A></H2>

<P>
<CODE>GROUP BY</CODE>, <CODE>ORDER BY</CODE>, <CODE>HAVING</CODE> 節において
項目を参照するに当たりエイリアスが使用できます。
エイリアスは項目としてより良い名称を与えるのに使用されます：

</P>

<PRE>
SELECT SQRT(a*b) as rt FROM table_name GROUP BY rt HAVING rt &#62; 0;
SELECT id,COUNT(*) AS cnt FROM table_name GROUP BY id HAVING cnt &#62; 0;
SELECT id AS "Customer identity" FROM table_name;
</PRE>

<P>
 ANSI SQL が <CODE>WHERE</CODE> 節内でエイリアスを参照することを
許可していないことに注意してください。これは <CODE>WHERE</CODE> が実行される時点で
項目の値がまだ決定されていないからです。例えば、以下のクエリは <STRONG>あやまりです</STRONG>：

</P>

<PRE>
SELECT id,COUNT(*) AS cnt FROM table_name WHERE cnt &#62; 0 GROUP BY id;
</PRE>

<P>
どの行が <CODE>GROUP BY</CODE> に含まれるかを決めるために <CODE>WHERE</CODE> 構文が
実行される一方で、
得られた結果のどの行を使うか確定するために <CODE>HAVING</CODE> が使用されます。

</P>



<H2><A NAME="Deleting_from_related_tables" HREF="manual.ja_toc.html#Deleting_from_related_tables">18.16  Deleting rows from related tables</A></H2>

<P>
<STRONG>MySQL</STRONG> は現在 sub-select は未サポートで、また
 <CODE>DELETE</CODE> 構文で複数のテーブルを扱う事もサポートしていません。
したがって、２つのテーブルに関連するレコードを消すには、以下のようにして行います：

</P>

<OL>
<LI>

いくつかの <CODE>WHERE</CODE> 条件を使用して、基本となるテーブルから行を <CODE>SELECT</CODE>
<LI>

同じ条件下で、基本となるテーブルに含まれる行を <CODE>DELETE</CODE>
<LI>

<CODE>DELETE FROM related_table WHERE related_column IN (selected_rows)</CODE>
</OL>

<P>
<CODE>related_column</CODE> のクエリの合計文字数が、1,048,576 (デフォルトは <CODE>max_allowed_packet</CODE> の値) をこえる場合、
それをいくつかに分割して、複数の <CODE>DELETE</CODE> 構文にしなくてはなりません。

</P>
<P>
<CODE>related_column</CODE> がインデックスで、100-1000 の<CODE>related_column</CODE>だけを消す場合、
よりはやく <CODE>DELETE</CODE> できます。
もし <CODE>related_column</CODE> がインデックスでない場合、その速度は <CODE>IN</CODE> 節の引数の数に無関係になります。

</P>



<H2><A NAME="No_matching_rows" HREF="manual.ja_toc.html#No_matching_rows">18.17  Solving problems with no matching rows</A></H2>

<P>
複雑なクエリーを行って、もしなんの結果も返さなければ、
そのクエリーの何が悪いかを見つけるため、以下の手続きを行います：

</P>

<OL>
<LI>

<CODE>EXPLAIN</CODE> を使用してクエリーをテストし、明白な間違いを見つけます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.22  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.

<LI>

<CODE>WHERE</CODE> 節で使用されているフィールドだけを Select してみます

<LI>

結果が返ってくるまで、一つ一つクエリーからテーブルを取り除いていきます。
テーブルが大きい場合、<CODE>LIMIT 10</CODE> をクエリーで使用することは良くありません。

<LI>

もし <CODE>FLOAT</CODE> か <CODE>DOUBLE</CODE> 型のものを数字と比較するなら、
 <CODE>=</CODE> は使用しないでください！これはほとんどのコンピュータ言語において、
浮動小数点の値はぴったりの値にならないからです。


<PRE>
mysql&#62; SELECT * FROM table_name WHERE float_column=3.5;
   -&#62;
mysql&#62; SELECT * FROM table_name WHERE float_column between 3.45 and 3.55;
</PRE>

In most cases, changing the <CODE>FLOAT</CODE> to a <CODE>DOUBLE</CODE> will fix this!

<LI>

行にマッチすべきであろう項を <CODE>SELECT</CODE> してみます。
その場合、select するのは、上記で最後に取り除いたテーブルに対して行います。

<LI>

もしなにも悪いところを見つけることができなかった場合、
小さなテストをつくって <CODE>mysql test &#60; query.sql</CODE> を行ってみてください。
<CODE>mysqldump --quick database tables &#62; query.sql</CODE> でテストファイルを作成できます。
このファイルをエディターで編集し、いくつかのinsert行を(多すぎるなら)消します。
そしてファイルの最後にselect構文を付け足します。

テストを行うには：


<PRE>
shell&#62; mysqladmin create test2
shell&#62; mysql test2 &#60; query.sql
</PRE>

<CODE>mysqlbug</CODE> を使用して <a HREF="mailto:mysql@lists.mysql.com">mysql@lists.mysql.com</a> にテストを投稿してください。
</OL>



<H2><A NAME="ALTER_TABLE_problems" HREF="manual.ja_toc.html#ALTER_TABLE_problems">18.18  Problems with <CODE>ALTER TABLE</CODE>.</A></H2>

<P>
もし <CODE>ALTER TABLE</CODE> が以下のようなエラーで死んだ場合：

</P>

<PRE>
Error on rename of './database/name.frm' to './database/B-a.frm' (Errcode: 17)
</PRE>

<P>
これは以前の <CODE>ALTER TABLE</CODE> で <STRONG>MySQL</STRONG> がクラッシュしており、
<TT>`A-something'</TT> か <TT>`B-something'</TT> という名前の、誤った情報を流している
古いテーブルが存在しています。
この場合、<STRONG>MySQL</STRONG> データディレクトリに入り、<CODE>A-</CODE> や <CODE>B-</CODE> で始まる
名前を持つファイルを全て消します。
(消す代わりにどこかに移動しても構いません。)

</P>
<P>
<CODE>ALTER TABLE</CODE> は以下のように動作します:

</P>

<UL>
<LI>変更要求のあった <TT>`A-xxx'</TT> という名前の新しいテーブルを作成。

<LI>元のテーブル内の全ての行を <TT>`A-xxx'</TT> にコピー。

<LI>元のテーブルを <TT>`B-xxx'</TT> に名称変更。

<LI><TT>`A-xxx'</TT> は元のテーブル名に名称変更される。

<LI><TT>`B-xxx'</TT> は消去される。

</UL>

<P>
もし名称変更の際に問題があると、<STRONG>MySQL</STRONG> は変更を取り消すように動きます。
致命的な問題が起きた場合(ありえませんが)、<STRONG>MySQL</STRONG> は元の古いテーブルを
 <TT>`B-xxx'</TT> という名前のままにしておきます。単に名称変更すればデータは戻ります。

</P>


<H2><A NAME="Change_column_order" HREF="manual.ja_toc.html#Change_column_order">18.19  How to change the order of columns in a table</A></H2>

<P>
The whole point of SQL is to abstract the application from the data
storage format.  You should always specify the order in wish you wish to
retrieve your data.  For example:

</P>

<PRE>
SELECT col_name1, col_name2, col_name3 FROM tbl_name;
</PRE>

<P>
will return columns in the order <CODE>col_name1</CODE>, <CODE>col_name2</CODE>, <CODE>col_name3</CODE>, whereas:

</P>

<PRE>
SELECT col_name1, col_name3, col_name2 FROM tbl_name;
</PRE>

<P>
will return columns in the order <CODE>col_name1</CODE>, <CODE>col_name3</CODE>, <CODE>col_name2</CODE>.

</P>
<P>
You should <STRONG>NEVER</STRONG>, in an application, use <CODE>SELECT *</CODE> and
retrieve the columns based on their position, because the order in which columns are
returned <STRONG>CANNOT</STRONG> be guaranteed over time; A simple change to
your database may cause your application to fail rather dramatically.

</P>
<P>
If you want to change the order of columns anyway, you can do it as follows:

</P>

<OL>
<LI>

Create a new table with the columns in the right order.
<LI>

Execute
<CODE>INSERT INTO new_table SELECT fields-in-new_table-order FROM old_table</CODE>.
<LI>

Drop or rename <CODE>old_table</CODE>
<LI>

<CODE>ALTER TABLE new_table RENAME old_table</CODE>
</OL>

<P>
 
<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Common_programs.html">previous</A>, <A HREF="manual.ja_Common_problems.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
