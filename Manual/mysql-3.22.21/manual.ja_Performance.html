  <HTML>
  <HEAD>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 1 December 1999 -->

  <TITLE>MySQL Reference Manual for version 3.22.21. - 10  MySQL の最大性能をひきだすには</TITLE>
  </HEAD>
  <BODY BGCOLOR=#FFFFFF TEXT=#000000 LINK=#101090 VLINK=#7030B0>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Server.html">previous</A>, <A HREF="manual.ja_MySQL_Benchmarks.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="Performance" HREF="manual.ja_toc.html#Performance">10  MySQL の最大性能をひきだすには</A></H1>

<P>
Optimization is a complicated task since it ultimately requires
understanding of the whole system. While it may be possible to do some
local optimizations with small knowledge of your system/application, the
more optimal you want your system to become the more you will have to
know about it.

</P>
<P>
So this chapter will try to explain and give some examples of different
ways to optimize MySQL. But remember that there are always some
(increasingly harder) ways to make the system even faster left to do.

</P>



<H2><A NAME="Optimize_Basics" HREF="manual.ja_toc.html#Optimize_Basics">10.1  最適化 概要</A></H2>

<P>
The most important part for getting a system fast is of course the basic
design. You also need to know that kinds of things your system will be
doing. That is your bottlenecks are.

</P>
<P>
The most common bottlenecks are.

<UL>
<LI>Disk シーク ：

一片のデータを見つけるためには、ディスクに時間がかかります。
1999年の最新型のディスクでは、このための平均時間は、10msよりも通常より小さいです。
したがって、我々は、理論上は 1秒で約1000 シークすることができます。
この時間は、一つのテーブルであるならば、データの増加と共にディスクアクセスの時間が
少しずつ増加することになり、とても最適化するのは難しくなっていきます。
これを最適化する方法は、データを 1個以上のディスクに分散する事です。
<LI>CPU cycles ：

データをメイン・メモリーの中に入れた(または既にメモリに存在している)場合に、
結果を得るためには、それを処理する必要があります。
メモリー容量よりも小さなテーブルを持っている場合、これは、制限の要因となります。
小さいテーブルでは、スピードは、通常問題にはなりません。
<LI>Memory bandwidth ：

CPU がキャッシュに収まらないようなデータを要求した場合、メイン・メモリー
のバンド幅はボトルネックになります。
これはほとんどのシステムで分かりにくいボトルネックとなりますが、
誰かはそれを知っているべきです。
</UL>



<H2><A NAME="System" HREF="manual.ja_toc.html#System">10.2  システム、コンパイル時、スタートパラメターのチューニング</A></H2>

<P>
We start with the system level things sine some of these decisions have
to be made very early. In other cases a fast look at this part may
suffice since it not that important for the big gains. But it is always
nice to have a feeling about how much one gould gain by chancing things
at this level.

</P>
<P>
使うべき OS はとても重要です！ 複数の CPU を持つマシンでは、
Solaris (なぜなら、Solaris のスレッドはとても素晴らしく動作するから)、
あるいは、Linux ( kernel 2.2 は良い SMP をサポートしているから) を
使用すべきです。 32bit マシンの Linux では、2G bytes のファイルサイズの
制限があります。 これは新しいファイルシステム (XFS) のリリース時に
なくなって欲しいものです。

</P>
<P>
Since we have not run production MySQL on that many platforms we advice
you to test your intended platform before choosing it if possible.

</P>
<P>
Other tips:

<UL>
<LI>

充分 RAM があるならば、全ての swap を外してもよいでしょう。
いくつかのシステムでは、たとえメモリーが空いていても、
swap を使用する場合があります。

<LI>

外部のロックを避けるため、<CODE>--skip-locking</CODE> <STRONG>MySQL</STRONG> オプション
を使用します。 
Note that this will not impact <STRONG>MySQL</STRONG> functionality as
long that only run one server. Just remember to take down the server (or
lock relevant parts) before you run <CODE>myisamchk</CODE>. On some system
this switch is mandatory since the external locking does not work in any
case.

MIT スレッドでコンパイルする時は <CODE>--skip-locking</CODE> がデフォルトです。
これは全てのプラットフォームで MIT スレッドが <CODE>flock()</CODE> を完全にサポートし
ていないためです。

<CODE>--skip-locking</CODE> が使用できないただ一つの状態は、
もしあなたが複数の <STRONG>MySQL</STRONG> SERVER (クライアントではないです) を
同じデータに対して走らせている場合です。
Or run
<CODE>myisamchk</CODE> on the table without first flushing and locking the
<CODE>mysqld</CODE> server tables first.

たとえ <CODE>--skip-locking</CODE> を使用していても、
<CODE>LOCK TABLES</CODE> / <CODE>UNLOCK TABLES</CODE> の使用は可能です。
</UL>



<H3><A NAME="Compile_and_link_options" HREF="manual.ja_toc.html#Compile_and_link_options">10.2.1  MySQL の速度に影響するコンパイルとリンク方法</A></H3>

<P>
次のテストの多くは Linux 上で <STRONG>MySQL</STRONG> ベンチマークで行われました。
しかし、これらは他の OS についてもいくつかの指標を与えます。 

</P>
<P>
<CODE>-static</CODE> でのリンク時に最速の実行形式を得ます。
TCP/IP の代わりに Unix ソケットをデータベースへの
接続に使用することも、より良い性能を与えます。

</P>
<P>
Linux では、<CODE>pgcc</CODE> と <CODE>-O6</CODE> でコンパイルした時に最速のコードを得られます。
このオプションで <TT>`sql_yacc.cc'</TT> をコンパイルすると、<CODE>gcc/pgcc</CODE> は
全ての関数をインラインにするために多くのメモリを必要とするので、200M のメモリが必要です。
<CODE>libstdc++</CODE> ライブラリの増加を避けるためには、
<STRONG>MySQL</STRONG> の configure 時に <CODE>CXX=gcc</CODE> も設定すべきです。 

</P>
<P>
より良いコンパイラー、そしてコンパイラーのオプションは、10-30% の
速度の向上をもたらします。 これはあなた自身が MySQL をコンパイルする
時に重要なことです！

</P>
<P>
Intel では、例えば pgcc か Cygnus CodeFusion compiler で最速となります。
我々は 新しい Fujitsu コンパイラーでもテストしましたが、
MySQL を最適化オプションでコンパイルするには、
まだ完全なバグ・フリーではありませんでした。

</P>
<P>
Here is a list of some mesurements that we have done:

<UL>
<LI>

<CODE>pgcc</CODE> を使用して <CODE>-O6</CODE> で全てをコンパイルすると、
<CODE>mysqld</CODE> サーバーは <CODE>gcc</CODE> よりも 11% 速くなります。 

<LI>

動的リンク(<CODE>-static</CODE>) 無し)の場合、結果は 13% 遅くなります。
Note that you still can use a dynamic linked MySQL library. It
is only the server that is critical for performance.

<LI>

(localhost への接続に) Unix ソケットの代わりに TCP/IP を使用すると、結果は 7.5% 遅くなります。 

<LI>

SPARCstation 10 では、<CODE>gcc</CODE> 2.7.3 は Sun Pro C++ 4.2 より 13% 速くなります。

<LI>

Solaris 2.5.1 では、mit-pthreads は Solaris ネイティブスレッドより 8-12% 遅くなります。
With more load/cpus the difference should
get bigger.
</UL>

<P>
TCX により配布されている <STRONG>MySQL</STRONG>-Linux 配布は <CODE>pgcc</CODE> でコンパイルされ、
静的にリンクされています。 

</P>



<H3><A NAME="Disk_issues" HREF="manual.ja_toc.html#Disk_issues">10.2.2  Disk の問題</A></H3>


<UL>
<LI>

As mentioned before disks seeks are a big performance botteneck. This
problems gets more and more apparent when the data starts to grow so
large that effective caching becomes impossible. For large databases,
where you access data more or less random, you can count on that you
will need at least one disk seek to read and a couple of disk seeks to
write things. To minimize this problem use disks with low seek times.
<LI>

To increase the number of available disk spindles (and thereby reduce
the seek overhead) it is possible to either symlink files to different
disks or stripe the disks.
<DL COMPACT>

<DT><STRONG>symbolic link の使用</STRONG>
<DD>
これは通常のデータディレクトリから、違うディスクへ、
インデックスやデータファイルをシンボリック・リンクすることです。
これは シーク と リード を速くします。 (もしそのディスクが
他に使用されていなければ).  「<A HREF="manual.ja_Performance.html#Symbolic_links">10.2.2.1  データベースとテーブルにシンボリックリンクを使用する</A>」節参照.
<DT><STRONG>Striping</STRONG>
<DD>
ストライピングは、複数のディスクに対して、まずデータの最初のブロックを
1番目の disk に書き、2番目のブロックを2つ目のdiskに書き、順次 N 番目
(N は disk の数) まで順に書いていきます。 これは、もしデータがストライプの
サイズよりも小さければ、よりよいパフォーマンスを得ることが出来ます。
ストライピングは、OS や ストライプのサイズにとても依存していることに注意してください。
そのため、あなたのアプリケーションのベンチマークがストライプサイズによって
変わるでしょう。  「<A HREF="manual.ja_Performance.html#Benchmarks">10.8  Using your own benchmarks</A>」節参照.

ストライピングのスピードに違いは、<STRONG>とても</STRONG> パラメターに依存しています。
Depending on how you set the striping parameters and
number of disks you may get difference in orders of magnitude. Note that
you have to choose to optimize for random or sequential access.
</DL>
<LI>

可用性のため、あなたは RAID 0+1 (striping + mirroring) を使用したいと
思うかもしれません。 しかしこれは N 個のドライブのデータを収めるのに
2*N 個のドライブが必要となります。
This is
probably the best option if you have the money for it!  You may however
also have to invest in some volume management software to handle it
efficiently.
<LI>

A good option is to have semi-important data (that can be re-generated)
on RAID 0 disk while store really important data (like host information
and logs) on a RAID 0+1 or RAID N disks. RAID N can be a problem if you
have many writes because of the time to update the parity bits.
<LI>

データベースに使用しているファイルシステムの mount パラメターを変更しても
良いでしょう。 一つの簡単な方法としては、noatime オプションでファイルシステムを
マウントします。 これは inode にある最後にアクセスした時間の更新を
スキップします。 これでいくらか ディスクシークを避けることができるでしょう。
</UL>



<H4><A NAME="Symbolic_links" HREF="manual.ja_toc.html#Symbolic_links">10.2.2.1  データベースとテーブルにシンボリックリンクを使用する</A></H4>

<P>
テーブルとデータベースのファイルを MySQL のデータベースディレクトリーから
違う場所に移動し、 それに対してシンボリックリンクを張ることができます。
これは例えばディスク容量が少なくなって、データベースを移動したい場合にそうしたくなるでしょう。 

</P>
<P>
<STRONG>MySQL</STRONG> が、テーブルがシンボリックリンクであることに気づいた場合、
symlink を解析し、代わりにその実体のテーブルを使用します。
これは <CODE>realpath()</CODE> コールをサポートする全てのシステムで働きます（少
なくとも Linux と Solaris は <CODE>realpath()</CODE> をサポートします！）。
<CODE>realpath()</CODE> をサポー トしないシステム上では、symlink とテーブルを
同時に使用すべきでありません！ テーブルはテーブルの更新後に矛盾する事になるでしょう。 

</P>
<P>
<STRONG>MySQL</STRONG> はデフォルトではデータベース同士のリンクをサポートしません。
が、データベース間のシンボリックリンクを作成しない限り、これは正常に働くでしょう。
<STRONG>MySQL</STRONG> データディレクトリに <CODE>db1</CODE> データベースがあるとして、
仮に <CODE>db2</CODE> を <CODE>db1</CODE> のシンボリックリンクにしたとします: 

</P>

<PRE>
shell&#62; cd /path/to/datadir
shell&#62; ln -s db1 db2
</PRE>

<P>
すると、<CODE>db1</CODE> 中の <CODE>tbl_a</CODE> テーブルは <CODE>db2</CODE> の  <CODE>tbl_a</CODE> テーブルとして見えます。
もしあるスレッドが <CODE>db1.tbl_a</CODE> を更新し、他のスレッドが <CODE>db2.tbl_a</CODE> を
更新した場合、 問題が発生します。 

</P>
<P>
こういった使用をどうしてもしたい場合、<TT>`mysys/mf_format.c'</TT> を以下のように変更します: 

</P>

<PRE>
if (!lstat(to,&#38;stat_buff))  /* Check if it's a symbolic link */
    if (S_ISLNK(stat_buff.st_mode) &#38;& realpath(to,buff))
</PRE>

<P>
Change the code to this:

</P>

<PRE>
if (realpath(to,buff))
</PRE>

<P>
<A NAME="IDX620"></A>


<H3><A NAME="Server_parameters" HREF="manual.ja_toc.html#Server_parameters">10.2.3  サーバーパラメーターのチューニング</A></H3>

<P>
<CODE>mysqld</CODE> サーバーが使用している現在のバッファサイズを次で得ることができます:

</P>

<PRE>
shell&#62; mysqld --help
</PRE>

<P>
この結果、全ての <CODE>mysqld</CODE> オプションと次のようなコンフィグ可能変数のリスト
を得られます。出力結果にはデフォルト値が含まれ、以下のように表示されます:

</P>

<PRE>
Possible variables for option --set-variable (-O) are:
back_log              current value: 5
connect_timeout       current value: 5
delayed_insert_timeout  current value: 300
delayed_insert_limit  current value: 100
delayed_queue_size    current value: 1000
flush_time            current value: 0
join_buffer_size      current value: 131072
key_buffer_size       current value: 1048540
lower_case_table_names  current value: 0
long_query_time       current value: 10
max_allowed_packet    current value: 1048576
max_connections       current value: 100
max_connect_errors    current value: 10
max_delayed_threads   current value: 20
max_heap_table_size   current value: 16777216
max_join_size         current value: 4294967295
max_sort_length       current value: 1024
max_tmp_tables        current value: 32
max_write_lock_count  current value: 4294967295
net_buffer_length     current value: 16384
query_buffer_size     current value: 0
record_buffer         current value: 131072
sort_buffer           current value: 2097116
table_cache           current value: 64
thread_concurrency    current value: 10
tmp_table_size        current value: 1048576
thread_stack          current value: 131072
wait_timeout          current value: 28800
</PRE>

<P>
もし <CODE>mysqld</CODE> サーバーを走らせているなら、以下のコマンドでも変数の値を見ることができます:

</P>

<PRE>
shell&#62; mysqladmin variables
</PRE>

<P>
これらのオプションは以下のように決めてください。
buffer size, buffer length, stack size は byte 単位で与えます。
これらの値の後ろに <SAMP>`K'</SAMP> や <SAMP>`M'</SAMP> を追加すると、キロバイト、メガバイトになります。
例えば、<CODE>16M</CODE> は16メガバイトを示します。大文字小文字の区別はなく、
<CODE>16M</CODE> と <CODE>16m</CODE> は同じ意味になります。

</P>
<P>
稼働中のサーバーの統計情報は <CODE>SHOW STATUS</CODE> で参照できます.  「<A HREF="manual.ja_Reference.html#SHOW">7.21  <CODE>SHOW</CODE> 構文 (テーブルやフィールドなどについての情報を得る)</A>」節参照. 

</P>
<DL COMPACT>

<DT><CODE><CODE>back_log</CODE></CODE>
<DD>
<STRONG>MySQL</STRONG> が持てる未解決の接続要求の数です。これは <STRONG>MySQL</STRONG> 
スレッドが<STRONG>ものすごく</STRONG>多くの接続要求をとても短い時間に得た時に、働き
ます。接続のチェックと新しいスレッドの開始はメインスレッドにすこし時間
(しかしほんのわずか)がかかります。back_log は、<STRONG>MySQL</STRONG> が瞬間的に新
しい要求への回答を停止する前に、この短い時間の間にスタックできる接続数で
す。短い期間に多くの接続を期待する場合にだけ、これを増加する必要がありま
す。

いいかえるなら、これは TCP/IP 接続の入力 listen キューのサイズです。
オペレーティングシステムはこのキューの大きさを制限しています。
UNIX システムコール <CODE>listen(2)</CODE> のマニュアルページに、さらに詳細があります。
この値を最大限にしたい場合、お使いのOSのドキュメントを見てください。
<CODE>back_log</CODE> をこのOSの制限値より多く取ってもは全く効果ありません。

<DT><CODE><CODE>connect_timeout</CODE></CODE>
<DD>
<CODE>mysqld</CODE> サーバーが接続パケットを待つ秒数。 (<CODE>Bad handshake</CODE> を返すまでの秒数)

<DT><CODE><CODE>delayed_insert_timeout</CODE></CODE>
<DD>
どれぐらい <CODE>INSERT DELAYED</CODE> スレッドが <CODE>INSERT</CODE> 文を待つべきか。

<DT><CODE><CODE>delayed_insert_limit</CODE></CODE>
<DD>
<CODE>delayed_insert_limit</CODE> 個のレコードを挿入した後、 <CODE>INSERT DELAYED</CODE> ハンドラーは
待たされている <CODE>SELECT</CODE> 文がないかチェックします。 もしあるなら、
挿入を続ける前にそれらの実行を許します。

<DT><CODE><CODE>delayed_queue_size</CODE></CODE>
<DD>
How big a queue (in rows) should be allocated for handling <CODE>INSERT DELAYED</CODE>.
If the queue becomes full, any client that does <CODE>INSERT DELAYED</CODE> will wait until
there is room in the queue again.

<DT><CODE><CODE>flush_time</CODE></CODE>
<DD>
これがもし、非ゼロにセットされたなら、毎 <CODE>flush_time</CODE> 秒ごとに
全てのテーブルが閉じられます。 (リソースの解放とDiskへのsyncのために)

<DT><CODE><CODE>join_buffer_size</CODE></CODE>
<DD>
このバッファは(インデックス無しの)完全な結合に使用されます。それは2つの
テーブル間の完全な結合ごとに1回割り当てられます。インデックスの追加がで
きない時、より速い完全な結合を得るために、これを増加してください。通常、
速い結合を得る一番良い方法は、インデックスを追加することです。

<DT><CODE><CODE>key_buffer_size</CODE></CODE>
<DD>
インデックス・ブロックはバッファされ、そして全てのスレッドに共有されます。
<CODE>key_buffer_size</CODE> はインデックス・ブロックのためのバッファ・サイズです。

Increase this get better index handling (for all reads and multiple
writes) to as much as you can afford.  If you make this too big the
system will starte to page and go REAL slow. Remember that since <STRONG>MySQL</STRONG>
does not cache data read that you will have to leave some room for the
OS filesystem cache.

To get even more speed when writing many rows at the same time use
<CODE>LOCK TABLES</CODE>.   「<A HREF="manual.ja_Reference.html#LOCK_TABLES">7.24  <CODE>LOCK TABLES/UNLOCK TABLES</CODE> 構文</A>」節参照.

<DT><CODE><CODE>long_query_time</CODE></CODE>
<DD>
もしあるクエリがこの値(秒)より時間がかかれば、<CODE>Slow_queries</CODE> カウンター
が増やされます。

<DT><CODE><CODE>max_allowed_packet</CODE></CODE>
<DD>
一つのパケットの最大サイズ。メッセージバッファは <CODE>net_buffer_length</CODE> バイトに初期化されますが、
<CODE>max_allowed_packet</CODE>まで大きくすることができます。このデフォルト値は、
大きなパケット、間違ったパケットをを受けるには小さい値です。
大きな <CODE>BLOB</CODE> を使用している場合は、これを増加する必要があります。使用した
い最大の <CODE>BLOB</CODE> と同じくらい大きくするべきです。

<DT><CODE><CODE>max_connections</CODE></CODE>
<DD>
許される同時クライアントの数。これを増加する場合は、<CODE>mysqld</CODE> が持つファイ
ルディスクリプタの数を増やす必要があるでしょう。
後述のファイルデスクリプターの制限の説明を参照のこと。
これは OS に依存しますので、OS のドキュメントを見てください。

<DT><CODE><CODE>max_connect_errors</CODE></CODE>
<DD>
もしあるホストからの接続中断がこの値を以上になった場合、これ以後、
そのホストからの接続を拒絶します。<CODE>FLUSH HOSTS</CODE> コマンドで
ホストの拒否を解除できます。

<DT><CODE><CODE>max_delayed_threads</CODE></CODE>
<DD>
この値を超えて <CODE>INSERT DELAYED</CODE> を扱うスレッドを起動できません。
もし全ての <CODE>INSERT DELAYED</CODE> スレッドが使用されていて、さらに新しいテーブルに
データを挿入しようとすると、そのレコードは <CODE>DELAYED</CODE> が与えられていない
場合と同様に挿入されます。

<DT><CODE><CODE>max_join_size</CODE></CODE>
<DD>
<CODE>max_join_size</CODE> より多いレコードを触るとエラーが返ります。長い時間をかけて
百万行を返すような <CODE>WHERE</CODE> なしの結合を作成するようなユーザを持って
いる場合にこれを設定してください。

<DT><CODE><CODE>max_sort_length</CODE></CODE>
<DD>
<CODE>BLOB</CODE> または <CODE>TEXT</CODE> 項目上でソートする時に使用するバイト数。
(最初の <CODE>max_sort_length</CODE> バイトだけがそれぞれの値で使用でき、残りは無視されます)

<DT><CODE><CODE>max_tmp_tables</CODE></CODE>
<DD>
(このオプションはまだなにも行いません).
Maximum number of temporary tables a client can keep open at the same time.

<DT><CODE><CODE>net_buffer_length</CODE></CODE>
<DD>
通信バッファがクエリ間でこのサイズにリセットされます。これは通常は変更す
べきではありませんが、とても小さなメモリしかない場合は、これを期待される
クエリのサイズに設定してください。
( これは、クライアントから送られてくるSQL文の長さ分あればいいでしょう。
もし構文がこの値をこえた場合、バッファは自動的に大きくなります。
ただし <CODE>max_allowed_packet</CODE> バイトまでです)

<DT><CODE><CODE>record_buffer</CODE></CODE>
<DD>
順序スキャンを行う各スレッドが、スキャンするテーブル毎に、このサイズのバッ
ファを割り当てます。多くの順序スキャンを行う場合は、これを増加させてくだ
さい。

<DT><CODE><CODE>sort_buffer</CODE></CODE>
<DD>
ソートを行う必要がある各スレッドがこのサイズのバッファを割り当てます。よ
り速い <CODE>ORDER BY</CODE> または <CODE>GROUP BY</CODE> のためにはこれを増やしてく
ださい。
 「<A HREF="manual.ja_Problems.html#Temporary_files">18.4  <STRONG>MySQL</STRONG> が一時ファイルを格納する場所</A>」節参照.

<DT><CODE><CODE>table_cache</CODE></CODE>
<DD>
全てのスレッドについてのオープンテーブルの数。これを増加する場合は、
<CODE>mysqld</CODE>が要求するオープンファイルディスクリプタの数も
増加することに注意しないといけません。
<STRONG>MySQL</STRONG> はユニークテーブル毎に2つのファイルディスクリプタを必要と
します。
後述のファイルデスクリプターの制限の説明を参照のこと。
テーブルキャッシュがどのように働くかはこちらを参照  「<A HREF="manual.ja_Performance.html#Table_cache">10.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A>」節.

<DT><CODE><CODE>tmp_table_size</CODE></CODE>
<DD>
一時テーブルがこれよりも大きい場合、<STRONG>MySQL</STRONG> は
<CODE>The table ### is full</CODE> エラーを生成します。
多くの先進的な <CODE>GROUP BY</CODE> クエリを行う場合は、この値を増加してください。

<DT><CODE><CODE>thread_stack</CODE></CODE>
<DD>
各スレッドのスタックの大きさ。<CODE>crash-me</CODE> によって検出される多く
の制限がこれに依存します。デフォルトでは、通常のオペレーションに対して
十分とってあります。
 「<A HREF="manual.ja_Performance.html#Benchmarks">10.8  Using your own benchmarks</A>」節参照.

<DT><CODE>wait_timeout</CODE>
<DD>
サーバーがコネクションを閉じるまでにアクティブなコネクションを待つ秒数。
</DL>

<P>
<STRONG>MySQL</STRONG> はとてもスケーラブルなアルゴリズムを使用します。そのため
通常はとても少ないメモリで動作し、またより良い性能を得るために 
<STRONG>MySQL</STRONG> に多くのメモリを与えることができます。

</P>
<P>
多くのメモリと多くのテーブルを持っていて、適度のクライアント数で最大性能を得た
い場合、次のようなものを使用します:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=16M -O table_cache=128 \
           -O sort_buffer=4M -O record_buffer=1M &#38;
</PRE>

<P>
多くの接続で少ないメモリしかない場合、次のようなものを使用します:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=100k \
           -O record_buffer=100k &#38;
</PRE>

<P>
or even:

</P>

<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=16k \
           -O table_cache=32 -O record_buffer=8k -O net_buffer=1K &#38;
</PRE>

<P>
もしとても多くの接続があり、<CODE>mysqld</CODE> が各接続に対して少ないメモリーで
動作するように設定されていれば、スワップの読み書きによるパフォーマンスの低下がおきます。
もちろん十分なメモリーがあれば、全ての接続にたいして <CODE>mysqld</CODE> のパフォーマンス良くなります。

</P>
<P>
<CODE>mysqld</CODE> へのオプションを変更する場合、そのサーバのインスタンスにだけに
有効であることに注意して下さい。

</P>
<P>
パラメータ変更の効果を見るには、このようにします:

</P>

<PRE>
shell&#62; mysqld -O key_buffer=32m --help
</PRE>

<P>
<CODE>--help</CODE> オプションは最後につけてください。
その他のオプションを --help の後につけると、そのオプションは反映されません。

</P>
<P>
<A NAME="IDX621"></A>
<A NAME="IDX622"></A>


<H3><A NAME="Table_cache" HREF="manual.ja_toc.html#Table_cache">10.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A></H3>

<P>
<CODE>table_cache</CODE>, <CODE>max_connections</CODE> , <CODE>max_tmp_tables</CODE> は
サーバーが開いた状態にしておく事が出来るファイルの最大数に影響します。
If you
increase one or both of these values, you may run up against a limit
imposed by your operating system on the per-process number of open file
descriptors.  However, you can increase the limit on many systems.
Consult your OS documentation to find out how to do this, because the
method for changing the limit varies widely from system to system.

</P>
<P>
<CODE>table_cache</CODE> は <CODE>max_connections</CODE> に関連します。
例えば 200 のコネクションを同時に開けるなら、少なくとも <CODE>200 * n</CODE> の
テーブル・キャッシュが必要です。 ここで <CODE>n</CODE> は join におけるテーブルの
最大数です。

</P>
<P>
オープンテーブルのキャッシュは最大で <CODE>table_cache</CODE> まで大きくなります(デ
フォルトは 64, <CODE>mysqld</CODE> のオプション <CODE>-O table_cache=#</CODE> で変更可能)。
キャッシュが一杯になって、他のスレッドがテーブルのオープンを試みた時、
または <CODE>mysqladmin refresh</CODE> <CODE>mysqladmin flush-tables</CODE>
を使用した場合を除いて、テーブルはクローズされません。

</P>
<P>
キャッシュがいっぱいになった場合、サーバーは以下の処置を取って
キャッシュを使用できるように配置します：

</P>

<UL>
<LI>

現在使われていないテーブルが解放されます。もっとも使用されていないテーブルからから順に。

<LI>

もしキャッシュが一杯でテーブルを解放することが出来ず、さらに新しいテーブルの
オープン要求がある場合、キャッシュは一時的な拡張を必要とします。

<LI>

もしそのキャッシュが一時拡張に配置されていて、かつ、テーブルが使用状態から
未使用状態に移行した場合、そのテーブルは閉じられ、キャッシュから解放されます。
</UL>

<P>
テーブルは各同時アクセスに (再び) オープンされます。これは、同じテーブルで2つのスレッ
ドが実行されている場合、または同じクエリで(<CODE>AS</CODE> で)テーブルを2回アクセス
する場合、テーブルは2回オープンする必要があることを意味します。最初のテーブルのオー
プンは2つのファイル記述子を使用し、続くテーブルの各使用は1つだけのファイル記述
子を使用します。

</P>



<H3><A NAME="Creating_many_tables" HREF="manual.ja_toc.html#Creating_many_tables">10.2.5  Drawbacks of creating large numbers of tables in the same database</A></H3>

<P>
もしたくさんのファイルが一つのディレクトリにある場合、オープン、クローズ、
作成操作は遅くなるでしょう、 もし <CODE>SELECT</CODE> 文を多くのテーブルに対し
実行した場合、テーブルキャッシュが一杯ならば、このオーバーヘッドは多くなるでしょう。
なぜなら、それぞれのテーブルにつきオープンし、クローズしなくてはならないからです。
このオーバーヘッドを緩和するには、テーブルキャッシュを大きくします。

</P>


<H3><A NAME="Open_tables" HREF="manual.ja_toc.html#Open_tables">10.2.6  何故そんなに多くのテーブルをオープンするのか？</A></H3>

<P>
<CODE>mysqladmin status</CODE> を実行すると、次のようなものが得られます:

</P>

<PRE>
Uptime: 426 Running threads: 1 Questions: 11082 Reloads: 1 Open tables: 12
</PRE>

<P>
確かにたった6個しかテーブルがないのに、このような結果が出るので少々戸惑われるかもしれません。

</P>
<P>
<STRONG>MySQL</STRONG> はマルチスレッドなので、同じテーブルで一度に多くのクエリを持て
ます。同じファイル上で異なる状態を持つ2つのスレッドで、問題を最小化する
ため、同時に動作する各スレッドのためテーブルを再びオープンします。これはいくつ
かのメモリとデータファイルについての一つの拡張ファイル記述子を使用します。
インデックスファイル記述子は全てのスレッド間で共有されます。

</P>

<P>
<A NAME="IDX623"></A>


<H3><A NAME="Memory_use" HREF="manual.ja_toc.html#Memory_use">10.2.7  MySQL はどのようにメモリを使用するのか？</A></H3>

<P>
以下に <CODE>mysqld</CODE> サーバーがどのようにメモリーを使用するか、いくつか示します。
サーバーに与える変数名は、サーバーのメモリーの使用方に関連した名前となっています。

</P>

<UL>
<LI>

キーバッファ (変数 <CODE>key_buffer</CODE>) は全てのスレッドで共有され、
残りは必要時に割り当てられます。
 「<A HREF="manual.ja_Performance.html#Server_parameters">10.2.3  サーバーパラメーターのチューニング</A>」節参照.

<LI>

各接続はいくつかのスレッド空間を使用します；
スタック (64K, 変数 <CODE>thread_stack</CODE>), 接続バッファ(variable
<CODE>net_buffer_length</CODE>), 結果バッファ(variable
<CODE>net_buffer_length</CODE>)。接続バッファと結果バッファは必要となった時、
動的に最大 <CODE>max_allowed_packet</CODE> まで増えます。
クエリが走っている時、そのクエリの文字のコピーが割り当てられます。

<LI>

全てのスレッドは同じベースメモリを共有します。

<LI>

まだ memory-mapped を使用していません (圧縮テーブルは除きますが、これは別の話)。
これは 4GB の 32bit メモリ空間は多くの大きなテーブルを扱うには小さいためです。
64bit アドレス空間を持つシステムを我々が手に入れた時、我々は mmemory-mapping を通常にサポートします。

<LI>

テーブルを越えて順次スキャンを行なう各要求は、読み込みバッファを割り当てます
(変数 record_buffer)

<LI>

全ての結合は1パスで行なわれ、多くの結合は一時テーブルを使用せずに行なわ
れます。多くの一時テーブルはメモリベース(HEAP)のテーブルです。大きなレコー
ドサイズ (= 全フィールド長の合計) を持つ一時テーブルまたは、<CODE>BLOB</CODE> を含む
テーブルはディスク上に置かれます。

<STRONG>MySQL</STRONG> 3.23.2 以前での問題は、HEAP テーブルが 
<CODE>tmp_table_size</CODE> のサイズを越えると、エラー <CODE>The table tbl_name is full</CODE>
が出ることです。将来我々は、必要時にメモリ (HEAP) テーブルをディスクベー
ス (NISAM) テーブルに自動的に変更することにより、これを修正します。この
問題を回避するため、<CODE>mysqld</CODE> への <CODE>tmp_table_size</CODE> オプションま
たはクライアント側で SQL オプション <CODE>SQL_BIG_TABLES</CODE> で増加できます。
 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.25  <CODE>SET OPTION</CODE> 構文</A>」節参照.
<STRONG>MySQL</STRONG> 3.20 では、一時テーブルの最大サイズは 
<CODE>recordbuffer*16</CODE> でした。そのため、このバージョンを使用していると、
<CODE>recordbuffer</CODE> を追加する必要があります。 <CODE>mysqld</CODE> を <CODE>--big-tables</CODE> で
開始することで、常に一時テーブルをディスク上に格納できます。しかしこれは
多くの複雑なクエリの速度に影響します。

<LI>

ほとんどのリクエストは、1,2個の一時ファイルとわずかなソートバッファへの割り当てを行います。
 「<A HREF="manual.ja_Problems.html#Temporary_files">18.4  <STRONG>MySQL</STRONG> が一時ファイルを格納する場所</A>」節参照.

<LI>

変形と演算時に使用されるほとんど全てのメモリはローカルメモリストア内で行
なわれます。小さな項目に必要とされるメモリオーバーヘッドはなく、通常の遅
いメモリ割り当て/解放が回避されます。メモリは予期しない大きな文字列にだ
け割り当てられます(これは <CODE>malloc()</CODE> と <CODE>free()</CODE> で行なわれます)。

<LI>

各インデックスファイルは一度オープンされ、データファイルは各同時実行スレッ
ド毎に一度オープンされます。各同時スレッドには、テーブル構造、各フィールドの構造そし
て <CODE>3 * n</CODE> のサイズのバッファが割り当てられます。
( <CODE>n</CODE> は <CODE>BLOB</CODE> 型のフィールドの長さを含めない、一レコードの最大長です )
<CODE>BLOB</CODE> は 5 から 8 バイト + <CODE>BLOB</CODE> データの長さを使用します。

<LI>

<CODE>BLOB</CODE> を持つ各テーブルでは、より大きな <CODE>BLOB</CODE> の読み込みでバッファ
は動的に拡大されます。テーブルのスキャンをする場合、割り当てられたバッファは最
も大きい <CODE>BLOB</CODE> と同じ大きさになります。

<LI>

全ての使用されているテーブルのテーブルハンドラーはキャッシュ内に保存され、
FIFO として管理されます。
通常、キャッシュは 64 個のテーブルです。テーブルが 2 つの実行しているス
レッドで同時に使用される場合、キャッシュ内にテーブルの 2 つのエントリが
あります。
 「<A HREF="manual.ja_Performance.html#Table_cache">10.2.4  <STRONG>MySQL</STRONG> はどのようにテーブルのオープン &#38; クローズを行なうか？</A>」節参照.

<LI>

<CODE>mysqladmin refresh</CODE> は使用されていない全てのテーブルをクローズし、
使用されている全てのテーブルを、実行中スレッドが終った時にクローズするよ
うにマークします。これは多くの使用メモリを解放するのに有効です。全てのロ
グファイルもクローズと再オープンされます。
</UL>

<P>
<STRONG>mysqld</STRONG> 実行時、<CODE>ps</CODE> や他のプログラムは、それが多くのメモリ
を使用していると報告するでしょう。これは異なったメモリアドレス上のスレッ
ドスタックによって発生します。例えば、Solaris ps はスタック間の未使用メ
モリを使用メモリとして計算します。'swap -s' で有効なスワップをチェックす
ることでこれを確かめられます。我々は市販のメモリリーク検出プログラムで 
<CODE>mysqld</CODE> をテストしました。そのため、メモリリークは全くありません。

</P>


<H3><A NAME="Internal_locking" HREF="manual.ja_toc.html#Internal_locking">10.2.8  <STRONG>MySQL</STRONG> はどのようにテーブルをロックするか</A></H3>

<P>
<STRONG>MySQL</STRONG> の全てのロックはデッドロックフリーです。これは、常にクエ
リ開始時に一度ロックを必要とする全てを要求し、常に同じ順でテーブルをロッ
クすることで管理されます。

</P>
<P>
<STRONG>MySQL</STRONG> が使用する <CODE>WRITE</CODE> ロックは次のように働きます:

</P>

<UL>
<LI>

テーブル上にロックがない場合 write ロックを置きます。
<LI>

そうでなければ write ロックキューにロックを置きます。
</UL>

<P>
<STRONG>MySQL</STRONG> の <CODE>READ</CODE> ロックは次のように動きます:

</P>

<UL>
<LI>

テーブル上に write ロックがない場合 read ロックを置きます。
<LI>

そうでなければ read ロックキューにロックを置きます。
</UL>

<P>
ロックが解放されたとき、最初に write ロックキュー内のスレッドに、その後 
read ロックキュー内のスレッドにロックを与えます。

</P>
<P>
これは、同じテーブルで多くの更新をする場合、<CODE>SELECT</CODE> 構文は 
update がなくなるまで待たされることを意味します。

</P>
<P>
同じテーブルで多くの <CODE>INSERT</CODE> と多くの <CODE>SELECT</CODE> を行う場合、これを解決するに
は、他のテーブルに行を挿入して、たまに、その一時テーブルから全てのレコー
ドをもう一方のテーブルに update します。

</P>
<P>
これは次のコードで行えます:

<PRE>
mysql&#62; LOCK TABLES real_table WRITE, insert_table WRITE;
mysql&#62; insert into real_table select * from insert_table;
mysql&#62; delete from insert_table;
mysql&#62; UNLOCK TABLES;
</PRE>

<P>
決まりきった検索に優先権を与えるため、<CODE>INSERT</CODE> 構文で <CODE>LOW_PRIORITY</CODE> か <CODE>HIGH_PRIORITY</CODE> オプションが使用できます。
 「<A HREF="manual.ja_Reference.html#INSERT">7.14  <CODE>INSERT</CODE>構文</A>」節参照.

</P>
<P>
一つのキューだけを使用するように <TT>`mysys/thr_lock.c'</TT> 内のロックコードを変更
することもできます。この場合、いくつかのアプリケーションのために、
write ロックは read ロックと同じ優先順位にします。

</P>


<H3><A NAME="Table_locking" HREF="manual.ja_toc.html#Table_locking">10.2.9  テーブル・ロッキングの問題</A></H3>

<P>
<STRONG>MySQL</STRONG> のテーブル・ロッキングのコードはデッドロック・フリーです。

</P>
<P>
<STRONG>MySQL</STRONG> はとても速いロックスピードを得るために、
(レコードのロックやフィールドのロックの代わりに) テーブルのロックを使用します。
大きなテーブルには、 テーブルのロックはレコードのロックよりはるかに良いですが、
いくつかの落とし穴があります。

</P>
<P>
In <STRONG>MySQL</STRONG> 3.23.7 and above, one can insert rows into
<CODE>MyISAM</CODE> tables at the same time as other threads are reading on
the table.  Note that currently this only works if there is no deleted
rows in the table.

</P>
<P>
テーブルのロックはたくさんのスレッドが同時にあるテーブルから読み出すのを可能にしますが、
もしあるスレッドがあるテーブルに対し書込み要求を出す場合、
それはまず最初に排他的なアクセスを得なければなりません.
その更新の間、更新が完了するまで、この特定のテーブルにアクセスしようとする
他の全てのスレッドが待たされることになります。

</P>
<P>
通常データベースの更新は <CODE>SELECT</CODE> よりも重要とされるため、
テーブルを更新する全てのスレッドが、テーブルから情報を検索するスレッドよりも
高い優先順位を持ちます。 これは ある特定のテーブルに対して、多くの重いクエリが発行され
た場合に、 更新が不完全に終わらないことを確実にするためです。

</P>
<P>
Starting from <STRONG>MySQL 3.23.7</STRONG> one can use the
<CODE>max_write_lock_count</CODE> variable to force <STRONG>MySQL</STRONG> to issue
a <CODE>SELECT</CODE> after a specific number of inserts on a table. 

</P>
<P>
この1つの主な問題が以下です：

</P>

<UL>
<LI>

あるクライアントが実行に長い時間のかかる <CODE>SELECT</CODE> を発行。
<LI>

その後に、他のクライアントが、使用されているテーブルに対し <CODE>UPDATE</CODE> を発行；
このクライアントは先の <CODE>SELECT</CODE> が完了するまで待ちます
<LI>

さらに他のクライアントが同じテーブルに対して <CODE>SELECT</CODE> 構文を発行；
<CODE>UPDATE</CODE> は <CODE>SELECT</CODE> よりも高い優先度を持つので、
この <CODE>SELECT</CODE> は先の <CODE>UPDATE</CODE> が完了するまで待ちます。
これは一番最初の <CODE>SELECT</CODE> が 終了するまで待たされます！
</UL>

<P>
この問題のいくつかの可能な解決は以下の通りです：

</P>

<UL>
<LI>

<CODE>SELECT</CODE> 構文を速く実行できるように試みます； これを行うにあたり、
いくつかのサマリーテーブルを作成しなければならないかもしれません.

<LI>

<CODE>mysqld</CODE> を <CODE>--low-priority-updates</CODE> オプションで起動。
これは全てのあるテーブルを更新する構文に対して、 <CODE>SELECT</CODE> 構文よりも
低い優先度を与えます。 この場合、前述のシナリオ中の最後の <CODE>SELECT</CODE> 構文は
<CODE>INSERT</CODE> 構文が完了する前に実行されます。

<LI>

<CODE>LOW_PRIORITY</CODE> 属性指定を用いて、 <CODE>INSERT</CODE>,<CODE>UPDATE</CODE>,<CODE>DELETE</CODE> 構文
に低い優先度を与えることも出来ます。

<LI>

Start <CODE>mysqld</CODE> with a low value for <STRONG>max_write_lock_count</STRONG> to give
<CODE>READ</CODE> locks after a certain number of <CODE>WRITE</CODE> locks.

<LI>

SQL コマンドの <CODE>SET SQL_LOW_PRIORITY_UPDATES=1</CODE> を使用して、
ある特定のスレッドからの全ての更新を、低い優先度に指定する事ができます。
 「<A HREF="manual.ja_Reference.html#SET_OPTION">7.25  <CODE>SET OPTION</CODE> 構文</A>」節参照.

<LI>

<CODE>HIGH_PRIORITY</CODE> 属性を用いて、特定の <CODE>SELECT</CODE> がとても重要であると
指定することが可能です。.  「<A HREF="manual.ja_Reference.html#SELECT">7.12  <CODE>SELECT</CODE>構文</A>」節参照.

<LI>

If you have problems with <CODE>INSERT</CODE> combined with <CODE>SELECT</CODE>,
switch to use the new <CODE>MyISAM</CODE> tables as these supports concurrent
<CODE>SELECT</CODE>s and <CODE>INSERT</CODE>s.

<LI>

もし <CODE>INSERT</CODE> と <CODE>SELECT</CODE> 構文を主に混在させるのなら、
<CODE>INSERT</CODE> の <CODE>DELAYED</CODE> 属性指定はこの問題を解決させるでしょう。
 「<A HREF="manual.ja_Reference.html#INSERT">7.14  <CODE>INSERT</CODE>構文</A>」節参照.

<LI>

もし <CODE>SELECT</CODE> と <CODE>DELETE</CODE> で問題があるなら、
<CODE>DELETE</CODE> の <CODE>LIMIT</CODE> オプションが助けになるでしょう。
  「<A HREF="manual.ja_Reference.html#DELETE">7.11  <CODE>DELETE</CODE>構文</A>」節参照.
</UL>



<H2><A NAME="Data_size" HREF="manual.ja_toc.html#Data_size">10.3  可能な限りデータを小さくする</A></H2>

<P>
One of the most basic optimization is to get your data (and indexes) to
take as little space on the disk (and in memory) as possible. This can
give huge improvements since disk reads are faster and normally less
main memory will also be used. Indexing also takes less resources if
done on smaller columns.

</P>
<P>
You can get better performance on a table and minimize storage space
using the techniques listed below:

</P>

<UL>
<LI>

可能ならば、一番小さな型を使用します。 <STRONG>MySQL</STRONG> は
ディスクとメモリーを節約する多くの型を持っています。
<LI>

より小さな整数型を可能ならば使用します。 例えば、
<CODE>MEDIUMINT</CODE> は <CODE>INT</CODE> より良いでしょう。
<LI>

可能ならフィールドを <CODE>NOT NULL</CODE> に定義してください。これは全てをより速くし、
各フィールド毎に1ビットを節約します。
Note that if you really need
<CODE>NULL</CODE> in your application you should definitely use it. Just avoid
haveing it on all columns by default.
<LI>

可変長のフィールド (<CODE>VARCHAR</CODE>, <CODE>TEXT</CODE>, <CODE>BLOB</CODE>) を持たない場合は、
固定サイズレコード形式が使用されます。
これはかなり速いです。しかしあいにくいくらかの領域を浪費します。
 「<A HREF="manual.ja_Performance.html#Choosing_table_type">10.6  table 型の選択</A>」節参照.
<LI>

Each table should have as short as possible primary index. This makes
identification of one row easy and efficient.
<LI>

それぞれのテーブルについて、どのテーブルの形式を使用するかを
決めます。  「<A HREF="manual.ja_Server.html#Table_types">9.4  MySQL table types</A>」節参照. See also  「<A HREF="manual.ja_Performance.html#Choosing_table_type">10.6  table 型の選択</A>」節参照.
<LI>

本当に必要な物にだけインデックスを作成します。
インデックスは検索には良いですが、より速く保存したい場合には良くありません。
もしテーブルをフィールドの組み合わせでサーチすることがほとんどであれば、
それらにインデックスを作成します。 最初のインデックスの部分は、もっとも
使用されるフィールドにすべきです。
If you are
ALWAYS using many columns you should use the column with more duplicates
first to get better compression of the index.
<LI>

If its very likely that an index has unique prefix on the first number
of characters, it's better that only index this prefix. <STRONG>MySQL</STRONG>
supports an index on a part of a character column. Shorter indexes is
faster not only because they take less disk space but also because they
will give you more hits in the index cache and thus fewer disk
seeks.  「<A HREF="manual.ja_Performance.html#Server_parameters">10.2.3  サーバーパラメーターのチューニング</A>」節参照.
<LI>

いくつかの状況下で、とてもよく走査されるテーブルを２つに分割することは、
利益になることがあります。
Especially if it is a dynamic format table
and it is possible to a smaller static format table that can be used to
find the relevant rows then scanning.
</UL>



<H2><A NAME="MySQL_indexes" HREF="manual.ja_toc.html#MySQL_indexes">10.4  MySQL はどのようにインデックスを使用するか？</A></H2>

<P>
Indexes are used to find find a row with a specific calue on one column
fast. Without a index MySQL has to start with the first record and then
read through the whole table until it find the relevent rows. The bigger
the table the more this costs. If the table has a index for the colums
in question MySQL can get fast a possition to seek to in the middle of
the data file without having to look at all data. If a table have 1000
rows this is at least 100 times faster than reading sequentially. Note
that is you need to access almost all 1000 rows it is faster to read
sequentially since we when avoid disk seeks.

</P>
<P>
全ての MySQL インデックス, <CODE>PRIMARY</CODE>, <CODE>UNIQUE</CODE> そして <CODE>INDEX()</CODE> 
は B tree に格納されます。文字列は自動的に始めと終りの空白が圧縮されます。
 「<A HREF="manual.ja_Reference.html#CREATE_INDEX">7.27  <CODE>CREATE INDEX</CODE> 構文</A>」節参照.

</P>
<P>
Indexes are used to:

<UL>
<LI>

<CODE>WHERE</CODE>節にマッチした行の素早い検索

<LI>

join を実行したときの他のテーブルからの行の検索

<LI>

与えられたフィールドの <CODE>MAX()</CODE> や <CODE>MIN()</CODE> 値の割り出し

<LI>

テーブルをソートかグループ化する場合で、ソート(グループ化)が一番左(接頭部)の
キーを使用して行われる場合(例えば <CODE>ORDER BY key_part_1,key_part_2 </CODE>)。
もし <CODE>DESC</CODE> 指定があれば、全てのキーは逆順に読まれます。

<LI>

データファイルを参照することなく値を検索する場合。
もし使用する全てのフィールドが数値でかつ、一番左から(接頭部から)キーを形成する場合、
値はインデックスツリーから検索され、これはとても速くなります。

</UL>

<P>
以下のような <CODE>SELECT</CODE> 文を発行したとします：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
</PRE>

<P>
もし <CODE>col1</CODE> と <CODE>col2</CODE> に複数フィールドインデックスが定義されている場合、
すぐに思ったとおりの結果が得られます。
If separate single-column
indexes exist on <CODE>col1</CODE> and <CODE>col2</CODE>, the optimizer tries to
find the most restrictive index by deciding which index will find fewer
rows and using that index to fetch the rows.

</P>
<P>
<A NAME="IDX624"></A>
<A NAME="IDX625"></A>
もしテーブルが複数フィールドインデックスを持つなら、インデックスの接頭部一番左の部分
がレコードを見つけるための最適化に使用されます。例えば、3つのフィールド
 <CODE>(col1,col2,col3)</CODE> に対して一つのインデックスを持っていたとします。
すると、これは <CODE>(col1)</CODE>, <CODE>(col1,col2)</CODE> ,
<CODE>(col1,col2,col3)</CODE> でインデックスがサーチされます。

</P>
<P>
もし一番左に指定しているフィールドがインデックスを作成していないなら、
<STRONG>MySQL</STRONG> は部分的なインデックスを使用しません。

</P>
<P>
以下のような <CODE>SELECT</CODE> 文を発行したとします：

</P>

<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
</PRE>

<P>
もしインデックスが <CODE>(col1,col2,col3)</CODE> にあるならば、
上に示した最初のクエリだけがインデックスを使用します。二番目三番目のクエリは
インデックスを持つフィールドを発動しますが、
<CODE>(col2)</CODE> と <CODE>(col2,col3)</CODE> は、<CODE>(col1,col2,col3)</CODE> の
接頭部一番左に指定されていません。

</P>
<P>
<A NAME="IDX626"></A>
<A NAME="IDX627"></A>
<A NAME="IDX628"></A>
<A NAME="IDX629"></A>
<STRONG>MySQL</STRONG> は、もし  <CODE>LIKE</CODE> がワイルドカードから始まっていなくて、
ある種固定された文字で始まっているなら、
<CODE>LIKE</CODE> の評価にインデックスを使用します。
例えば、以下の <CODE>SELECT</CODE> 文はインデックスを使用します:

</P>

<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE "Pat%_ck%";
</PRE>

<P>
一つ目の文は、<CODE>"Patrick" &#60;= key_col &#60; "Patricl"</CODE> となるレコードだけ、考慮されます。
二つ目の文は、<CODE>"Pat" &#60;= key_col &#60; "Pau"</CODE> となるレコードだけ、考慮されます。

</P>
<P>
以下の <CODE>SELECT</CODE> 文はインデックスを使用しません:

<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "%Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE other_col;
</PRE>

<P>
最初の文は、<CODE>LIKE</CODE> がワイルドカード文字で始まっています。
二つ目の文は、<CODE>LIKE</CODE> が定数ではありません。

</P>
<P>
<A NAME="IDX630"></A>
<A NAME="IDX631"></A>
Searching using <CODE>column_name IS NULL</CODE> will use indexes if column_name
is a index.

</P>
<P>
<STRONG>MySQL</STRONG> は通常、一番少ないレコード数を見つけるインデックスを使用します。
インデックスは、以下に示す演算子を用いて比較できるフィールドに対して、使用されます：
<CODE>=</CODE>, <CODE>&#62;</CODE>, <CODE>&#62;=</CODE>, <CODE>&#60;</CODE>, <CODE>&#60;=</CODE>, <CODE>BETWEEN</CODE> そして
<CODE>'something%'</CODE> の様に頭にワイルドカードがない <CODE>LIKE</CODE>。

</P>
<P>
<CODE>WHERE</CODE> 節ないの全ての <CODE>AND</CODE> にかからないインデックスは、
全くクエリの最適化に使用されません。

</P>
<P>
以下の <CODE>WHERE</CODE> 節はインデックスを使用します：

<PRE>
... WHERE index_part1=1 AND index_part2=2
... WHERE index=1 OR A=10 AND index=2      /* index = 1 OR index = 2 */
... WHERE index_part1='hello' AND index_part_3=5
          /* optimized like "index_part1='hello'" */
</PRE>

<P>
以下の <CODE>WHERE</CODE> 節はインデックスを<STRONG>使用しません</STRONG>：

<PRE>
... WHERE index_part2=1 AND index_part3=2  /* index_part_1 is not used */
... WHERE index=1 OR A=10                  /* No index */
... WHERE index_part1=1 OR index_part2=10  /* No index spans all rows */
</PRE>



<H2><A NAME="Query_Speed" HREF="manual.ja_toc.html#Query_Speed">10.5  Speed of querys that access or update data</A></H2>

<P>
First one thing that affect all querys. The more compex permission
systen setup you have, the more overhead you get. 

</P>
<P>
If you do not have any <CODE>GRANT</CODE> statements done MySQL will optimize
the permission checking somewhat. So if you have a very high vokume it
may be worth the time to avoid grants. Otherwise more permission check
gives a larger overhead.

</P>
<P>
もし <STRONG>MySQL</STRONG> 関数のあるものが確実に問題を引き起こしているのならば、
常に <STRONG>MySQL</STRONG> クライアント側は以下のようになります：

</P>

<PRE>
mysql&#62; select benchmark(1000000,1+1);
+------------------------+
| benchmark(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</PRE>

<P>
上の例では <STRONG>MySQL</STRONG> は 1,000,000 <CODE>+</CODE> 式を 0.32 秒で実行できています
(たんなる <CODE>PentiumII 400MHz</CODE> マシンで)。

</P>
<P>
全ての <STRONG>MySQL</STRONG> 関数は最適化されていますが、
いくつかは例外があるかもしれません。
<CODE>benchmark(loop_count,expression)</CODE>はあなたのクエリの
問題を見つけるためのとてもよいツールです。

</P>



<H3><A NAME="Estimating_performance" HREF="manual.ja_toc.html#Estimating_performance">10.5.1  Estimating query performance</A></H3>

<P>
ほとんどの場合、ディスク・シークを数えることでだいたいのパフォーマンスを予測できます。
小さなテーブルでは、通常、1回のディスク・シークでレコードを見つけれるでしょう
(インデックスがたぶんキャッシュされるので)。 大きなテーブルでは、
おおよその予測として、(B++ ツリーインデックスを使用している場合)、
<CODE>log(row_count) /
log(index_block_length / 3 * 2 / (index_length + data_pointer_length)) +
1</CODE> シーク、1レコードを見つけるのに必要となるでしょう。

</P>
<P>
<STRONG>MySQL</STRONG> では、インデックス・ブロックは通常 1024 バイトで、
データ・ポインターは通常 4 バイトです。 これは、
インデックス長が 3 (medium integer) 、データが 500,000 レコードあるテーブルでは、 
<CODE>log(500,000)/log(1024/3*2/(3+4)) + 1</CODE> = 4 シークとなります。

</P>
<P>
As the above index would require about 500,000 * 7 * 3/2 = 5.2M,
(assuming that the index buffers are filled to 2/3 (which is typical)
you will probably have much of the index in memory and you will probably
only need 1-2 calls to read data from the OS to find the row.

</P>
<P>
For writes you will however need 4 seek requests (as above) to find
where to place the new index and normally 2 seeks to update the index
and write the row.

</P>
<P>
Note that the above doesn't mean that your application will slowly
degenerate by N log N!  As long as everything is cached by the OS or SQL
server things will only go marginally slower while the table gets
bigger. After the data gets too big to be cached, things will start to
go much slower until your applications is only bound by disk-seeks
(which increase by N log N). To avoid this increase the index cache as
the data grows.  「<A HREF="manual.ja_Performance.html#Server_parameters">10.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>


<H3><A NAME="SELECT_speed" HREF="manual.ja_toc.html#SELECT_speed">10.5.2  <CODE>SELECT</CODE> クエリの速度</A></H3>

<P>
通常、遅い <CODE>SELECT ... WHERE</CODE> を速くするには、
まず最初にインデックスがあるかどうかをチェックします。 「<A HREF="manual.ja_Performance.html#MySQL_indexes">10.4  MySQL はどのようにインデックスを使用するか？</A>」節参照. 
違うテーブルを参照する場合には、普通はインデックスをともなうべきです。
<CODE>EXPLAIN</CODE> コマンドを使用すれば、<CODE>SELECT</CODE> でどのインデックスが
使用されているか確認できます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.22  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.

</P>
<P>
Some general tips:

</P>

<UL>
<LI>

To help <STRONG>MySQL</STRONG> optimize queries better, run <CODE>myisamchk
--analyze</CODE> on a table after it has been loaded with relevant data. This
updates a value for each index that indicates the average number of rows
that have the same value.  (For unique indexes, this is always 1, of
course.)
<LI>

To sort an index and data according to an index, use <CODE>myisamchk
--sort-index --sort-records=1</CODE> (if you want to sort on index 1). If you
have a unique index from which you want to read all records in order
according to that index, this is a good way to make that faster.  Note
however that this sorting isn't written optimally and will take a long
time for a large table!
</UL>

<P>
<A NAME="IDX632"></A>


<H3><A NAME="Where_optimizations" HREF="manual.ja_toc.html#Where_optimizations">10.5.3  MySQL はどのように <CODE>WHERE</CODE> 節を最適化するか？</A></H3>

<P>
The where optimizes are put in the <CODE>SELECT</CODE> part here since they
are mostly used there. But the same optimizations are used for there in
<CODE>DELETE</CODE> and <CODE>UPDATE</CODE> statements.

</P>
<P>
Also note that this section is incomplete. <STRONG>MySQL</STRONG> does many
optimizations and we have not had time to document them all.

</P>
<P>
<STRONG>MySQL</STRONG>による最適化のいくつかを以下に示します:

</P>

<UL>
<LI>

括弧の除去 (全ての不必要な括弧は削除されます):

<PRE>
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&#62; (a AND b AND c) OR (a AND b AND c AND d)
</PRE>

<LI>

定数の保持:

<PRE>
   (a&#60;b AND b=c) AND a=5
-&#62; b&#62;5 AND b=c AND a=5
</PRE>

<LI>

定数条件の除去 (定数保持のために必要とされます):

<PRE>
   (B&#62;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&#62; B=5 OR B=6
</PRE>

<LI>

インデックスに使用される全ての表現は一度だけ評価されます。
<LI>

一つのテーブル上の <CODE>WHERE</CODE> がない <CODE>CONST(*)</CODE> は、テーブルから
直接取り出されます。これはまた同じ条件下での任意の <CODE>NOT NULL</CODE> 表現
のためにも行われます。
<LI>

不当な定数表現は早く検出されます。
<STRONG>MySQL</STRONG> は不可能な  <CODE>SELECT</CODE> 構文を素早く見つけ、0 行を結果として返します。
<LI>

<CODE>GROUP BY</CODE> または group 関数 (<CODE>COUNT()</CODE>, <CODE>MIN()</CODE>...) を使用しない場合は、
<CODE>HAVING</CODE> は <CODE>WHERE</CODE> とマージされます。
<LI>

各サブ結合についての速い <CODE>WHERE</CODE> 評価を得るために、また、可能な限り
早くレコードをスキップするために、各サブ結合についてより簡単な 
<CODE>WHERE</CODE> が構築されます。
<A NAME="IDX633"></A>
<A NAME="IDX634"></A>
<LI>

全ての定数テーブルをクエリー中の他のテーブルより先に読みます。
定数テーブルは次です:

<UL>
<LI>

0 または 1 行のテーブル。
<LI>

<CODE>WHERE</CODE> 節で <CODE>UNIQUE</CODE> インデックスや <CODE>PRIMARY KEY</CODE> が使用されたテーブルで、
かつ、全てのインデックスが定数式で使用されていて、
かつ、インデックスのパートが <CODE>NOT NULL</CODE> で定義されているテーブル。
</UL>

以下のテーブルのように定数だけを使用するテーブル:

<PRE>
mysql&#62; SELECT * FROM t WHERE primary_key=1;
mysql&#62; SELECT * FROM t1,t2
           WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
</PRE>

<LI>

テーブルを結合するために最良の結合の組合せを見つけます。全ての可能性を試して:( 。
<CODE>ORDER BY</CODE> または <CODE>GROUP</CODE> 内の全てのフィールドが同じテーブルの場合は、
このテーブルは結合時に最初に優先されます。
<LI>

<CODE>ORDER BY</CODE> 節と <CODE>GROUP BY</CODE> 節がある場合、または <CODE>ORDER BY</CODE> か <CODE>GROUP BY</CODE> が結合キュー
内の最初のテーブルではない他のテーブルからの項目を含む場合、一時テーブルが生成されます。
<LI>

もし <CODE>SQL_SMALL_RESULT</CODE> を使用するなら, <STRONG>MySQL</STRONG> はメモリー内の一次テーブルを
使用します
<LI>

<CODE>DISTINCT</CODE> は、全てのフィールドに対する <CODE>GROUP BY</CODE> に変換されるため、
<CODE>ORDER BY</CODE> と合わした <CODE>DISTINCT</CODE> は多くの場合で一時テーブルが
必要になります。
<LI>

各テーブルのインデックスはクエリされ、得られる行の 30% 未満の幅しかない最良のインデックスが使用されます。
そのようなインデックスが見つけられない場合、素早いテーブルの走査(quick table scan)が使用されます。
<LI>

同じように、<STRONG>MySQL</STRONG> はデータファイルを等しく調べはしないインデックスから
レコードを読むことが可能です。もし全てのフィールドが数値型のインデックスなら、
インデックスツリーだけがクエリの解決に使用されます。
<LI>

各レコードが出力される前に、<CODE>HAVING</CODE> 節に適合するものをスキップします。
</UL>

<P>
以下はとても速いクエリの例です:

</P>

<PRE>
mysql&#62; SELECT COUNT(*) FROM tbl_name;
mysql&#62; SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;
mysql&#62; SELECT MAX(key_part2) FROM tbl_name
           WHERE key_part_1=constant;
mysql&#62; SELECT ... FROM tbl_name
           ORDER BY key_part1,key_part2,... LIMIT 10;
mysql&#62; SELECT ... FROM tbl_name
           ORDER BY key_part1 DESC,key_part2 DESC,... LIMIT 10;
</PRE>

<P>
以下のクエリはインデックスツリーのみを使用します(インデックス化されているフィールドは
数値型と仮定します)：

</P>

<PRE>
mysql&#62; SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
mysql&#62; SELECT COUNT(*) FROM tbl_name
           WHERE key_part1=val1 AND key_part2=val2;
mysql&#62; SELECT key_part2 FROM tbl_name GROUP BY key_part1;
</PRE>

<P>
以下のクエリは、ソートされた行の検索にインデックスを使用します：

</P>

<PRE>
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1,key_part2,...
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1 DESC,key_part2 DESC,...
</PRE>



<H3><A NAME="LEFT_JOIN_optimization" HREF="manual.ja_toc.html#LEFT_JOIN_optimization">10.5.4  How MySQL optimizes <CODE>LEFT JOIN</CODE></A></H3>

<P>
<CODE>A LEFT JOIN B</CODE> is in <STRONG>MySQL</STRONG> implemented as follows

</P>

<UL>
<LI>

The table <CODE>B</CODE> is set to be dependent on table <CODE>A</CODE>.
<LI>

The table <CODE>A</CODE> is set to be dependent on all tables (except <CODE>B</CODE>)
that are used in the <CODE>LEFT JOIN</CODE> condition.
<LI>

All <CODE>LEFT JOIN</CODE> conditions are moved to the <CODE>WHERE</CODE> clause.
<LI>

All standard join optimizations are done, with the exception that a table is
always read after all tables it is dependent on.  If there is a circular
dependence then <STRONG>MySQL</STRONG> will issue an error.
<LI>

All standard <CODE>WHERE</CODE> optimzations are done.
<LI>

If there is a row in <CODE>A</CODE> that matches the <CODE>WHERE</CODE> clause, but there
wasn't any row in <CODE>B</CODE> that matched the <CODE>LEFT JOIN</CODE> condition,
then an extra <CODE>B</CODE> row is generated with all columns set to <CODE>NULL</CODE>.
<LI>

If you use <CODE>LEFT JOIN</CODE> to find rows that doesn't exist in some
table and you have the following test: <CODE>column_name IS NULL</CODE> in the
<CODE>WHERE</CODE> part, where column_name is a column that is declared as
<CODE>NOT NULL</CODE>, then <CODE>MySQL</CODE> will stop searching after more rows
(for a particular key combination) after it has found one row that
matches the <CODE>LEFT JOIN</CODE> condition.
</UL>



<H3><A NAME="LIMIT_optimization" HREF="manual.ja_toc.html#LIMIT_optimization">10.5.5  How MySQL optimizes <CODE>LIMIT</CODE></A></H3>

<P>
In some cases <STRONG>MySQL</STRONG> will handle the query differently when you are
using <CODE>LIMIT #</CODE> and not using <CODE>HAVING</CODE>:

</P>

<UL>
<LI>

If you are selecting only a few rows with <CODE>LIMIT</CODE>, <STRONG>MySQL</STRONG>
will use indexes in some cases when it normally would prefer to do a
full table scan.
<LI>

If you use <CODE>LIMIT #</CODE> with <CODE>ORDER BY</CODE>, <STRONG>MySQL</STRONG> will end the
sorting as soon as it has found the first <CODE>#</CODE> lines instead of sorting
the whole table.
<LI>

When combinating <CODE>LIMIT #</CODE> with <CODE>DISTINCT</CODE>, <STRONG>MySQL</STRONG> will stop
as soon as it finds <CODE>#</CODE> unique rows.
<LI>

In some cases a <CODE>GROUP BY</CODE> can be resolved by reading the key in order 
(or do a sort on the key) and then calculate summaries until the
key value changes.  In this case <CODE>LIMIT #</CODE> will not calculate any
unnecessary <CODE>GROUP</CODE>'s.
<LI>

As soon as <CODE>MySQL</CODE> has sent the first <CODE>#</CODE> rows to the client, it
will abort the query.
<LI>

<CODE>LIMIT 0</CODE> will always quickly return an empty set.  This is useful
to check the query and to get the column types of the result columns.
<LI>

The size of temporary tables uses the <CODE>LIMIT #</CODE> to calculate how much
space is needed to resolve the query.
</UL>



<H3><A NAME="Insert_speed" HREF="manual.ja_toc.html#Insert_speed">10.5.6  <CODE>INSERT</CODE> クエリの速度</A></H3>

<P>
レコードを挿入する時間は次からなります:

</P>

<UL>
<LI>

接続:                    (3)
<LI>

クエリをサーバへ送信:    (2)
<LI>

クエリの解析:            (2)
<LI>

レコードの挿入:          (1 x size of record)
<LI>

インデックスの挿入:      (1 x indexes)
<LI>

クローズ:                (1)
</UL>

<P>
ここで (数字) は比例時間です。これは、テーブルのオープンにかかる初期オーバーヘッ
ド(これは同時に動作する各クエリ毎に1回行なわれます)は考慮されていません。

</P>
<P>
テーブルのサイズはインデックスの挿入を N log N で遅くします (B-tree)。

</P>
<P>
Some ways to speed up inserts:

</P>

<UL>
<LI>

もし同じクライアントから多くのレコードを同時にインサートするなら、
複数の値が書ける <CODE>INSERT</CODE> 文を使用します。 これは個々に <CODE>INSERT</CODE> 文
を発行する場合に比べて、とても速くなります。
<LI>

もし違うクライアントから多くのレコードを同時にインサートするなら、
 <CODE>INSERT DELAYED</CODE> 文の使用で、より速くなるでしょう。  「<A HREF="manual.ja_Reference.html#INSERT">7.14  <CODE>INSERT</CODE>構文</A>」節参照.
<LI>

Note that with <CODE>MyISAM</CODE> one can insert rows at the same time
<CODE>SELECT</CODE>:s are running if there is no deleted rows in the tables.
<LI>

テキストファイルからテーブルにデータをいれる場合は、 <CODE>LOAD DATA INFILE</CODE> を
使用します。 これはたくさんの <CODE>INSERT</CODE> 文の発行に比べて通常 20倍 程度
速くなります
 「<A HREF="manual.ja_Reference.html#LOAD_DATA">7.16  <CODE>LOAD DATA INFILE</CODE>構文</A>」節参照.
<LI>

It is possible with somce extra work to get <CODE>LOAD DATA INFILE</CODE> even
faster when the table has many indexes. Use the following procedure:


<OL>
<LI>

Optionally create the table with <CODE>CREATE TABLE</CODE>. For example using
<CODE>mysql</CODE> or Perl-DBI.

<LI>

<CODE>FLUSH TABLES</CODE> の実行。 あるいは <CODE>mysqladmin flush-tables</CODE> 
コマンドの実行。

<LI>

<CODE>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</CODE> の使用。 This will
remove all usage of all indexes from the table.

<LI>

そのテーブルに <CODE>LOAD DATA INFILE</CODE> を使用してデータを入れます. This will not
update any indexes and will therefore be very fast.

<LI>

もし <CODE>myisampack</CODE> をお持ちで、テーブルを圧縮したいなら、
<CODE>myisampack</CODE> を実行します.  「<A HREF="manual.ja_Performance.html#Compressed_format">10.6.3  Compressed table characteristics</A>」節参照.

<LI>

<CODE>myisamchk -r -q /path/to/db/tbl_name</CODE> でインデックスを再構築. 
これは disk に書き込む前にインデックスをメモリに作成します。
And that is much faster since it avoid lots of disk
seeks. The resulting index tree is also perfectly balanced.

<LI>

<CODE>FLUSH TABLES</CODE> の実行。 あるいは <CODE>mysqladmin flush-tables</CODE> 
コマンドの実行。
</OL>

This procedure will be built into <CODE>LOAD DATA INFILE</CODE> in some future
version of MySQL.
<LI>

You can speed up insertions locking your tables


<PRE>
mysql&#62; LOCK TABLES a WRITE;
mysql&#62; INSERT INTO a VALUES (1,23),(2,34),(4,33);
mysql&#62; INSERT INTO a VALUES (8,26),(6,29);
mysql&#62; UNLOCK TABLES;
</PRE>

主な速度差は、全ての <CODE>INSERT</CODE> 構文でインデックスバッファが一度だけディスクにフ
ラッシュされることです。通常は  <CODE>INSERT</CODE> 構文があるのと同じくらい多くのインデッ
クスバッファフラッシュがあります。単一構文の全てのレコードは、ロックなしで挿入できます。

ロックも複数接続テストの合計時間を低くしますが、いくつかのスレッドの最大
待ち時間は上がります(ロックを待っているから)。
例えば:


<PRE>
thread 1 does 1000 inserts
thread 2, 3, and 4 does 1 insert
thread 5 does 1000 inserts
</PRE>

ロックを使用しない場合、2, 3 そして 4 は 1 と 5 の前に終ります。ロックを
使用する場合、2,3,4 は 1 や 5 の前に終わることはおそらくありませんが、合
計時間は約 40 % 速くなります。

<CODE>INSERT</CODE>, <CODE>UPDATE</CODE> , <CODE>DELETE</CODE> は、 <STRONG>MySQL</STRONG> ではとても速いので、
1 行で約 5 つ以上、値を 挿入・更新 をする操作に対して、
ロックを追加すれば、全般的により良い性能が得られます。
とても多い insert を行なう場合、
他のスレッドにそのロックしたテーブルへのアクセスを与えるために 、
だいたい 1000 レコードごとに一度、<CODE>UNLOCK TABLES</CODE> した後に
 <CODE>LOCK TABLES</CODE> を行います。 これでもまだ良い性能が得られます。

もちろん <CODE>LOAD DATA INFILE</CODE> はとても速いです。
</UL>

<P>
To get some more speed for both <CODE>LOAD DATA INFILE</CODE> and
<CODE>INSERT</CODE>, enlarge the key buffer.  「<A HREF="manual.ja_Performance.html#Server_parameters">10.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>


<H3><A NAME="Update_speed" HREF="manual.ja_toc.html#Update_speed">10.5.7  <CODE>UPDATE</CODE> クエリの速度</A></H3>

<P>
<CODE>UPDATE</CODE> クエリは <CODE>SELECT</CODE> クエリのように最適化されますが、
書き込みのオーバーヘッドが加わります。
書き込み速度は、更新されるデータの大きさ、更新されるインデックス数に
依ります。

</P>
<P>
Also another way to get fast updates is to delay updates and then do
many updates in a row later. Doing many updates in a row is much quicker
than doing one at a time if you lock the table.

</P>
<P>
Not that with dynamic record format updating a record with to a longer
total length may split the record. So if you do this often it is very
important to <CODE>OPTIMIZE TABLE</CODE> sometimes.  「<A HREF="manual.ja_Reference.html#OPTIMIZE_TABLE">7.9  <CODE>OPTIMIZE TABLE</CODE>構文</A>」節参照.

</P>


<H3><A NAME="Delete_speed" HREF="manual.ja_toc.html#Delete_speed">10.5.8  <CODE>DELETE</CODE> クエリの速度</A></H3>

<P>
1レコードを削除する時間は、ちょうどインデックスの数に比例します。
より速くレコードを削除したいなら、インデックス・キャッシュを
増やします。  「<A HREF="manual.ja_Performance.html#Server_parameters">10.2.3  サーバーパラメーターのチューニング</A>」節参照.

</P>
<P>
Its also much faster to remove all rows than to remove a big part of the
rows from a table.

</P>
<P>
<A NAME="IDX635"></A>
<A NAME="IDX636"></A>


<H2><A NAME="Choosing_table_type" HREF="manual.ja_toc.html#Choosing_table_type">10.6  table 型の選択</A></H2>

<P>
MySQL では、現在 (version 3.23.5)、4つのテーブルフォーマットを、
スピードの観点から選ぶことが出来ます。

</P>
<DL COMPACT>

<DT><STRONG>MyISAM Static</STRONG>
<DD>
このフォーマットは、最も単純、かつ、安全なフォーマットです。
これは最も速いフォーマットでもあります。
The speed comes from the easy way data
can be found on disk. When looking up something with a index and static
format it very simple, just multiply the row number with the row length.

Also when scanning a table it is very easy to read a constant number of
records with each disk read.

安全、というのは、次の様なことです。
もし仮に、静的(固定長) MyISAM ファイルに書き込み中に、
あなたのコンピュータがクラッシュした場合、
<CODE>myisamchk</CODE> は、それぞれのレコードの開始点と終了点を安易に見つけることが出来ます。 
So it can usually reclaim all records except the
partially written one. Not that in MySQL all indexes can always be
reconstructed.

<DT><STRONG>MyISAM Dynamic</STRONG>
<DD>
This format is a litte more comples since each row has to have a header
that says how long it is. One record can also end up at more that one
location when it is made longer at a update.

<CODE>OPTIMIZE table</CODE> か <CODE>myisamchk</CODE> を使用して、テーブルの
フラグメンテーションを修正することが可能です。
If you have static data that you acess/change a lot in the same
table as some <CODE>VARCHAR</CODE> or <CODE>BLOB</CODE> columns, it might be a good
idea to move the dynamic columns to other tables just to avoid
fragmentation.

<DT><STRONG>MyISAM compressed</STRONG>
<DD>
これは読み込み専用の型で、オプションツールの <CODE>myisampack</CODE> で作成されます。

<DT><STRONG>In memory (HEAP)</STRONG>
<DD>
This table format is extramly usefull for small/medium sized lookup
tables. It is possible to copy/create a frequently used lookup table (in
joins) table to a (maybe temporary) HEAP table to speed up many joins.

Suppose we want to do the following join may times with the same data.

<PRE>
SELECT tab1.a, tab3.a FROM tab1, tab2, tab3
        WHERE tab1.a = tab2.a and tab2.a = tab3.a and tab2.c != 0;
</PRE>

これをスピードアップするために、我々は、
tab2 と tab3 を join した一時テーブルを作成することができます。
なぜならこれらは同じフィールド(tab1.a) に参照されるからです。
以下に一時テーブルの作成と SELECT を示します。

<PRE>
CREATE TEMPORARY TABLE test TYPE=HEAP
        SELECT
                tab2.a as a2, tab3.a as a3
        FROM
                tab2, tab3
        WHERE
                tab2.a = tab3.a and c = 0;
SELECT tab1.a, test.a3 from tab1, test where tab1.a = test.a1;
SELECT tab1.b, test.a3 from tab1, test where tab1.a = test.a1 and something;
</PRE>

</DL>



<H3><A NAME="Static_format" HREF="manual.ja_toc.html#Static_format">10.6.1  Static (Fixed-length) table characteristics</A></H3>


<UL>
<LI>

これはデフォルトのフォーマットです。 これはテーブルに <CODE>VARCHAR</CODE>,
<CODE>BLOB</CODE>, <CODE>TEXT</CODE> フィールドがない場合に、使用されます。
<LI>

全ての <CODE>CHAR</CODE>, <CODE>NUMERIC</CODE>, <CODE>DECIMAL</CODE> フィールドは、そのフィールド長
に足りない部分にはスペースが埋められます。
<LI>

とても速い
<LI>

Easy to cache.
<LI>

Easy to reconstruct after a crash, because records are located in fixed
positions.
<LI>

Doesn't have to be reorganized (with <CODE>myisamchk</CODE>) unless a huge number of
records are deleted and you want to return free disk space to the operating
system.
<LI>

通常、動的テーブルよりも多くのディスク容量が必要。
</UL>



<H3><A NAME="Dynamic_format" HREF="manual.ja_toc.html#Dynamic_format">10.6.2  Dynamic table characteristics</A></H3>


<UL>
<LI>

このフォーマットは、<CODE>VARCHAR</CODE>, <CODE>BLOB</CODE>, <CODE>TEXT</CODE> フィールドが
含まれている場合に使用されます。
<LI>

全ての文字フィールドが動的になります（ただし4byteより短い物は除きます）
<LI>

Each record is preceded by a bitmap indicating which columns are empty
(<CODE>''</CODE>) for string columns, or zero for numeric columns (this isn't
the same as columns containing <CODE>NULL</CODE> values).  If a string column
has a length of zero after removal of trailing spaces, or a numeric
column has a value of zero, it is marked in the bit map and not saved to
disk.  Non-empty strings are saved as a length byte plus the string
contents.
<LI>

通常、固定長のテーブルよりも少ないディスク容量ですみます
<LI>

Each record uses only as much space as is required. If a record becomes
larger, it is split into as many pieces as required.  This results in record
fragmentation.
<LI>

If you update a row with information that extends the row length, the
row will be fragmented.  In this case, you may have to run <CODE>myisamchk
-r</CODE> from time to time to get better performance.  Use <CODE>myisamchk -ei
tbl_name</CODE> for some statistics.
<LI>

Not as easy to reconstruct after a crash, because a record may be fragmented
into many pieces and a link (fragment) may be missing.
<LI>

期待されるレコードの長さは：


<PRE>
3
+ (フィールド数 + 7) / 8
+ (char フィールドの数)
+ 数値フィールドをパックしたサイズ
+ 文字の長さ
+ (NULL フィールドの数 + 7) / 8
</PRE>

There is a penalty of 6 bytes for each link. A dynamic record is linked
whenever an update causes an enlargement of the record. Each new link will be
at least 20 bytes, so the next enlargement will probably go in the same link.
If not, there will be another link. You may check how many links there are
with <CODE>myisamchk -ed</CODE>. All links may be removed with <CODE>myisamchk -r</CODE>.
</UL>



<H3><A NAME="Compressed_format" HREF="manual.ja_toc.html#Compressed_format">10.6.3  Compressed table characteristics</A></H3>


<UL>
<LI>

A read-only table made with the <CODE>myisampack</CODE> utility. All customers
with extended <STRONG>MySQL</STRONG> email support are entitled to a copy of
<CODE>myisampack</CODE> for their internal usage.
<LI>

The uncompress code exists in all <STRONG>MySQL</STRONG> distributions so that
even customers who don't have <CODE>myisampack</CODE> can read tables that
were compressed with <CODE>myisampack</CODE>
<LI>

Takes very little disk space. Minimises disk usage.
<LI>

Each record is compressed separately (very little access overhead).  The
header for a record is fixed (1-3 bytes) depending on the biggest record in the
table.  Each column is compressed differently. Some of the compression types
are:

<UL>
<LI>

There is usually a different Huffman table for each column.
<LI>

Suffix space compression.
<LI>

Prefix space compression.
<LI>

Numbers with value <CODE>0</CODE> are stored using 1 bit.
<LI>

If values in an integer column have a small range, the column is stored using
the smallest possible type. For example, a <CODE>BIGINT</CODE> column (8 bytes) may
be stored as a <CODE>TINYINT</CODE> column (1 byte) if all values are in the range
<CODE>0</CODE> to <CODE>255</CODE>.
<LI>

If a column has only a small set of possible values, the column type is
converted to <CODE>ENUM</CODE>.
<LI>

A column may use a combination of the above compressions.
</UL>

<LI>

Can handle fixed or dynamic length records, but not <CODE>BLOB</CODE> or <CODE>TEXT</CODE>
columns.
<LI>

Can be uncompressed with <CODE>myisamchk</CODE>.
</UL>

<P>
<STRONG>MySQL</STRONG> can support different index types, but the normal type is
ISAM.  This is a B-tree index and you can roughly calculate the size for the
index file as <CODE>(key_length+4)*0.67</CODE>, summed over all keys.  (This is for
the worst case when all keys are inserted in sorted order.)

</P>
<P>
String indexes are space compressed. If the first index part is a string, it
will also be prefix compressed.  Space compression makes the index file
smaller if the string column has a lot of trailing space or is a <CODE>VARCHAR</CODE>
column that is not always used to the full length. Prefix compression helps
if there are many strings with an identical prefix.

</P>
<P>
<A NAME="IDX637"></A>
<A NAME="IDX638"></A>


<H3><A NAME="HEAP_format" HREF="manual.ja_toc.html#HEAP_format">10.6.4  In memory table characteristics</A></H3>

<P>
HEAP テーブルはメモリー内にのみ存在することが出来ます。
そのため、もし <CODE>mysqld</CODE> が止められたりクラッシュしたりした場合、
このデータはなくなります。
しかしこれは <STRONG>とても</STRONG> 速いので、とにかく便利です。

</P>
<P>
The <STRONG>MySQL</STRONG> internal HEAP tables uses 100% dynamic hashing
without overflow areas and don't have problems with delete.

</P>
<P>
You can only access things by equality using a index (usually by the
<CODE>=</CODE> operator) whith a heap table. 

</P>
<P>
HEAP のもつマイナス面は:

<OL>
<LI>

同時に使用したいと思っている HEAP テーブルを全て記憶できるような、
十分おおきなメモリが必要。
<LI>

インデックスのパートをサーチできません。
<LI>

You can't search for the next entry in order (that is to use the index
to do a <CODE>ORDER BY</CODE>).
<LI>

<STRONG>MySQL</STRONG> also cannot find out how approximately many rows there
are between two values. This is used by the optimizer to chose which
index to use. But on the other hand no disk seeks are even needed.
</OL>



<H2><A NAME="Tips" HREF="manual.ja_toc.html#Tips">10.7  Other optimization tips</A></H2>

<P>
Unsorted tips for faster systems:

</P>

<UL>
<LI>

コネクションオーバーヘッドを避けるために、データベースに対して、
逐次コネクションを落とさないように、常に接続を保ちます。
<LI>

あなたのクエリがテーブルのインデックスを使用しているか、いつもチェックします。
<STRONG>MySQL</STRONG> では <CODE>EXPLAIN</CODE> コマンドでこれが行えれます。
 「<A HREF="manual.ja_Reference.html#EXPLAIN">7.22  <CODE>EXPLAIN</CODE> 構文 (<CODE>SELECT</CODE>についての情報を得る)</A>」節参照.
<LI>

Try to avoid complex <CODE>SELECT</CODE> queries on tables that are updated a
lot. This is to avoid problems with table locking.
<LI>

In some cases it may make sense to introduce a column that is 'hashed'
based on information from other columns. If this column is short and
reasonable unique it may be much faster than a big index on many
columns. In <STRONG>MySQL</STRONG> its very easy to use this extra column:
<CODE>SELECT * from table where hash='calculated hash on col1 and col2'
and col_1='constant' and col_2='constant' and ..</CODE>
<LI>

多くの変更がなされるテーブルに対しては、全ての <CODE>VARCHAR</CODE> や <CODE>BLOB</CODE> 
フィールドを避けるように試みるべきです。
You will get dynamic row length as soon as you
are using a single <CODE>VARCHAR</CODE> or <CODE>BLOB</CODE> columns.  「<A HREF="manual.ja_Server.html#Table_types">9.4  MySQL table types</A>」節参照.
<LI>

It's not normally useful to split a table into different tables just
because the rows gets 'big'. To access a row, the biggest performance
hit is the disk seek to find the first byte of the row. After finding
the data most new disks can read the whole row fast enough for most
applications. The only cases it really matters to split up a table is if
its a dynamic row size table (see above) that you can change to a fixed
row size. Or if you very often need to scan the table and don't need
most of the columns.  「<A HREF="manual.ja_Server.html#Table_types">9.4  MySQL table types</A>」節参照.
<LI>

If you very often need to calculate things based on information from a
lot of rows (like counts of things) it's probably much better to
introduce a new table and update the counter in real time. An update of
type <CODE>UPDATE table set count=count+1 where index_column=constant</CODE>
is very fast!

This is really important when you use databases like <STRONG>MySQL</STRONG> that
only has table locking (multiple readers / single writers). This will
also give better performance with most databases as the row locking
manager in this case will have less to do.
<LI>

If you need to collect statistics from big log tables use summary tables
instead of scanning the whole table. Maintaing the summarys should be
much faster than trying to do statistics 'live'. It's much faster to
re-generate new summary tables from the logs when things changes
(depending on business decisions) than to have to change the running
application!
<LI>

If possible one should classify reports as 'live' or 'statistical',
where data needed for statistical reports are only generated based on
summary tables that are generated from the actual data.
<LI>

Take advantage of the fact that columns have default values. Insert
values explicitly only when the value to be inserted differs from the
default. This reduces the parsing that MySQL need to do and improves the
insert speed.
<LI>

In some cases its convenient to pack and store data into a blob In this
case you have to add some extra code in your appliction to pack/unpack
things in the blob but this may save a lot of accesses at some stage.
This is practical when you have data that doesn't conform to a static
table structure.
<LI>

In normal cases you should try to keep data in the 3 normal form, but
you should not be afraid of duplication things or create summary tables
if you need these to gain more speed.
<LI>

ストアド・プロセジャ や UDF (ユーザー定義関数) はよりパフォーマンスを得る
ためにはよい方法かもしれません。
In this case you should however always have a way
to do this some other (slower) way if you use some database that doesn't
support this.
<LI>

You can always gain something by caching queries/answers in your
application and try to do many inserts/updates at the same time.  If
your database supports lock tables (like <STRONG>MySQL</STRONG> and Oracle),
this should help to ensure that the index cache is only flushed once
after all updates.
<LI>

Use <CODE>INSERT /*! DELAYED */</CODE> when you do not need to now when your
data is written. This speeds things up since many records can be written
with a single disk write.
<LI>

Use <CODE>INSERT /*! LOW_PRIORITY */</CODE> when you want your selects are
more important.
<LI>

Use <CODE>SELECT /*! HIGH_PRIORITY */</CODE> to get selects that jumps the
que. That is the select is done even if there is somebody waiting to do
a write.
<LI>

複数行 <CODE>INSERT</CODE> 文の使用。 これは多くのレコードを一つの SQL コマンドで
挿入することが出来ます。
(多くの SQL サーバーがこれをサポートしています)
<LI>

Use <CODE>LOAD DATA INFILE</CODE> to load bigger amounts of data. This if
faster than normal inserts and will be even faster when <CODE>myisamchk</CODE>
is integrated in <CODE>mysqld</CODE>.
<LI>

Use <CODE>AUTO_INCREMENT</CODE> columns to make unique values.
<LI>

動的テーブルフォーマットの使用時には、フラグメンテーションを避けるために、
<CODE>OPTIMIZE TABLE</CODE> を時々使用します。
 「<A HREF="manual.ja_Reference.html#OPTIMIZE_TABLE">7.9  <CODE>OPTIMIZE TABLE</CODE>構文</A>」節参照.

<LI>

可能ならば <CODE>HEAP</CODE> テーブルをスピードアップのために使用します.  「<A HREF="manual.ja_Server.html#Table_types">9.4  MySQL table types</A>」節参照.
<LI>

通常の Web サーバーの設定ならば、イメージはファイルに保存すべきです。
データベースには、それらファイルの参照(パスとか)のみを入れます。
この主な理由は、通常の Web サーバーはデータベースよりもコンテンツを
よりよくキャッシュしてくれるからです。 それでファイルを使用するなら、
速いシステムをより簡単に得ることができます。
<LI>

重要でないデータで、よくアクセスされる物は、メモリテーブルにいれます。
(like
information about the last shown banner for users that doesn't have
cookies)
<LI>

Columns with identical information in different tables should be
declared identical and have identical names. Before version 3.23 you
eneded up with slow joins otherwise.

Try to keep the names simple (use <CODE>name</CODE> instead of
<CODE>customer_name</CODE> in the customer table). To make your names portable
to other SQL servers you should keep them shorter than 18 characters.
<LI>

If you need REALLY high speed you should take a look at the low level
interfaces for data storage that the different SQL servers support!  For
example by accessing the <STRONG>MySQL</STRONG> <CODE>MyISAM</CODE> directly you could
get a speed increase of 2-5 times compared to using the SQL interface.
The be able to do this the data must however be on the same server as
the application and usually it should only be accessed by on processes
(because external file locking is real slow).  One could eliminate the
above problems by introducing low level <CODE>MyISAM</CODE> commands in the
<STRONG>MySQL</STRONG> server (this could be one easy way to get more
performance if needed).  By carefully designing the database interface
it should be quite easy to support this types of optimisations.
<LI>

In many cases it's faster to access data from a database (using a live
connection) than accessing a text file, just because the database is
likely to be more compact than the text file (if you are using numerical
data) and this will involve fewer disk accesses.  You will also save
code because you don't have to parse your text files to find line and
column boundaries.
<LI>

You can also use replication to speed things up.  「<A HREF="manual.ja_Common_problems.html#Replication">19.1  データベースの複製</A>」節参照.
</UL>



<H2><A NAME="Benchmarks" HREF="manual.ja_toc.html#Benchmarks">10.8  Using your own benchmarks</A></H2>

<P>
You should definitely benchmark your application and database to find
out where is the bottlenecks.  By fixing it (or by replacing the
bottleneck with a 'dummy module') you can then easily identify the next
bottleneck (and so on).  Even if the overall performance for your
application is 'good enough' you should at least make a 'plan', for each
bottleneck, how to solve it if you someday 'really need it fix it'.

</P>
<P>
For some example portable becnchmark programs look at the MySQL
benchmark suite.  「<A HREF="manual.ja_MySQL_Benchmarks.html#MySQL_Benchmarks">11  <STRONG>MySQL</STRONG> ベンチマークスイート</A>」節参照. You can take any program this
suite and modify it for your needs. By doing this, you can try different
solutions to your problem and test which is really the fastest solution
for you.

</P>
<P>
It is very common that some problems only occur then the system is very
heavily loaded. And we have had many customer who contacts us then they
have a (tested) system in production and have have got load problems. In
every on these cases so far it has been problems with basic design
(table scans are NOT good at high load) or OS/Library issues. Most of
this would be a <STRONG>LOT</STRONG> easier to fix if the system where not
already in production.

</P>
<P>
To avoid probles like this you should put some effort into benchmarking
your whole appliction under the worst possible load!

</P>


<H2><A NAME="Design" HREF="manual.ja_toc.html#Design">10.9  Design choices</A></H2>

<P>
MySQL keeps row data and index data in separate files. Many (almost all)
other databases mix row and index data in the same file. We belive that
the MySQL choice is better for a very wide range of modern systems.

</P>
<P>
Another way to store the row data is to keep the information for each
column in a separate area (examples are SDBM and Focus). This will get a
performance hit for every query that access more than one column. Since
this degenerates so quickly when more that when one columns are accessed
we believe that this model is not good for general purpose databases.

</P>
<P>
The more common case is there the index and data are stored together
(like in Oracle/Sybase at all). In this case you will find the row
information at the leaf page of the index. The good thing with this
layout is that it in many cases (depends on how well the index is
cached) saves a disk read.  The bad things with this layout is:

</P>
<DL COMPACT>

<DT>*
<DD>
Table scanning is much slower since you have to read through the indexes
to get at the data.
<DT>*
<DD>
You loose a lot of space as you must duplicate indexes from the nodes
(as you can't store the row in the nodes)
<DT>*
<DD>
Deletes will degenerate the table over times (as indexes in nodes are
usually not updated on delete).
<DT>*
<DD>
You can't use only the index table to retrieve data for a query.
<DT>*
<DD>
The index data is harder to cache.
</DL>



<H2><A NAME="Design_Limitations" HREF="manual.ja_toc.html#Design_Limitations">10.10  MySQL design limitations/tradeoffs</A></H2>

<P>
Since MySQL uses extremely fast table locking (multiple readers / single
writers) the biggest remaining problem is a mix of a steady stream of
inserts and slow selects on the same table.

</P>
<P>
We belive that for a huge number of system the extreamy fast performance
in other cases make this choice a win. This case is usually also
possible to solve by having multiple copies of the table. But it takes
more effort and hardware.

</P>
<P>
We are also working on some extension to solve this problem for some
common application niches.

</P>


<H2><A NAME="Portability" HREF="manual.ja_toc.html#Portability">10.11  Portability</A></H2>

<P>
Since all SQL servers implement different parts of SQL it takes work to
write portable SQL applications. For very simple selects/inserts it is
very easy but the more you need the harder it gets. And if you want a
application that is fast with many databases it becomes even harder!

</P>
<P>
To make a complex application portable you need to choose a number of
SQL server that it should work with.

</P>
<P>
When you can use the <STRONG>MySQL</STRONG> crash-me program/web-page
<a HREF="http://www.mysql.com/crash-me-choose.htmy">http://www.mysql.com/crash-me-choose.htmy</a> to find functions,
types and limits you can use with a selection of database
servers. Crash-me now test a long way from everything possible but it
still is vｴcomprehensive with about 450 things tested.

</P>
<P>
For example, you shouldn't have longer column names than 18 characters
if you want to be able to use Informix or DB2.

</P>
<P>
Both the <STRONG>MySQL</STRONG> benchmarks and Crash-me programs are very
database independent.  By taking a look of how we have handled this, you
can get a feeling of what you have to do to write your application
database independent.  The benchmark themselves can be found in the
<TT>`sql-bench'</TT> directory in the <STRONG>MySQL</STRONG> source
distribution. They are written in Perl with DBI database interface
(which solves the access part of the problem.

</P>
<P>
See <a HREF="http://www.mysql.com/benchmark.html">http://www.mysql.com/benchmark.html</a> the results from this
benchmark.

</P>
<P>
As you can see in these results all databases has some weak points. That
is they have different design compromises that lead to different
behavior. 

</P>
<P>
If you strive for database independence you need to get a good feeling
of each SQL servers bottlenecks. <STRONG>MySQL</STRONG> is VERY fast in
retrieving and updating things, but will have a problem in mixing slow
readers/writers on the same table. Oracle on the other hand has a big
problem when you try to access rows that you have recently updated
(until they are flushed to disk). Transaction databases in general are
not very good in generating summary tables from log tables as in this
case row locking is almost useless.

</P>
<P>
To get your application 'really database independent' you need to define
a easy extendable interface through which you manipulate your data. As
C++ is available on most systems, it makes sense to use a C++ classes
interface to the databases.

</P>
<P>
If you use some specific feature for some database (like the
<CODE>REPLACE</CODE> command in <STRONG>MySQL</STRONG>), you should code a method for
the other SQL servers to implement the same feature (but slower).  With
<STRONG>MySQL</STRONG> you can use the <CODE>/*!  */</CODE> syntax to add
<STRONG>MySQL</STRONG> specific keywords to a query.  The code inside
<CODE>/**/</CODE> will be treated as a comment (ignored) by most other SQL
servers.

</P>
<P>
If REAL high performance is more important than exactness, like in some
web applications. A possibility is to create a application layer that
caches all results to give you even higher performance. By just letting
old results 'expire' after a while you can keep the cache reasonable
fresh.  This is quite nice in case of extremely high load, in which case
you can dynamicly increase the cache to be bigger and set the expire
timeout higher until things gets back to normal.

</P>
<P>
In this case the table creating information should contain information
of the initial size of the cache and how often the table should normally
be refreshed.

</P>


<H2><A NAME="Internal_use" HREF="manual.ja_toc.html#Internal_use">10.12  What have we used MySQL for?</A></H2>

<P>
MySQL の初期の開発期には、MySQL は我々のもっとも大口の顧客に合うように
機能が作成されました。 彼らは、いくつかのスウェーデン最大手の小売り業者
のために、倉庫に入れている（商品）データを取り扱います。

</P>
<P>
我々は、すべての店から、全ボーナス・カード取扱高の、その週間まとめを得ます。
そして、その店のオーナにとって有益な情報、その店の広告キャンペーンが
お客にどの程度影響を及ぼすか、を提供することが、我々に求められています。

</P>
<P>
そのデータは、とても大きくて (約700万/月 回の取り扱い)、
我々はその顧客に提供する必要のあるデータを 4〜10年分、持っています。
我々は、カスタマーから、彼らがこのデータからできる新しいレポートに
”即時に”アクセスしたいという、要求を受けました。

</P>
<P>
我々はこれを、全ての月ごとの情報を圧縮した 'transaction' テーブルに
保存することで解決しました。
We have a set of simple macros/script that
generate summary tables grouped by different criterias (product group,
customer id, store ...) from the transaction tables. 
そのレポートは Web ページで、これは小さな perl スクリプトで動的に
作成されます。 この perl script は Web Page を分析し、SQL 文を
実行し、結果を挿入します。
Now we would have used PHP or mod_perl instead but they where
not available at that time.

</P>
<P>
画像データのために、我々は簡単なツールを <CODE>C</CODE> でかきました。
これは SQL のクエリの結果を元に(結果にいくつか処理をして) GIF を提供します。
これも動的に perl スクリプト(<CODE>HTML</CODE> ファイルを分析する)から実行されます。

</P>
<P>
In most cases a new report can simple by done by copying a existing
script and modifying the SQL query in it.  In some cases we will need to
add more fields to an existing summary table or generate a new one, but
this is also quite simply as we keep all transactions tables on disk.
(Currently we have at least 50G of transactions tables and 200G of other
customer data).

</P>
<P>
We also let our customers access the summary tables directly with ODBC
so that the advanced users can themselves experiment with the data.

</P>
<P>
我々はこれらを  Sun Ultra sparcstation (2x200 Mz) で扱っていますが、
なんの問題もありません。
We recently upgrade one of our servers to a 2
CPU 400 Mz Ultra sparc and we are now planing to start handling
transactions on the product level, which would mean a 10 fold increase
of data. We think we can keep up with this by just adding more disk to
our systems.

</P>
<P>
We are also experimenting with Intel-Linux to be able to get more cpu
power cheaper.  現在、我々はバイナリ互換のデータベースフォーマットを持っており
(new in 3.23) 、我々はこれをアプリケーションのいくつかの部分に使用しはじめる事でしょう。

</P>
<P>
Our initial feelings are that Linux will perform much better on low to
medium load but Solaris will perform better when you start to get a a
high load because of extrema disk IO, but we don't yet have anything
conclusive about this. After some discussion with a Linux Kernel
developer this might be a side effect of Linux giving so much resources
to the batch job that the interactive performance gets very low. This
make the machine feel very slow and unresponsive while big batches are
going. Hopefully this will be better handled in future Linux Kernels.

</P>
<P><HR><P>
Go to the <A HREF="manual.ja_Introduction.html">first</A>, <A HREF="manual.ja_Server.html">previous</A>, <A HREF="manual.ja_MySQL_Benchmarks.html">next</A>, <A HREF="manual.ja_Concept_Index.html">last</A> section, <A HREF="manual.ja_toc.html">table of contents</A>.
 </BODY>
 </HTML>
