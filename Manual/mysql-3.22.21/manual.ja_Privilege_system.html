<html><head>
  <!-- This HTML file has been created by texi2html 1.52 (hacked by david@detron.se)
     from manual.ja.texi on 1 December 1999 -->

  <title>MySQL Reference Manual for version 3.22.21. - 6  MySQL 特権はどのように動くか？</title>
  </head>
  <body bgcolor="#FFFFFF" text="#000000" link="#101090" vlink="#7030B0">
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_Compatibility.html">previous</a>, <a href="manual.ja_Reference.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
<p></p><hr><p>


</p><h1><a name="Privilege_system" href="manual.ja_toc.html#Privilege_system">6  <strong>MySQL</strong> 特権はどのように動くか？</a></h1>

<p>
<strong>MySQL</strong> は先進的な非標準のセキュリティ/特権システムを持っています。
本章ではどのようにそれが動くかを述べます。

</p>



<h2><a name="What_Privileges" href="manual.ja_toc.html#What_Privileges">6.1  特権システムの行うこと</a></h2>

<p>
<strong>MySQL</strong> 特権システムの基本機能は、与えられたホストから接続する
ユーザを認証すること、そしてデータベースの
 <strong>select</strong>, <strong>insert</strong>, <strong>update</strong>, <strong>delete</strong> 特権を与えることです。

</p>
<p>
拡張機能は匿名ユーザをもつ能力を含み、<code>LOAD DATA INFILE</code> のような 
<strong>MySQL</strong> 固有の機能を使用する許可を与えます。

</p>



<h2><a name="User_names" href="manual.ja_toc.html#User_names">6.2  <strong>MySQL</strong> ユーザ名とパスワード</a></h2>

<p>
<strong>MySQL</strong> によって使用されるユーザー名とパスワードの使用のされ方と、
UNIX, Windows で使用される方法とは、いくつか異なる点があります。

</p>

<ul>
<li>

<strong>MySQL</strong> データベースのアクセス認証に使用するユーザー名は、
UNIX のログインユーザやWindowsのユーザー名で行うことはありません(一致していません)。
利便性をはかるため、多くの <strong>MySQL</strong> クライアントは現在のログインしているユーザ名を
<strong>MySQL</strong>のユーザー名としてログインを試みます。
しかしこれは <code>-u</code> か <code>--user</code> スイッチで変更できます。
これは、全てのユーザに対しパスワードを設定しておかないと、
全くデータベースを安全にできないことを意味します。
もしパスワードを全ユーザーに設定しておかないと、そのユーザー名で認証なしにサーバーに接続できます。

</li><li>

<strong>MySQL</strong> のユーザー名は 16文字まで(英数半角)使用できます。
UNIXはだいたい8文字ですが。(8文字をこえるシステムもある)

</li><li>

<strong>MySQL</strong> ユーザーのパスワードは、Unix のパスワードと違います。
よって、それらのマシン上で Unix のログインパスワードと
データベースのパスワードは同じにする必要はありません。

</li><li>

<strong>MySQL</strong> は Unix のログインパスワードとは全く違う、
独自の暗号化されたパスワードだけを使用します。
<code>PASSWORD()</code> と <code>ENCRYPT()</code> 関数の説明を参照 →  「<a href="manual.ja_Reference.html#Miscellaneous_functions">7.4.12  その他の関数</a>」節.
</li></ul>



<h2><a name="Connecting" href="manual.ja_toc.html#Connecting">6.3  <strong>MySQL</strong> サーバーに接続</a></h2>

<p>
<strong>MySQL</strong> クライアントプログラムは、共通の決まった引数を持ちます：
接続したいホスト名、接続ユーザー名、そしてパスワードです。
例えば、<code>mysql</code> コマンドは以下のような引数を持ちます
(オプションの引数は <samp>`['</samp> と <samp>`]'</samp> で囲まれている部分です)

</p>

<pre>shell&gt; mysql [-h host_name] [-u user_name] [-pyour_pass]
</pre>

<p>
<code>-h</code>, <code>-u</code>, <code>-p</code> オプションは以下と等価です。
<code>--host=host_name</code>, <code>--user=user_name</code>, <code>--password=your_pass</code>
<code>-p</code> とパスワードの間にはスペースがないことに注意

</p>
<p>
<em>注意:</em> コマンドラインにパスワードを与えるのは安全ではありません！
システムに入っている如何なるユーザーも <code>ps auxww</code> のようなコマンドを
使用する事でパスワードを見付ける事ができます
 「<a href="manual.ja_Installing.html#Option_files">4.15.4  オプションファイル ( <code>my.cnf</code> )</a>」節参照.

</p>
<p>
<code>mysql</code> コマンドはコマンドラインに引数がなければ接続にデフォルト値を用います。

</p>

<ul>
<li>

デフォルトのホスト名は <code>localhost</code>, ユーザー名は Unix のログイン名です。

</li><li>

(<code>-p</code> が指定されていなければパスワードは与えられません)
</li></ul>

<p>
Unix のログインユーザーが <code>joe</code> の場合、以下のコマンドは等価です：

</p>

<pre>shell&gt; mysql -h localhost -u joe
shell&gt; mysql -h localhost
shell&gt; mysql -u joe
shell&gt; mysql
</pre>

<p>
他の <strong>MySQL</strong> クライアントも同じように動作します。

</p>
<p>
Unix システムでは、ある値をデフォルト値にして接続に使用することができます。
そうすることにそり、毎回毎回コマンドラインに引数を与えなくてすむようになります：

</p>

<ul>
<li>

<a name="IDX121"></a>
自分のホームディレクトリに <tt>`.my.cnf'</tt> を作り、そのファイルの中の
<code>[client]</code> セクションに接続用のパラメターを記述できます。
その記述は以下のようです：


<pre>[client]
host=host_name
user=user_name
password=your_pass
</pre>

 「<a href="manual.ja_Installing.html#Option_files">4.15.4  オプションファイル ( <code>my.cnf</code> )</a>」節参照.

</li><li>

<a name="IDX122"></a>
<a name="IDX123"></a>
<a name="IDX124"></a>
<a name="IDX125"></a>
<a name="IDX126"></a>
<a name="IDX127"></a>
接続のパラメターに環境変数を使用することもできます。
ホスト名は <code>MYSQL_HOST</code> 環境変数を使用します。
<strong>MySQL</strong> のユーザー名は <code>USER</code> (これは Windows のみ) に設定された値を使用します。
パスワードは <code>MYSQL_PWD</code> 環境変数を見ますが、これは危険です。(次の節参照)
</li></ul>

<p>
<a name="IDX128"></a>
もし接続のためのパラメターの設定が複数重なっていた場合、コマンドラインに与えられた値が、
設定ファイルに書かれたものと環境変数をを上書きします。
設定ファイルに書かれた値は、環境変数で与えられたものを上書きします。

</p>



<h3><a name="Password_security" href="manual.ja_toc.html#Password_security">6.3.1  パスワードを安全にする</a></h3>

<p>
自分のパスワードを他人にさらけ出すのは勧められることではありません。
それぞれの方法に於ける危険度に応じ、以下に示す方法でクライアントプログラムに
あなたのパスワードをあたえて走らせることができます：

</p>

<ul>
<li>

<code>-pyour_pass</code> か <code>--password=your_pass</code> オプションをコマンドラインで使用します。
これは便利ですが安全ではありません。あなたのパスワードは (<code>ps</code> コマンドのような)
システムの状態を見るコマンドにて見ることができます。
(<strong>MySQL</strong> クライアントは初期化過程においてコマンドラインの引数をゼロで上書きして
見せないようにしているのですが、瞬間ですが値が見えてしまうのです)

</li><li>

<code>-p</code> あるいは <code>--password</code> オプションを <code>your_pass</code> を与えないで使用します。
この場合、クライアントプログラムはターミナルを通じてパスワードの入力を促してきます:


<pre>shell&gt; mysql -u user_name -p
Enter password: ********
</pre>

クライアントはあなたの入力したパスワードを <samp>`*'</samp> 文字で端末に返していますので、
画面をのぞき込まれたとしてもパスワードはわかりません。

これはコマンドラインにパスワードを指定するより安全です。他のユーザーには見えませんから。
しかしこのパスワードを毎回入れる方法は対話式のプログラムを実行する場合だけに使用できる手です。
もし非対話式のスクリプトからクライアントプログラムを起動したい場合、
パスワードを端末から入れる機会がありません。

</li><li>

<a name="IDX129"></a>
設定ファイルにパスワードを書いておくこともできます。
例えば、自分のホームディレクトリーにある <tt>`.my.cnf'</tt> ファイルの <code>[client]</code>
セクションに、以下のような形で書きます：


<pre>[client]
password=your_pass
</pre>

もし <tt>`.my.cnf'</tt> ファイルにパスワードを書いているなら、ファイルはグループや
その他のユーザーが読み書きできないようにすべきです。ファイルのモードは <code>400</code>
か <code>600</code> にします。

 「<a href="manual.ja_Installing.html#Option_files">4.15.4  オプションファイル ( <code>my.cnf</code> )</a>」節参照.
</li><li>

<code>MYSQL_PWD</code> 環境変数にパスワードを設定することもできます。しかしこの方法は
きわめて危険であるので、使用すべきではありません。
<code>ps</code> のあるバージョンでは、実行中のプロセスの環境変数を表示するオプションがあります；
もし <code>MYSQL_PWD</code> 環境変数にパスワードを設定していると全てべたで見れます。
このバージョンの <code>ps</code> を持っていないシステムだとしても、プロセスの環境変数を調べる
方法がないとはいえないので、この方法はあまりいい方法ではありません。
</li></ul>

<p>
まとめると、より安全な方法は、
パスワードプロンプトを返すクライアントプログラムを実行するか、
適切なパーミッションをかけた <tt>`.my.cnf'</tt> ファイルにパスワードを書くか
です。

</p>



<h2><a name="Privileges_provided" href="manual.ja_toc.html#Privileges_provided">6.4  <strong>MySQL</strong> が提供する特権</a></h2>

<p>
特権の設定は <code>mysql</code> データベースの <code>user</code>, <code>db</code>, <code>host</code>,
 <code>tables_priv</code>, <code>columns_priv</code> で行います。
(<code>mysql</code> はデータベースの名前です)
<strong>MySQL</strong> サーバーは、サーバーの起動時か
  「<a href="manual.ja_Privilege_system.html#Privilege_changes">6.8  いつ特権の変更が反映されるか</a>」節 で説明されている方法により、
これらのテーブルから特権の設定を読み込みます。

</p>
<p>
<strong>MySQL</strong> が提供する特権の名称は,
本マニュアルでは以下の表の名称を用います。
この表の項目名がそれぞれの許可される特権とその説明に対応しています：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Privilege</strong> </td><td> <strong>Column</strong> </td><td> <strong>Context</strong>
</td></tr>
<tr><td><strong>select</strong> </td><td> <code>Select_priv</code> </td><td> tables
</td></tr>
<tr><td><strong>insert</strong> </td><td> <code>Insert_priv</code> </td><td> tables
</td></tr>
<tr><td><strong>update</strong> </td><td> <code>Update_priv</code> </td><td> tables
</td></tr>
<tr><td><strong>delete</strong> </td><td> <code>Delete_priv</code> </td><td> tables
</td></tr>
<tr><td><strong>index</strong> </td><td> <code>Index_priv</code> </td><td> tables
</td></tr>
<tr><td><strong>alter</strong> </td><td> <code>Alter_priv</code> </td><td> tables
</td></tr>
<tr><td><strong>create</strong> </td><td> <code>Create_priv</code> </td><td> databases, tables or indexes
</td></tr>
<tr><td><strong>drop</strong> </td><td> <code>Drop_priv</code> </td><td> databases or tables
</td></tr>
<tr><td><strong>grant</strong> </td><td> <code>Grant_priv</code> </td><td> databases or tables
</td></tr>
<tr><td><strong>references</strong> </td><td> <code>References_priv</code> </td><td> databases or tables
</td></tr>
<tr><td><strong>reload</strong> </td><td> <code>Reload_priv</code> </td><td> server administration
</td></tr>
<tr><td><strong>shutdown</strong> </td><td> <code>Shutdown_priv</code> </td><td> server administration
</td></tr>
<tr><td><strong>process</strong> </td><td> <code>Process_priv</code> </td><td> server administration
</td></tr>
<tr><td><strong>file</strong> </td><td> <code>File_priv</code> </td><td> file access on server
</td></tr>
</tbody></table>

<p>
<strong>select</strong>, <strong>insert</strong>, <strong>update</strong>, <strong>delete</strong> の特権は、
存在しているデータベースのテーブルに対して許可されます。

</p>
<p>
もしテーブルから行を取り出すだけなら、<code>SELECT</code> 構文を実行するためには
 <strong>select</strong> 特権だけあればかまいません。
だけでなく、サーバーのどのデータベースにアクセスを許可されていない場合でも、
ある種の <code>SELECT</code> は実行することができます。
例えば、簡単な計算を <code>mysql</code> クライアントで行う場合です：

</p>

<pre>mysql&gt; SELECT 1+1;
mysql&gt; SELECT PI()*2;
</pre>

<p>
<strong>index</strong> 特権はインデックスの作成と破棄(削除)を許可します。

</p>
<p>
<strong>alter</strong> 特権は <code>ALTER TABLE</code> の実行を許可します。

</p>
<p>
<strong>create</strong> と <strong>drop</strong> 特権は、新しいデータベースやテーブルの作成、
あるいは既に存在するデータベース、テーブルの破棄(削除)を許可します。

</p>
<p>
注意： <code>mysql</code> データベースに登録されているユーザーに <strong>drop</strong> 権限を与えると、
そのユーザーは <strong>MySQL</strong> のアクセス特権が格納されているデータベースを破棄できます！

</p>
<p>
<strong>grant</strong> 特権は、あなたが他のユーザーに対して自分の特権を持たせる事を許可します。

</p>
<p>
 <strong>file</strong> の特権を与えると、<code>LOAD DATA INFILE</code> と <code>SELECT ... INTO OUTFILE</code> 構文を使用して、サーバーのファイルを読み書きする事ができます。
 <strong>MySQL</strong> サーバーがが読み書きできるファイルに対して、この特権が与えられたユーザーはファイルを読み書きできます。

</p>
<p>
残りの特権はアドミン操作に関する許可で、<code>mysqladmin</code> コマンドを使用して実行します。
次の表に <code>mysqladmin</code> コマンドのどれが、どの特権に対応しているかを示します：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Privilege</strong> </td><td> <strong>Commands permitted to privilege holders</strong>
</td></tr>
<tr><td><strong>reload</strong> </td><td> <code>reload</code>, <code>refresh</code>,
<code>flush-privileges</code>,
<code>flush-hosts</code>, <code>flush-logs</code>, <code>flush-tables</code>
</td></tr>
<tr><td><strong>shutdown</strong> </td><td> <code>shutdown</code>
</td></tr>
<tr><td><strong>process</strong> </td><td> <code>processlist</code>, <code>kill</code>
</td></tr>
</tbody></table>

<p>
<code>reload</code> コマンドはサーバーに特権の設定を再読込させるように伝えます。
<code>refresh</code> コマンドは全てのテーブルをフラッシュし、ログファイルを開き直します。
<code>flush-privileges</code> は <code>reload</code> と同義です。
その他の <code>flush-*</code> コマンドは <code>refresh</code> の動作とよく似ていますが、
適用範囲を絞っており、ちょっとした場合に有効です。
例えば、ログファイルだけをフラッシュしたい場合、
<code>refresh</code> を行うよりも <code>flush-logs</code> がいいです。

</p>
<p>
<code>shutdown</code> コマンドは、サーバーをシャットダウンします。

</p>
<p>
<code>processlist</code> コマンドはサーバーが実行しているスレッドの情報を表示します。
 <code>kill</code> コマンドはサーバーのスレッドをkillします。
自分のスレッドは常に表示、killできますが、他人のスレッドをそうするには <strong>process</strong> 特権が必要です。

</p>
<p>
ある特権を欲しがるユーザーだけにその特権を許可するのはよい考えですが、
特権を与えるときには、特定の事項を熟知していなければなりません：

</p>

<ul>
<li>

<strong>grant</strong> 特権を許可されたユーザーは、他のユーザーの特権を変える事ができます。
二人のユーザー間で違っている特権と <code>grant</code> 特権を入れ換えることができます。

</li><li>

<strong>alter</strong> 特権は、テーブル名の変更を行うことにより特権システムを破るために
使用されるかもしれません。

</li><li>

<strong>file</strong> 特権は、サーバー上にある全ての読み込み可能なファイルを
データベースに取り込むことができ、これは <code>SELECT</code> 文でアクセスできます。

</li><li>

<strong>shutdown</strong> 特権は、他のユーザーに対するサービスを、サーバーを
停止することによって、拒否するようにできます。

</li><li>

<strong>process</strong> 特権は実行されているクエリーをプレーンテキストで見ることに使えます。
パスワードの設定、変更のクエリーも含みます。

</li><li>

 <code>mysql</code> データベースに対しての特権は、パスワードの変更と他の特権の設定を変更ができます。
パスワードは暗号化されて登録されており、悪意のあるユーザーでも
単純に読むことはできませんが、この特権を許可されたそのユーザーは、
パスワードを違うものに変えることができます。
</li></ul>

<p>
以下は <strong>MySQL</strong> の特権システムで行うものではありません：

</p>

<ul>
<li>

アクセスを拒否するユーザーを特定して設定することはできません。
完全に一致したユーザーからの接続を拒否できません。

</li><li>

データベース内のテーブルの作成、破棄の特権を持つが、
データベースそのものを作成、破棄できる、そのようなユーザーを設定できません。
</li></ul>



<h2><a name="Privileges" href="manual.ja_toc.html#Privileges">6.5  特権システムはどのように動くか？</a></h2>

<p>
<strong>MySQL</strong> の特権システムは、全てのユーザーが与えられた許可の範囲内で動く事を保証します。
<strong>MySQL</strong> サーバーに接続するとき、本人の身元は、<strong>接続元のホスト</strong> と
 <strong>接続に使用するユーザー名</strong> によって確認されます。
このシステムは、あなたの身元と<strong>あなたが要求することが何か</strong> によって、特権を与えます。

</p>
<p>
<strong>MySQL</strong> はあなたのホスト名とユーザー名の両方をあわせてチェックします。
これはインターネット上に同じ名前のユーザーがどこかにいるかもしれないということからそうしています。
例えば、<code>whitehouse.gov</code> から接続してきた <code>bill</code> と、
 <code>mosoft.com</code> から接続してきた <code>bill</code> は同一人物である必要はありません。
<strong>MySQL</strong> はこの違うホストから接続してきた同名のユーザーを以下のようにして扱います：
 <code>whitehouse.gov</code> から接続した <code>bill</code> にある許可をあたえ、
それとは違う許可を <code>mosoft.com</code> から接続してきた <code>bill</code> に与えます。

</p>
<p>
<strong>MySQL</strong> のアクセスコントロールは以下の二つからなります：

</p>

<ul>
<li>

Stage 1: サーバーは接続許可があるかどうかをチェックします。

</li><li>

Stage 2: 接続許可後、サーバーはそれぞれのリクエストをチェックします。
あなたが要求してきた事柄を、あなたが実行できるかどうかをチェックします。
例えば、あるデータベースのテーブルの行の取り出しやテーブルの破棄をあなたが命令した場合、
サーバーは、あなたにそのテーブルに対する <strong>select</strong> 許可があるのか、
データベースに対して <strong>drop</strong> する許可が与えられているのか、を確認します。
</li></ul>

<p>
サーバーは <code>mysql</code> データベースの <code>user</code>, <code>db</code>, <code>host</code> ３つのテーブルから、
この２つのアクセス制限を決定します。
このテーブルのフィールドは以下のようになっています：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Table name</strong> </td><td> <code>user</code> </td><td> <code>db</code> </td><td> <code>host</code>

</td></tr>
<tr><td><strong>Scope fields</strong> </td><td> <code>Host</code> </td><td> <code>Host</code> </td><td> <code>Host</code>
</td></tr>
<tr><td></td><td> <code>User</code> </td><td> <code>Db</code> </td><td> <code>Db</code>
</td></tr>
<tr><td></td><td> <code>Password</code> </td><td> <code>User</code> </td><td>

</td></tr>
<tr><td><strong>Privilege fields</strong> </td><td> <code>Select_priv</code> </td><td> <code>Select_priv</code> </td><td> <code>Select_priv</code>
</td></tr>
<tr><td></td><td> <code>Insert_priv</code> </td><td> <code>Insert_priv</code> </td><td> <code>Insert_priv</code>
</td></tr>
<tr><td></td><td> <code>Update_priv</code> </td><td> <code>Update_priv</code> </td><td> <code>Update_priv</code>
</td></tr>
<tr><td></td><td> <code>Delete_priv</code> </td><td> <code>Delete_priv</code> </td><td> <code>Delete_priv</code>
</td></tr>
<tr><td></td><td> <code>Index_priv</code> </td><td> <code>Index_priv</code> </td><td> <code>Index_priv</code>
</td></tr>
<tr><td></td><td> <code>Alter_priv</code> </td><td> <code>Alter_priv</code> </td><td> <code>Alter_priv</code>
</td></tr>
<tr><td></td><td> <code>Create_priv</code> </td><td> <code>Create_priv</code> </td><td> <code>Create_priv</code>
</td></tr>
<tr><td></td><td> <code>Drop_priv</code> </td><td> <code>Drop_priv</code> </td><td> <code>Drop_priv</code>
</td></tr>
<tr><td></td><td> <code>Grant_priv</code> </td><td> <code>Grant_priv</code> </td><td> <code>Grant_priv</code>
</td></tr>
<tr><td></td><td> <code>Reload_priv</code> </td><td> </td><td> 
</td></tr>
<tr><td></td><td> <code>Shutdown_priv</code> </td><td> </td><td> 
</td></tr>
<tr><td></td><td> <code>Process_priv</code> </td><td> </td><td> 
</td></tr>
<tr><td></td><td> <code>File_priv</code> </td><td> </td><td> 
</td></tr>
</tbody></table>

<p>
　アクセスコントロールの第2段階(要求承認)のために、サーバーはこれら 3 つの
テーブルによって決められた許可を基本としますが、もしテーブルに対する要求で
あるならば、<code>tables_priv</code> と <code>columns_priv</code> テーブルを
さらに調べます。これらのテーブルのフィールドは以下のようになっています：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Table name</strong> </td><td> <code>tables_priv</code> </td><td> <code>columns_priv</code>

</td></tr>
<tr><td><strong>Scope fields</strong> </td><td> <code>Host</code> </td><td> <code>Host</code>
</td></tr>
<tr><td></td><td> <code>Db</code> </td><td> <code>Db</code>
</td></tr>
<tr><td></td><td> <code>User</code> </td><td> <code>User</code>
</td></tr>
<tr><td></td><td> <code>Table_name</code> </td><td> <code>Table_name</code>
</td></tr>
<tr><td></td><td> </td><td> <code>Column_name</code>

</td></tr>
<tr><td><strong>Privilege fields</strong> </td><td> <code>Table_priv</code> </td><td> <code>Type</code>
</td></tr>
<tr><td></td><td> <code>Column_priv</code> </td><td>

</td></tr>
<tr><td><strong>Other fields</strong> </td><td> <code>Timestamp</code> </td><td> <code>Timestamp</code>
</td></tr>
<tr><td></td><td> <code>Grantor</code> </td><td>
</td></tr>
</tbody></table>

<p>
　テーブルの各項目を分類すると、２種類にわかれます：
適用範囲を指定する項目(以下　スコープフィールド)と許可を定義する項目(以下　特権フィールド)です。

</p>
<p>
　スコープフィールドは、特権テーブルの登録ごとに、その適用範囲を決めます。
例えば、 <code>user</code> テーブルの <code>Host</code> と <code>User</code> に
 <code>'thomas.loc.gov'</code> と <code>'bob'</code> が登録されている場合、
サーバーへの接続は ホスト <code>thomas.loc.gov</code> から来た <code>'bob'</code> に許可されます。
同様に、<code>db</code> テーブルの  <code>Host</code>, <code>User</code>, <code>Db</code> に
 <code>'thomas.loc.gov'</code>, <code>'bob'</code>, <code>'reports'</code> が登録されていると、
ホスト <code>thomas.loc.gov</code> から来た <code>bob</code> に対し <code>reports</code> データベースへの接続が許されます。
<code>tables_priv</code> と <code>columns_priv</code> テーブルは、
テーブルか、テーブルとフィールドを対にしたスコープフィールドを含みます。

</p>
<p>
<a name="IDX130"></a>
　アクセスのチェックは、<code>Host</code> の値はケース非依存で比較されます。
<code>User</code>, <code>Password</code>, <code>Db</code>, <code>Table_name</code> の値はケース依存で比較されます。
<code>Column_name</code> の値は <strong>MySQL</strong> 3.22.12 以上ではケース非依存で比較されます。
(3.22.11 までは ケース依存です)

</p>
<p>
特権フィールドは、テーブルに登録されることにより有効になった許可をしめし、
これはどの操作が実行できるかを示します。
サーバーは許可テーブルの情報をユーザーの特権を得るためにまとめます。
このユーザーの特権許可を割り出す方法は  「<a href="manual.ja_Privilege_system.html#Request_access">6.7  Access control, stage 2: 要求の承認</a>」節 に述べておきます。

</p>
<p>
スコープフィールドは文字で定義され、デフォルト値は空文字になっています：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Field name</strong> </td><td> <strong>Type</strong>
</td></tr>
<tr><td><code>Host</code> </td><td> <code>CHAR(60)</code>
</td></tr>
<tr><td><code>User</code> </td><td> <code>CHAR(16)</code>
</td></tr>
<tr><td><code>Password</code> </td><td> <code>CHAR(16)</code>
</td></tr>
<tr><td><code>Db</code> </td><td> <code>CHAR(64)</code> </td><td> (<code>CHAR(60)</code> for the
<code>tables_priv</code> and <code>columns_priv</code> tables)
</td></tr>
</tbody></table>

<p>
<code>user</code>, <code>db</code>, <code>host</code> テーブルでは、
全ての特権フィールドは <code>ENUM('N','Y')</code> で定義されます。
この値は <code>'N'</code> か <code>'Y'</code> のどちらかで、デフォルト値は <code>'N'</code> です。

</p>
<p>
<code>tables_priv</code> と <code>columns_priv</code> テーブルでは、
特権フィールドは <code>SET</code> フィールドとして定義されます：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><strong>Table name</strong> </td><td> <strong>Field name</strong> </td><td> <strong>Possible set elements</strong>
</td></tr>
<tr><td><code>tables_priv</code> </td><td> <code>Table_priv</code> </td><td> <code>'Select', 'Insert',
'Update', 'Delete', 'Create', 'Drop', 'Grant', 'References', 'Index', 'Alter'</code>
</td></tr>
<tr><td><code>tables_priv</code> </td><td> <code>Column_priv</code> </td><td> <code>'Select', 'Insert',
'Update', 'References'</code>
</td></tr>
<tr><td><code>columns_priv</code> </td><td> <code>column_priv</code> </td><td> <code>'Select', 'Insert',
'Update', 'References'</code>
</td></tr>
</tbody></table>

<p>
サーバーは以下のように許可テーブルを使用します：

</p>

<ul>
<li>

<code>user</code> テーブルのスコープフィールドは、接続要求を受け入れるか拒否するかを決定します。
特権フィールドは、その許可されたユーザーのグローバルな許可状態を定義します。
(訳注：
例えば、<code>user</code> テーブル の特権を <code>'Y'</code> にした場合、
どんなに <code>Db</code> や <code>Host</code> で <code>'N'</code> にしたとしても <code>'Y'</code> のままである。
ようは <code>user</code> テーブルの特権許可 <code>'Y'</code> が全てに反映されてしまうという事。
<code>user</code> テーブルには最低限の許可を与えるようにし、
<code>Db</code> や <code>Host</code> ごとに、それぞれの特権許可を定義する方が無難。
)

</li><li>

<code>db</code> と <code>host</code> テーブルは一緒に使用されます：


<ul>
<li>

<code>db</code> テーブルのスコープフィールドはどのホストからどのデータベースのアクセスできるかを決定します。
特権フィールドは、どういった操作ができるか定義します。

</li><li>

<code>host</code> テーブルは、<code>db</code> テーブルの登録ににホストを与えた場合に、
<code>db</code> テーブルの拡張として使用されます。
例えば、ネットワーク上の限定したマシンからデータベースを使用したい場合、
<code>db</code> テーブルの <code>Host</code> の値は空にしておきます。
そして <code>host</code> テーブルにそれぞれのホストについての登録を行います。
この機構は、  「<a href="manual.ja_Privilege_system.html#Request_access">6.7  Access control, stage 2: 要求の承認</a>」節 で詳細に述べられています。
</li></ul>

</li><li>

<code>tables_priv</code> と <code>columns_priv</code> テーブルは <code>db</code> テーブルに似ていますが、
それらはより細かく定義できます；
データベースレベルではなく、テーブルとフィールドのレベルで与えます。
</li></ul>

<p>
管理者特権 (<strong>reload</strong>, <strong>shutdown</strong>,など) は <code>user</code> テーブルにだけ定義するように。
これは、管理者操作はデータベースではなくサーバーへの操作であり、
他の許可テーブルにある必要がないからです。
またこうしておくと、管理者操作の許可は、<code>user</code> テーブルの定義だけを
見ればわかるようになります。

</p>
<p>
<strong>file</strong> 操作の特権は <code>user</code> テーブルにだけ定義するように。
これは管理者操作ではありませんが、アクセスしているデータベースにかかわらず、
サーバー内のファイルを読み書きできるのです。

</p>
<p>
<code>mysqld</code> サーバーは起動時にこれらのテーブルを読み込みます。
許可テーブルの変更を反映させる方法はこちらを参照のこと →  「<a href="manual.ja_Privilege_system.html#Privilege_changes">6.8  いつ特権の変更が反映されるか</a>」節

</p>
<p>
これらのテーブルの登録を変更した場合、思ったとおりの特権状態になっている事を確認することはいいことです。
問題の解決には,  「<a href="manual.ja_Privilege_system.html#Access_denied">6.12  何故 <code>Access denied</code> エラーになるのか</a>」節.  セキュリティに関するアドバイスは
 「<a href="manual.ja_Privilege_system.html#Security">6.13  <strong>MySQL</strong> をクラッカーに対して安全にする方法</a>」節.

</p>
<p>
便利なツールとして <code>mysqlaccess</code> スクリプト( Yves Carlier 作)が <strong>MySQL</strong> の配布に含まれています。
<code>mysqlaccess</code> を  <code>--help</code> オプションで起動するとヘルプが表示されます。
<code>mysqlaccess</code> は <code>user</code>,<code>db</code> and <code>host</code> テーブルだけしか
検査しません。テーブルレベルの特権、フィールドレベルの特権は調べません。

</p>



<h2><a name="Connection_access" href="manual.ja_toc.html#Connection_access">6.6  Access control, stage 1: 接続の承認</a></h2>

<p>
<strong>MySQL</strong> サーバーに接続すると、あなたがパスワード認証して接続していようがいまいが、
サーバーはあなたの身元により接続の許可拒否を行います。
もし身元が一致しない場合接続を拒否し、接続許可した場合、サーバーは stage 2 へと進み、要求を待ちます。

</p>
<p>
身元は二つのものに基づいて確認されます：

</p>

<ul>
<li>

あなたが接続しようとしているホスト

</li><li>

あなたの <strong>MySQL</strong> ユーザー名
</li></ul>

<p>
身元の確認は <code>user</code> テーブルのスコープフィールド(<code>Host</code>, <code>User</code>, <code>Password</code>) を使用して行います。
サーバーは <code>user</code> テーブルの登録に一致しているホスト名とユーザー名に限り接続を許可し、その後、パスワードを要求します。

</p>
<p>
<code>user</code> テーブルのスコープフィールドの登録は以下のようになります：

</p>

<ul>
<li>

<code>Host</code> の値はホスト名か IP アドレスか <code>'localhost'</code>(ローカルホスト) です。

</li><li>

<a name="IDX131"></a>
<code>Host</code> にはワイルドカード文字 <samp>`%'</samp> と <samp>`_'</samp> を使用できます。

</li><li>

<code>Host</code> に <code>'%'</code> を設定すると、全てのホストにマッチします。
<code>Host</code> を空にすると、<code>'%'</code> と同じになります。
これらの値は、<em>どんなホストもサーバーに接続できる</em>ということになります！

</li><li>

<a name="IDX132"></a>
ワイルドカード文字は <code>User</code> フィールドには設定できませんが、
<code>User</code> フィールドをブランク(空)にすることはできます。ブランクは全ての名前にマッチします。
これはユーザー名がない状態で接続してきたものに適用され、
クライアントがユーザー名を明記しない限り、匿名ユーザー(名前がブランク)として扱われます。
全てのアクセスのチェックにブランクのユーザー名が使用される事を意味します。(that is, during stage 2)

</li><li>

<code>Password</code> フィールドは空にできます。その場合、パスワードなして接続できることになります。
</li></ul>

<p>
<a name="IDX133"></a>
非ブランクの <code>Password</code> 値はパスワードを暗号化したものです。
<strong>MySQL</strong> はだれもが見れるようにパスワードを平文では保存しません。
接続を試みようとしているユーザーのパスワードも、(<code>PASSWORD()</code> 関数で)
暗号化され、<code>user</code> テーブルに保存されている暗号化パスワードと
比較します。もし一致したなら、パスワードは正しいということです。

</p>
<p>
以下の表は、接続要求に対して与える、
<code>user</code> テーブルの <code>Host</code> と  <code>User</code> の設定例です：

</p>
<table border="" width="100%" nosave="">
<tbody><tr><td><code>Host</code> <strong>value</strong> </td><td> <code>User</code> <strong>value</strong> </td><td> <strong>Connections matched by entry</strong>
</td></tr>
<tr><td><code>'thomas.loc.gov'</code> </td><td> <code>'fred'</code> </td><td> <code>fred</code>, <code>thomas.loc.gov</code> から接続
</td></tr>
<tr><td><code>'thomas.loc.gov'</code> </td><td> <code>''</code> </td><td> <code>thomas.loc.gov</code> から接続してくる全てのユーザー
</td></tr>
<tr><td><code>'%'</code> </td><td> <code>'fred'</code> </td><td> <code>fred</code>, 全てのホストから接続
</td></tr>
<tr><td><code>'%'</code> </td><td> <code>''</code> </td><td> 全てのホストから接続してくる全ユーザー
</td></tr>
<tr><td><code>'%.loc.gov'</code> </td><td> <code>'fred'</code> </td><td> <code>fred</code>, <code>loc.gov</code> ドメイン内の全てのホストからの接続
</td></tr>
<tr><td><code>'x.y.%'</code> </td><td> <code>'fred'</code> </td><td> <code>fred</code>, <code>x.y.net</code>, <code>x.y.com</code>,<code>x.y.edu</code>, などからの接続. (あまり有効な使い方ではないです)
</td></tr>
<tr><td><code>'144.155.166.177'</code> </td><td> <code>'fred'</code> </td><td> <code>fred</code>, IP address が <code>144.155.166.177</code> のホストからの接続
</td></tr>
<tr><td><code>'144.155.166.%'</code> </td><td> <code>'fred'</code> </td><td> <code>fred</code>, <code>144.155.166</code> class C subnet 内の全てのホストからの接続
</td></tr>
</tbody></table>

<p>
<code>Host</code> に IP のワイルドカード(例えば <code>'144.155.166.%'</code> は
サブネットの全てのホストにマッチ) を使用することができます。
が、この場合、 <code>144.155.166.somewhere.com</code> というホスト名で
だれかが接続しようとしてくるかもしれません。
このような攻撃に対し、<strong>MySQL</strong> は数字やドットで始まるホスト名を拒否しています。
もし <code>1.2.foo.com</code> のような名前のホストを持っている場合、
許可テーブルの <code>Host</code> には絶対にマッチしません。
IPアドレスのみ、IP のワイルドカードにマッチする事になります。

</p>
<p>
サーバーに来る接続は、<code>user</code> テーブル内の登録に１つ以上
マッチするかもしれません。
例えば, <code>thomas.loc.gov</code> の <code>fred</code> からの接続は、上に示された
登録のうちのいくつかにマッチするでしょう。
サーバーは、複数の登録にマッチした場合、どのようにしてその中から
使用する登録を選ぶのでしょう？
サーバーは起動後に <code>user</code> テーブルをソートし、並び換えられた順に
登録を検索することにより、この問題を解決します。
最初にマッチした登録が使用されます。

</p>
<p>
<code>user</code> テーブルが以下のようにソートされていた場合：

</p>

<pre>+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| %         | root     | ...
| %         | jeffrey  | ...
| localhost | root     | ...
| localhost |          | ...
+-----------+----------+-
</pre>

<p>
サーバーがこのテーブルを読むと、<code>Host</code> に値が最も確実に特定できるホストを指定しているエントリを、最初に参照します。
(<code>Host</code> 項の <code>'%'</code> は ``すべてのホスト'' を意味し、ホスト名をはっきりと特定しているものではありません)

</p>
<p>
<code>Host</code> の値が同じエントリがあった場合、もっとも明確に <code>User</code> の値がユーザーを指定しているエントリを最初に参照します。(<code>User</code> の値が空の場合、``だれでも'' を意味します)
この結果、<code>user</code> テーブルは以下のようにソートされます：

</p>

<pre>+-----------+----------+-
| Host      | User     | ...
+-----------+----------+-
| localhost | root     | ...
| localhost |          | ...
| %         | jeffrey  | ...
| %         | root     | ...
+-----------+----------+-
</pre>

<p>
<a name="IDX134"></a>
<a name="IDX135"></a>
<a name="IDX136"></a>
接続が試みられた場合、サーバーは並び換えられた登録を探し、最初に見つけたものを
使用します。
<code>'localhost'</code> の <code>jeffrey</code> からの接続は、まず最初に <code>Host</code> に <code>localhost</code> を設定しているエントリにマッチします。
ユーザー名が空のエントリは、ホスト名とユーザー名の両方を指定した接続にもマッチします。
( <code>'%'/'jeffrey'</code> エントリもマッチします。が、これは最初にはマッチしません。)

</p>
<p>
もう一例。<code>user</code> が以下の設定と仮定します：

</p>

<pre>+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| %              | jeffrey  | ...
| thomas.loc.gov |          | ...
+----------------+----------+-
</pre>

<p>
これは次のようにソートされます：

</p>

<pre>+----------------+----------+-
| Host           | User     | ...
+----------------+----------+-
| thomas.loc.gov |          | ...
| %              | jeffrey  | ...
+----------------+----------+-
</pre>

<p>
<code>thomas.loc.gov</code> の <code>jeffrey</code> からの接続は、最初のエントリにマッチし、
<code>whitehouse.gov</code> の <code>jeffrey</code> からの接続は、二つ目のエントリにマッチします。

</p>
<p>
最初にサーバが,接続のためのマッチを見つけるのを試みるとき,共通の誤解は与えられた
ユーザ名に明らかにそのユーザを命名するすべてのエントリが使用されると思うことです.
これは単に本当ではありません. jeffreyによるthomas.loc.govからの接続が最初に
エントリによってユーザ分野値として‘jeffrey'を含まないいずれのエントリによってる合わ
せられる場合,前の例はこれをユーザ名なしで例示します!

</p>
<p>
よくある考え違いは、ユーザー名を与えた場合、
サーバーが接続にマッチするものを探す際に、
そのユーザーが登録されている全てのルールが、
最初に使用されるだろうと考えることです。これは正しくありません。
前の例でこれを示しましたが、<code>thomas.loc.gov</code> の <code>jeffrey</code> からの接続が
最初にマッチするのは、 <code>User</code> フィールドの値が <code>'jeffrey'</code> に
なっているエントリではなく、ユーザー名なし(＝だれでも) のエントリの方が
先にマッチします！

</p>
<p>
もしサーバーへの接続がうまく行かない場合、 <code>user</code> テーブルを表示し、
マニュアルでソートしてみて、どのエントリに最初にマッチするか探してください。

</p>



<h2><a name="Request_access" href="manual.ja_toc.html#Request_access">6.7  Access control, stage 2: 要求の承認</a></h2>

<p>
一度接続か確立されると、サーバーはステージ２に移ります。
このステージでは、サーバーはこの接続から来るそれぞれの要求が許可されているかどうかをチェックします。
チェックは実行しようとしている操作のタイプにより行います。
その操作が許可テーブルのどの特権フィールドに当てはまるかを見ます。
これら特権は  <code>user</code>, <code>db</code>,<code>host</code>, <code>tables_priv</code> か <code>columns_priv</code> テーブルより導出されます。
許可テーブルは <code>GRANT</code> コマンドで操作します。
 「<a href="manual.ja_Reference.html#GRANT">7.26  <code>GRANT</code> と <code>REVOKE</code> 構文</a>」節参照.
(You may find it helpful to refer to the table shown earlier that lists
the fields present in each of the grant tables; see  「<a href="manual.ja_Privilege_system.html#Privileges">6.5  特権システムはどのように動くか？</a>」節.)

</p>
<p>
<code>user</code> テーブルは全てに対して基本となる特権をユーザーに割り当てます。
たとえカレントのデータベースが許可を与えていなくても、<code>user</code> テーブルの設定が有効になります。
例えば、<code>user</code> テーブルで <strong>delete</strong> を許可した場合、
サーバーにあるどんなデータベースの行も削除できるのです！ 
いうならば、<code>user</code> テーブルの特権はスーパーユーザーの特権と言ってもいいでしょう。
この特権はスーパーユーザー(サーバーやデーターベース管理者)のみに与えておく事が賢明です。
他のユーザーは、<code>user</code> テーブルの特権の設定を <code>'N'</code> のままにしておくべきですし、
また、<code>db</code> テーブルと <code>host</code> テーブルを利用して、
データベースを指定した上でユーザーに特権を許可すべきです。

</p>
<p>
<a name="IDX137"></a>
<a name="IDX138"></a>
<a name="IDX139"></a>
<code>db</code> テーブルと <code>host</code> テーブルは特定のデータベースに対する特権許可を行います。
Values in the scope fields may be specified as follows:

</p>

<ul>
<li>

ワイルドカード文字 <samp>`%'</samp> と <samp>`_'</samp> は <code>Db</code> テーブルと <code>Host</code> フィールドだけに使用できます。

</li><li>

<code>'%'</code> <code>Host</code> 値は ``あらゆるホスト'' を意味します。
<code>db</code> テーブルの <code>Host</code> に空を設定すると、``さらに <code>host</code> テーブルに許可情報を探しにいく''
となります。

</li><li>

<code>'%'</code> か 空値を <code>Host</code> テーブルに設定すると、それは ``あらゆるホスト'' となります。

</li><li>

<code>'%'</code> か 空値を <code>host</code> テーブルの <code>Db</code> フィールドに設定すると、
それは ``あらゆるデータベース'' となります。

</li><li>

<code>User</code> を空値にすると、匿名ユーザーにマッチします。
</li></ul>

<p>
<a name="IDX140"></a>
<a name="IDX141"></a>
<a name="IDX142"></a>
<a name="IDX143"></a>
サーバー起動時に、<code>db</code> テーブルと <code>host</code> テーブルはサーバーに読み込まれます。
(<code>user</code> テーブルもこの時に同時に読まれます)
<code>db</code> テーブルは <code>Host</code>, <code>Db</code>, <code>User</code> のフィールドでソートされ、
<code>host</code> テーブルは <code>Host</code>, <code>Db</code> フィールドでソートされます。
<code>user</code> テーブルは、一番特定できるエントリを最初に、一番特定できないものを最後にソートします。
サーバーはソートされたものの中から、最初にマッチしたものを使用します。

</p>
<p>
<a name="IDX144"></a>
<a name="IDX145"></a>
<code>tables_priv</code> と <code>columns_priv</code> テーブルは、
特定のテーブルとフィールドに対する特権を許可します。
スコープフィールドの値は、いかにそって記述されます：

</p>

<ul>
<li>

ワイルドカード文字 <samp>`%'</samp> と <samp>`_'</samp> はどちらかのテーブルの
<code>Host</code> フィールドに使用できます。

</li><li>

どちらかのテーブルの <code>Host</code> 値を <code>'%'</code> かブランクにすると、
``any host.'' を意味します。

</li><li>

<code>Db</code>, <code>Table_name</code>, <code>Column_name</code> フィールドはどのテーブルにも
ワイルドカードやブランクは使用できません。
</li></ul>

<p>
<code>tables_priv</code> と <code>columns_priv</code> テーブルは
<code>Host</code>, <code>Db</code>, <code>User</code> フィールドで並び換えられます。
これは <code>db</code> テーブルのソートに似ていますが、 <code>Host</code> フィールドだけが
ワイルドカードを含むので、ソートはより単純なものになります。

</p>
<p>
この要求の承認は次のようにして行います。
もしアクセス承認を決定する部分のソースコードを理解できるなら、
ちょっと変わったアルゴリズムで承認の決定を行っている事に気づくでしょう。

</p>
<p>
管理者の要求(<strong>shutdown</strong>, <strong>reload</strong>, etc.)については、サーバーは
 <code>user</code> テーブルだけを参照します。(<code>user</code> テーブルだけが管理者特権のフィールドを持つ)。
エントリに許可登録されている操作は受け入れられ、それ以外は拒否されます。
例えば、<code>mysqladmin shutdown</code> を実行しようとしても、<code>user</code> テーブルの <strong>shutdown</strong> 特権が許されていなければ実行できません。この時、<code>db</code> と <code>host</code> テーブルはチェックされません。(これらのテーブルには <code>Shutdown_priv</code> フィールドが無いからです)

</p>
<p>
データベースへの要求 (<strong>insert</strong>, <strong>update</strong>, etc.) において、サーバーはまず最初に、ユーザーのグローバルな特権(スーパーユーザー)を <code>user</code> の中から探しだします。
もし許可が与えられていれば、アクセスは成功します。

</p>
<p>
<code>user</code> テーブルのグローバルな特権の設定が不十分であるなら、サーバーはユーザーのデータベースに対する特権を <code>db</code> テーブルと <code>host</code> テーブルから決定します：

</p>

<ol>
<li>

サーバーは <code>db</code> テーブルの <code>Host</code>,<code>Db</code>,<code>User</code>フィールドを参照します。
<code>Host</code> と <code>User</code> はユーザーの接続時のホスト名と <strong>MySQL</strong> ユーザー名にマッチします。
<code>Db</code> フィールドはユーザーがアクセスしたいデータベース名にマッチします。
<code>Host</code> と <code>User</code> にマッチするものが無かった場合、アクセスは拒否されます。

</li><li>

<code>db</code> テーブル内の <code>Host</code> フィールドが空でないエントリにマッチした場合、
ユーザーの指定されているデータベースに対する特権が定義されます。

</li><li>

<code>Host</code> フィールドが空値の <code>db</code> テーブルのエントリにマッチした場合、
どのホストがそのデータベースへアクセスできるかを <code>host</code> テーブルから探し出します。
この場合、<code>host</code> テーブル の <code>Host</code>, <code>Db</code> フィールドとマッチするものを探し出します。
<code>host</code> テーブルにエントリがなかった場合、アクセスは拒否されます。
もしマッチすると、ユーザーの特定データベースに対する特権は、
<code>host</code> テーブルと <code>db</code> テーブル両方にまたがった特権から割り出されます。
いうならば両方とも <code>'Y'</code> である特権。
(この方法を使用すると、まず <code>db</code> テーブルのエントリに大まかな特権を設定しておき、
それから <code>host</code> テーブルのエントリを使用して、ホスト情報もとに特権を限定していくという事ができます)
</li></ol>

<p>
特定データベースに対する特権が <code>db</code> テーブルと <code>host</code> テーブルのエントリから決定された後、
サーバーはその割り出された特権に対し、<code>user</code> テーブルて設定されている特権を加えます。
この結果から得られた特権にマッチした要求は受け入れられます。
そうでなければ、サーバーはユーザーのテーブル、フィールドに対する許可を、
 <code>tables_priv</code> と <code>columns_priv</code> 内に探します。
アクセスはこの結果により、許可、拒否されます。

</p>
<p>
先のユーザーの特権が計算される方法の記述は、boolean 表記で示すならば、
以下のようになるでしょう：

</p>

<pre>global privileges
OR (database privileges AND host privileges)
OR table privileges
OR column privileges
</pre>

<p>
これは少し分かりにくいかもしれません。もしグローバルの <code>user</code> エントリ
特権許可が、リクエストされたオペレーションには不十分だと最初に分かった際、
サーバーがこれらの特権を database-, table-, column-固有の特権の
後に、なぜ、追加してしまうのか。
 その理由は、リクエストが1個以上の特権を要求するだろうということです。
例えば、もしあなたが <code>INSERT ...  SELECT</code> 構文を実行するなら、
あなたには <strong>insert</strong> と <strong>select</strong> 許可が必要です。
あなたの特権が、 <code>user</code> テーブルエントリで一つの特権が許可され、
 <code>db</code> テーブルで、そのほかの特権が許可されていたとします。
この場合、あなたは、そのリクエストを実行するために、必要な特権を持っています。
しかし、サーバーはどちらのテーブル、それ単体からでは、特権を得ることが出来ません。
特権は、両方のエントリーを合わせるなくてはならないのです。

</p>
<p>
<code>host</code> テーブルは ``安全な'' ホストのリストを維持するために使用できます。
TcX では、<code>host</code> テーブルにはローカルネット上の全てのホストが登録されています。
これらのホストは全ての特権が許可されています。

</p>
<p>
逆に <code>host</code> table で安全<em>ではない</em>ホストを指定することもできます。
 <code>public.your.domain</code> というマシンが安全ではない、公開されている場所にあるとします。
その場合以下のようにして、その公開マシン以外のネットワーク上のホストに対して、アクセスを許可することができます：

</p>

<pre>+--------------------+----+-
| Host               | Db | ...
+--------------------+----+-
| public.your.domain | %  | ... (all privileges set to 'N')
| %.your.domain      | %  | ... (all privileges set to 'Y')
+--------------------+----+-
</pre>

<p>
特権のテーブル設定は、あなたの思い通りに許可が得られるのか、常に(<code>mysqlaccess</code>等を使用して)チェックすべきです。

</p>



<h2><a name="Privilege_changes" href="manual.ja_toc.html#Privilege_changes">6.8  いつ特権の変更が反映されるか</a></h2>

<p>
<code>mysqld</code> の起動時、全ての許可テーブルはメモリーに読み込まれ、
この時点で有効になります。

</p>
<p>
<code>GRANT</code>, <code>REVOKE</code>, <code>SET PASSWORD</code> を使用して許可テーブルを
変更した場合、直にサーバに通知されます。

</p>
<p>
もし手動で許可テーブルを変更した場合(<code>INSERT</code>, <code>UPDATE</code> などで)、
<code>FLUSH PRIVILEGES</code> 構文か <code>mysqladmin flush-privileges</code> コマンドを
実行して、サーバーに許可テーブルの読み込みを指示しなければなりません。
そうしなければ、サーバーを再起動させるまで、変更は<em>反映されません</em>。

</p>
<p>
サーバーが許可テーブルの変更を通知した場合、既に接続している
クライアントは、以下のような影響を受けます：

</p>

<ul>
<li>

テーブルとフィールドの許可の変更は、次のクライアントの要求から反映されます。

</li><li>

データベースに対する許可の変更は次の <code>USE db_name</code> コマンド以降から
有効になります。

</li></ul>

<p>
グローバル特権とパスワードの変更は、次のクライアントの接続時から反映されます。

</p>



<h2><a name="Default_privileges" href="manual.ja_toc.html#Default_privileges">6.9  <strong>MySQL</strong> 特権許可の初期設定</a></h2>

<p>
<strong>MySQL</strong> インストール後、<code>scripts/mysql_install_db</code> を実行して特権のアクセス許可を初期化します。
 「<a href="manual.ja_Installing.html#Quick_install">4.7.1  素早いインストールの概要</a>」節参照.
<code>scripts/mysql_install_db</code> スクリプトは <code>mysqld</code> サーバーを起動し、
以下のように特権を初期化してテーブルに登録します：

</p>

<ul>
<li>

<strong>MySQL</strong> <code>root</code> ユーザーはスーパーユーザーとして登録され、
全ての操作ができます。
localhostからしか接続できません。

<strong>注意:</strong>
<code>root</code> のパスワードの初期値は空です。
全ての人が <em>パスワードなしで</em> <code>root</code> になれ、全ての特権許可を得ることができます。

</li><li>

<a name="IDX146"></a>
<code>'test'</code> あるいは <code>'test_'</code> で名前がはじまっているデータベースに対して、
匿名ユーザーでもなんでもできるように許可が与えられます。
ローカルホストからの全てのユーザーは接続ができ、匿名ユーザーとして扱われます。

</li><li>

その他の要求は拒否されます。例えば、一般ユーザーは <code>mysqladmin shutdown</code> や <code>mysqladmin processlist</code> を実行できません。
</li></ul>

<p>
<strong>注意:</strong> デフォルトの特権は Win32 では違います。
 「<a href="manual.ja_Installing.html#Win32_running">4.12.4  Win32 上で <strong>MySQL</strong> を実行</a>」節参照.

</p>
<p>
初期インストールの状態ではかなりアクセスが解放されているので、
インストール後最初にすることは、<strong>MySQL</strong> <code>root</code> ユーザーにパスワードを設定することです。
以下のようにします(パスワードは <code>PASSWORD()</code> 関数を使用することをお忘れなく)：

</p>

<pre>shell&gt; mysql -u root mysql
mysql&gt; UPDATE user SET Password=PASSWORD('new_password')
           WHERE user='root';
mysql&gt; FLUSH PRIVILEGES;
</pre>

<p>
<strong>MySQL</strong> 3.22 以上では、<code>SET PASSWORD</code> 構文も使用できます:

</p>

<pre>shell&gt; mysql -u root mysql
mysql&gt; SET PASSWORD FOR root=PASSWORD('new_password');
</pre>

<p>
password をセットする他の方法として、<code>mysqladmin</code> コマンドも使用できます：

</p>

<pre>shell&gt; mysqladmin -u root password new_password
</pre>

<p>
もし最初の方法で <code>user</code> テーブルのパスワードを直接更新したなら、
サーバーに許可テーブルの再読み込みを行わせなければなりません(<code>FLUSH PRIVILEGES</code> を使用して)。

</p>
<p>
一度 <code>root</code> のパスワードを設定したなら、<code>root</code> でサーバーに接続する場合は
常にパスワードを与えなければなりません。

</p>
<p>
追加設定やテストをしているためパスワードを入れたくない場合、
<code>root</code> パスワードをブランクのままにしておこうと考えるかも知れませんが、
実稼働させる前には必ず設定してください。

</p>
<p>
どのようにデフォルトの特権を設定しているか、<code>scripts/mysql_install_db</code> 見てみてください。
これは他のユーザーを設定するときに使えるでしょう。

</p>
<p>
もし特権の初期状態を違うものにして初期化したいなら、
<code>mysql_install_db</code> を実行する前に編集してもよいでしょう。

</p>
<p>
もしテーブルを完全に作り直したいなら、<code>mysql</code> データベースのディレクトリに存在する
全ての <tt>`*.frm'</tt>, <tt>`*.MYI'</tt>, <tt>`*.MYD'</tt> ファイルを削除します。
(このディレクトリーはデータベースディレクトリーの下に <code>mysql</code> という名前で存在します。
<code>mysqld --help</code> とすればデータベースのディレクトリーが表示されます。)
そして好みの許可状態に <code>mysql_install_db</code> を編集してから実行します。

</p>
<p>
<strong>注意:</strong> <strong>MySQL</strong> 3.22.10 以前のバージョンでは, 
<tt>`*.frm'</tt> ファイルを消してはいけません.  もしうっかり消してしまった場合、
<code>mysql_install_db</code> を実行する前に、 <strong>MySQL</strong> 配布からコピーしなおさ
なくてはなりません。

</p>



<h2><a name="Adding_users" href="manual.ja_toc.html#Adding_users">6.10  新しいユーザ特権を <strong>MySQL</strong> へ追加</a></h2>

<p>
ユーザーは２つの違った方法で追加できます：
<code>GRANT</code> 構文を使用して行う方法と、
<strong>MySQL</strong> の許可テーブルを直接操作する方法とです。
<code>GRANT</code> 構文の使用をお勧めします。

</p>
<p>
以下の例では、いかにして <code>mysql</code> クライアントを使用して新規にユーザーを登録するかを示します。
以下の例では、特権は前節で述べたデフォルト値になっているとします。
よって変更を行うためには、あなたは <code>mysqld</code> が走っているマシン上にログインしていなくてはなりませんし、
かつ、<strong>MySQL</strong> <code>root</code> ユーザーで接続していなければなりません。
さらに <strong>MySQL</strong> <code>root</code> ユーザーには
 <code>mysql</code> データベースに対して <strong>insert</strong> 権限を持ち、
<strong>reload</strong> のアドミニストレーター特権を持っていなければなりません。
もし <code>root</code> ユーザーのパスワードを変えていたならば、
 <code>mysql</code> コマンドにパスワード指定を与えなくてはなりません。

</p>

<pre>shell&gt; mysql --user=root mysql
mysql&gt; GRANT ALL PRIVILEGES ON *.* TO monty@localhost
           IDENTIFIED BY 'something' WITH GRANT OPTION;
mysql&gt; GRANT ALL PRIVILEGES ON *.* TO monty@"%"
           IDENTIFIED BY 'something' WITH GRANT OPTION;
mysql&gt; GRANT RELOAD,PROCESS ON *.* TO admin@localhost;
mysql&gt; GRANT USAGE ON *.* TO dummy@localhost;
</pre>

<p>
これら <code>GRANT</code> 構文では3つの新しいユーザを作ります:

</p>
<dl compact="">

<dt><code>monty</code>
</dt><dd>
どこからでもサーバーに接続できる完全なスーパーユーザ。
しかし、<strong>MySQL</strong> を使用する時にはパスワードを使用する必要があります。
<code>monty@localhost</code> と <code>monty@"%"</code> の両方に <code>GRANT</code> 構文を
発行しなくてはならない事に注意してください。
もし <code>localhost</code> からの許可をした登録がないと、<code>localhost</code> から接続した時、
<code>mysql_install_db</code> が自動で作成した <code>localhost</code> への匿名ユーザーが優先されます。
なぜなら、 <code>Host</code> フィールドの値が(ブランクやワールドカード以外に)明記されており、
許可登録が MySQL 内部でソートされる時に順番が上にソートされるからです。

</dd><dt><code>admin</code>
</dt><dd>
<code>localhost</code> からパスワードなしで接続できますが、<code>reload</code>, <code>process</code> の使用だけが許されます。
これは、<code>mysqladmin reload</code>, <code>mysqladmin refresh</code>, <code>mysqladmin flush-*</code> そして
 <code>mysqladmin processlist</code> コマンドの実行がこのユーザーに許可されます。
データベースへのアクセスは許可されていません。
しかしこれは後でテーブル <code>GRANT</code> 構文を発行すれば、
個々のデータベースへのアクセス特権が設定できます。

</dd><dt><code>dummy</code>
</dt><dd>
パスワードなしで localhost からのみ、接続できるユーザー。
グローバルな特権は全て <code>'N'</code> に設定されます。
<code>USAGE</code> 特権は特権無しユーザーの設定を許可する事になります。
これは、特定データーベースに対しての許可を後から与える事を想定しています。
</dd></dl>

<p>
同じアクセス許可を <code>INSERT</code> 構文を使用して直接設定できます。
サーバーに許可テーブルの再読み込みを指示します：

</p>

<pre>shell&gt; mysql --user=root mysql
mysql&gt; INSERT INTO user VALUES('localhost','monty',PASSWORD('something'),
                'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y')
mysql&gt; INSERT INTO user VALUES('%','monty',PASSWORD('something'),
                'Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y','Y')
mysql&gt; INSERT INTO user SET Host='localhost',User='admin',
                 Reload_priv='Y', Process_priv='Y';
mysql&gt; INSERT INTO user (Host,User,Password)
                        VALUES('localhost','dummy','');
mysql&gt; FLUSH PRIVILEGES;
</pre>

<p>
<strong>MySQL</strong> のバージョンにより、上の <code>'Y'</code> の数が違う事に注意してください。
(3.22.11 以前のバージョンでは項目数が少なくなります).
<code>admin</code> ユーザーを登録で使用している <code>INSERT</code> の拡張は 3.22.11 以上で可能です。

</p>
<p>
スーパーユーザーを定義するためには、<code>user</code> テーブルの許可フィールドを
<code>'Y'</code> にするだけでかまいません。
<code>db</code> や <code>host</code> テーブルに登録は必要無いのです。

</p>
<p>
<code>user</code> テーブルの許可フィールドは最後の <code>INSERT</code> 文で(<code>dummy</code> ユーザーのために)
は設定されていません。これらのフィールドはデフォルト値の <code>'N'</code> になります。
これは <code>GRANT USAGE</code> が行うのと同じものです。

</p>
<p>
以下は、<code>localhost</code>, <code>server.domain</code>, <code>whitehouse.gov</code> から接続が可能な
 <code>custom</code> ユーザーの追加例です。
 <code>custom</code> ユーザーは <code>bankaccount</code> データーベースには <code>localhost</code> からの接続のみを許可され、
<code>expenses</code> データベースには <code>whitehouse.gov</code> からのみ接続が許可され、
<code>customer</code> データベースには全てのホストから接続できます。
<code>custom</code> ユーザーは、 <code>stupid</code> というパスワードを全てのホストで使用したいとします。

</p>
<p>
このユーザーの許可を <code>GRANT</code> 構文で定義するには、以下のようにします：

</p>

<pre>shell&gt; mysql --user=root mysql
mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON bankaccount.*
           TO custom@localhost
           IDENTIFIED BY 'stupid';
mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON expenses.*
           TO custom@whitehouse.gov
           IDENTIFIED BY 'stupid';
mysql&gt; GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP
           ON customer.*
           TO custom@'%'
           IDENTIFIED BY 'stupid';
</pre>

<p>
許可テーブルを直接変更してこのユーザーの特権を設定するにはいかのようにします
(<code>FLUSH PRIVILEGES</code> を最後に実行している事に注意)：

</p>

<pre>shell&gt; mysql --user=root mysql
mysql&gt; INSERT INTO user (Host,User,Password)
       VALUES('localhost','custom',PASSWORD('stupid'));
mysql&gt; INSERT INTO user (Host,User,Password)
       VALUES('server.domain','custom',PASSWORD('stupid'));
mysql&gt; INSERT INTO user (Host,User,Password)
       VALUES('whitehouse.gov','custom',PASSWORD('stupid'));
mysql&gt; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES
       ('localhost','bankaccount','custom','Y','Y','Y','Y','Y','Y');
mysql&gt; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES
       ('whitehouse.gov','expenses','custom','Y','Y','Y','Y','Y','Y');
mysql&gt; INSERT INTO db
       (Host,Db,User,Select_priv,Insert_priv,Update_priv,Delete_priv,
        Create_priv,Drop_priv)
       VALUES('%','customer','custom','Y','Y','Y','Y','Y','Y');
mysql&gt; FLUSH PRIVILEGES;
</pre>

<p>
最初の３つの <code>INSERT</code> 文は、 <code>custom</code> ユーザーがそれぞれのホストから
パスワードつきで接続できるように <code>user</code> テーブルに追加しています。
しかしここでは特権は１つも与えられていません(特権のデフォルト値は <code>'N'</code> です)。
次の三つの <code>INSERT</code> 文は、<code>bankaccount</code>, <code>expenses</code>, <code>customer</code>
 データベースに対する該当ホストからのアクセス許可を <code>custom</code> ユーザーに与えるように、
<code>db</code> テーブルに追加しています。
許可テーブルが直接変更された場合、これらをサーバーに反映させるために、許可テーブルの
再読み込みを(<code>FLUSH PRIVILEGES</code>で) サーバーにつげなければなりません。

</p>
<p>
もし、あるドメインの全てのマシンに接続を許可したい場合、
以下のように <code>GRANT</code> 構文を発行します：

</p>

<pre>mysql&gt; GRANT ...
           ON *.*
           TO myusername@"%.mydomainname.com"
           IDENTIFIED BY 'mypassword';
</pre>

<p>
許可テーブルを直接変更するには以下のようにします：

</p>

<pre>mysql&gt; INSERT INTO user VALUES ('%.mydomainname.com', 'myusername', 
           PASSWORD('mypassword'),...);
mysql&gt; FLUSH PRIVILEGES;
</pre>

<p>
もちろん、<code>xmysqladmin</code>, <code>mysql_webadmin</code>, そして <code>xmysql</code> を使って
も、特権テーブルへの値の挿入/変更/更新ができます。これらのユーティリティは 
<strong>MySQL</strong> <a href="http://www.mysql.com/Contrib/">Contrib directory</a>.
に見つけることができます。

</p>



<h2><a name="Passwords" href="manual.ja_toc.html#Passwords">6.11  パスワードの設定法</a></h2>
<p>
<a name="IDX147"></a>
<a name="IDX148"></a>

</p>
<p>
前節の例で述べた、とても重要な基本原則：

</p>
<p>
<code>INSERT</code> か <code>UPDATE</code> で空ではないパスワードを設定する場合、
暗号化するために <code>PASSWORD()</code> 関数を使用しなくてはなりません。
これは <code>user</code> テーブルはプレーンテキストでなく、暗号化されたパスワードであることを要求しているからです。
この原則を忘れてしまった場合、以下のようにしてパスワードをセットしてしまうかもしれません：

</p>

<pre>shell&gt; mysql -u root mysql
mysql&gt; INSERT INTO user (Host,User,Password)
       VALUES('%','jeffrey','biscuit');
mysql&gt; FLUSH PRIVILEGES;
</pre>

<p>
これは <code>user</code> テーブルにプレーンテキストの <code>'biscuit'</code> をパスワードとして登録してしまいます。
<code>jeffrey</code> ユーザーでこのパスワードを使用してサーバーに接続しようとすると、
 <code>mysql</code> クライアントは暗号化したパスワードをサーバーに送ります。
サーバーは暗号化されたパスワード(<code>'biscuit'</code> では<em>ありません</em>) と
 <code>user</code> テーブルに登録された値(<code>'biscuit'</code>) を比較します。
その結果、比較は失敗し、サーバーは接続を拒否します：

</p>

<pre>shell&gt; mysql -u jeffrey -pbiscuit test
Access denied
</pre>

<p>
 <code>user</code> テーブルに登録されるパスワードは暗号化されたものでなくてはなりません。
<code>INSERT</code> 構文は以下のようにして使用しなくてはなりません：

</p>

<pre>mysql&gt; INSERT INTO user (Host,User,Password)
       VALUES('%','jeffrey',PASSWORD('biscuit'));
</pre>

<p>
<code>SET PASSWORD</code> 構文を使用する場合は、以下のようにしなくてはなりません：

</p>

<pre>mysql&gt; SET PASSWORD FOR jeffrey@"%" = PASSWORD('biscuit');
</pre>

<p>
もし <code>GRANT ... IDENTIFIED BY</code> 構文や <code>mysqladmin password</code> コマンド
でパスワードを設定した場合、<code>PASSWORD()</code> 関数は必要ありません。
両方とも、パスワードを暗号化してくれますので、
以下のように<code>'biscuit'</code>と与えます：

</p>

<pre>mysql&gt; GRANT USAGE ON *.* TO jeffrey@"%" IDENTIFIED BY 'biscuit';

shell&gt; mysqladmin -u jeffrey password biscuit
</pre>

<p>
<code>PASSWORD()</code> がパスワードを暗号化することに注意してください。
この暗号化は UNIX のパスワードで使用されている暗号化と違うことにも留意してください。
UNIX パスワードファイルに記録されている暗号と <code>PASSWORD()</code> が暗号化した物が同じでも、
同じパスワードであるとは思わないでください。
 「<a href="manual.ja_Privilege_system.html#User_names">6.2  <strong>MySQL</strong> ユーザ名とパスワード</a>」節参照.

</p>


<h2><a name="Access_denied" href="manual.ja_toc.html#Access_denied">6.12  何故 <code>Access denied</code> エラーになるのか</a></h2>

<p>
もし、<strong>MySQL</strong> サーバーに接続しようとして <code>Access denied</code> エラーに
遭遇してしまったら、以下に記すことが問題の解決のための指標となるでしょう:

</p>

<ul>
<li>

<strong>MySQL</strong> をインストールした後に、スクリプト <code>mysql_install_db</code> を実行しで
許可テーブルを初期化しましたか？
していなければ実行してください。 「<a href="manual.ja_Privilege_system.html#Default_privileges">6.9  <strong>MySQL</strong> 特権許可の初期設定</a>」節参照
特権許可のテーブルが初期化されているかを試すには以下のようにします：


<pre>shell&gt; mysql -u root test
</pre>

これは普通はエラーなしで接続できます。
<strong>MySQL</strong> データベースディレクトリ内に <tt>`user.MYD'</tt> ファイルがあるかどうかでもチェックします。
(普通は <tt>`PATH/var/mysql/user.MYD'</tt> です。ここで <code>PATH</code> は <strong>MySQL</strong> をインストールしたディレクトリーパスを示します。)

</li><li>

初めてインストールした後は、以下のようにしてサーバーに接続してユーザーとアクセス権を設定しなくてはなりません：


<pre>shell&gt; mysql -u root mysql
</pre>

初期状態では、<strong>MySQL</strong> に <code>root</code> ユーザーをパスワードなしで登録しているので、
問題なく接続できるはずです。
しかしこれはセキュリティ上危険な状態なので、
他の <strong>MySQL</strong> ユーザーを登録している時に、
<code>root</code> のパスワードを設定しておいてください。

もし <code>root</code> で接続しようとして以下のエラーが出た場合：


<pre>Access denied for user: '@unknown' to database mysql
</pre>

これは <code>user</code> テーブルに、 <code>User</code> フィールド = <code>root</code> かつ
<code>mysqld</code> がリゾルブできなかったホスト名で、クライアントが登録されていないからです。
この場合、 <tt>`/etc/hosts'</tt> ファイルあるいは <tt>`\windows\hosts'</tt> ファイルを編集して
ホスト名を追加し、<code>--skip-grant-tables</code> オプションでサーバーをリスタートします。

<a name="IDX149"></a>
もし 3.22.11 より前の <strong>MySQL</strong> から 3.22.11 以上にバージョンアップしたなら、
<code>mysql_fix_privilege_tables</code> スクリプトを実行しましたか？
実行していないなら、このエラーになります。
許可テーブルの構造が <strong>MySQL</strong> 3.22.11 から変更され、
<code>GRANT</code> 構文が機能しています。

</li><li>

もし許可テーブルを直接変えて(<code>INSERT</code> か <code>UPDATE</code> 構文で)、
変更が無視されているようならば、サーバーにテーブルを再読み込みさせるために、
<code>FLUSH PRIVILEGES</code> 構文か <code>mysqladmin flush-privileges</code> コマンドを
実行する事を思い出してください。
これを実行しなかった場合、変更は次のサーバーのリスタートまで反映されません。
<code>root</code> ユーザーのパスワードを設定したあとでも、
特権情報を再読み込みするまでは新しいパスワードは不要です。
なぜなら、サーバーは新しいパスワードをまだ知らないからです！

<code>mysqladmin reload</code> を行っても、特権が有効なのは、
このコマンド発行後に新しく接続したクライアントに対してだけです。
(多くの特権情報がサーバーにキャッシュされているためです)

</li><li>

もしあなたの特権がセッションの途中で変更されたように思ったなら、それは
スーパーユーザーが特権を変えたのかも知れません。許可テーブルの再読み込みは
新しいクライアントの接続から反映されますが、すでに接続している場合でも
 「<a href="manual.ja_Privilege_system.html#Privilege_changes">6.8  いつ特権の変更が反映されるか</a>」節. に示す条件下では影響を受けます。

</li><li>

テストのためには、<code>mysqld</code> デーモンを <code>--skip-grant-tables</code> オプショ
ンで開始すべきです。そうすれば <strong>MySQL</strong> 承認テーブルを変更でき、スクリプ
ト <code>mysqlaccess</code> を、あなたの承認が働くかどうかのチェックのために使
用できます。
<code>mysqladmin flush-privileges</code> は <code>mysqld</code> デーモンに新しい承認テーブルの
使用を開始するように知らせます。これは <code>--skip-grant-tables</code> オプションを上書きします。
ユーザーの許可テーブルを読み込ませるのに、サーバーを落して立ち上げ直す必要はありません。

</li><li>

perl, python または ODBC でアクセスの問題があった場合も、常に 
<code>mysql -u user_name db_name</code> または <code>mysql -u user_name -pyour_pass db_name</code> で、
特権の問題をテストしてください。(<code>-p</code> と password の間には空
白がないことに注意してください。<code>--password=your_password</code> 構文でも
パスワードを与えられます)
<code>mysql</code> クライアントで接続できるなら、アクセスの特権の設定の問題ではなく、
プログラムの問題です。

</li><li>

もしあなたのパスワードが働かないのであれば、
<code>INSERT</code>, <code>UPDATE</code>, <code>SET PASSWORD</code> 構文でパスワードを設定するとき
 <code>PASSWORD()</code> 関数を使用しなければならないことを思い出してください。
しかし <code>PASSWORD()</code> 関数は、<code>GRANT ... INDENTIFIED BY</code> 構文や
<code>mysqladmin password</code> コマンドでは不要です。
 「<a href="manual.ja_Privilege_system.html#Passwords">6.11  パスワードの設定法</a>」節参照.

</li><li>

<code>localhost</code> はローカルのホスト名です。
もしクライアントがホストを指定せずに接続してきた場合、<code>localhost</code> がデフォルトで使用されます。
しかし、 MIT-pthreads を使用している場合、<code>localhost</code> への接続は失敗します。
(<code>localhost</code> への接続は、Unixソケットを使用しますが、 MIT-pthreads が ソケット接続をサポートしていないためです。)
この問題が起きるシステムでは、サーバー名を指定するために <code>--host</code> オプションを使用すべきです。
これは TCP/IP 接続を使用して <code>mysqld</code> サーバーに接続します。
この場合、<code>user</code> テーブルに、サーバーの実ホスト名を登録しておかなくてはなりません。
(これはクライアントプログラムをサーバーと同じホスト上で動かしている場合真となります)

</li><li>

<code>mysql -u user_name db_name</code> を使用してデータベースに接続しているときに
 <code>Access denied</code> エラーが発生した場合、<code>user</code> テーブルの設定違いが考えられます。
<code>mysql -u root mysql</code> を実行し、以下の SQL 文を試してください：


<pre>mysql&gt; SELECT * FROM user;
</pre>

<code>Host</code> と <code>User</code> にあなたのコンピュータ名と <strong>MySQL</strong> ユーザー名にマッチする登録がなされていなければなりません。

</li><li>

<code>Access denied</code> エラーは、どのユーザーで接続してきたか、どのホストから接続しようとしているか、パスワードを使用しているのかをメッセージに出力します。
通常、エラーになっているホスト名とユーザー名がマッチするエントリが <code>user</code> テーブルに一つはなければなりません。

</li><li>

他のホストから <strong>MySQL</strong> サーバーに接続を試みた時に以下のエラーが出た場合、
<code>user</code> テーブルにあなたがアクセスしているホストにマッチする行がありません：


<pre>Host ... is not allowed to connect to this MySQL server
</pre>

<code>mysql</code> コマンドをサーバーのホスト上で使用して、
<code>user</code> テーブルに、接続しようとしている ユーザー名／ホスト名 を
加えれば解決できるでしょう。
もしサーバーが <strong>MySQL</strong> 3.22 ではなく、接続しようとしているホストの IP もホスト名もわからない場合、
<code>user</code> テーブルの <code>Host</code> フィールドに <code>'%'</code> を設定し、
<code>mysqld</code> を <code>--log</code> オプションで再起動してください。
そしてクライアントホストから接続すれば、<strong>MySQL</strong> のログファイルに
そのホストの情報が記録されているはずです。
それがわかれば、先に設定した <code>user</code> テーブルの <code>Host</code> フィールドの <code>'%'</code> を
ログに記録されたホスト名に置き換えます。(しかしこれはシステムを危険にさらします)

</li><li>

<code>mysql -u root test</code> は動いたものの <code>mysql -h your_hostname -u root test</code> が
 <code>Access denied</code> を返した場合、
<code>user</code> テーブルに正しいホスト名が使用されていないと思われます。
<code>user</code> テーブルの <code>Host</code> フィールドにホスト名を確定できる形で指定していないか、
使用しているシステムのリゾルブが FQDN (or vice-versa) を返しているかだと思われます。
例えば、<code>user</code> テーブルに <code>'tcx'</code> ホストの定義があったとして、
DNS が <strong>MySQL</strong> に <code>'tcx.subnet.se'</code> をホスト名として返した場合、
これは動きません。
<code>user</code> テーブルの <code>Host</code> フィールドの値に、あなたのホストの IP 番号を加えてください。
(<code>user</code> テーブルの <code>Host</code> の値にワイルドカードを使用することができます。<code>'tcx.%'</code> のように。
しかしホスト名の値を <samp>`%'</samp> 文字で終わらせる設定は、<em>安全ではなく</em>、<em>推奨されません</em>)

</li><li>

もし <code>mysql -u user_name test</code> が動作し <code>mysql -u user_name other_db_name</code> が
動作しない場合は、<code>db</code> テーブルに <code>other_db_name</code> のエントリが
登録されていません。

</li><li>

<code>mysql -u user_name db_name</code> はザーバー上では動作するが、
<code>mysql -u host_name -u user_name db_name</code> がクライアントホスト上で動作しない場合、
<code>user</code> テーブルか <code>db</code> テーブルにクライアントホストの名前が登録されていません。

</li><li>

<code>Access denied</code> の原因がもし上記に当てはまらない場合は、
<code>user</code> テーブルから <code>Host</code> にワイルドカードを使用しているエントリを全て消去してみてください。(<samp>`%'</samp> や <samp>`_'</samp> を含む値です)
よくある間違いは、<code>localhost</code> に対して <code>localhost</code> と同じマシン上から
の接続を許可すると考えて
<code>Host</code>=<code>'%'</code> と <code>User</code>=<code>'some user'</code> を登録することです。
これは動きません。なぜなら、デフォルトの特権に
<code>Host</code>=<code>'localhost'</code> と <code>User</code>=<code>''</code> が含まれているからです。
<code>Host</code> の値が <code>'localhost'</code> の場合、これは <code>'%'</code> よりも
具体的に指定されているので、<code>localhost</code> からの接続にはこちらの方が
使用されるのです！ 正しい指定の仕方は、二番目の登録として
<code>Host</code>=<code>'localhost'</code> と <code>User</code>=<code>'some_user'</code> を追加するか、
あるいは、<code>Host</code>=<code>'localhost'</code> と <code>User</code>=<code>''</code> を削除することです。

</li><li>

もし以下のエラーが出た場合
<code>db</code> か <code>host</code> テーブルに問題があるのかもしれません。：


<pre>Access to database denied
</pre>

もし <code>db</code> テーブルに <code>Host</code> フィールドが空の登録がある場合には、
<code>host</code> テーブル中に、<code>db</code> テーブルに登録されている
ホストを明記した物が一つ以上あるかどうかを確認してください。

もし <code>SELECT ... INTO OUTFILE</code> や <code>LOAD DATA INFILE</code> SQL 文を
使用している時にこのエラーが出る場合、
<code>user</code> テーブルのあなたの登録に <strong>file</strong> 特権が
許可されていないと思われます。

</li><li>

<a name="IDX150"></a>
<a name="IDX151"></a>
<a name="IDX152"></a>
クライアントプログラムは接続に際して、
設定ファイルで設定された値か環境変数の値を使用することに注意してください。
もしクライアントプログラムが誤った値を接続に使用しているようなら、
環境変数とホームディレクトリにある <tt>`.my.cnf'</tt> ファイルを確認してください。
もちろんシステムワイドの <strong>MySQL</strong> 設定ファイルも、パラメターが記述されていないか、
チェックしてみてください。 「<a href="manual.ja_Installing.html#Option_files">4.15.4  オプションファイル ( <code>my.cnf</code> )</a>」節参照.
もしクライアントをオプションなしで起動していて <code>Access denied</code> がでるなら、
オプションファイルに古いパスワードが書かれているか確認してください。
 「<a href="manual.ja_Installing.html#Option_files">4.15.4  オプションファイル ( <code>my.cnf</code> )</a>」節参照.

</li><li>

もし全て失敗するなら、<code>mysqld</code> デーモンをデバッグオプションで起動してください。
例えば、<code>--debug=d,general,query</code>。これはコネクションに試みたホストやユーザーの情報、
また実行したコマンドを表示します。  「<a href="manual.ja_Porting.html#Debugging_server">G.1  MySQL server のデバッグ</a>」節参照.

</li><li>

もし <strong>MySQL</strong> の特権許可についてその他の問題が起こり、
メーリング・リストに問題をポストしなくてはいけないと感じれば、
いつも <strong>MySQL</strong> 許可テーブルのダンプを提供して下さい。
<code>mysqldump mysql</code> コマンドでダンプできます。
いつものように、 <code>mysqlbug</code> スクリプトでポストしてください。
ときにはは、 <code>mysqldump</code> を実行するために、
<code>mysqld</code> を <code>--skip-grant-tables</code> オプションで実行しないと
いけないかもしれません。
</li></ul>



<h2><a name="Security" href="manual.ja_toc.html#Security">6.13  <strong>MySQL</strong> をクラッカーに対して安全にする方法</a></h2>

<p>
<strong>MySQL</strong> サーバーに接続するときは、パスワードを使用すべきです。
パスワードはコネクション間で、べたテキストでは流れません。

</p>
<p>
その他の全ての情報はテキストで転送され、
これは接続を覗くことが出来る人に読まれます。
もしこれを心配するなら、圧縮プロトコル(<strong>MySQL</strong> 3.22 以上)を
使用することが出来ます。より安全にしたい場合、
<code>ssh</code> (<a href="http://www.cs.hut.fi/ssh">http://www.cs.hut.fi/ssh</a>) をインストールすべきです。
これを使用すれば、<strong>MySQL</strong> サーバーと <strong>MySQL</strong> クライアント
間の TCP/IP コネクションは全て暗号化されます。
 
<strong>MySQL</strong> システムを安全にするためには、次のことを考えるべきです:

</p>

<ul>
<li>

全ての <strong>MySQL</strong> ユーザにパスワードを使用すべきです。
<code>other_user</code> にパスワードが設定されていない場合、
誰でも <code>mysql -u other_user db_name</code> として簡単に他の人としてログインでき
ることを覚えてください。これは全てのクライアント／サーバアプリケーション
で一般的な振る舞いです。全てのユーザのパスワードは、
<code>mysql_install_db</code> スクリプトを実行前に編集することで、または 
<strong>MySQL</strong> <code>root</code> ユーザだけは次のようにして変更することができます。


<pre>shell&gt; mysql -u root mysql
mysql&gt; UPDATE user SET Password=PASSWORD('new_password')
           WHERE user='root';
</pre>

</li><li>

<strong>MySQL</strong> デーモンを Unix の <code>root</code> ユーザーで実行しないでください。
<code>mysqld</code> は任意のユーザで実行できます。
より安全にするため、新しく Unix ユーザ <code>mysql</code> を追加することもできます。
<code>mysqld</code> を 他の Unix ユーザーで起動したとしても、
<strong>MySQL</strong> の <code>user</code> テーブルの <code>root</code> ユーザーの名前を変更する必要はありません。
なぜなら、 <strong>MySQL</strong> ユーザーの名前は Unix のユーザー名とはなんの関係もないからです。
root ユーザ名を変更する必要はありません。
<code>mysqld</code> を他の Unix ユーザで起動するために、<code>mysql.server</code> 編集してもよいでしょう。
通常、これは <code>su</code> コマンドで行われます。
より詳しい情報は →  「<a href="manual.ja_Problems.html#Changing_MySQL_user">18.7  一般ユーザで <strong>MySQL</strong> を動かす方法</a>」節.

</li><li>

<code>mysql.server</code> スクリプト内に Unix <code>root</code> ユーザーのためにパスワードを
書いた場合、このスクリプトは <code>root</code> だけが読めるようにしなくては
なりません。

</li><li>

データベースディレクトリは <code>mysqld</code> を実行している Unix ユーザだけが
読み込み／書き込み可能なことをチェックしてください。

</li><li>

<strong>process</strong> 特権を全てのユーザに与えないでください。この許可がある人は誰でも
<code>mysqladmin processlist</code> コマンドで実行されているクエリーの中身を見ることができます。
もし誰かが、<code>UPDATE user SET password=PASSWORD('not_secure')</code> クエリーを
実行していたとして、それが見えてしまいます。

<code>mysqld</code> は <strong>process</strong> 特権を持つユーザに対する拡張接続を保存します。
そのため、たとえ全ての通常接続が使われたとしても、<strong>MySQL</strong> <code>root</code> ユーザだけは、
ログインでき、いろいろチェックできます。

</li><li>

<strong>file</strong> を全てのユーザに与えないでください。ユーザがこの特権を持つ場
合、<code>mysqld</code> デーモンを実行している Unix ユーザーの権限で
ファイルシステム内のどこにでもファイルを書き込むことができます！
これを少し安全にするために、<code>SELECT ... INTO OUTFILE</code> で作成される全てのファイルは
全員に読み込み可能で生成され、既存のファイルには上書きできません。

<a name="IDX153"></a>
<strong>file</strong> 特権はサーバーを走らせている UNIX ユーザーがアクセスできる
全てのファイルを読むために使用されかもしれません。
例えば、 <tt>`/etc/passwd'</tt> をテーブルに取り込むために <code>LOAD DATA</code> が
使用されると、 <code>SELECT</code> でその内容が読めることになります。

</li><li>

あなたの DNS を信用しない場合、特権テーブル内にはホスト名の代わりに IP 
を使用すべきです。<code>mysqld</code> への <code>--secure</code> オプションは原理上はホスト名を安
全にします。どんな場合でも、ホスト名へのワイルドカードの使用については、
本当に注意深くすべきです！

</li></ul>

<p>
<code>mysqld</code> への次のオプションはセキュリティに影響します:

</p>
<dl compact="">

<dt><code>--secure</code>
</dt><dd>
<code>gethostbyname()</code> から返される ip がオリジナルのホスト名に戻せるかど
うかをチェックします。これは、外の誰かが他のホストを真似てアクセスを得る
ことを難しくします。このオプションはいくつかの正しいホスト名チェックも追
加します。これは、時にチェックに長い時間がかかるため、<strong>MySQL</strong> 3.21
ではデフォルトではオフにされています。<strong>MySQL</strong> 3.22 ではこのオプションは
デフォルトで有効になっていますが、ホスト名をキャッシュするようになっています。

</dd><dt><code>--skip-grant-tables</code>
</dt><dd>
特権システムを全く使用しません。これは全員に全てのデータベースへの 
<em>完全なアクセス</em> を与えます！
(<code>mysqladmin reload</code> を実行することで、起動しているサーバーは特権システムを使用するようになります。)

</dd><dt><code>--skip-name-resolve</code>
</dt><dd>
ホスト名を解析しません。特権テーブル中の全ての <code>Host</code>フィールドは IP アドレスか
<code>localhost</code> でなければなりません。

</dd><dt><code>--skip-networking</code>
</dt><dd>
ネットワーク (TCP/IP) 経由の接続を許可しません。<code>mysqld</code> への全ての接続は、
Unix ソケットで行われます。MIT-pthreads は Unix ソケットをサポートしない
ため、このオプションは MIT-pthreads を使用するシステム上では、うまく動きません。
</dd></dl>

<p></p><hr><p>
Go to the <a href="manual.ja_Introduction.html">first</a>, <a href="manual.ja_Compatibility.html">previous</a>, <a href="manual.ja_Reference.html">next</a>, <a href="manual.ja_Concept_Index.html">last</a> section, <a href="manual.ja_toc.html">table of contents</a>.
 
 
</p></body></html>